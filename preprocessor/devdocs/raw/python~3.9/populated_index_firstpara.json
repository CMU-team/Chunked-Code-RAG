[{"name": "abc", "path": "library/abc", "type": "Runtime", "text": "\nSource code: Lib/abc.py\n\n"}, {"name": "abc.ABC", "path": "library/abc#abc.ABC", "type": "Runtime", "text": "\nA helper class that has `ABCMeta` as its metaclass. With this class, an\nabstract base class can be created by simply deriving from `ABC` avoiding\nsometimes confusing metaclass usage, for example:\n\n"}, {"name": "abc.ABCMeta", "path": "library/abc#abc.ABCMeta", "type": "Runtime", "text": "\nMetaclass for defining Abstract Base Classes (ABCs).\n\n"}, {"name": "abc.ABCMeta.register()", "path": "library/abc#abc.ABCMeta.register", "type": "Runtime", "text": "\nRegister subclass as a \u201cvirtual subclass\u201d of this ABC. For example:\n\n"}, {"name": "abc.ABCMeta.__subclasshook__()", "path": "library/abc#abc.ABCMeta.__subclasshook__", "type": "Runtime", "text": "\n(Must be defined as a class method.)\n\n"}, {"name": "abc.abstractclassmethod()", "path": "library/abc#abc.abstractclassmethod", "type": "Runtime", "text": "\nNew in version 3.2.\n\n"}, {"name": "abc.abstractmethod()", "path": "library/abc#abc.abstractmethod", "type": "Runtime", "text": "\nA decorator indicating abstract methods.\n\n"}, {"name": "abc.abstractproperty()", "path": "library/abc#abc.abstractproperty", "type": "Runtime", "text": "\nDeprecated since version 3.3: It is now possible to use `property`,\n`property.getter()`, `property.setter()` and `property.deleter()` with\n`abstractmethod()`, making this decorator redundant.\n\n"}, {"name": "abc.abstractstaticmethod()", "path": "library/abc#abc.abstractstaticmethod", "type": "Runtime", "text": "\nNew in version 3.2.\n\n"}, {"name": "abc.get_cache_token()", "path": "library/abc#abc.get_cache_token", "type": "Runtime", "text": "\nReturns the current abstract base class cache token.\n\n"}, {"name": "abs()", "path": "library/functions#abs", "type": "Built-in Functions", "text": "\nReturn the absolute value of a number. The argument may be an integer, a\nfloating point number, or an object implementing `__abs__()`. If the argument\nis a complex number, its magnitude is returned.\n\n"}, {"name": "aifc", "path": "library/aifc", "type": "Multimedia", "text": "\nSource code: Lib/aifc.py\n\n"}, {"name": "aifc.aifc.aifc()", "path": "library/aifc#aifc.aifc.aifc", "type": "Multimedia", "text": "\nCreate an AIFF-C file. The default is that an AIFF-C file is created, unless\nthe name of the file ends in `'.aiff'` in which case the default is an AIFF\nfile.\n\n"}, {"name": "aifc.aifc.aiff()", "path": "library/aifc#aifc.aifc.aiff", "type": "Multimedia", "text": "\nCreate an AIFF file. The default is that an AIFF-C file is created, unless the\nname of the file ends in `'.aiff'` in which case the default is an AIFF file.\n\n"}, {"name": "aifc.aifc.close()", "path": "library/aifc#aifc.aifc.close", "type": "Multimedia", "text": "\nClose the AIFF file. After calling this method, the object can no longer be\nused.\n\n"}, {"name": "aifc.aifc.getcompname()", "path": "library/aifc#aifc.aifc.getcompname", "type": "Multimedia", "text": "\nReturn a bytes array convertible to a human-readable description of the type\nof compression used in the audio file. For AIFF files, the returned value is\n`b'not compressed'`.\n\n"}, {"name": "aifc.aifc.getcomptype()", "path": "library/aifc#aifc.aifc.getcomptype", "type": "Multimedia", "text": "\nReturn a bytes array of length 4 describing the type of compression used in\nthe audio file. For AIFF files, the returned value is `b'NONE'`.\n\n"}, {"name": "aifc.aifc.getframerate()", "path": "library/aifc#aifc.aifc.getframerate", "type": "Multimedia", "text": "\nReturn the sampling rate (number of audio frames per second).\n\n"}, {"name": "aifc.aifc.getmark()", "path": "library/aifc#aifc.aifc.getmark", "type": "Multimedia", "text": "\nReturn the tuple as described in `getmarkers()` for the mark with the given\nid.\n\n"}, {"name": "aifc.aifc.getmarkers()", "path": "library/aifc#aifc.aifc.getmarkers", "type": "Multimedia", "text": "\nReturn a list of markers in the audio file. A marker consists of a tuple of\nthree elements. The first is the mark ID (an integer), the second is the mark\nposition in frames from the beginning of the data (an integer), the third is\nthe name of the mark (a string).\n\n"}, {"name": "aifc.aifc.getnchannels()", "path": "library/aifc#aifc.aifc.getnchannels", "type": "Multimedia", "text": "\nReturn the number of audio channels (1 for mono, 2 for stereo).\n\n"}, {"name": "aifc.aifc.getnframes()", "path": "library/aifc#aifc.aifc.getnframes", "type": "Multimedia", "text": "\nReturn the number of audio frames in the file.\n\n"}, {"name": "aifc.aifc.getparams()", "path": "library/aifc#aifc.aifc.getparams", "type": "Multimedia", "text": "\nReturns a `namedtuple()` `(nchannels, sampwidth, framerate, nframes, comptype,\ncompname)`, equivalent to output of the `get*()` methods.\n\n"}, {"name": "aifc.aifc.getsampwidth()", "path": "library/aifc#aifc.aifc.getsampwidth", "type": "Multimedia", "text": "\nReturn the size in bytes of individual samples.\n\n"}, {"name": "aifc.aifc.readframes()", "path": "library/aifc#aifc.aifc.readframes", "type": "Multimedia", "text": "\nRead and return the next nframes frames from the audio file. The returned data\nis a string containing for each frame the uncompressed samples of all\nchannels.\n\n"}, {"name": "aifc.aifc.rewind()", "path": "library/aifc#aifc.aifc.rewind", "type": "Multimedia", "text": "\nRewind the read pointer. The next `readframes()` will start from the\nbeginning.\n\n"}, {"name": "aifc.aifc.setcomptype()", "path": "library/aifc#aifc.aifc.setcomptype", "type": "Multimedia", "text": "\nSpecify the compression type. If not specified, the audio data will not be\ncompressed. In AIFF files, compression is not possible. The name parameter\nshould be a human-readable description of the compression type as a bytes\narray, the type parameter should be a bytes array of length 4. Currently the\nfollowing compression types are supported: `b'NONE'`, `b'ULAW'`, `b'ALAW'`,\n`b'G722'`.\n\n"}, {"name": "aifc.aifc.setframerate()", "path": "library/aifc#aifc.aifc.setframerate", "type": "Multimedia", "text": "\nSpecify the sampling frequency in frames per second.\n\n"}, {"name": "aifc.aifc.setmark()", "path": "library/aifc#aifc.aifc.setmark", "type": "Multimedia", "text": "\nAdd a mark with the given id (larger than 0), and the given name at the given\nposition. This method can be called at any time before `close()`.\n\n"}, {"name": "aifc.aifc.setnchannels()", "path": "library/aifc#aifc.aifc.setnchannels", "type": "Multimedia", "text": "\nSpecify the number of channels in the audio file.\n\n"}, {"name": "aifc.aifc.setnframes()", "path": "library/aifc#aifc.aifc.setnframes", "type": "Multimedia", "text": "\nSpecify the number of frames that are to be written to the audio file. If this\nparameter is not set, or not set correctly, the file needs to support seeking.\n\n"}, {"name": "aifc.aifc.setparams()", "path": "library/aifc#aifc.aifc.setparams", "type": "Multimedia", "text": "\nSet all the above parameters at once. The argument is a tuple consisting of\nthe various parameters. This means that it is possible to use the result of a\n`getparams()` call as argument to `setparams()`.\n\n"}, {"name": "aifc.aifc.setpos()", "path": "library/aifc#aifc.aifc.setpos", "type": "Multimedia", "text": "\nSeek to the specified frame number.\n\n"}, {"name": "aifc.aifc.setsampwidth()", "path": "library/aifc#aifc.aifc.setsampwidth", "type": "Multimedia", "text": "\nSpecify the size in bytes of audio samples.\n\n"}, {"name": "aifc.aifc.tell()", "path": "library/aifc#aifc.aifc.tell", "type": "Multimedia", "text": "\nReturn the current frame number.\n\n"}, {"name": "aifc.aifc.writeframes()", "path": "library/aifc#aifc.aifc.writeframes", "type": "Multimedia", "text": "\nWrite data to the output file. This method can only be called after the audio\nfile parameters have been set.\n\n"}, {"name": "aifc.aifc.writeframesraw()", "path": "library/aifc#aifc.aifc.writeframesraw", "type": "Multimedia", "text": "\nLike `writeframes()`, except that the header of the audio file is not updated.\n\n"}, {"name": "aifc.open()", "path": "library/aifc#aifc.open", "type": "Multimedia", "text": "\nOpen an AIFF or AIFF-C file and return an object instance with methods that\nare described below. The argument file is either a string naming a file or a\nfile object. mode must be `'r'` or `'rb'` when the file must be opened for\nreading, or `'w'` or `'wb'` when the file must be opened for writing. If\nomitted, `file.mode` is used if it exists, otherwise `'rb'` is used. When used\nfor writing, the file object should be seekable, unless you know ahead of time\nhow many samples you are going to write in total and use `writeframesraw()`\nand `setnframes()`. The `open()` function may be used in a `with` statement.\nWhen the `with` block completes, the `close()` method is called.\n\n"}, {"name": "all()", "path": "library/functions#all", "type": "Built-in Functions", "text": "\nReturn `True` if all elements of the iterable are true (or if the iterable is\nempty). Equivalent to:\n\n"}, {"name": "any()", "path": "library/functions#any", "type": "Built-in Functions", "text": "\nReturn `True` if any element of the iterable is true. If the iterable is\nempty, return `False`. Equivalent to:\n\n"}, {"name": "argparse", "path": "library/argparse", "type": "Operating System", "text": "\nNew in version 3.2.\n\n"}, {"name": "argparse.Action", "path": "library/argparse#argparse.Action", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentDefaultsHelpFormatter", "path": "library/argparse#argparse.ArgumentDefaultsHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser", "path": "library/argparse#argparse.ArgumentParser", "type": "Operating System", "text": "\nCreate a new `ArgumentParser` object. All parameters should be passed as\nkeyword arguments. Each parameter has its own more detailed description below,\nbut in short they are:\n\n"}, {"name": "argparse.ArgumentParser.add_argument()", "path": "library/argparse#argparse.ArgumentParser.add_argument", "type": "Operating System", "text": "\nDefine how a single command-line argument should be parsed. Each parameter has\nits own more detailed description below, but in short they are:\n\n"}, {"name": "argparse.ArgumentParser.add_argument_group()", "path": "library/argparse#argparse.ArgumentParser.add_argument_group", "type": "Operating System", "text": "\nBy default, `ArgumentParser` groups command-line arguments into \u201cpositional\narguments\u201d and \u201coptional arguments\u201d when displaying help messages. When there\nis a better conceptual grouping of arguments than this default one,\nappropriate groups can be created using the `add_argument_group()` method:\n\n"}, {"name": "argparse.ArgumentParser.add_mutually_exclusive_group()", "path": "library/argparse#argparse.ArgumentParser.add_mutually_exclusive_group", "type": "Operating System", "text": "\nCreate a mutually exclusive group. `argparse` will make sure that only one of\nthe arguments in the mutually exclusive group was present on the command line:\n\n"}, {"name": "argparse.ArgumentParser.add_subparsers()", "path": "library/argparse#argparse.ArgumentParser.add_subparsers", "type": "Operating System", "text": "\nMany programs split up their functionality into a number of sub-commands, for\nexample, the `svn` program can invoke sub-commands like `svn checkout`, `svn\nupdate`, and `svn commit`. Splitting up functionality this way can be a\nparticularly good idea when a program performs several different functions\nwhich require different kinds of command-line arguments. `ArgumentParser`\nsupports the creation of such sub-commands with the `add_subparsers()` method.\nThe `add_subparsers()` method is normally called with no arguments and returns\na special action object. This object has a single method, `add_parser()`,\nwhich takes a command name and any `ArgumentParser` constructor arguments, and\nreturns an `ArgumentParser` object that can be modified as usual.\n\n"}, {"name": "argparse.ArgumentParser.convert_arg_line_to_args()", "path": "library/argparse#argparse.ArgumentParser.convert_arg_line_to_args", "type": "Operating System", "text": "\nArguments that are read from a file (see the fromfile_prefix_chars keyword\nargument to the `ArgumentParser` constructor) are read one argument per line.\n`convert_arg_line_to_args()` can be overridden for fancier reading.\n\n"}, {"name": "argparse.ArgumentParser.error()", "path": "library/argparse#argparse.ArgumentParser.error", "type": "Operating System", "text": "\nThis method prints a usage message including the message to the standard error\nand terminates the program with a status code of 2.\n\n"}, {"name": "argparse.ArgumentParser.exit()", "path": "library/argparse#argparse.ArgumentParser.exit", "type": "Operating System", "text": "\nThis method terminates the program, exiting with the specified status and, if\ngiven, it prints a message before that. The user can override this method to\nhandle these steps differently:\n\n"}, {"name": "argparse.ArgumentParser.format_help()", "path": "library/argparse#argparse.ArgumentParser.format_help", "type": "Operating System", "text": "\nReturn a string containing a help message, including the program usage and\ninformation about the arguments registered with the `ArgumentParser`.\n\n"}, {"name": "argparse.ArgumentParser.format_usage()", "path": "library/argparse#argparse.ArgumentParser.format_usage", "type": "Operating System", "text": "\nReturn a string containing a brief description of how the `ArgumentParser`\nshould be invoked on the command line.\n\n"}, {"name": "argparse.ArgumentParser.get_default()", "path": "library/argparse#argparse.ArgumentParser.get_default", "type": "Operating System", "text": "\nGet the default value for a namespace attribute, as set by either\n`add_argument()` or by `set_defaults()`:\n\n"}, {"name": "argparse.ArgumentParser.parse_args()", "path": "library/argparse#argparse.ArgumentParser.parse_args", "type": "Operating System", "text": "\nConvert argument strings to objects and assign them as attributes of the\nnamespace. Return the populated namespace.\n\n"}, {"name": "argparse.ArgumentParser.parse_intermixed_args()", "path": "library/argparse#argparse.ArgumentParser.parse_intermixed_args", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser.parse_known_args()", "path": "library/argparse#argparse.ArgumentParser.parse_known_args", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser.parse_known_intermixed_args()", "path": "library/argparse#argparse.ArgumentParser.parse_known_intermixed_args", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser.print_help()", "path": "library/argparse#argparse.ArgumentParser.print_help", "type": "Operating System", "text": "\nPrint a help message, including the program usage and information about the\narguments registered with the `ArgumentParser`. If file is `None`,\n`sys.stdout` is assumed.\n\n"}, {"name": "argparse.ArgumentParser.print_usage()", "path": "library/argparse#argparse.ArgumentParser.print_usage", "type": "Operating System", "text": "\nPrint a brief description of how the `ArgumentParser` should be invoked on the\ncommand line. If file is `None`, `sys.stdout` is assumed.\n\n"}, {"name": "argparse.ArgumentParser.set_defaults()", "path": "library/argparse#argparse.ArgumentParser.set_defaults", "type": "Operating System", "text": "\nMost of the time, the attributes of the object returned by `parse_args()` will\nbe fully determined by inspecting the command-line arguments and the argument\nactions. `set_defaults()` allows some additional attributes that are\ndetermined without any inspection of the command line to be added:\n\n"}, {"name": "argparse.FileType", "path": "library/argparse#argparse.FileType", "type": "Operating System", "text": "\nThe `FileType` factory creates objects that can be passed to the type argument\nof `ArgumentParser.add_argument()`. Arguments that have `FileType` objects as\ntheir type will open command-line arguments as files with the requested modes,\nbuffer sizes, encodings and error handling (see the `open()` function for more\ndetails):\n\n"}, {"name": "argparse.MetavarTypeHelpFormatter", "path": "library/argparse#argparse.MetavarTypeHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.Namespace", "path": "library/argparse#argparse.Namespace", "type": "Operating System", "text": "\nSimple class used by default by `parse_args()` to create an object holding\nattributes and return it.\n\n"}, {"name": "argparse.RawDescriptionHelpFormatter", "path": "library/argparse#argparse.RawDescriptionHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.RawTextHelpFormatter", "path": "library/argparse#argparse.RawTextHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "ArithmeticError", "path": "library/exceptions#ArithmeticError", "type": "Built-in Exceptions", "text": "\nThe base class for those built-in exceptions that are raised for various\narithmetic errors: `OverflowError`, `ZeroDivisionError`, `FloatingPointError`.\n\n"}, {"name": "array", "path": "library/array", "type": "Data Types", "text": "\nThis module defines an object type which can compactly represent an array of\nbasic values: characters, integers, floating point numbers. Arrays are\nsequence types and behave very much like lists, except that the type of\nobjects stored in them is constrained. The type is specified at object\ncreation time by using a type code, which is a single character. The following\ntype codes are defined:\n\n"}, {"name": "array.array", "path": "library/array#array.array", "type": "Data Types", "text": "\nA new array whose items are restricted by typecode, and initialized from the\noptional initializer value, which must be a list, a bytes-like object, or\niterable over elements of the appropriate type.\n\n"}, {"name": "array.array.append()", "path": "library/array#array.array.append", "type": "Data Types", "text": "\nAppend a new item with value x to the end of the array.\n\n"}, {"name": "array.array.buffer_info()", "path": "library/array#array.array.buffer_info", "type": "Data Types", "text": "\nReturn a tuple `(address, length)` giving the current memory address and the\nlength in elements of the buffer used to hold array\u2019s contents. The size of\nthe memory buffer in bytes can be computed as `array.buffer_info()[1] *\narray.itemsize`. This is occasionally useful when working with low-level (and\ninherently unsafe) I/O interfaces that require memory addresses, such as\ncertain `ioctl()` operations. The returned numbers are valid as long as the\narray exists and no length-changing operations are applied to it.\n\n"}, {"name": "array.array.byteswap()", "path": "library/array#array.array.byteswap", "type": "Data Types", "text": "\n\u201cByteswap\u201d all items of the array. This is only supported for values which are\n1, 2, 4, or 8 bytes in size; for other types of values, `RuntimeError` is\nraised. It is useful when reading data from a file written on a machine with a\ndifferent byte order.\n\n"}, {"name": "array.array.count()", "path": "library/array#array.array.count", "type": "Data Types", "text": "\nReturn the number of occurrences of x in the array.\n\n"}, {"name": "array.array.extend()", "path": "library/array#array.array.extend", "type": "Data Types", "text": "\nAppend items from iterable to the end of the array. If iterable is another\narray, it must have exactly the same type code; if not, `TypeError` will be\nraised. If iterable is not an array, it must be iterable and its elements must\nbe the right type to be appended to the array.\n\n"}, {"name": "array.array.frombytes()", "path": "library/array#array.array.frombytes", "type": "Data Types", "text": "\nAppends items from the string, interpreting the string as an array of machine\nvalues (as if it had been read from a file using the `fromfile()` method).\n\n"}, {"name": "array.array.fromfile()", "path": "library/array#array.array.fromfile", "type": "Data Types", "text": "\nRead n items (as machine values) from the file object f and append them to the\nend of the array. If less than n items are available, `EOFError` is raised,\nbut the items that were available are still inserted into the array.\n\n"}, {"name": "array.array.fromlist()", "path": "library/array#array.array.fromlist", "type": "Data Types", "text": "\nAppend items from the list. This is equivalent to `for x in list: a.append(x)`\nexcept that if there is a type error, the array is unchanged.\n\n"}, {"name": "array.array.fromunicode()", "path": "library/array#array.array.fromunicode", "type": "Data Types", "text": "\nExtends this array with data from the given unicode string. The array must be\na type `'u'` array; otherwise a `ValueError` is raised. Use\n`array.frombytes(unicodestring.encode(enc))` to append Unicode data to an\narray of some other type.\n\n"}, {"name": "array.array.index()", "path": "library/array#array.array.index", "type": "Data Types", "text": "\nReturn the smallest i such that i is the index of the first occurrence of x in\nthe array.\n\n"}, {"name": "array.array.insert()", "path": "library/array#array.array.insert", "type": "Data Types", "text": "\nInsert a new item with value x in the array before position i. Negative values\nare treated as being relative to the end of the array.\n\n"}, {"name": "array.array.itemsize", "path": "library/array#array.array.itemsize", "type": "Data Types", "text": "\nThe length in bytes of one array item in the internal representation.\n\n"}, {"name": "array.array.pop()", "path": "library/array#array.array.pop", "type": "Data Types", "text": "\nRemoves the item with the index i from the array and returns it. The optional\nargument defaults to `-1`, so that by default the last item is removed and\nreturned.\n\n"}, {"name": "array.array.remove()", "path": "library/array#array.array.remove", "type": "Data Types", "text": "\nRemove the first occurrence of x from the array.\n\n"}, {"name": "array.array.reverse()", "path": "library/array#array.array.reverse", "type": "Data Types", "text": "\nReverse the order of the items in the array.\n\n"}, {"name": "array.array.tobytes()", "path": "library/array#array.array.tobytes", "type": "Data Types", "text": "\nConvert the array to an array of machine values and return the bytes\nrepresentation (the same sequence of bytes that would be written to a file by\nthe `tofile()` method.)\n\n"}, {"name": "array.array.tofile()", "path": "library/array#array.array.tofile", "type": "Data Types", "text": "\nWrite all items (as machine values) to the file object f.\n\n"}, {"name": "array.array.tolist()", "path": "library/array#array.array.tolist", "type": "Data Types", "text": "\nConvert the array to an ordinary list with the same items.\n\n"}, {"name": "array.array.tounicode()", "path": "library/array#array.array.tounicode", "type": "Data Types", "text": "\nConvert the array to a unicode string. The array must be a type `'u'` array;\notherwise a `ValueError` is raised. Use `array.tobytes().decode(enc)` to\nobtain a unicode string from an array of some other type.\n\n"}, {"name": "array.array.typecode", "path": "library/array#array.array.typecode", "type": "Data Types", "text": "\nThe typecode character used to create the array.\n\n"}, {"name": "array.typecodes", "path": "library/array#array.typecodes", "type": "Data Types", "text": "\nA string with all available type codes.\n\n"}, {"name": "ascii()", "path": "library/functions#ascii", "type": "Built-in Functions", "text": "\nAs `repr()`, return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by `repr()`\nusing `\\x`, `\\u` or `\\U` escapes. This generates a string similar to that\nreturned by `repr()` in Python 2.\n\n"}, {"name": "AssertionError", "path": "library/exceptions#AssertionError", "type": "Built-in Exceptions", "text": "\nRaised when an `assert` statement fails.\n\n"}, {"name": "ast", "path": "library/ast", "type": "Language", "text": "\nSource code: Lib/ast.py\n\n"}, {"name": "ast.Add", "path": "library/ast#ast.Add", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.alias", "path": "library/ast#ast.alias", "type": "Language", "text": "\nBoth parameters are raw strings of the names. `asname` can be `None` if the\nregular name is to be used.\n\n"}, {"name": "ast.And", "path": "library/ast#ast.And", "type": "Language", "text": "\nBoolean operator tokens.\n\n"}, {"name": "ast.AnnAssign", "path": "library/ast#ast.AnnAssign", "type": "Language", "text": "\nAn assignment with a type annotation. `target` is a single node and can be a\n`Name`, a `Attribute` or a `Subscript`. `annotation` is the annotation, such\nas a `Constant` or `Name` node. `value` is a single optional node. `simple` is\na boolean integer set to True for a `Name` node in `target` that do not appear\nin between parenthesis and are hence pure names and not expressions.\n\n"}, {"name": "ast.arg", "path": "library/ast#ast.arg", "type": "Language", "text": "\nA single argument in a list. `arg` is a raw string of the argument name,\n`annotation` is its annotation, such as a `Str` or `Name` node.\n\n"}, {"name": "ast.arg.type_comment", "path": "library/ast#ast.arg.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment\n\n"}, {"name": "ast.arguments", "path": "library/ast#ast.arguments", "type": "Language", "text": "\nThe arguments for a function.\n\n"}, {"name": "ast.Assert", "path": "library/ast#ast.Assert", "type": "Language", "text": "\nAn assertion. `test` holds the condition, such as a `Compare` node. `msg`\nholds the failure message.\n\n"}, {"name": "ast.Assign", "path": "library/ast#ast.Assign", "type": "Language", "text": "\nAn assignment. `targets` is a list of nodes, and `value` is a single node.\n\n"}, {"name": "ast.Assign.type_comment", "path": "library/ast#ast.Assign.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.AST", "path": "library/ast#ast.AST", "type": "Language", "text": "\nThis is the base of all AST node classes. The actual node classes are derived\nfrom the `Parser/Python.asdl` file, which is reproduced below. They are\ndefined in the `_ast` C module and re-exported in `ast`.\n\n"}, {"name": "ast.AST.col_offset", "path": "library/ast#ast.AST.col_offset", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST.end_col_offset", "path": "library/ast#ast.AST.end_col_offset", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST.end_lineno", "path": "library/ast#ast.AST.end_lineno", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST.lineno", "path": "library/ast#ast.AST.lineno", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST._fields", "path": "library/ast#ast.AST._fields", "type": "Language", "text": "\nEach concrete class has an attribute `_fields` which gives the names of all\nchild nodes.\n\n"}, {"name": "ast.AsyncFor", "path": "library/ast#ast.AsyncFor", "type": "Language", "text": "\n`async for` loops and `async with` context managers. They have the same fields\nas `For` and `With`, respectively. Only valid in the body of an\n`AsyncFunctionDef`.\n\n"}, {"name": "ast.AsyncFunctionDef", "path": "library/ast#ast.AsyncFunctionDef", "type": "Language", "text": "\nAn `async def` function definition. Has the same fields as `FunctionDef`.\n\n"}, {"name": "ast.AsyncWith", "path": "library/ast#ast.AsyncWith", "type": "Language", "text": "\n`async for` loops and `async with` context managers. They have the same fields\nas `For` and `With`, respectively. Only valid in the body of an\n`AsyncFunctionDef`.\n\n"}, {"name": "ast.Attribute", "path": "library/ast#ast.Attribute", "type": "Language", "text": "\nAttribute access, e.g. `d.keys`. `value` is a node, typically a `Name`. `attr`\nis a bare string giving the name of the attribute, and `ctx` is `Load`,\n`Store` or `Del` according to how the attribute is acted on.\n\n"}, {"name": "ast.AugAssign", "path": "library/ast#ast.AugAssign", "type": "Language", "text": "\nAugmented assignment, such as `a += 1`. In the following example, `target` is\na `Name` node for `x` (with the `Store` context), `op` is `Add`, and `value`\nis a `Constant` with value for 1.\n\n"}, {"name": "ast.Await", "path": "library/ast#ast.Await", "type": "Language", "text": "\nAn `await` expression. `value` is what it waits for. Only valid in the body of\nan `AsyncFunctionDef`.\n\n"}, {"name": "ast.BinOp", "path": "library/ast#ast.BinOp", "type": "Language", "text": "\nA binary operation (like addition or division). `op` is the operator, and\n`left` and `right` are any expression nodes.\n\n"}, {"name": "ast.BitAnd", "path": "library/ast#ast.BitAnd", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.BitOr", "path": "library/ast#ast.BitOr", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.BitXor", "path": "library/ast#ast.BitXor", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.BoolOp", "path": "library/ast#ast.BoolOp", "type": "Language", "text": "\nA boolean operation, \u2018or\u2019 or \u2018and\u2019. `op` is `Or` or `And`. `values` are the\nvalues involved. Consecutive operations with the same operator, such as `a or\nb or c`, are collapsed into one node with several values.\n\n"}, {"name": "ast.Break", "path": "library/ast#ast.Break", "type": "Language", "text": "\nThe `break` and `continue` statements.\n\n"}, {"name": "ast.Call", "path": "library/ast#ast.Call", "type": "Language", "text": "\nA function call. `func` is the function, which will often be a `Name` or\n`Attribute` object. Of the arguments:\n\n"}, {"name": "ast.ClassDef", "path": "library/ast#ast.ClassDef", "type": "Language", "text": "\nA class definition.\n\n"}, {"name": "ast.Compare", "path": "library/ast#ast.Compare", "type": "Language", "text": "\nA comparison of two or more values. `left` is the first value in the\ncomparison, `ops` the list of operators, and `comparators` the list of values\nafter the first element in the comparison.\n\n"}, {"name": "ast.comprehension", "path": "library/ast#ast.comprehension", "type": "Language", "text": "\nOne `for` clause in a comprehension. `target` is the reference to use for each\nelement - typically a `Name` or `Tuple` node. `iter` is the object to iterate\nover. `ifs` is a list of test expressions: each `for` clause can have multiple\n`ifs`.\n\n"}, {"name": "ast.Constant", "path": "library/ast#ast.Constant", "type": "Language", "text": "\nA constant value. The `value` attribute of the `Constant` literal contains the\nPython object it represents. The values represented can be simple types such\nas a number, string or `None`, but also immutable container types (tuples and\nfrozensets) if all of their elements are constant.\n\n"}, {"name": "ast.Continue", "path": "library/ast#ast.Continue", "type": "Language", "text": "\nThe `break` and `continue` statements.\n\n"}, {"name": "ast.copy_location()", "path": "library/ast#ast.copy_location", "type": "Language", "text": "\nCopy source location (`lineno`, `col_offset`, `end_lineno`, and\n`end_col_offset`) from old_node to new_node if possible, and return new_node.\n\n"}, {"name": "ast.Del", "path": "library/ast#ast.Del", "type": "Language", "text": "\nVariable references can be used to load the value of a variable, to assign a\nnew value to it, or to delete it. Variable references are given a context to\ndistinguish these cases.\n\n"}, {"name": "ast.Delete", "path": "library/ast#ast.Delete", "type": "Language", "text": "\nRepresents a `del` statement. `targets` is a list of nodes, such as `Name`,\n`Attribute` or `Subscript` nodes.\n\n"}, {"name": "ast.Dict", "path": "library/ast#ast.Dict", "type": "Language", "text": "\nA dictionary. `keys` and `values` hold lists of nodes representing the keys\nand the values respectively, in matching order (what would be returned when\ncalling `dictionary.keys()` and `dictionary.values()`).\n\n"}, {"name": "ast.DictComp", "path": "library/ast#ast.DictComp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.Div", "path": "library/ast#ast.Div", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.dump()", "path": "library/ast#ast.dump", "type": "Language", "text": "\nReturn a formatted dump of the tree in node. This is mainly useful for\ndebugging purposes. If annotate_fields is true (by default), the returned\nstring will show the names and the values for fields. If annotate_fields is\nfalse, the result string will be more compact by omitting unambiguous field\nnames. Attributes such as line numbers and column offsets are not dumped by\ndefault. If this is wanted, include_attributes can be set to true.\n\n"}, {"name": "ast.Eq", "path": "library/ast#ast.Eq", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.ExceptHandler", "path": "library/ast#ast.ExceptHandler", "type": "Language", "text": "\nA single `except` clause. `type` is the exception type it will match,\ntypically a `Name` node (or `None` for a catch-all `except:` clause). `name`\nis a raw string for the name to hold the exception, or `None` if the clause\ndoesn\u2019t have `as foo`. `body` is a list of nodes.\n\n"}, {"name": "ast.Expr", "path": "library/ast#ast.Expr", "type": "Language", "text": "\nWhen an expression, such as a function call, appears as a statement by itself\nwith its return value not used or stored, it is wrapped in this container.\n`value` holds one of the other nodes in this section, a `Constant`, a `Name`,\na `Lambda`, a `Yield` or `YieldFrom` node.\n\n"}, {"name": "ast.fix_missing_locations()", "path": "library/ast#ast.fix_missing_locations", "type": "Language", "text": "\nWhen you compile a node tree with `compile()`, the compiler expects `lineno`\nand `col_offset` attributes for every node that supports them. This is rather\ntedious to fill in for generated nodes, so this helper adds these attributes\nrecursively where not already set, by setting them to the values of the parent\nnode. It works recursively starting at node.\n\n"}, {"name": "ast.FloorDiv", "path": "library/ast#ast.FloorDiv", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.For", "path": "library/ast#ast.For", "type": "Language", "text": "\nA `for` loop. `target` holds the variable(s) the loop assigns to, as a single\n`Name`, `Tuple` or `List` node. `iter` holds the item to be looped over, again\nas a single node. `body` and `orelse` contain lists of nodes to execute. Those\nin `orelse` are executed if the loop finishes normally, rather than via a\n`break` statement.\n\n"}, {"name": "ast.For.type_comment", "path": "library/ast#ast.For.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.FormattedValue", "path": "library/ast#ast.FormattedValue", "type": "Language", "text": "\nNode representing a single formatting field in an f-string. If the string\ncontains a single formatting field and nothing else the node can be isolated\notherwise it appears in `JoinedStr`.\n\n"}, {"name": "ast.FunctionDef", "path": "library/ast#ast.FunctionDef", "type": "Language", "text": "\nA function definition.\n\n"}, {"name": "ast.FunctionDef.type_comment", "path": "library/ast#ast.FunctionDef.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.GeneratorExp", "path": "library/ast#ast.GeneratorExp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.get_docstring()", "path": "library/ast#ast.get_docstring", "type": "Language", "text": "\nReturn the docstring of the given node (which must be a `FunctionDef`,\n`AsyncFunctionDef`, `ClassDef`, or `Module` node), or `None` if it has no\ndocstring. If clean is true, clean up the docstring\u2019s indentation with\n`inspect.cleandoc()`.\n\n"}, {"name": "ast.get_source_segment()", "path": "library/ast#ast.get_source_segment", "type": "Language", "text": "\nGet source code segment of the source that generated node. If some location\ninformation (`lineno`, `end_lineno`, `col_offset`, or `end_col_offset`) is\nmissing, return `None`.\n\n"}, {"name": "ast.Global", "path": "library/ast#ast.Global", "type": "Language", "text": "\n`global` and `nonlocal` statements. `names` is a list of raw strings.\n\n"}, {"name": "ast.Gt", "path": "library/ast#ast.Gt", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.GtE", "path": "library/ast#ast.GtE", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.If", "path": "library/ast#ast.If", "type": "Language", "text": "\nAn `if` statement. `test` holds a single node, such as a `Compare` node.\n`body` and `orelse` each hold a list of nodes.\n\n"}, {"name": "ast.IfExp", "path": "library/ast#ast.IfExp", "type": "Language", "text": "\nAn expression such as `a if b else c`. Each field holds a single node, so in\nthe following example, all three are `Name` nodes.\n\n"}, {"name": "ast.Import", "path": "library/ast#ast.Import", "type": "Language", "text": "\nAn import statement. `names` is a list of `alias` nodes.\n\n"}, {"name": "ast.ImportFrom", "path": "library/ast#ast.ImportFrom", "type": "Language", "text": "\nRepresents `from x import y`. `module` is a raw string of the \u2018from\u2019 name,\nwithout any leading dots, or `None` for statements such as `from . import\nfoo`. `level` is an integer holding the level of the relative import (0 means\nabsolute import).\n\n"}, {"name": "ast.In", "path": "library/ast#ast.In", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.increment_lineno()", "path": "library/ast#ast.increment_lineno", "type": "Language", "text": "\nIncrement the line number and end line number of each node in the tree\nstarting at node by n. This is useful to \u201cmove code\u201d to a different location\nin a file.\n\n"}, {"name": "ast.Invert", "path": "library/ast#ast.Invert", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.Is", "path": "library/ast#ast.Is", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.IsNot", "path": "library/ast#ast.IsNot", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.iter_child_nodes()", "path": "library/ast#ast.iter_child_nodes", "type": "Language", "text": "\nYield all direct child nodes of node, that is, all fields that are nodes and\nall items of fields that are lists of nodes.\n\n"}, {"name": "ast.iter_fields()", "path": "library/ast#ast.iter_fields", "type": "Language", "text": "\nYield a tuple of `(fieldname, value)` for each field in `node._fields` that is\npresent on node.\n\n"}, {"name": "ast.JoinedStr", "path": "library/ast#ast.JoinedStr", "type": "Language", "text": "\nAn f-string, comprising a series of `FormattedValue` and `Constant` nodes.\n\n"}, {"name": "ast.keyword", "path": "library/ast#ast.keyword", "type": "Language", "text": "\nA keyword argument to a function call or class definition. `arg` is a raw\nstring of the parameter name, `value` is a node to pass in.\n\n"}, {"name": "ast.Lambda", "path": "library/ast#ast.Lambda", "type": "Language", "text": "\n`lambda` is a minimal function definition that can be used inside an\nexpression. Unlike `FunctionDef`, `body` holds a single node.\n\n"}, {"name": "ast.List", "path": "library/ast#ast.List", "type": "Language", "text": "\nA list or tuple. `elts` holds a list of nodes representing the elements. `ctx`\nis `Store` if the container is an assignment target (i.e. `(x,y)=something`),\nand `Load` otherwise.\n\n"}, {"name": "ast.ListComp", "path": "library/ast#ast.ListComp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.literal_eval()", "path": "library/ast#ast.literal_eval", "type": "Language", "text": "\nSafely evaluate an expression node or a string containing a Python literal or\ncontainer display. The string or node provided may only consist of the\nfollowing Python literal structures: strings, bytes, numbers, tuples, lists,\ndicts, sets, booleans, and `None`.\n\n"}, {"name": "ast.Load", "path": "library/ast#ast.Load", "type": "Language", "text": "\nVariable references can be used to load the value of a variable, to assign a\nnew value to it, or to delete it. Variable references are given a context to\ndistinguish these cases.\n\n"}, {"name": "ast.LShift", "path": "library/ast#ast.LShift", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Lt", "path": "library/ast#ast.Lt", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.LtE", "path": "library/ast#ast.LtE", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.MatMult", "path": "library/ast#ast.MatMult", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Mod", "path": "library/ast#ast.Mod", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Mult", "path": "library/ast#ast.Mult", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Name", "path": "library/ast#ast.Name", "type": "Language", "text": "\nA variable name. `id` holds the name as a string, and `ctx` is one of the\nfollowing types.\n\n"}, {"name": "ast.NamedExpr", "path": "library/ast#ast.NamedExpr", "type": "Language", "text": "\nA named expression. This AST node is produced by the assignment expressions\noperator (also known as the walrus operator). As opposed to the `Assign` node\nin which the first argument can be multiple nodes, in this case both `target`\nand `value` must be single nodes.\n\n"}, {"name": "ast.NodeTransformer", "path": "library/ast#ast.NodeTransformer", "type": "Language", "text": "\nA `NodeVisitor` subclass that walks the abstract syntax tree and allows\nmodification of nodes.\n\n"}, {"name": "ast.NodeVisitor", "path": "library/ast#ast.NodeVisitor", "type": "Language", "text": "\nA node visitor base class that walks the abstract syntax tree and calls a\nvisitor function for every node found. This function may return a value which\nis forwarded by the `visit()` method.\n\n"}, {"name": "ast.NodeVisitor.generic_visit()", "path": "library/ast#ast.NodeVisitor.generic_visit", "type": "Language", "text": "\nThis visitor calls `visit()` on all children of the node.\n\n"}, {"name": "ast.NodeVisitor.visit()", "path": "library/ast#ast.NodeVisitor.visit", "type": "Language", "text": "\nVisit a node. The default implementation calls the method called\n`self.visit_classname` where classname is the name of the node class, or\n`generic_visit()` if that method doesn\u2019t exist.\n\n"}, {"name": "ast.Nonlocal", "path": "library/ast#ast.Nonlocal", "type": "Language", "text": "\n`global` and `nonlocal` statements. `names` is a list of raw strings.\n\n"}, {"name": "ast.Not", "path": "library/ast#ast.Not", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.NotEq", "path": "library/ast#ast.NotEq", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.NotIn", "path": "library/ast#ast.NotIn", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.Or", "path": "library/ast#ast.Or", "type": "Language", "text": "\nBoolean operator tokens.\n\n"}, {"name": "ast.parse()", "path": "library/ast#ast.parse", "type": "Language", "text": "\nParse the source into an AST node. Equivalent to `compile(source, filename,\nmode, ast.PyCF_ONLY_AST)`.\n\n"}, {"name": "ast.Pass", "path": "library/ast#ast.Pass", "type": "Language", "text": "\nA `pass` statement.\n\n"}, {"name": "ast.Pow", "path": "library/ast#ast.Pow", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.PyCF_ALLOW_TOP_LEVEL_AWAIT", "path": "library/ast#ast.PyCF_ALLOW_TOP_LEVEL_AWAIT", "type": "Language", "text": "\nEnables support for top-level `await`, `async for`, `async with` and async\ncomprehensions.\n\n"}, {"name": "ast.PyCF_ONLY_AST", "path": "library/ast#ast.PyCF_ONLY_AST", "type": "Language", "text": "\nGenerates and returns an abstract syntax tree instead of returning a compiled\ncode object.\n\n"}, {"name": "ast.PyCF_TYPE_COMMENTS", "path": "library/ast#ast.PyCF_TYPE_COMMENTS", "type": "Language", "text": "\nEnables support for PEP 484 and PEP 526 style type comments (`# type: <type>`,\n`# type: ignore <stuff>`).\n\n"}, {"name": "ast.Raise", "path": "library/ast#ast.Raise", "type": "Language", "text": "\nA `raise` statement. `exc` is the exception object to be raised, normally a\n`Call` or `Name`, or `None` for a standalone `raise`. `cause` is the optional\npart for `y` in `raise x from y`.\n\n"}, {"name": "ast.Return", "path": "library/ast#ast.Return", "type": "Language", "text": "\nA `return` statement.\n\n"}, {"name": "ast.RShift", "path": "library/ast#ast.RShift", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Set", "path": "library/ast#ast.Set", "type": "Language", "text": "\nA set. `elts` holds a list of nodes representing the set\u2019s elements.\n\n"}, {"name": "ast.SetComp", "path": "library/ast#ast.SetComp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.Slice", "path": "library/ast#ast.Slice", "type": "Language", "text": "\nRegular slicing (on the form `lower:upper` or `lower:upper:step`). Can occur\nonly inside the slice field of `Subscript`, either directly or as an element\nof `Tuple`.\n\n"}, {"name": "ast.Starred", "path": "library/ast#ast.Starred", "type": "Language", "text": "\nA `*var` variable reference. `value` holds the variable, typically a `Name`\nnode. This type must be used when building a `Call` node with `*args`.\n\n"}, {"name": "ast.Store", "path": "library/ast#ast.Store", "type": "Language", "text": "\nVariable references can be used to load the value of a variable, to assign a\nnew value to it, or to delete it. Variable references are given a context to\ndistinguish these cases.\n\n"}, {"name": "ast.Sub", "path": "library/ast#ast.Sub", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Subscript", "path": "library/ast#ast.Subscript", "type": "Language", "text": "\nA subscript, such as `l[1]`. `value` is the subscripted object (usually\nsequence or mapping). `slice` is an index, slice or key. It can be a `Tuple`\nand contain a `Slice`. `ctx` is `Load`, `Store` or `Del` according to the\naction performed with the subscript.\n\n"}, {"name": "ast.Try", "path": "library/ast#ast.Try", "type": "Language", "text": "\n`try` blocks. All attributes are list of nodes to execute, except for\n`handlers`, which is a list of `ExceptHandler` nodes.\n\n"}, {"name": "ast.Tuple", "path": "library/ast#ast.Tuple", "type": "Language", "text": "\nA list or tuple. `elts` holds a list of nodes representing the elements. `ctx`\nis `Store` if the container is an assignment target (i.e. `(x,y)=something`),\nand `Load` otherwise.\n\n"}, {"name": "ast.UAdd", "path": "library/ast#ast.UAdd", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.UnaryOp", "path": "library/ast#ast.UnaryOp", "type": "Language", "text": "\nA unary operation. `op` is the operator, and `operand` any expression node.\n\n"}, {"name": "ast.unparse()", "path": "library/ast#ast.unparse", "type": "Language", "text": "\nUnparse an `ast.AST` object and generate a string with code that would produce\nan equivalent `ast.AST` object if parsed back with `ast.parse()`.\n\n"}, {"name": "ast.USub", "path": "library/ast#ast.USub", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.walk()", "path": "library/ast#ast.walk", "type": "Language", "text": "\nRecursively yield all descendant nodes in the tree starting at node (including\nnode itself), in no specified order. This is useful if you only want to modify\nnodes in place and don\u2019t care about the context.\n\n"}, {"name": "ast.While", "path": "library/ast#ast.While", "type": "Language", "text": "\nA `while` loop. `test` holds the condition, such as a `Compare` node.\n\n"}, {"name": "ast.With", "path": "library/ast#ast.With", "type": "Language", "text": "\nA `with` block. `items` is a list of `withitem` nodes representing the context\nmanagers, and `body` is the indented block inside the context.\n\n"}, {"name": "ast.With.type_comment", "path": "library/ast#ast.With.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.withitem", "path": "library/ast#ast.withitem", "type": "Language", "text": "\nA single context manager in a `with` block. `context_expr` is the context\nmanager, often a `Call` node. `optional_vars` is a `Name`, `Tuple` or `List`\nfor the `as foo` part, or `None` if that isn\u2019t used.\n\n"}, {"name": "ast.Yield", "path": "library/ast#ast.Yield", "type": "Language", "text": "\nA `yield` or `yield from` expression. Because these are expressions, they must\nbe wrapped in a `Expr` node if the value sent back is not used.\n\n"}, {"name": "ast.YieldFrom", "path": "library/ast#ast.YieldFrom", "type": "Language", "text": "\nA `yield` or `yield from` expression. Because these are expressions, they must\nbe wrapped in a `Expr` node if the value sent back is not used.\n\n"}, {"name": "asynchat", "path": "library/asynchat", "type": "Networking & Interprocess Communication", "text": "\nSource code: Lib/asynchat.py\n\n"}, {"name": "asynchat.async_chat", "path": "library/asynchat#asynchat.async_chat", "type": "Networking & Interprocess Communication", "text": "\nThis class is an abstract subclass of `asyncore.dispatcher`. To make practical\nuse of the code you must subclass `async_chat`, providing meaningful\n`collect_incoming_data()` and `found_terminator()` methods. The\n`asyncore.dispatcher` methods can be used, although not all make sense in a\nmessage/response context.\n\n"}, {"name": "asynchat.async_chat.ac_in_buffer_size", "path": "library/asynchat#asynchat.async_chat.ac_in_buffer_size", "type": "Networking & Interprocess Communication", "text": "\nThe asynchronous input buffer size (default `4096`).\n\n"}, {"name": "asynchat.async_chat.ac_out_buffer_size", "path": "library/asynchat#asynchat.async_chat.ac_out_buffer_size", "type": "Networking & Interprocess Communication", "text": "\nThe asynchronous output buffer size (default `4096`).\n\n"}, {"name": "asynchat.async_chat.close_when_done()", "path": "library/asynchat#asynchat.async_chat.close_when_done", "type": "Networking & Interprocess Communication", "text": "\nPushes a `None` on to the producer queue. When this producer is popped off the\nqueue it causes the channel to be closed.\n\n"}, {"name": "asynchat.async_chat.collect_incoming_data()", "path": "library/asynchat#asynchat.async_chat.collect_incoming_data", "type": "Networking & Interprocess Communication", "text": "\nCalled with data holding an arbitrary amount of received data. The default\nmethod, which must be overridden, raises a `NotImplementedError` exception.\n\n"}, {"name": "asynchat.async_chat.discard_buffers()", "path": "library/asynchat#asynchat.async_chat.discard_buffers", "type": "Networking & Interprocess Communication", "text": "\nIn emergencies this method will discard any data held in the input and/or\noutput buffers and the producer queue.\n\n"}, {"name": "asynchat.async_chat.found_terminator()", "path": "library/asynchat#asynchat.async_chat.found_terminator", "type": "Networking & Interprocess Communication", "text": "\nCalled when the incoming data stream matches the termination condition set by\n`set_terminator()`. The default method, which must be overridden, raises a\n`NotImplementedError` exception. The buffered input data should be available\nvia an instance attribute.\n\n"}, {"name": "asynchat.async_chat.get_terminator()", "path": "library/asynchat#asynchat.async_chat.get_terminator", "type": "Networking & Interprocess Communication", "text": "\nReturns the current terminator for the channel.\n\n"}, {"name": "asynchat.async_chat.push()", "path": "library/asynchat#asynchat.async_chat.push", "type": "Networking & Interprocess Communication", "text": "\nPushes data on to the channel\u2019s queue to ensure its transmission. This is all\nyou need to do to have the channel write the data out to the network, although\nit is possible to use your own producers in more complex schemes to implement\nencryption and chunking, for example.\n\n"}, {"name": "asynchat.async_chat.push_with_producer()", "path": "library/asynchat#asynchat.async_chat.push_with_producer", "type": "Networking & Interprocess Communication", "text": "\nTakes a producer object and adds it to the producer queue associated with the\nchannel. When all currently-pushed producers have been exhausted the channel\nwill consume this producer\u2019s data by calling its `more()` method and send the\ndata to the remote endpoint.\n\n"}, {"name": "asynchat.async_chat.set_terminator()", "path": "library/asynchat#asynchat.async_chat.set_terminator", "type": "Networking & Interprocess Communication", "text": "\nSets the terminating condition to be recognized on the channel. `term` may be\nany of three types of value, corresponding to three different ways to handle\nincoming protocol data.\n\n"}, {"name": "asyncio", "path": "library/asyncio", "type": "Asynchronous I/O", "text": "\nHello World!\n\n"}, {"name": "asyncio.AbstractChildWatcher", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher", "type": "Asynchronous I/O", "text": "\nRegister a new child handler.\n\n"}, {"name": "asyncio.AbstractChildWatcher.add_child_handler()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.add_child_handler", "type": "Asynchronous I/O", "text": "\nRegister a new child handler.\n\n"}, {"name": "asyncio.AbstractChildWatcher.attach_loop()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.attach_loop", "type": "Asynchronous I/O", "text": "\nAttach the watcher to an event loop.\n\n"}, {"name": "asyncio.AbstractChildWatcher.close()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.close", "type": "Asynchronous I/O", "text": "\nClose the watcher.\n\n"}, {"name": "asyncio.AbstractChildWatcher.is_active()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.is_active", "type": "Asynchronous I/O", "text": "\nReturn `True` if the watcher is ready to use.\n\n"}, {"name": "asyncio.AbstractChildWatcher.remove_child_handler()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.remove_child_handler", "type": "Asynchronous I/O", "text": "\nRemoves the handler for process with PID equal to pid.\n\n"}, {"name": "asyncio.AbstractEventLoop", "path": "library/asyncio-eventloop#asyncio.AbstractEventLoop", "type": "Asynchronous I/O", "text": "\nAbstract base class for asyncio-compliant event loops.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nAn abstract base class for asyncio policies.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.get_child_watcher()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.get_child_watcher", "type": "Asynchronous I/O", "text": "\nGet a child process watcher object.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.get_event_loop()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.get_event_loop", "type": "Asynchronous I/O", "text": "\nGet the event loop for the current context.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.new_event_loop()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.new_event_loop", "type": "Asynchronous I/O", "text": "\nCreate and return a new event loop object.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.set_child_watcher()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.set_child_watcher", "type": "Asynchronous I/O", "text": "\nSet the current child process watcher to watcher.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.set_event_loop()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.set_event_loop", "type": "Asynchronous I/O", "text": "\nSet the event loop for the current context to loop.\n\n"}, {"name": "asyncio.all_tasks()", "path": "library/asyncio-task#asyncio.all_tasks", "type": "Asynchronous I/O", "text": "\nReturn a set of not yet finished `Task` objects run by the loop.\n\n"}, {"name": "asyncio.asyncio.subprocess.DEVNULL", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.DEVNULL", "type": "Asynchronous I/O", "text": "\nSpecial value that can be used as the stdin, stdout or stderr argument to\nprocess creation functions. It indicates that the special file `os.devnull`\nwill be used for the corresponding subprocess stream.\n\n"}, {"name": "asyncio.asyncio.subprocess.PIPE", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.PIPE", "type": "Asynchronous I/O", "text": "\nCan be passed to the stdin, stdout or stderr parameters.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process", "type": "Asynchronous I/O", "text": "\nAn object that wraps OS processes created by the `create_subprocess_exec()`\nand `create_subprocess_shell()` functions.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.communicate()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.communicate", "type": "Asynchronous I/O", "text": "\nInteract with process:\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.kill()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.kill", "type": "Asynchronous I/O", "text": "\nKill the child process.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.pid", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.pid", "type": "Asynchronous I/O", "text": "\nProcess identification number (PID).\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.returncode", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.returncode", "type": "Asynchronous I/O", "text": "\nReturn code of the process when it exits.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.send_signal()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.send_signal", "type": "Asynchronous I/O", "text": "\nSends the signal signal to the child process.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.stderr", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.stderr", "type": "Asynchronous I/O", "text": "\nStandard error stream (`StreamReader`) or `None` if the process was created\nwith `stderr=None`.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.stdin", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.stdin", "type": "Asynchronous I/O", "text": "\nStandard input stream (`StreamWriter`) or `None` if the process was created\nwith `stdin=None`.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.stdout", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.stdout", "type": "Asynchronous I/O", "text": "\nStandard output stream (`StreamReader`) or `None` if the process was created\nwith `stdout=None`.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.terminate()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.terminate", "type": "Asynchronous I/O", "text": "\nStop the child process.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.wait()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.wait", "type": "Asynchronous I/O", "text": "\nWait for the child process to terminate.\n\n"}, {"name": "asyncio.asyncio.subprocess.STDOUT", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.STDOUT", "type": "Asynchronous I/O", "text": "\nSpecial value that can be used as the stderr argument and indicates that\nstandard error should be redirected into standard output.\n\n"}, {"name": "asyncio.as_completed()", "path": "library/asyncio-task#asyncio.as_completed", "type": "Asynchronous I/O", "text": "\nRun awaitable objects in the aws iterable concurrently. Return an iterator of\ncoroutines. Each coroutine returned can be awaited to get the earliest next\nresult from the iterable of the remaining awaitables.\n\n"}, {"name": "asyncio.BaseProtocol", "path": "library/asyncio-protocol#asyncio.BaseProtocol", "type": "Asynchronous I/O", "text": "\nBase protocol with methods that all protocols share.\n\n"}, {"name": "asyncio.BaseProtocol.connection_lost()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.connection_lost", "type": "Asynchronous I/O", "text": "\nCalled when the connection is lost or closed.\n\n"}, {"name": "asyncio.BaseProtocol.connection_made()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.connection_made", "type": "Asynchronous I/O", "text": "\nCalled when a connection is made.\n\n"}, {"name": "asyncio.BaseProtocol.pause_writing()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.pause_writing", "type": "Asynchronous I/O", "text": "\nCalled when the transport\u2019s buffer goes over the high watermark.\n\n"}, {"name": "asyncio.BaseProtocol.resume_writing()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.resume_writing", "type": "Asynchronous I/O", "text": "\nCalled when the transport\u2019s buffer drains below the low watermark.\n\n"}, {"name": "asyncio.BaseTransport", "path": "library/asyncio-protocol#asyncio.BaseTransport", "type": "Asynchronous I/O", "text": "\nBase class for all transports. Contains methods that all asyncio transports\nshare.\n\n"}, {"name": "asyncio.BaseTransport.close()", "path": "library/asyncio-protocol#asyncio.BaseTransport.close", "type": "Asynchronous I/O", "text": "\nClose the transport.\n\n"}, {"name": "asyncio.BaseTransport.get_extra_info()", "path": "library/asyncio-protocol#asyncio.BaseTransport.get_extra_info", "type": "Asynchronous I/O", "text": "\nReturn information about the transport or underlying resources it uses.\n\n"}, {"name": "asyncio.BaseTransport.get_protocol()", "path": "library/asyncio-protocol#asyncio.BaseTransport.get_protocol", "type": "Asynchronous I/O", "text": "\nReturn the current protocol.\n\n"}, {"name": "asyncio.BaseTransport.is_closing()", "path": "library/asyncio-protocol#asyncio.BaseTransport.is_closing", "type": "Asynchronous I/O", "text": "\nReturn `True` if the transport is closing or is closed.\n\n"}, {"name": "asyncio.BaseTransport.set_protocol()", "path": "library/asyncio-protocol#asyncio.BaseTransport.set_protocol", "type": "Asynchronous I/O", "text": "\nSet a new protocol.\n\n"}, {"name": "asyncio.BoundedSemaphore", "path": "library/asyncio-sync#asyncio.BoundedSemaphore", "type": "Asynchronous I/O", "text": "\nA bounded semaphore object. Not thread-safe.\n\n"}, {"name": "asyncio.BufferedProtocol", "path": "library/asyncio-protocol#asyncio.BufferedProtocol", "type": "Asynchronous I/O", "text": "\nA base class for implementing streaming protocols with manual control of the\nreceive buffer.\n\n"}, {"name": "asyncio.BufferedProtocol.buffer_updated()", "path": "library/asyncio-protocol#asyncio.BufferedProtocol.buffer_updated", "type": "Asynchronous I/O", "text": "\nCalled when the buffer was updated with the received data.\n\n"}, {"name": "asyncio.BufferedProtocol.eof_received()", "path": "library/asyncio-protocol#asyncio.BufferedProtocol.eof_received", "type": "Asynchronous I/O", "text": "\nSee the documentation of the `protocol.eof_received()` method.\n\n"}, {"name": "asyncio.BufferedProtocol.get_buffer()", "path": "library/asyncio-protocol#asyncio.BufferedProtocol.get_buffer", "type": "Asynchronous I/O", "text": "\nCalled to allocate a new receive buffer.\n\n"}, {"name": "asyncio.CancelledError", "path": "library/asyncio-exceptions#asyncio.CancelledError", "type": "Asynchronous I/O", "text": "\nThe operation has been cancelled.\n\n"}, {"name": "asyncio.Condition", "path": "library/asyncio-sync#asyncio.Condition", "type": "Asynchronous I/O", "text": "\nA Condition object. Not thread-safe.\n\n"}, {"name": "asyncio.Condition.acquire()", "path": "library/asyncio-sync#asyncio.Condition.acquire", "type": "Asynchronous I/O", "text": "\nAcquire the underlying lock.\n\n"}, {"name": "asyncio.Condition.locked()", "path": "library/asyncio-sync#asyncio.Condition.locked", "type": "Asynchronous I/O", "text": "\nReturn `True` if the underlying lock is acquired.\n\n"}, {"name": "asyncio.Condition.notify()", "path": "library/asyncio-sync#asyncio.Condition.notify", "type": "Asynchronous I/O", "text": "\nWake up at most n tasks (1 by default) waiting on this condition. The method\nis no-op if no tasks are waiting.\n\n"}, {"name": "asyncio.Condition.notify_all()", "path": "library/asyncio-sync#asyncio.Condition.notify_all", "type": "Asynchronous I/O", "text": "\nWake up all tasks waiting on this condition.\n\n"}, {"name": "asyncio.Condition.release()", "path": "library/asyncio-sync#asyncio.Condition.release", "type": "Asynchronous I/O", "text": "\nRelease the underlying lock.\n\n"}, {"name": "asyncio.Condition.wait()", "path": "library/asyncio-sync#asyncio.Condition.wait", "type": "Asynchronous I/O", "text": "\nWait until notified.\n\n"}, {"name": "asyncio.Condition.wait_for()", "path": "library/asyncio-sync#asyncio.Condition.wait_for", "type": "Asynchronous I/O", "text": "\nWait until a predicate becomes true.\n\n"}, {"name": "asyncio.coroutine()", "path": "library/asyncio-task#asyncio.coroutine", "type": "Asynchronous I/O", "text": "\nDecorator to mark generator-based coroutines.\n\n"}, {"name": "asyncio.create_subprocess_exec()", "path": "library/asyncio-subprocess#asyncio.create_subprocess_exec", "type": "Asynchronous I/O", "text": "\nCreate a subprocess.\n\n"}, {"name": "asyncio.create_subprocess_shell()", "path": "library/asyncio-subprocess#asyncio.create_subprocess_shell", "type": "Asynchronous I/O", "text": "\nRun the cmd shell command.\n\n"}, {"name": "asyncio.create_task()", "path": "library/asyncio-task#asyncio.create_task", "type": "Asynchronous I/O", "text": "\nWrap the coro coroutine into a `Task` and schedule its execution. Return the\nTask object.\n\n"}, {"name": "asyncio.current_task()", "path": "library/asyncio-task#asyncio.current_task", "type": "Asynchronous I/O", "text": "\nReturn the currently running `Task` instance, or `None` if no task is running.\n\n"}, {"name": "asyncio.DatagramProtocol", "path": "library/asyncio-protocol#asyncio.DatagramProtocol", "type": "Asynchronous I/O", "text": "\nThe base class for implementing datagram (UDP) protocols.\n\n"}, {"name": "asyncio.DatagramProtocol.datagram_received()", "path": "library/asyncio-protocol#asyncio.DatagramProtocol.datagram_received", "type": "Asynchronous I/O", "text": "\nCalled when a datagram is received. data is a bytes object containing the\nincoming data. addr is the address of the peer sending the data; the exact\nformat depends on the transport.\n\n"}, {"name": "asyncio.DatagramProtocol.error_received()", "path": "library/asyncio-protocol#asyncio.DatagramProtocol.error_received", "type": "Asynchronous I/O", "text": "\nCalled when a previous send or receive operation raises an `OSError`. exc is\nthe `OSError` instance.\n\n"}, {"name": "asyncio.DatagramTransport", "path": "library/asyncio-protocol#asyncio.DatagramTransport", "type": "Asynchronous I/O", "text": "\nA transport for datagram (UDP) connections.\n\n"}, {"name": "asyncio.DatagramTransport.abort()", "path": "library/asyncio-protocol#asyncio.DatagramTransport.abort", "type": "Asynchronous I/O", "text": "\nClose the transport immediately, without waiting for pending operations to\ncomplete. Buffered data will be lost. No more data will be received. The\nprotocol\u2019s `protocol.connection_lost()` method will eventually be called with\n`None` as its argument.\n\n"}, {"name": "asyncio.DatagramTransport.sendto()", "path": "library/asyncio-protocol#asyncio.DatagramTransport.sendto", "type": "Asynchronous I/O", "text": "\nSend the data bytes to the remote peer given by addr (a transport-dependent\ntarget address). If addr is `None`, the data is sent to the target address\ngiven on transport creation.\n\n"}, {"name": "asyncio.DefaultEventLoopPolicy", "path": "library/asyncio-policy#asyncio.DefaultEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nThe default asyncio policy. Uses `SelectorEventLoop` on Unix and\n`ProactorEventLoop` on Windows.\n\n"}, {"name": "asyncio.ensure_future()", "path": "library/asyncio-future#asyncio.ensure_future", "type": "Asynchronous I/O", "text": "\nReturn:\n\n"}, {"name": "asyncio.Event", "path": "library/asyncio-sync#asyncio.Event", "type": "Asynchronous I/O", "text": "\nAn event object. Not thread-safe.\n\n"}, {"name": "asyncio.Event.clear()", "path": "library/asyncio-sync#asyncio.Event.clear", "type": "Asynchronous I/O", "text": "\nClear (unset) the event.\n\n"}, {"name": "asyncio.Event.is_set()", "path": "library/asyncio-sync#asyncio.Event.is_set", "type": "Asynchronous I/O", "text": "\nReturn `True` if the event is set.\n\n"}, {"name": "asyncio.Event.set()", "path": "library/asyncio-sync#asyncio.Event.set", "type": "Asynchronous I/O", "text": "\nSet the event.\n\n"}, {"name": "asyncio.Event.wait()", "path": "library/asyncio-sync#asyncio.Event.wait", "type": "Asynchronous I/O", "text": "\nWait until the event is set.\n\n"}, {"name": "asyncio.FastChildWatcher", "path": "library/asyncio-policy#asyncio.FastChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation reaps every terminated processes by calling\n`os.waitpid(-1)` directly, possibly breaking other code spawning processes and\nwaiting for their termination.\n\n"}, {"name": "asyncio.Future", "path": "library/asyncio-future#asyncio.Future", "type": "Asynchronous I/O", "text": "\nA Future represents an eventual result of an asynchronous operation. Not\nthread-safe.\n\n"}, {"name": "asyncio.Future.add_done_callback()", "path": "library/asyncio-future#asyncio.Future.add_done_callback", "type": "Asynchronous I/O", "text": "\nAdd a callback to be run when the Future is done.\n\n"}, {"name": "asyncio.Future.cancel()", "path": "library/asyncio-future#asyncio.Future.cancel", "type": "Asynchronous I/O", "text": "\nCancel the Future and schedule callbacks.\n\n"}, {"name": "asyncio.Future.cancelled()", "path": "library/asyncio-future#asyncio.Future.cancelled", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Future was cancelled.\n\n"}, {"name": "asyncio.Future.done()", "path": "library/asyncio-future#asyncio.Future.done", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Future is done.\n\n"}, {"name": "asyncio.Future.exception()", "path": "library/asyncio-future#asyncio.Future.exception", "type": "Asynchronous I/O", "text": "\nReturn the exception that was set on this Future.\n\n"}, {"name": "asyncio.Future.get_loop()", "path": "library/asyncio-future#asyncio.Future.get_loop", "type": "Asynchronous I/O", "text": "\nReturn the event loop the Future object is bound to.\n\n"}, {"name": "asyncio.Future.remove_done_callback()", "path": "library/asyncio-future#asyncio.Future.remove_done_callback", "type": "Asynchronous I/O", "text": "\nRemove callback from the callbacks list.\n\n"}, {"name": "asyncio.Future.result()", "path": "library/asyncio-future#asyncio.Future.result", "type": "Asynchronous I/O", "text": "\nReturn the result of the Future.\n\n"}, {"name": "asyncio.Future.set_exception()", "path": "library/asyncio-future#asyncio.Future.set_exception", "type": "Asynchronous I/O", "text": "\nMark the Future as done and set an exception.\n\n"}, {"name": "asyncio.Future.set_result()", "path": "library/asyncio-future#asyncio.Future.set_result", "type": "Asynchronous I/O", "text": "\nMark the Future as done and set its result.\n\n"}, {"name": "asyncio.gather()", "path": "library/asyncio-task#asyncio.gather", "type": "Asynchronous I/O", "text": "\nRun awaitable objects in the aws sequence concurrently.\n\n"}, {"name": "asyncio.get_child_watcher()", "path": "library/asyncio-policy#asyncio.get_child_watcher", "type": "Asynchronous I/O", "text": "\nReturn the current child watcher for the current policy.\n\n"}, {"name": "asyncio.get_event_loop()", "path": "library/asyncio-eventloop#asyncio.get_event_loop", "type": "Asynchronous I/O", "text": "\nGet the current event loop.\n\n"}, {"name": "asyncio.get_event_loop_policy()", "path": "library/asyncio-policy#asyncio.get_event_loop_policy", "type": "Asynchronous I/O", "text": "\nReturn the current process-wide policy.\n\n"}, {"name": "asyncio.get_running_loop()", "path": "library/asyncio-eventloop#asyncio.get_running_loop", "type": "Asynchronous I/O", "text": "\nReturn the running event loop in the current OS thread.\n\n"}, {"name": "asyncio.Handle", "path": "library/asyncio-eventloop#asyncio.Handle", "type": "Asynchronous I/O", "text": "\nA callback wrapper object returned by `loop.call_soon()`,\n`loop.call_soon_threadsafe()`.\n\n"}, {"name": "asyncio.Handle.cancel()", "path": "library/asyncio-eventloop#asyncio.Handle.cancel", "type": "Asynchronous I/O", "text": "\nCancel the callback. If the callback has already been canceled or executed,\nthis method has no effect.\n\n"}, {"name": "asyncio.Handle.cancelled()", "path": "library/asyncio-eventloop#asyncio.Handle.cancelled", "type": "Asynchronous I/O", "text": "\nReturn `True` if the callback was cancelled.\n\n"}, {"name": "asyncio.IncompleteReadError", "path": "library/asyncio-exceptions#asyncio.IncompleteReadError", "type": "Asynchronous I/O", "text": "\nThe requested read operation did not complete fully.\n\n"}, {"name": "asyncio.IncompleteReadError.expected", "path": "library/asyncio-exceptions#asyncio.IncompleteReadError.expected", "type": "Asynchronous I/O", "text": "\nThe total number (`int`) of expected bytes.\n\n"}, {"name": "asyncio.IncompleteReadError.partial", "path": "library/asyncio-exceptions#asyncio.IncompleteReadError.partial", "type": "Asynchronous I/O", "text": "\nA string of `bytes` read before the end of stream was reached.\n\n"}, {"name": "asyncio.InvalidStateError", "path": "library/asyncio-exceptions#asyncio.InvalidStateError", "type": "Asynchronous I/O", "text": "\nInvalid internal state of `Task` or `Future`.\n\n"}, {"name": "asyncio.iscoroutine()", "path": "library/asyncio-task#asyncio.iscoroutine", "type": "Asynchronous I/O", "text": "\nReturn `True` if obj is a coroutine object.\n\n"}, {"name": "asyncio.iscoroutinefunction()", "path": "library/asyncio-task#asyncio.iscoroutinefunction", "type": "Asynchronous I/O", "text": "\nReturn `True` if func is a coroutine function.\n\n"}, {"name": "asyncio.isfuture()", "path": "library/asyncio-future#asyncio.isfuture", "type": "Asynchronous I/O", "text": "\nReturn `True` if obj is either of:\n\n"}, {"name": "asyncio.LifoQueue", "path": "library/asyncio-queue#asyncio.LifoQueue", "type": "Asynchronous I/O", "text": "\nA variant of `Queue` that retrieves most recently added entries first (last\nin, first out).\n\n"}, {"name": "asyncio.LimitOverrunError", "path": "library/asyncio-exceptions#asyncio.LimitOverrunError", "type": "Asynchronous I/O", "text": "\nReached the buffer size limit while looking for a separator.\n\n"}, {"name": "asyncio.LimitOverrunError.consumed", "path": "library/asyncio-exceptions#asyncio.LimitOverrunError.consumed", "type": "Asynchronous I/O", "text": "\nThe total number of to be consumed bytes.\n\n"}, {"name": "asyncio.Lock", "path": "library/asyncio-sync#asyncio.Lock", "type": "Asynchronous I/O", "text": "\nImplements a mutex lock for asyncio tasks. Not thread-safe.\n\n"}, {"name": "asyncio.Lock.acquire()", "path": "library/asyncio-sync#asyncio.Lock.acquire", "type": "Asynchronous I/O", "text": "\nAcquire the lock.\n\n"}, {"name": "asyncio.Lock.locked()", "path": "library/asyncio-sync#asyncio.Lock.locked", "type": "Asynchronous I/O", "text": "\nReturn `True` if the lock is locked.\n\n"}, {"name": "asyncio.Lock.release()", "path": "library/asyncio-sync#asyncio.Lock.release", "type": "Asynchronous I/O", "text": "\nRelease the lock.\n\n"}, {"name": "asyncio.loop.add_reader()", "path": "library/asyncio-eventloop#asyncio.loop.add_reader", "type": "Asynchronous I/O", "text": "\nStart monitoring the fd file descriptor for read availability and invoke\ncallback with the specified arguments once fd is available for reading.\n\n"}, {"name": "asyncio.loop.add_signal_handler()", "path": "library/asyncio-eventloop#asyncio.loop.add_signal_handler", "type": "Asynchronous I/O", "text": "\nSet callback as the handler for the signum signal.\n\n"}, {"name": "asyncio.loop.add_writer()", "path": "library/asyncio-eventloop#asyncio.loop.add_writer", "type": "Asynchronous I/O", "text": "\nStart monitoring the fd file descriptor for write availability and invoke\ncallback with the specified arguments once fd is available for writing.\n\n"}, {"name": "asyncio.loop.call_at()", "path": "library/asyncio-eventloop#asyncio.loop.call_at", "type": "Asynchronous I/O", "text": "\nSchedule callback to be called at the given absolute timestamp when (an int or\na float), using the same time reference as `loop.time()`.\n\n"}, {"name": "asyncio.loop.call_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.call_exception_handler", "type": "Asynchronous I/O", "text": "\nCall the current event loop exception handler.\n\n"}, {"name": "asyncio.loop.call_later()", "path": "library/asyncio-eventloop#asyncio.loop.call_later", "type": "Asynchronous I/O", "text": "\nSchedule callback to be called after the given delay number of seconds (can be\neither an int or a float).\n\n"}, {"name": "asyncio.loop.call_soon()", "path": "library/asyncio-eventloop#asyncio.loop.call_soon", "type": "Asynchronous I/O", "text": "\nSchedule the callback callback to be called with args arguments at the next\niteration of the event loop.\n\n"}, {"name": "asyncio.loop.call_soon_threadsafe()", "path": "library/asyncio-eventloop#asyncio.loop.call_soon_threadsafe", "type": "Asynchronous I/O", "text": "\nA thread-safe variant of `call_soon()`. Must be used to schedule callbacks\nfrom another thread.\n\n"}, {"name": "asyncio.loop.close()", "path": "library/asyncio-eventloop#asyncio.loop.close", "type": "Asynchronous I/O", "text": "\nClose the event loop.\n\n"}, {"name": "asyncio.loop.connect_accepted_socket()", "path": "library/asyncio-eventloop#asyncio.loop.connect_accepted_socket", "type": "Asynchronous I/O", "text": "\nWrap an already accepted connection into a transport/protocol pair.\n\n"}, {"name": "asyncio.loop.connect_read_pipe()", "path": "library/asyncio-eventloop#asyncio.loop.connect_read_pipe", "type": "Asynchronous I/O", "text": "\nRegister the read end of pipe in the event loop.\n\n"}, {"name": "asyncio.loop.connect_write_pipe()", "path": "library/asyncio-eventloop#asyncio.loop.connect_write_pipe", "type": "Asynchronous I/O", "text": "\nRegister the write end of pipe in the event loop.\n\n"}, {"name": "asyncio.loop.create_connection()", "path": "library/asyncio-eventloop#asyncio.loop.create_connection", "type": "Asynchronous I/O", "text": "\nOpen a streaming transport connection to a given address specified by host and\nport.\n\n"}, {"name": "asyncio.loop.create_datagram_endpoint()", "path": "library/asyncio-eventloop#asyncio.loop.create_datagram_endpoint", "type": "Asynchronous I/O", "text": "\nNote\n\n"}, {"name": "asyncio.loop.create_future()", "path": "library/asyncio-eventloop#asyncio.loop.create_future", "type": "Asynchronous I/O", "text": "\nCreate an `asyncio.Future` object attached to the event loop.\n\n"}, {"name": "asyncio.loop.create_server()", "path": "library/asyncio-eventloop#asyncio.loop.create_server", "type": "Asynchronous I/O", "text": "\nCreate a TCP server (socket type `SOCK_STREAM`) listening on port of the host\naddress.\n\n"}, {"name": "asyncio.loop.create_task()", "path": "library/asyncio-eventloop#asyncio.loop.create_task", "type": "Asynchronous I/O", "text": "\nSchedule the execution of a Coroutines. Return a `Task` object.\n\n"}, {"name": "asyncio.loop.create_unix_connection()", "path": "library/asyncio-eventloop#asyncio.loop.create_unix_connection", "type": "Asynchronous I/O", "text": "\nCreate a Unix connection.\n\n"}, {"name": "asyncio.loop.create_unix_server()", "path": "library/asyncio-eventloop#asyncio.loop.create_unix_server", "type": "Asynchronous I/O", "text": "\nSimilar to `loop.create_server()` but works with the `AF_UNIX` socket family.\n\n"}, {"name": "asyncio.loop.default_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.default_exception_handler", "type": "Asynchronous I/O", "text": "\nDefault exception handler.\n\n"}, {"name": "asyncio.loop.getaddrinfo()", "path": "library/asyncio-eventloop#asyncio.loop.getaddrinfo", "type": "Asynchronous I/O", "text": "\nAsynchronous version of `socket.getaddrinfo()`.\n\n"}, {"name": "asyncio.loop.getnameinfo()", "path": "library/asyncio-eventloop#asyncio.loop.getnameinfo", "type": "Asynchronous I/O", "text": "\nAsynchronous version of `socket.getnameinfo()`.\n\n"}, {"name": "asyncio.loop.get_debug()", "path": "library/asyncio-eventloop#asyncio.loop.get_debug", "type": "Asynchronous I/O", "text": "\nGet the debug mode (`bool`) of the event loop.\n\n"}, {"name": "asyncio.loop.get_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.get_exception_handler", "type": "Asynchronous I/O", "text": "\nReturn the current exception handler, or `None` if no custom exception handler\nwas set.\n\n"}, {"name": "asyncio.loop.get_task_factory()", "path": "library/asyncio-eventloop#asyncio.loop.get_task_factory", "type": "Asynchronous I/O", "text": "\nReturn a task factory or `None` if the default one is in use.\n\n"}, {"name": "asyncio.loop.is_closed()", "path": "library/asyncio-eventloop#asyncio.loop.is_closed", "type": "Asynchronous I/O", "text": "\nReturn `True` if the event loop was closed.\n\n"}, {"name": "asyncio.loop.is_running()", "path": "library/asyncio-eventloop#asyncio.loop.is_running", "type": "Asynchronous I/O", "text": "\nReturn `True` if the event loop is currently running.\n\n"}, {"name": "asyncio.loop.remove_reader()", "path": "library/asyncio-eventloop#asyncio.loop.remove_reader", "type": "Asynchronous I/O", "text": "\nStop monitoring the fd file descriptor for read availability.\n\n"}, {"name": "asyncio.loop.remove_signal_handler()", "path": "library/asyncio-eventloop#asyncio.loop.remove_signal_handler", "type": "Asynchronous I/O", "text": "\nRemove the handler for the sig signal.\n\n"}, {"name": "asyncio.loop.remove_writer()", "path": "library/asyncio-eventloop#asyncio.loop.remove_writer", "type": "Asynchronous I/O", "text": "\nStop monitoring the fd file descriptor for write availability.\n\n"}, {"name": "asyncio.loop.run_forever()", "path": "library/asyncio-eventloop#asyncio.loop.run_forever", "type": "Asynchronous I/O", "text": "\nRun the event loop until `stop()` is called.\n\n"}, {"name": "asyncio.loop.run_in_executor()", "path": "library/asyncio-eventloop#asyncio.loop.run_in_executor", "type": "Asynchronous I/O", "text": "\nArrange for func to be called in the specified executor.\n\n"}, {"name": "asyncio.loop.run_until_complete()", "path": "library/asyncio-eventloop#asyncio.loop.run_until_complete", "type": "Asynchronous I/O", "text": "\nRun until the future (an instance of `Future`) has completed.\n\n"}, {"name": "asyncio.loop.sendfile()", "path": "library/asyncio-eventloop#asyncio.loop.sendfile", "type": "Asynchronous I/O", "text": "\nSend a file over a transport. Return the total number of bytes sent.\n\n"}, {"name": "asyncio.loop.set_debug()", "path": "library/asyncio-eventloop#asyncio.loop.set_debug", "type": "Asynchronous I/O", "text": "\nSet the debug mode of the event loop.\n\n"}, {"name": "asyncio.loop.set_default_executor()", "path": "library/asyncio-eventloop#asyncio.loop.set_default_executor", "type": "Asynchronous I/O", "text": "\nSet executor as the default executor used by `run_in_executor()`. executor\nshould be an instance of `ThreadPoolExecutor`.\n\n"}, {"name": "asyncio.loop.set_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.set_exception_handler", "type": "Asynchronous I/O", "text": "\nSet handler as the new event loop exception handler.\n\n"}, {"name": "asyncio.loop.set_task_factory()", "path": "library/asyncio-eventloop#asyncio.loop.set_task_factory", "type": "Asynchronous I/O", "text": "\nSet a task factory that will be used by `loop.create_task()`.\n\n"}, {"name": "asyncio.loop.shutdown_asyncgens()", "path": "library/asyncio-eventloop#asyncio.loop.shutdown_asyncgens", "type": "Asynchronous I/O", "text": "\nSchedule all currently open asynchronous generator objects to close with an\n`aclose()` call. After calling this method, the event loop will issue a\nwarning if a new asynchronous generator is iterated. This should be used to\nreliably finalize all scheduled asynchronous generators.\n\n"}, {"name": "asyncio.loop.shutdown_default_executor()", "path": "library/asyncio-eventloop#asyncio.loop.shutdown_default_executor", "type": "Asynchronous I/O", "text": "\nSchedule the closure of the default executor and wait for it to join all of\nthe threads in the `ThreadPoolExecutor`. After calling this method, a\n`RuntimeError` will be raised if `loop.run_in_executor()` is called while\nusing the default executor.\n\n"}, {"name": "asyncio.loop.sock_accept()", "path": "library/asyncio-eventloop#asyncio.loop.sock_accept", "type": "Asynchronous I/O", "text": "\nAccept a connection. Modeled after the blocking `socket.accept()` method.\n\n"}, {"name": "asyncio.loop.sock_connect()", "path": "library/asyncio-eventloop#asyncio.loop.sock_connect", "type": "Asynchronous I/O", "text": "\nConnect sock to a remote socket at address.\n\n"}, {"name": "asyncio.loop.sock_recv()", "path": "library/asyncio-eventloop#asyncio.loop.sock_recv", "type": "Asynchronous I/O", "text": "\nReceive up to nbytes from sock. Asynchronous version of `socket.recv()`.\n\n"}, {"name": "asyncio.loop.sock_recv_into()", "path": "library/asyncio-eventloop#asyncio.loop.sock_recv_into", "type": "Asynchronous I/O", "text": "\nReceive data from sock into the buf buffer. Modeled after the blocking\n`socket.recv_into()` method.\n\n"}, {"name": "asyncio.loop.sock_sendall()", "path": "library/asyncio-eventloop#asyncio.loop.sock_sendall", "type": "Asynchronous I/O", "text": "\nSend data to the sock socket. Asynchronous version of `socket.sendall()`.\n\n"}, {"name": "asyncio.loop.sock_sendfile()", "path": "library/asyncio-eventloop#asyncio.loop.sock_sendfile", "type": "Asynchronous I/O", "text": "\nSend a file using high-performance `os.sendfile` if possible. Return the total\nnumber of bytes sent.\n\n"}, {"name": "asyncio.loop.start_tls()", "path": "library/asyncio-eventloop#asyncio.loop.start_tls", "type": "Asynchronous I/O", "text": "\nUpgrade an existing transport-based connection to TLS.\n\n"}, {"name": "asyncio.loop.stop()", "path": "library/asyncio-eventloop#asyncio.loop.stop", "type": "Asynchronous I/O", "text": "\nStop the event loop.\n\n"}, {"name": "asyncio.loop.subprocess_exec()", "path": "library/asyncio-eventloop#asyncio.loop.subprocess_exec", "type": "Asynchronous I/O", "text": "\nCreate a subprocess from one or more string arguments specified by args.\n\n"}, {"name": "asyncio.loop.subprocess_shell()", "path": "library/asyncio-eventloop#asyncio.loop.subprocess_shell", "type": "Asynchronous I/O", "text": "\nCreate a subprocess from cmd, which can be a `str` or a `bytes` string encoded\nto the filesystem encoding, using the platform\u2019s \u201cshell\u201d syntax.\n\n"}, {"name": "asyncio.loop.time()", "path": "library/asyncio-eventloop#asyncio.loop.time", "type": "Asynchronous I/O", "text": "\nReturn the current time, as a `float` value, according to the event loop\u2019s\ninternal monotonic clock.\n\n"}, {"name": "asyncio.MultiLoopChildWatcher", "path": "library/asyncio-policy#asyncio.MultiLoopChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation registers a `SIGCHLD` signal handler on instantiation.\nThat can break third-party code that installs a custom handler for `SIGCHLD`\nsignal.\n\n"}, {"name": "asyncio.new_event_loop()", "path": "library/asyncio-eventloop#asyncio.new_event_loop", "type": "Asynchronous I/O", "text": "\nCreate a new event loop object.\n\n"}, {"name": "asyncio.open_connection()", "path": "library/asyncio-stream#asyncio.open_connection", "type": "Asynchronous I/O", "text": "\nEstablish a network connection and return a pair of `(reader, writer)`\nobjects.\n\n"}, {"name": "asyncio.open_unix_connection()", "path": "library/asyncio-stream#asyncio.open_unix_connection", "type": "Asynchronous I/O", "text": "\nEstablish a Unix socket connection and return a pair of `(reader, writer)`.\n\n"}, {"name": "asyncio.PidfdChildWatcher", "path": "library/asyncio-policy#asyncio.PidfdChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation polls process file descriptors (pidfds) to await child\nprocess termination. In some respects, `PidfdChildWatcher` is a \u201cGoldilocks\u201d\nchild watcher implementation. It doesn\u2019t require signals or threads, doesn\u2019t\ninterfere with any processes launched outside the event loop, and scales\nlinearly with the number of subprocesses launched by the event loop. The main\ndisadvantage is that pidfds are specific to Linux, and only work on recent\n(5.3+) kernels.\n\n"}, {"name": "asyncio.PriorityQueue", "path": "library/asyncio-queue#asyncio.PriorityQueue", "type": "Asynchronous I/O", "text": "\nA variant of `Queue`; retrieves entries in priority order (lowest first).\n\n"}, {"name": "asyncio.ProactorEventLoop", "path": "library/asyncio-eventloop#asyncio.ProactorEventLoop", "type": "Asynchronous I/O", "text": "\nAn event loop for Windows that uses \u201cI/O Completion Ports\u201d (IOCP).\n\n"}, {"name": "asyncio.Protocol", "path": "library/asyncio-protocol#asyncio.Protocol", "type": "Asynchronous I/O", "text": "\nThe base class for implementing streaming protocols (TCP, Unix sockets, etc).\n\n"}, {"name": "asyncio.Protocol.data_received()", "path": "library/asyncio-protocol#asyncio.Protocol.data_received", "type": "Asynchronous I/O", "text": "\nCalled when some data is received. data is a non-empty bytes object containing\nthe incoming data.\n\n"}, {"name": "asyncio.Protocol.eof_received()", "path": "library/asyncio-protocol#asyncio.Protocol.eof_received", "type": "Asynchronous I/O", "text": "\nCalled when the other end signals it won\u2019t send any more data (for example by\ncalling `transport.write_eof()`, if the other end also uses asyncio).\n\n"}, {"name": "asyncio.Queue", "path": "library/asyncio-queue#asyncio.Queue", "type": "Asynchronous I/O", "text": "\nA first in, first out (FIFO) queue.\n\n"}, {"name": "asyncio.Queue.empty()", "path": "library/asyncio-queue#asyncio.Queue.empty", "type": "Asynchronous I/O", "text": "\nReturn `True` if the queue is empty, `False` otherwise.\n\n"}, {"name": "asyncio.Queue.full()", "path": "library/asyncio-queue#asyncio.Queue.full", "type": "Asynchronous I/O", "text": "\nReturn `True` if there are `maxsize` items in the queue.\n\n"}, {"name": "asyncio.Queue.get()", "path": "library/asyncio-queue#asyncio.Queue.get", "type": "Asynchronous I/O", "text": "\nRemove and return an item from the queue. If queue is empty, wait until an\nitem is available.\n\n"}, {"name": "asyncio.Queue.get_nowait()", "path": "library/asyncio-queue#asyncio.Queue.get_nowait", "type": "Asynchronous I/O", "text": "\nReturn an item if one is immediately available, else raise `QueueEmpty`.\n\n"}, {"name": "asyncio.Queue.join()", "path": "library/asyncio-queue#asyncio.Queue.join", "type": "Asynchronous I/O", "text": "\nBlock until all items in the queue have been received and processed.\n\n"}, {"name": "asyncio.Queue.maxsize", "path": "library/asyncio-queue#asyncio.Queue.maxsize", "type": "Asynchronous I/O", "text": "\nNumber of items allowed in the queue.\n\n"}, {"name": "asyncio.Queue.put()", "path": "library/asyncio-queue#asyncio.Queue.put", "type": "Asynchronous I/O", "text": "\nPut an item into the queue. If the queue is full, wait until a free slot is\navailable before adding the item.\n\n"}, {"name": "asyncio.Queue.put_nowait()", "path": "library/asyncio-queue#asyncio.Queue.put_nowait", "type": "Asynchronous I/O", "text": "\nPut an item into the queue without blocking.\n\n"}, {"name": "asyncio.Queue.qsize()", "path": "library/asyncio-queue#asyncio.Queue.qsize", "type": "Asynchronous I/O", "text": "\nReturn the number of items in the queue.\n\n"}, {"name": "asyncio.Queue.task_done()", "path": "library/asyncio-queue#asyncio.Queue.task_done", "type": "Asynchronous I/O", "text": "\nIndicate that a formerly enqueued task is complete.\n\n"}, {"name": "asyncio.QueueEmpty", "path": "library/asyncio-queue#asyncio.QueueEmpty", "type": "Asynchronous I/O", "text": "\nThis exception is raised when the `get_nowait()` method is called on an empty\nqueue.\n\n"}, {"name": "asyncio.QueueFull", "path": "library/asyncio-queue#asyncio.QueueFull", "type": "Asynchronous I/O", "text": "\nException raised when the `put_nowait()` method is called on a queue that has\nreached its maxsize.\n\n"}, {"name": "asyncio.ReadTransport", "path": "library/asyncio-protocol#asyncio.ReadTransport", "type": "Asynchronous I/O", "text": "\nA base transport for read-only connections.\n\n"}, {"name": "asyncio.ReadTransport.is_reading()", "path": "library/asyncio-protocol#asyncio.ReadTransport.is_reading", "type": "Asynchronous I/O", "text": "\nReturn `True` if the transport is receiving new data.\n\n"}, {"name": "asyncio.ReadTransport.pause_reading()", "path": "library/asyncio-protocol#asyncio.ReadTransport.pause_reading", "type": "Asynchronous I/O", "text": "\nPause the receiving end of the transport. No data will be passed to the\nprotocol\u2019s `protocol.data_received()` method until `resume_reading()` is\ncalled.\n\n"}, {"name": "asyncio.ReadTransport.resume_reading()", "path": "library/asyncio-protocol#asyncio.ReadTransport.resume_reading", "type": "Asynchronous I/O", "text": "\nResume the receiving end. The protocol\u2019s `protocol.data_received()` method\nwill be called once again if some data is available for reading.\n\n"}, {"name": "asyncio.run()", "path": "library/asyncio-task#asyncio.run", "type": "Asynchronous I/O", "text": "\nExecute the coroutine coro and return the result.\n\n"}, {"name": "asyncio.run_coroutine_threadsafe()", "path": "library/asyncio-task#asyncio.run_coroutine_threadsafe", "type": "Asynchronous I/O", "text": "\nSubmit a coroutine to the given event loop. Thread-safe.\n\n"}, {"name": "asyncio.SafeChildWatcher", "path": "library/asyncio-policy#asyncio.SafeChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation uses active event loop from the main thread to handle\n`SIGCHLD` signal. If the main thread has no running event loop another thread\ncannot spawn a subprocess (`RuntimeError` is raised).\n\n"}, {"name": "asyncio.SelectorEventLoop", "path": "library/asyncio-eventloop#asyncio.SelectorEventLoop", "type": "Asynchronous I/O", "text": "\nAn event loop based on the `selectors` module.\n\n"}, {"name": "asyncio.Semaphore", "path": "library/asyncio-sync#asyncio.Semaphore", "type": "Asynchronous I/O", "text": "\nA Semaphore object. Not thread-safe.\n\n"}, {"name": "asyncio.Semaphore.acquire()", "path": "library/asyncio-sync#asyncio.Semaphore.acquire", "type": "Asynchronous I/O", "text": "\nAcquire a semaphore.\n\n"}, {"name": "asyncio.Semaphore.locked()", "path": "library/asyncio-sync#asyncio.Semaphore.locked", "type": "Asynchronous I/O", "text": "\nReturns `True` if semaphore can not be acquired immediately.\n\n"}, {"name": "asyncio.Semaphore.release()", "path": "library/asyncio-sync#asyncio.Semaphore.release", "type": "Asynchronous I/O", "text": "\nRelease a semaphore, incrementing the internal counter by one. Can wake up a\ntask waiting to acquire the semaphore.\n\n"}, {"name": "asyncio.SendfileNotAvailableError", "path": "library/asyncio-exceptions#asyncio.SendfileNotAvailableError", "type": "Asynchronous I/O", "text": "\nThe \u201csendfile\u201d syscall is not available for the given socket or file type.\n\n"}, {"name": "asyncio.Server", "path": "library/asyncio-eventloop#asyncio.Server", "type": "Asynchronous I/O", "text": "\nServer objects are asynchronous context managers. When used in an `async with`\nstatement, it\u2019s guaranteed that the Server object is closed and not accepting\nnew connections when the `async with` statement is completed:\n\n"}, {"name": "asyncio.Server.close()", "path": "library/asyncio-eventloop#asyncio.Server.close", "type": "Asynchronous I/O", "text": "\nStop serving: close listening sockets and set the `sockets` attribute to\n`None`.\n\n"}, {"name": "asyncio.Server.get_loop()", "path": "library/asyncio-eventloop#asyncio.Server.get_loop", "type": "Asynchronous I/O", "text": "\nReturn the event loop associated with the server object.\n\n"}, {"name": "asyncio.Server.is_serving()", "path": "library/asyncio-eventloop#asyncio.Server.is_serving", "type": "Asynchronous I/O", "text": "\nReturn `True` if the server is accepting new connections.\n\n"}, {"name": "asyncio.Server.serve_forever()", "path": "library/asyncio-eventloop#asyncio.Server.serve_forever", "type": "Asynchronous I/O", "text": "\nStart accepting connections until the coroutine is cancelled. Cancellation of\n`serve_forever` task causes the server to be closed.\n\n"}, {"name": "asyncio.Server.sockets", "path": "library/asyncio-eventloop#asyncio.Server.sockets", "type": "Asynchronous I/O", "text": "\nList of `socket.socket` objects the server is listening on.\n\n"}, {"name": "asyncio.Server.start_serving()", "path": "library/asyncio-eventloop#asyncio.Server.start_serving", "type": "Asynchronous I/O", "text": "\nStart accepting connections.\n\n"}, {"name": "asyncio.Server.wait_closed()", "path": "library/asyncio-eventloop#asyncio.Server.wait_closed", "type": "Asynchronous I/O", "text": "\nWait until the `close()` method completes.\n\n"}, {"name": "asyncio.set_child_watcher()", "path": "library/asyncio-policy#asyncio.set_child_watcher", "type": "Asynchronous I/O", "text": "\nSet the current child watcher to watcher for the current policy. watcher must\nimplement methods defined in the `AbstractChildWatcher` base class.\n\n"}, {"name": "asyncio.set_event_loop()", "path": "library/asyncio-eventloop#asyncio.set_event_loop", "type": "Asynchronous I/O", "text": "\nSet loop as a current event loop for the current OS thread.\n\n"}, {"name": "asyncio.set_event_loop_policy()", "path": "library/asyncio-policy#asyncio.set_event_loop_policy", "type": "Asynchronous I/O", "text": "\nSet the current process-wide policy to policy.\n\n"}, {"name": "asyncio.shield()", "path": "library/asyncio-task#asyncio.shield", "type": "Asynchronous I/O", "text": "\nProtect an awaitable object from being `cancelled`.\n\n"}, {"name": "asyncio.sleep()", "path": "library/asyncio-task#asyncio.sleep", "type": "Asynchronous I/O", "text": "\nBlock for delay seconds.\n\n"}, {"name": "asyncio.start_server()", "path": "library/asyncio-stream#asyncio.start_server", "type": "Asynchronous I/O", "text": "\nStart a socket server.\n\n"}, {"name": "asyncio.start_unix_server()", "path": "library/asyncio-stream#asyncio.start_unix_server", "type": "Asynchronous I/O", "text": "\nStart a Unix socket server.\n\n"}, {"name": "asyncio.StreamReader", "path": "library/asyncio-stream#asyncio.StreamReader", "type": "Asynchronous I/O", "text": "\nRepresents a reader object that provides APIs to read data from the IO stream.\n\n"}, {"name": "asyncio.StreamReader.at_eof()", "path": "library/asyncio-stream#asyncio.StreamReader.at_eof", "type": "Asynchronous I/O", "text": "\nReturn `True` if the buffer is empty and `feed_eof()` was called.\n\n"}, {"name": "asyncio.StreamReader.read()", "path": "library/asyncio-stream#asyncio.StreamReader.read", "type": "Asynchronous I/O", "text": "\nRead up to n bytes. If n is not provided, or set to `-1`, read until EOF and\nreturn all read bytes.\n\n"}, {"name": "asyncio.StreamReader.readexactly()", "path": "library/asyncio-stream#asyncio.StreamReader.readexactly", "type": "Asynchronous I/O", "text": "\nRead exactly n bytes.\n\n"}, {"name": "asyncio.StreamReader.readline()", "path": "library/asyncio-stream#asyncio.StreamReader.readline", "type": "Asynchronous I/O", "text": "\nRead one line, where \u201cline\u201d is a sequence of bytes ending with `\\n`.\n\n"}, {"name": "asyncio.StreamReader.readuntil()", "path": "library/asyncio-stream#asyncio.StreamReader.readuntil", "type": "Asynchronous I/O", "text": "\nRead data from the stream until separator is found.\n\n"}, {"name": "asyncio.StreamWriter", "path": "library/asyncio-stream#asyncio.StreamWriter", "type": "Asynchronous I/O", "text": "\nRepresents a writer object that provides APIs to write data to the IO stream.\n\n"}, {"name": "asyncio.StreamWriter.can_write_eof()", "path": "library/asyncio-stream#asyncio.StreamWriter.can_write_eof", "type": "Asynchronous I/O", "text": "\nReturn `True` if the underlying transport supports the `write_eof()` method,\n`False` otherwise.\n\n"}, {"name": "asyncio.StreamWriter.close()", "path": "library/asyncio-stream#asyncio.StreamWriter.close", "type": "Asynchronous I/O", "text": "\nThe method closes the stream and the underlying socket.\n\n"}, {"name": "asyncio.StreamWriter.drain()", "path": "library/asyncio-stream#asyncio.StreamWriter.drain", "type": "Asynchronous I/O", "text": "\nWait until it is appropriate to resume writing to the stream. Example:\n\n"}, {"name": "asyncio.StreamWriter.get_extra_info()", "path": "library/asyncio-stream#asyncio.StreamWriter.get_extra_info", "type": "Asynchronous I/O", "text": "\nAccess optional transport information; see `BaseTransport.get_extra_info()`\nfor details.\n\n"}, {"name": "asyncio.StreamWriter.is_closing()", "path": "library/asyncio-stream#asyncio.StreamWriter.is_closing", "type": "Asynchronous I/O", "text": "\nReturn `True` if the stream is closed or in the process of being closed.\n\n"}, {"name": "asyncio.StreamWriter.transport", "path": "library/asyncio-stream#asyncio.StreamWriter.transport", "type": "Asynchronous I/O", "text": "\nReturn the underlying asyncio transport.\n\n"}, {"name": "asyncio.StreamWriter.wait_closed()", "path": "library/asyncio-stream#asyncio.StreamWriter.wait_closed", "type": "Asynchronous I/O", "text": "\nWait until the stream is closed.\n\n"}, {"name": "asyncio.StreamWriter.write()", "path": "library/asyncio-stream#asyncio.StreamWriter.write", "type": "Asynchronous I/O", "text": "\nThe method attempts to write the data to the underlying socket immediately. If\nthat fails, the data is queued in an internal write buffer until it can be\nsent.\n\n"}, {"name": "asyncio.StreamWriter.writelines()", "path": "library/asyncio-stream#asyncio.StreamWriter.writelines", "type": "Asynchronous I/O", "text": "\nThe method writes a list (or any iterable) of bytes to the underlying socket\nimmediately. If that fails, the data is queued in an internal write buffer\nuntil it can be sent.\n\n"}, {"name": "asyncio.StreamWriter.write_eof()", "path": "library/asyncio-stream#asyncio.StreamWriter.write_eof", "type": "Asynchronous I/O", "text": "\nClose the write end of the stream after the buffered write data is flushed.\n\n"}, {"name": "asyncio.SubprocessProtocol", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol", "type": "Asynchronous I/O", "text": "\nThe base class for implementing protocols communicating with child processes\n(unidirectional pipes).\n\n"}, {"name": "asyncio.SubprocessProtocol.pipe_connection_lost()", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol.pipe_connection_lost", "type": "Asynchronous I/O", "text": "\nCalled when one of the pipes communicating with the child process is closed.\n\n"}, {"name": "asyncio.SubprocessProtocol.pipe_data_received()", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol.pipe_data_received", "type": "Asynchronous I/O", "text": "\nCalled when the child process writes data into its stdout or stderr pipe.\n\n"}, {"name": "asyncio.SubprocessProtocol.process_exited()", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol.process_exited", "type": "Asynchronous I/O", "text": "\nCalled when the child process has exited.\n\n"}, {"name": "asyncio.SubprocessTransport", "path": "library/asyncio-protocol#asyncio.SubprocessTransport", "type": "Asynchronous I/O", "text": "\nAn abstraction to represent a connection between a parent and its child OS\nprocess.\n\n"}, {"name": "asyncio.SubprocessTransport.close()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.close", "type": "Asynchronous I/O", "text": "\nKill the subprocess by calling the `kill()` method.\n\n"}, {"name": "asyncio.SubprocessTransport.get_pid()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.get_pid", "type": "Asynchronous I/O", "text": "\nReturn the subprocess process id as an integer.\n\n"}, {"name": "asyncio.SubprocessTransport.get_pipe_transport()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.get_pipe_transport", "type": "Asynchronous I/O", "text": "\nReturn the transport for the communication pipe corresponding to the integer\nfile descriptor fd:\n\n"}, {"name": "asyncio.SubprocessTransport.get_returncode()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.get_returncode", "type": "Asynchronous I/O", "text": "\nReturn the subprocess return code as an integer or `None` if it hasn\u2019t\nreturned, which is similar to the `subprocess.Popen.returncode` attribute.\n\n"}, {"name": "asyncio.SubprocessTransport.kill()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.kill", "type": "Asynchronous I/O", "text": "\nKill the subprocess.\n\n"}, {"name": "asyncio.SubprocessTransport.send_signal()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.send_signal", "type": "Asynchronous I/O", "text": "\nSend the signal number to the subprocess, as in\n`subprocess.Popen.send_signal()`.\n\n"}, {"name": "asyncio.SubprocessTransport.terminate()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.terminate", "type": "Asynchronous I/O", "text": "\nStop the subprocess.\n\n"}, {"name": "asyncio.Task", "path": "library/asyncio-task#asyncio.Task", "type": "Asynchronous I/O", "text": "\nA `Future-like` object that runs a Python coroutine. Not thread-safe.\n\n"}, {"name": "asyncio.Task.add_done_callback()", "path": "library/asyncio-task#asyncio.Task.add_done_callback", "type": "Asynchronous I/O", "text": "\nAdd a callback to be run when the Task is done.\n\n"}, {"name": "asyncio.Task.cancel()", "path": "library/asyncio-task#asyncio.Task.cancel", "type": "Asynchronous I/O", "text": "\nRequest the Task to be cancelled.\n\n"}, {"name": "asyncio.Task.cancelled()", "path": "library/asyncio-task#asyncio.Task.cancelled", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Task is cancelled.\n\n"}, {"name": "asyncio.Task.done()", "path": "library/asyncio-task#asyncio.Task.done", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Task is done.\n\n"}, {"name": "asyncio.Task.exception()", "path": "library/asyncio-task#asyncio.Task.exception", "type": "Asynchronous I/O", "text": "\nReturn the exception of the Task.\n\n"}, {"name": "asyncio.Task.get_coro()", "path": "library/asyncio-task#asyncio.Task.get_coro", "type": "Asynchronous I/O", "text": "\nReturn the coroutine object wrapped by the `Task`.\n\n"}, {"name": "asyncio.Task.get_name()", "path": "library/asyncio-task#asyncio.Task.get_name", "type": "Asynchronous I/O", "text": "\nReturn the name of the Task.\n\n"}, {"name": "asyncio.Task.get_stack()", "path": "library/asyncio-task#asyncio.Task.get_stack", "type": "Asynchronous I/O", "text": "\nReturn the list of stack frames for this Task.\n\n"}, {"name": "asyncio.Task.print_stack()", "path": "library/asyncio-task#asyncio.Task.print_stack", "type": "Asynchronous I/O", "text": "\nPrint the stack or traceback for this Task.\n\n"}, {"name": "asyncio.Task.remove_done_callback()", "path": "library/asyncio-task#asyncio.Task.remove_done_callback", "type": "Asynchronous I/O", "text": "\nRemove callback from the callbacks list.\n\n"}, {"name": "asyncio.Task.result()", "path": "library/asyncio-task#asyncio.Task.result", "type": "Asynchronous I/O", "text": "\nReturn the result of the Task.\n\n"}, {"name": "asyncio.Task.set_name()", "path": "library/asyncio-task#asyncio.Task.set_name", "type": "Asynchronous I/O", "text": "\nSet the name of the Task.\n\n"}, {"name": "asyncio.ThreadedChildWatcher", "path": "library/asyncio-policy#asyncio.ThreadedChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation starts a new waiting thread for every subprocess spawn.\n\n"}, {"name": "asyncio.TimeoutError", "path": "library/asyncio-exceptions#asyncio.TimeoutError", "type": "Asynchronous I/O", "text": "\nThe operation has exceeded the given deadline.\n\n"}, {"name": "asyncio.TimerHandle", "path": "library/asyncio-eventloop#asyncio.TimerHandle", "type": "Asynchronous I/O", "text": "\nA callback wrapper object returned by `loop.call_later()`, and\n`loop.call_at()`.\n\n"}, {"name": "asyncio.TimerHandle.when()", "path": "library/asyncio-eventloop#asyncio.TimerHandle.when", "type": "Asynchronous I/O", "text": "\nReturn a scheduled callback time as `float` seconds.\n\n"}, {"name": "asyncio.to_thread()", "path": "library/asyncio-task#asyncio.to_thread", "type": "Asynchronous I/O", "text": "\nAsynchronously run function func in a separate thread.\n\n"}, {"name": "asyncio.Transport", "path": "library/asyncio-protocol#asyncio.Transport", "type": "Asynchronous I/O", "text": "\nInterface representing a bidirectional transport, such as a TCP connection.\n\n"}, {"name": "asyncio.wait()", "path": "library/asyncio-task#asyncio.wait", "type": "Asynchronous I/O", "text": "\nRun awaitable objects in the aws iterable concurrently and block until the\ncondition specified by return_when.\n\n"}, {"name": "asyncio.wait_for()", "path": "library/asyncio-task#asyncio.wait_for", "type": "Asynchronous I/O", "text": "\nWait for the aw awaitable to complete with a timeout.\n\n"}, {"name": "asyncio.WindowsProactorEventLoopPolicy", "path": "library/asyncio-policy#asyncio.WindowsProactorEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nAn alternative event loop policy that uses the `ProactorEventLoop` event loop\nimplementation.\n\n"}, {"name": "asyncio.WindowsSelectorEventLoopPolicy", "path": "library/asyncio-policy#asyncio.WindowsSelectorEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nAn alternative event loop policy that uses the `SelectorEventLoop` event loop\nimplementation.\n\n"}, {"name": "asyncio.wrap_future()", "path": "library/asyncio-future#asyncio.wrap_future", "type": "Asynchronous I/O", "text": "\nWrap a `concurrent.futures.Future` object in a `asyncio.Future` object.\n\n"}, {"name": "asyncio.WriteTransport", "path": "library/asyncio-protocol#asyncio.WriteTransport", "type": "Asynchronous I/O", "text": "\nA base transport for write-only connections.\n\n"}, {"name": "asyncio.WriteTransport.abort()", "path": "library/asyncio-protocol#asyncio.WriteTransport.abort", "type": "Asynchronous I/O", "text": "\nClose the transport immediately, without waiting for pending operations to\ncomplete. Buffered data will be lost. No more data will be received. The\nprotocol\u2019s `protocol.connection_lost()` method will eventually be called with\n`None` as its argument.\n\n"}, {"name": "asyncio.WriteTransport.can_write_eof()", "path": "library/asyncio-protocol#asyncio.WriteTransport.can_write_eof", "type": "Asynchronous I/O", "text": "\nReturn `True` if the transport supports `write_eof()`, `False` if not.\n\n"}, {"name": "asyncio.WriteTransport.get_write_buffer_limits()", "path": "library/asyncio-protocol#asyncio.WriteTransport.get_write_buffer_limits", "type": "Asynchronous I/O", "text": "\nGet the high and low watermarks for write flow control. Return a tuple `(low,\nhigh)` where low and high are positive number of bytes.\n\n"}, {"name": "asyncio.WriteTransport.get_write_buffer_size()", "path": "library/asyncio-protocol#asyncio.WriteTransport.get_write_buffer_size", "type": "Asynchronous I/O", "text": "\nReturn the current size of the output buffer used by the transport.\n\n"}, {"name": "asyncio.WriteTransport.set_write_buffer_limits()", "path": "library/asyncio-protocol#asyncio.WriteTransport.set_write_buffer_limits", "type": "Asynchronous I/O", "text": "\nSet the high and low watermarks for write flow control.\n\n"}, {"name": "asyncio.WriteTransport.write()", "path": "library/asyncio-protocol#asyncio.WriteTransport.write", "type": "Asynchronous I/O", "text": "\nWrite some data bytes to the transport.\n\n"}, {"name": "asyncio.WriteTransport.writelines()", "path": "library/asyncio-protocol#asyncio.WriteTransport.writelines", "type": "Asynchronous I/O", "text": "\nWrite a list (or any iterable) of data bytes to the transport. This is\nfunctionally equivalent to calling `write()` on each element yielded by the\niterable, but may be implemented more efficiently.\n\n"}, {"name": "asyncio.WriteTransport.write_eof()", "path": "library/asyncio-protocol#asyncio.WriteTransport.write_eof", "type": "Asynchronous I/O", "text": "\nClose the write end of the transport after flushing all buffered data. Data\nmay still be received.\n\n"}, {"name": "asyncore", "path": "library/asyncore", "type": "Networking & Interprocess Communication", "text": "\nSource code: Lib/asyncore.py\n\n"}, {"name": "asyncore.dispatcher", "path": "library/asyncore#asyncore.dispatcher", "type": "Networking & Interprocess Communication", "text": "\nThe `dispatcher` class is a thin wrapper around a low-level socket object. To\nmake it more useful, it has a few methods for event-handling which are called\nfrom the asynchronous loop. Otherwise, it can be treated as a normal non-\nblocking socket object.\n\n"}, {"name": "asyncore.dispatcher.accept()", "path": "library/asyncore#asyncore.dispatcher.accept", "type": "Networking & Interprocess Communication", "text": "\nAccept a connection. The socket must be bound to an address and listening for\nconnections. The return value can be either `None` or a pair `(conn, address)`\nwhere conn is a new socket object usable to send and receive data on the\nconnection, and address is the address bound to the socket on the other end of\nthe connection. When `None` is returned it means the connection didn\u2019t take\nplace, in which case the server should just ignore this event and keep\nlistening for further incoming connections.\n\n"}, {"name": "asyncore.dispatcher.bind()", "path": "library/asyncore#asyncore.dispatcher.bind", "type": "Networking & Interprocess Communication", "text": "\nBind the socket to address. The socket must not already be bound. (The format\nof address depends on the address family \u2014 refer to the `socket` documentation\nfor more information.) To mark the socket as re-usable (setting the\n`SO_REUSEADDR` option), call the `dispatcher` object\u2019s `set_reuse_addr()`\nmethod.\n\n"}, {"name": "asyncore.dispatcher.close()", "path": "library/asyncore#asyncore.dispatcher.close", "type": "Networking & Interprocess Communication", "text": "\nClose the socket. All future operations on the socket object will fail. The\nremote end-point will receive no more data (after queued data is flushed).\nSockets are automatically closed when they are garbage-collected.\n\n"}, {"name": "asyncore.dispatcher.connect()", "path": "library/asyncore#asyncore.dispatcher.connect", "type": "Networking & Interprocess Communication", "text": "\nAs with the normal socket object, address is a tuple with the first element\nthe host to connect to, and the second the port number.\n\n"}, {"name": "asyncore.dispatcher.create_socket()", "path": "library/asyncore#asyncore.dispatcher.create_socket", "type": "Networking & Interprocess Communication", "text": "\nThis is identical to the creation of a normal socket, and will use the same\noptions for creation. Refer to the `socket` documentation for information on\ncreating sockets.\n\n"}, {"name": "asyncore.dispatcher.handle_accept()", "path": "library/asyncore#asyncore.dispatcher.handle_accept", "type": "Networking & Interprocess Communication", "text": "\nCalled on listening channels (passive openers) when a connection can be\nestablished with a new remote endpoint that has issued a `connect()` call for\nthe local endpoint. Deprecated in version 3.2; use `handle_accepted()`\ninstead.\n\n"}, {"name": "asyncore.dispatcher.handle_accepted()", "path": "library/asyncore#asyncore.dispatcher.handle_accepted", "type": "Networking & Interprocess Communication", "text": "\nCalled on listening channels (passive openers) when a connection has been\nestablished with a new remote endpoint that has issued a `connect()` call for\nthe local endpoint. sock is a new socket object usable to send and receive\ndata on the connection, and addr is the address bound to the socket on the\nother end of the connection.\n\n"}, {"name": "asyncore.dispatcher.handle_close()", "path": "library/asyncore#asyncore.dispatcher.handle_close", "type": "Networking & Interprocess Communication", "text": "\nCalled when the socket is closed.\n\n"}, {"name": "asyncore.dispatcher.handle_connect()", "path": "library/asyncore#asyncore.dispatcher.handle_connect", "type": "Networking & Interprocess Communication", "text": "\nCalled when the active opener\u2019s socket actually makes a connection. Might send\na \u201cwelcome\u201d banner, or initiate a protocol negotiation with the remote\nendpoint, for example.\n\n"}, {"name": "asyncore.dispatcher.handle_error()", "path": "library/asyncore#asyncore.dispatcher.handle_error", "type": "Networking & Interprocess Communication", "text": "\nCalled when an exception is raised and not otherwise handled. The default\nversion prints a condensed traceback.\n\n"}, {"name": "asyncore.dispatcher.handle_expt()", "path": "library/asyncore#asyncore.dispatcher.handle_expt", "type": "Networking & Interprocess Communication", "text": "\nCalled when there is out of band (OOB) data for a socket connection. This will\nalmost never happen, as OOB is tenuously supported and rarely used.\n\n"}, {"name": "asyncore.dispatcher.handle_read()", "path": "library/asyncore#asyncore.dispatcher.handle_read", "type": "Networking & Interprocess Communication", "text": "\nCalled when the asynchronous loop detects that a `read()` call on the\nchannel\u2019s socket will succeed.\n\n"}, {"name": "asyncore.dispatcher.handle_write()", "path": "library/asyncore#asyncore.dispatcher.handle_write", "type": "Networking & Interprocess Communication", "text": "\nCalled when the asynchronous loop detects that a writable socket can be\nwritten. Often this method will implement the necessary buffering for\nperformance. For example:\n\n"}, {"name": "asyncore.dispatcher.listen()", "path": "library/asyncore#asyncore.dispatcher.listen", "type": "Networking & Interprocess Communication", "text": "\nListen for connections made to the socket. The backlog argument specifies the\nmaximum number of queued connections and should be at least 1; the maximum\nvalue is system-dependent (usually 5).\n\n"}, {"name": "asyncore.dispatcher.readable()", "path": "library/asyncore#asyncore.dispatcher.readable", "type": "Networking & Interprocess Communication", "text": "\nCalled each time around the asynchronous loop to determine whether a channel\u2019s\nsocket should be added to the list on which read events can occur. The default\nmethod simply returns `True`, indicating that by default, all channels will be\ninterested in read events.\n\n"}, {"name": "asyncore.dispatcher.recv()", "path": "library/asyncore#asyncore.dispatcher.recv", "type": "Networking & Interprocess Communication", "text": "\nRead at most buffer_size bytes from the socket\u2019s remote end-point. An empty\nbytes object implies that the channel has been closed from the other end.\n\n"}, {"name": "asyncore.dispatcher.send()", "path": "library/asyncore#asyncore.dispatcher.send", "type": "Networking & Interprocess Communication", "text": "\nSend data to the remote end-point of the socket.\n\n"}, {"name": "asyncore.dispatcher.writable()", "path": "library/asyncore#asyncore.dispatcher.writable", "type": "Networking & Interprocess Communication", "text": "\nCalled each time around the asynchronous loop to determine whether a channel\u2019s\nsocket should be added to the list on which write events can occur. The\ndefault method simply returns `True`, indicating that by default, all channels\nwill be interested in write events.\n\n"}, {"name": "asyncore.dispatcher_with_send", "path": "library/asyncore#asyncore.dispatcher_with_send", "type": "Networking & Interprocess Communication", "text": "\nA `dispatcher` subclass which adds simple buffered output capability, useful\nfor simple clients. For more sophisticated usage use `asynchat.async_chat`.\n\n"}, {"name": "asyncore.file_dispatcher", "path": "library/asyncore#asyncore.file_dispatcher", "type": "Networking & Interprocess Communication", "text": "\nA file_dispatcher takes a file descriptor or file object along with an\noptional map argument and wraps it for use with the `poll()` or `loop()`\nfunctions. If provided a file object or anything with a `fileno()` method,\nthat method will be called and passed to the `file_wrapper` constructor.\n\n"}, {"name": "asyncore.file_wrapper", "path": "library/asyncore#asyncore.file_wrapper", "type": "Networking & Interprocess Communication", "text": "\nA file_wrapper takes an integer file descriptor and calls `os.dup()` to\nduplicate the handle so that the original handle may be closed independently\nof the file_wrapper. This class implements sufficient methods to emulate a\nsocket for use by the `file_dispatcher` class.\n\n"}, {"name": "asyncore.loop()", "path": "library/asyncore#asyncore.loop", "type": "Networking & Interprocess Communication", "text": "\nEnter a polling loop that terminates after count passes or all open channels\nhave been closed. All arguments are optional. The count parameter defaults to\n`None`, resulting in the loop terminating only when all channels have been\nclosed. The timeout argument sets the timeout parameter for the appropriate\n`select()` or `poll()` call, measured in seconds; the default is 30 seconds.\nThe use_poll parameter, if true, indicates that `poll()` should be used in\npreference to `select()` (the default is `False`).\n\n"}, {"name": "atexit", "path": "library/atexit", "type": "Runtime", "text": "\nThe `atexit` module defines functions to register and unregister cleanup\nfunctions. Functions thus registered are automatically executed upon normal\ninterpreter termination. `atexit` runs these functions in the reverse order in\nwhich they were registered; if you register `A`, `B`, and `C`, at interpreter\ntermination time they will be run in the order `C`, `B`, `A`.\n\n"}, {"name": "atexit.register()", "path": "library/atexit#atexit.register", "type": "Runtime", "text": "\nRegister func as a function to be executed at termination. Any optional\narguments that are to be passed to func must be passed as arguments to\n`register()`. It is possible to register the same function and arguments more\nthan once.\n\n"}, {"name": "atexit.unregister()", "path": "library/atexit#atexit.unregister", "type": "Runtime", "text": "\nRemove func from the list of functions to be run at interpreter shutdown.\nAfter calling `unregister()`, func is guaranteed not to be called when the\ninterpreter shuts down, even if it was registered more than once.\n`unregister()` silently does nothing if func was not previously registered.\n\n"}, {"name": "AttributeError", "path": "library/exceptions#AttributeError", "type": "Built-in Exceptions", "text": "\nRaised when an attribute reference (see Attribute references) or assignment\nfails. (When an object does not support attribute references or attribute\nassignments at all, `TypeError` is raised.)\n\n"}, {"name": "audioop", "path": "library/audioop", "type": "Multimedia", "text": "\nThe `audioop` module contains some useful operations on sound fragments. It\noperates on sound fragments consisting of signed integer samples 8, 16, 24 or\n32 bits wide, stored in bytes-like objects. All scalar items are integers,\nunless specified otherwise.\n\n"}, {"name": "audioop.add()", "path": "library/audioop#audioop.add", "type": "Multimedia", "text": "\nReturn a fragment which is the addition of the two samples passed as\nparameters. width is the sample width in bytes, either `1`, `2`, `3` or `4`.\nBoth fragments should have the same length. Samples are truncated in case of\noverflow.\n\n"}, {"name": "audioop.adpcm2lin()", "path": "library/audioop#audioop.adpcm2lin", "type": "Multimedia", "text": "\nDecode an Intel/DVI ADPCM coded fragment to a linear fragment. See the\ndescription of `lin2adpcm()` for details on ADPCM coding. Return a tuple\n`(sample, newstate)` where the sample has the width specified in width.\n\n"}, {"name": "audioop.alaw2lin()", "path": "library/audioop#audioop.alaw2lin", "type": "Multimedia", "text": "\nConvert sound fragments in a-LAW encoding to linearly encoded sound fragments.\na-LAW encoding always uses 8 bits samples, so width refers only to the sample\nwidth of the output fragment here.\n\n"}, {"name": "audioop.avg()", "path": "library/audioop#audioop.avg", "type": "Multimedia", "text": "\nReturn the average over all samples in the fragment.\n\n"}, {"name": "audioop.avgpp()", "path": "library/audioop#audioop.avgpp", "type": "Multimedia", "text": "\nReturn the average peak-peak value over all samples in the fragment. No\nfiltering is done, so the usefulness of this routine is questionable.\n\n"}, {"name": "audioop.bias()", "path": "library/audioop#audioop.bias", "type": "Multimedia", "text": "\nReturn a fragment that is the original fragment with a bias added to each\nsample. Samples wrap around in case of overflow.\n\n"}, {"name": "audioop.byteswap()", "path": "library/audioop#audioop.byteswap", "type": "Multimedia", "text": "\n\u201cByteswap\u201d all samples in a fragment and returns the modified fragment.\nConverts big-endian samples to little-endian and vice versa.\n\n"}, {"name": "audioop.cross()", "path": "library/audioop#audioop.cross", "type": "Multimedia", "text": "\nReturn the number of zero crossings in the fragment passed as an argument.\n\n"}, {"name": "audioop.error", "path": "library/audioop#audioop.error", "type": "Multimedia", "text": "\nThis exception is raised on all errors, such as unknown number of bytes per\nsample, etc.\n\n"}, {"name": "audioop.findfactor()", "path": "library/audioop#audioop.findfactor", "type": "Multimedia", "text": "\nReturn a factor F such that `rms(add(fragment, mul(reference, -F)))` is\nminimal, i.e., return the factor with which you should multiply reference to\nmake it match as well as possible to fragment. The fragments should both\ncontain 2-byte samples.\n\n"}, {"name": "audioop.findfit()", "path": "library/audioop#audioop.findfit", "type": "Multimedia", "text": "\nTry to match reference as well as possible to a portion of fragment (which\nshould be the longer fragment). This is (conceptually) done by taking slices\nout of fragment, using `findfactor()` to compute the best match, and\nminimizing the result. The fragments should both contain 2-byte samples.\nReturn a tuple `(offset, factor)` where offset is the (integer) offset into\nfragment where the optimal match started and factor is the (floating-point)\nfactor as per `findfactor()`.\n\n"}, {"name": "audioop.findmax()", "path": "library/audioop#audioop.findmax", "type": "Multimedia", "text": "\nSearch fragment for a slice of length length samples (not bytes!) with maximum\nenergy, i.e., return i for which `rms(fragment[i*2:(i+length)*2])` is maximal.\nThe fragments should both contain 2-byte samples.\n\n"}, {"name": "audioop.getsample()", "path": "library/audioop#audioop.getsample", "type": "Multimedia", "text": "\nReturn the value of sample index from the fragment.\n\n"}, {"name": "audioop.lin2adpcm()", "path": "library/audioop#audioop.lin2adpcm", "type": "Multimedia", "text": "\nConvert samples to 4 bit Intel/DVI ADPCM encoding. ADPCM coding is an adaptive\ncoding scheme, whereby each 4 bit number is the difference between one sample\nand the next, divided by a (varying) step. The Intel/DVI ADPCM algorithm has\nbeen selected for use by the IMA, so it may well become a standard.\n\n"}, {"name": "audioop.lin2alaw()", "path": "library/audioop#audioop.lin2alaw", "type": "Multimedia", "text": "\nConvert samples in the audio fragment to a-LAW encoding and return this as a\nbytes object. a-LAW is an audio encoding format whereby you get a dynamic\nrange of about 13 bits using only 8 bit samples. It is used by the Sun audio\nhardware, among others.\n\n"}, {"name": "audioop.lin2lin()", "path": "library/audioop#audioop.lin2lin", "type": "Multimedia", "text": "\nConvert samples between 1-, 2-, 3- and 4-byte formats.\n\n"}, {"name": "audioop.lin2ulaw()", "path": "library/audioop#audioop.lin2ulaw", "type": "Multimedia", "text": "\nConvert samples in the audio fragment to u-LAW encoding and return this as a\nbytes object. u-LAW is an audio encoding format whereby you get a dynamic\nrange of about 14 bits using only 8 bit samples. It is used by the Sun audio\nhardware, among others.\n\n"}, {"name": "audioop.max()", "path": "library/audioop#audioop.max", "type": "Multimedia", "text": "\nReturn the maximum of the absolute value of all samples in a fragment.\n\n"}, {"name": "audioop.maxpp()", "path": "library/audioop#audioop.maxpp", "type": "Multimedia", "text": "\nReturn the maximum peak-peak value in the sound fragment.\n\n"}, {"name": "audioop.minmax()", "path": "library/audioop#audioop.minmax", "type": "Multimedia", "text": "\nReturn a tuple consisting of the minimum and maximum values of all samples in\nthe sound fragment.\n\n"}, {"name": "audioop.mul()", "path": "library/audioop#audioop.mul", "type": "Multimedia", "text": "\nReturn a fragment that has all samples in the original fragment multiplied by\nthe floating-point value factor. Samples are truncated in case of overflow.\n\n"}, {"name": "audioop.ratecv()", "path": "library/audioop#audioop.ratecv", "type": "Multimedia", "text": "\nConvert the frame rate of the input fragment.\n\n"}, {"name": "audioop.reverse()", "path": "library/audioop#audioop.reverse", "type": "Multimedia", "text": "\nReverse the samples in a fragment and returns the modified fragment.\n\n"}, {"name": "audioop.rms()", "path": "library/audioop#audioop.rms", "type": "Multimedia", "text": "\nReturn the root-mean-square of the fragment, i.e. `sqrt(sum(S_i^2)/n)`.\n\n"}, {"name": "audioop.tomono()", "path": "library/audioop#audioop.tomono", "type": "Multimedia", "text": "\nConvert a stereo fragment to a mono fragment. The left channel is multiplied\nby lfactor and the right channel by rfactor before adding the two channels to\ngive a mono signal.\n\n"}, {"name": "audioop.tostereo()", "path": "library/audioop#audioop.tostereo", "type": "Multimedia", "text": "\nGenerate a stereo fragment from a mono fragment. Each pair of samples in the\nstereo fragment are computed from the mono sample, whereby left channel\nsamples are multiplied by lfactor and right channel samples by rfactor.\n\n"}, {"name": "audioop.ulaw2lin()", "path": "library/audioop#audioop.ulaw2lin", "type": "Multimedia", "text": "\nConvert sound fragments in u-LAW encoding to linearly encoded sound fragments.\nu-LAW encoding always uses 8 bits samples, so width refers only to the sample\nwidth of the output fragment here.\n\n"}, {"name": "Audit events table", "path": "library/audit_events", "type": "Debugging & Profiling", "text": "\nThis table contains all events raised by `sys.audit()` or `PySys_Audit()`\ncalls throughout the CPython runtime and the standard library. These calls\nwere added in 3.8.0 or later.\n\n"}, {"name": "base64", "path": "library/base64", "type": "Internet Data", "text": "\nSource code: Lib/base64.py\n\n"}, {"name": "base64.a85decode()", "path": "library/base64#base64.a85decode", "type": "Internet Data", "text": "\nDecode the Ascii85 encoded bytes-like object or ASCII string b and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.a85encode()", "path": "library/base64#base64.a85encode", "type": "Internet Data", "text": "\nEncode the bytes-like object b using Ascii85 and return the encoded `bytes`.\n\n"}, {"name": "base64.b16decode()", "path": "library/base64#base64.b16decode", "type": "Internet Data", "text": "\nDecode the Base16 encoded bytes-like object or ASCII string s and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.b16encode()", "path": "library/base64#base64.b16encode", "type": "Internet Data", "text": "\nEncode the bytes-like object s using Base16 and return the encoded `bytes`.\n\n"}, {"name": "base64.b32decode()", "path": "library/base64#base64.b32decode", "type": "Internet Data", "text": "\nDecode the Base32 encoded bytes-like object or ASCII string s and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.b32encode()", "path": "library/base64#base64.b32encode", "type": "Internet Data", "text": "\nEncode the bytes-like object s using Base32 and return the encoded `bytes`.\n\n"}, {"name": "base64.b64decode()", "path": "library/base64#base64.b64decode", "type": "Internet Data", "text": "\nDecode the Base64 encoded bytes-like object or ASCII string s and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.b64encode()", "path": "library/base64#base64.b64encode", "type": "Internet Data", "text": "\nEncode the bytes-like object s using Base64 and return the encoded `bytes`.\n\n"}, {"name": "base64.b85decode()", "path": "library/base64#base64.b85decode", "type": "Internet Data", "text": "\nDecode the base85-encoded bytes-like object or ASCII string b and return the\ndecoded `bytes`. Padding is implicitly removed, if necessary.\n\n"}, {"name": "base64.b85encode()", "path": "library/base64#base64.b85encode", "type": "Internet Data", "text": "\nEncode the bytes-like object b using base85 (as used in e.g. git-style binary\ndiffs) and return the encoded `bytes`.\n\n"}, {"name": "base64.decode()", "path": "library/base64#base64.decode", "type": "Internet Data", "text": "\nDecode the contents of the binary input file and write the resulting binary\ndata to the output file. input and output must be file objects. input will be\nread until `input.readline()` returns an empty bytes object.\n\n"}, {"name": "base64.decodebytes()", "path": "library/base64#base64.decodebytes", "type": "Internet Data", "text": "\nDecode the bytes-like object s, which must contain one or more lines of base64\nencoded data, and return the decoded `bytes`.\n\n"}, {"name": "base64.encode()", "path": "library/base64#base64.encode", "type": "Internet Data", "text": "\nEncode the contents of the binary input file and write the resulting base64\nencoded data to the output file. input and output must be file objects. input\nwill be read until `input.read()` returns an empty bytes object. `encode()`\ninserts a newline character (`b'\\n'`) after every 76 bytes of the output, as\nwell as ensuring that the output always ends with a newline, as per RFC 2045\n(MIME).\n\n"}, {"name": "base64.encodebytes()", "path": "library/base64#base64.encodebytes", "type": "Internet Data", "text": "\nEncode the bytes-like object s, which can contain arbitrary binary data, and\nreturn `bytes` containing the base64-encoded data, with newlines (`b'\\n'`)\ninserted after every 76 bytes of output, and ensuring that there is a trailing\nnewline, as per RFC 2045 (MIME).\n\n"}, {"name": "base64.standard_b64decode()", "path": "library/base64#base64.standard_b64decode", "type": "Internet Data", "text": "\nDecode bytes-like object or ASCII string s using the standard Base64 alphabet\nand return the decoded `bytes`.\n\n"}, {"name": "base64.standard_b64encode()", "path": "library/base64#base64.standard_b64encode", "type": "Internet Data", "text": "\nEncode bytes-like object s using the standard Base64 alphabet and return the\nencoded `bytes`.\n\n"}, {"name": "base64.urlsafe_b64decode()", "path": "library/base64#base64.urlsafe_b64decode", "type": "Internet Data", "text": "\nDecode bytes-like object or ASCII string s using the URL- and filesystem-safe\nalphabet, which substitutes `-` instead of `+` and `_` instead of `/` in the\nstandard Base64 alphabet, and return the decoded `bytes`.\n\n"}, {"name": "base64.urlsafe_b64encode()", "path": "library/base64#base64.urlsafe_b64encode", "type": "Internet Data", "text": "\nEncode bytes-like object s using the URL- and filesystem-safe alphabet, which\nsubstitutes `-` instead of `+` and `_` instead of `/` in the standard Base64\nalphabet, and return the encoded `bytes`. The result can still contain `=`.\n\n"}, {"name": "BaseException", "path": "library/exceptions#BaseException", "type": "Built-in Exceptions", "text": "\nThe base class for all built-in exceptions. It is not meant to be directly\ninherited by user-defined classes (for that, use `Exception`). If `str()` is\ncalled on an instance of this class, the representation of the argument(s) to\nthe instance are returned, or the empty string when there were no arguments.\n\n"}, {"name": "BaseException.args", "path": "library/exceptions#BaseException.args", "type": "Built-in Exceptions", "text": "\nThe tuple of arguments given to the exception constructor. Some built-in\nexceptions (like `OSError`) expect a certain number of arguments and assign a\nspecial meaning to the elements of this tuple, while others are usually called\nonly with a single string giving an error message.\n\n"}, {"name": "BaseException.with_traceback()", "path": "library/exceptions#BaseException.with_traceback", "type": "Built-in Exceptions", "text": "\nThis method sets tb as the new traceback for the exception and returns the\nexception object. It is usually used in exception handling code like this:\n\n"}, {"name": "bdb", "path": "library/bdb", "type": "Debugging & Profiling", "text": "\nSource code: Lib/bdb.py\n\n"}, {"name": "bdb.Bdb", "path": "library/bdb#bdb.Bdb", "type": "Debugging & Profiling", "text": "\nThe `Bdb` class acts as a generic Python debugger base class.\n\n"}, {"name": "bdb.Bdb.break_anywhere()", "path": "library/bdb#bdb.Bdb.break_anywhere", "type": "Debugging & Profiling", "text": "\nThis method checks if there is a breakpoint in the filename of the current\nframe.\n\n"}, {"name": "bdb.Bdb.break_here()", "path": "library/bdb#bdb.Bdb.break_here", "type": "Debugging & Profiling", "text": "\nThis method checks if there is a breakpoint in the filename and line belonging\nto frame or, at least, in the current function. If the breakpoint is a\ntemporary one, this method deletes it.\n\n"}, {"name": "bdb.Bdb.canonic()", "path": "library/bdb#bdb.Bdb.canonic", "type": "Debugging & Profiling", "text": "\nAuxiliary method for getting a filename in a canonical form, that is, as a\ncase-normalized (on case-insensitive filesystems) absolute path, stripped of\nsurrounding angle brackets.\n\n"}, {"name": "bdb.Bdb.clear_all_breaks()", "path": "library/bdb#bdb.Bdb.clear_all_breaks", "type": "Debugging & Profiling", "text": "\nDelete all existing breakpoints.\n\n"}, {"name": "bdb.Bdb.clear_all_file_breaks()", "path": "library/bdb#bdb.Bdb.clear_all_file_breaks", "type": "Debugging & Profiling", "text": "\nDelete all breakpoints in filename. If none were set, an error message is\nreturned.\n\n"}, {"name": "bdb.Bdb.clear_bpbynumber()", "path": "library/bdb#bdb.Bdb.clear_bpbynumber", "type": "Debugging & Profiling", "text": "\nDelete the breakpoint which has the index arg in the `Breakpoint.bpbynumber`.\nIf arg is not numeric or out of range, return an error message.\n\n"}, {"name": "bdb.Bdb.clear_break()", "path": "library/bdb#bdb.Bdb.clear_break", "type": "Debugging & Profiling", "text": "\nDelete the breakpoints in filename and lineno. If none were set, an error\nmessage is returned.\n\n"}, {"name": "bdb.Bdb.dispatch_call()", "path": "library/bdb#bdb.Bdb.dispatch_call", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop on this function call, invoke the `user_call()`\nmethod (which should be overridden in subclasses). Raise a `BdbQuit` exception\nif the `Bdb.quitting` flag is set (which can be set from `user_call()`).\nReturn a reference to the `trace_dispatch()` method for further tracing in\nthat scope.\n\n"}, {"name": "bdb.Bdb.dispatch_exception()", "path": "library/bdb#bdb.Bdb.dispatch_exception", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop at this exception, invokes the `user_exception()`\nmethod (which should be overridden in subclasses). Raise a `BdbQuit` exception\nif the `Bdb.quitting` flag is set (which can be set from `user_exception()`).\nReturn a reference to the `trace_dispatch()` method for further tracing in\nthat scope.\n\n"}, {"name": "bdb.Bdb.dispatch_line()", "path": "library/bdb#bdb.Bdb.dispatch_line", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop on the current line, invoke the `user_line()`\nmethod (which should be overridden in subclasses). Raise a `BdbQuit` exception\nif the `Bdb.quitting` flag is set (which can be set from `user_line()`).\nReturn a reference to the `trace_dispatch()` method for further tracing in\nthat scope.\n\n"}, {"name": "bdb.Bdb.dispatch_return()", "path": "library/bdb#bdb.Bdb.dispatch_return", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop on this function return, invoke the\n`user_return()` method (which should be overridden in subclasses). Raise a\n`BdbQuit` exception if the `Bdb.quitting` flag is set (which can be set from\n`user_return()`). Return a reference to the `trace_dispatch()` method for\nfurther tracing in that scope.\n\n"}, {"name": "bdb.Bdb.do_clear()", "path": "library/bdb#bdb.Bdb.do_clear", "type": "Debugging & Profiling", "text": "\nHandle how a breakpoint must be removed when it is a temporary one.\n\n"}, {"name": "bdb.Bdb.format_stack_entry()", "path": "library/bdb#bdb.Bdb.format_stack_entry", "type": "Debugging & Profiling", "text": "\nReturn a string with information about a stack entry, identified by a `(frame,\nlineno)` tuple:\n\n"}, {"name": "bdb.Bdb.get_all_breaks()", "path": "library/bdb#bdb.Bdb.get_all_breaks", "type": "Debugging & Profiling", "text": "\nReturn all breakpoints that are set.\n\n"}, {"name": "bdb.Bdb.get_bpbynumber()", "path": "library/bdb#bdb.Bdb.get_bpbynumber", "type": "Debugging & Profiling", "text": "\nReturn a breakpoint specified by the given number. If arg is a string, it will\nbe converted to a number. If arg is a non-numeric string, if the given\nbreakpoint never existed or has been deleted, a `ValueError` is raised.\n\n"}, {"name": "bdb.Bdb.get_break()", "path": "library/bdb#bdb.Bdb.get_break", "type": "Debugging & Profiling", "text": "\nCheck if there is a breakpoint for lineno of filename.\n\n"}, {"name": "bdb.Bdb.get_breaks()", "path": "library/bdb#bdb.Bdb.get_breaks", "type": "Debugging & Profiling", "text": "\nReturn all breakpoints for lineno in filename, or an empty list if none are\nset.\n\n"}, {"name": "bdb.Bdb.get_file_breaks()", "path": "library/bdb#bdb.Bdb.get_file_breaks", "type": "Debugging & Profiling", "text": "\nReturn all breakpoints in filename, or an empty list if none are set.\n\n"}, {"name": "bdb.Bdb.get_stack()", "path": "library/bdb#bdb.Bdb.get_stack", "type": "Debugging & Profiling", "text": "\nGet a list of records for a frame and all higher (calling) and lower frames,\nand the size of the higher part.\n\n"}, {"name": "bdb.Bdb.reset()", "path": "library/bdb#bdb.Bdb.reset", "type": "Debugging & Profiling", "text": "\nSet the `botframe`, `stopframe`, `returnframe` and `quitting` attributes with\nvalues ready to start debugging.\n\n"}, {"name": "bdb.Bdb.run()", "path": "library/bdb#bdb.Bdb.run", "type": "Debugging & Profiling", "text": "\nDebug a statement executed via the `exec()` function. globals defaults to\n`__main__.__dict__`, locals defaults to globals.\n\n"}, {"name": "bdb.Bdb.runcall()", "path": "library/bdb#bdb.Bdb.runcall", "type": "Debugging & Profiling", "text": "\nDebug a single function call, and return its result.\n\n"}, {"name": "bdb.Bdb.runctx()", "path": "library/bdb#bdb.Bdb.runctx", "type": "Debugging & Profiling", "text": "\nFor backwards compatibility. Calls the `run()` method.\n\n"}, {"name": "bdb.Bdb.runeval()", "path": "library/bdb#bdb.Bdb.runeval", "type": "Debugging & Profiling", "text": "\nDebug an expression executed via the `eval()` function. globals and locals\nhave the same meaning as in `run()`.\n\n"}, {"name": "bdb.Bdb.set_break()", "path": "library/bdb#bdb.Bdb.set_break", "type": "Debugging & Profiling", "text": "\nSet a new breakpoint. If the lineno line doesn\u2019t exist for the filename passed\nas argument, return an error message. The filename should be in canonical\nform, as described in the `canonic()` method.\n\n"}, {"name": "bdb.Bdb.set_continue()", "path": "library/bdb#bdb.Bdb.set_continue", "type": "Debugging & Profiling", "text": "\nStop only at breakpoints or when finished. If there are no breakpoints, set\nthe system trace function to `None`.\n\n"}, {"name": "bdb.Bdb.set_next()", "path": "library/bdb#bdb.Bdb.set_next", "type": "Debugging & Profiling", "text": "\nStop on the next line in or below the given frame.\n\n"}, {"name": "bdb.Bdb.set_quit()", "path": "library/bdb#bdb.Bdb.set_quit", "type": "Debugging & Profiling", "text": "\nSet the `quitting` attribute to `True`. This raises `BdbQuit` in the next call\nto one of the `dispatch_*()` methods.\n\n"}, {"name": "bdb.Bdb.set_return()", "path": "library/bdb#bdb.Bdb.set_return", "type": "Debugging & Profiling", "text": "\nStop when returning from the given frame.\n\n"}, {"name": "bdb.Bdb.set_step()", "path": "library/bdb#bdb.Bdb.set_step", "type": "Debugging & Profiling", "text": "\nStop after one line of code.\n\n"}, {"name": "bdb.Bdb.set_trace()", "path": "library/bdb#bdb.Bdb.set_trace", "type": "Debugging & Profiling", "text": "\nStart debugging from frame. If frame is not specified, debugging starts from\ncaller\u2019s frame.\n\n"}, {"name": "bdb.Bdb.set_until()", "path": "library/bdb#bdb.Bdb.set_until", "type": "Debugging & Profiling", "text": "\nStop when the line with the line no greater than the current one is reached or\nwhen returning from current frame.\n\n"}, {"name": "bdb.Bdb.stop_here()", "path": "library/bdb#bdb.Bdb.stop_here", "type": "Debugging & Profiling", "text": "\nThis method checks if the frame is somewhere below `botframe` in the call\nstack. `botframe` is the frame in which debugging started.\n\n"}, {"name": "bdb.Bdb.trace_dispatch()", "path": "library/bdb#bdb.Bdb.trace_dispatch", "type": "Debugging & Profiling", "text": "\nThis function is installed as the trace function of debugged frames. Its\nreturn value is the new trace function (in most cases, that is, itself).\n\n"}, {"name": "bdb.Bdb.user_call()", "path": "library/bdb#bdb.Bdb.user_call", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_call()` when there is the possibility\nthat a break might be necessary anywhere inside the called function.\n\n"}, {"name": "bdb.Bdb.user_exception()", "path": "library/bdb#bdb.Bdb.user_exception", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_exception()` when `stop_here()` yields\n`True`.\n\n"}, {"name": "bdb.Bdb.user_line()", "path": "library/bdb#bdb.Bdb.user_line", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_line()` when either `stop_here()` or\n`break_here()` yields `True`.\n\n"}, {"name": "bdb.Bdb.user_return()", "path": "library/bdb#bdb.Bdb.user_return", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_return()` when `stop_here()` yields\n`True`.\n\n"}, {"name": "bdb.BdbQuit", "path": "library/bdb#bdb.BdbQuit", "type": "Debugging & Profiling", "text": "\nException raised by the `Bdb` class for quitting the debugger.\n\n"}, {"name": "bdb.Breakpoint", "path": "library/bdb#bdb.Breakpoint", "type": "Debugging & Profiling", "text": "\nThis class implements temporary breakpoints, ignore counts, disabling and\n(re-)enabling, and conditionals.\n\n"}, {"name": "bdb.Breakpoint.bpformat()", "path": "library/bdb#bdb.Breakpoint.bpformat", "type": "Debugging & Profiling", "text": "\nReturn a string with all the information about the breakpoint, nicely\nformatted:\n\n"}, {"name": "bdb.Breakpoint.bpprint()", "path": "library/bdb#bdb.Breakpoint.bpprint", "type": "Debugging & Profiling", "text": "\nPrint the output of `bpformat()` to the file out, or if it is `None`, to\nstandard output.\n\n"}, {"name": "bdb.Breakpoint.deleteMe()", "path": "library/bdb#bdb.Breakpoint.deleteMe", "type": "Debugging & Profiling", "text": "\nDelete the breakpoint from the list associated to a file/line. If it is the\nlast breakpoint in that position, it also deletes the entry for the file/line.\n\n"}, {"name": "bdb.Breakpoint.disable()", "path": "library/bdb#bdb.Breakpoint.disable", "type": "Debugging & Profiling", "text": "\nMark the breakpoint as disabled.\n\n"}, {"name": "bdb.Breakpoint.enable()", "path": "library/bdb#bdb.Breakpoint.enable", "type": "Debugging & Profiling", "text": "\nMark the breakpoint as enabled.\n\n"}, {"name": "bdb.checkfuncname()", "path": "library/bdb#bdb.checkfuncname", "type": "Debugging & Profiling", "text": "\nCheck whether we should break here, depending on the way the breakpoint b was\nset.\n\n"}, {"name": "bdb.effective()", "path": "library/bdb#bdb.effective", "type": "Debugging & Profiling", "text": "\nDetermine if there is an effective (active) breakpoint at this line of code.\nReturn a tuple of the breakpoint and a boolean that indicates if it is ok to\ndelete a temporary breakpoint. Return `(None, None)` if there is no matching\nbreakpoint.\n\n"}, {"name": "bdb.set_trace()", "path": "library/bdb#bdb.set_trace", "type": "Debugging & Profiling", "text": "\nStart debugging with a `Bdb` instance from caller\u2019s frame.\n\n"}, {"name": "bin()", "path": "library/functions#bin", "type": "Built-in Functions", "text": "\nConvert an integer number to a binary string prefixed with \u201c0b\u201d. The result is\na valid Python expression. If x is not a Python `int` object, it has to define\nan `__index__()` method that returns an integer. Some examples:\n\n"}, {"name": "binascii", "path": "library/binascii", "type": "Internet Data", "text": "\nThe `binascii` module contains a number of methods to convert between binary\nand various ASCII-encoded binary representations. Normally, you will not use\nthese functions directly but use wrapper modules like `uu`, `base64`, or\n`binhex` instead. The `binascii` module contains low-level functions written\nin C for greater speed that are used by the higher-level modules.\n\n"}, {"name": "binascii.a2b_base64()", "path": "library/binascii#binascii.a2b_base64", "type": "Internet Data", "text": "\nConvert a block of base64 data back to binary and return the binary data. More\nthan one line may be passed at a time.\n\n"}, {"name": "binascii.a2b_hex()", "path": "library/binascii#binascii.a2b_hex", "type": "Internet Data", "text": "\nReturn the binary data represented by the hexadecimal string hexstr. This\nfunction is the inverse of `b2a_hex()`. hexstr must contain an even number of\nhexadecimal digits (which can be upper or lower case), otherwise an `Error`\nexception is raised.\n\n"}, {"name": "binascii.a2b_hqx()", "path": "library/binascii#binascii.a2b_hqx", "type": "Internet Data", "text": "\nConvert binhex4 formatted ASCII data to binary, without doing RLE-\ndecompression. The string should contain a complete number of binary bytes, or\n(in case of the last portion of the binhex4 data) have the remaining bits\nzero.\n\n"}, {"name": "binascii.a2b_qp()", "path": "library/binascii#binascii.a2b_qp", "type": "Internet Data", "text": "\nConvert a block of quoted-printable data back to binary and return the binary\ndata. More than one line may be passed at a time. If the optional argument\nheader is present and true, underscores will be decoded as spaces.\n\n"}, {"name": "binascii.a2b_uu()", "path": "library/binascii#binascii.a2b_uu", "type": "Internet Data", "text": "\nConvert a single line of uuencoded data back to binary and return the binary\ndata. Lines normally contain 45 (binary) bytes, except for the last line. Line\ndata may be followed by whitespace.\n\n"}, {"name": "binascii.b2a_base64()", "path": "library/binascii#binascii.b2a_base64", "type": "Internet Data", "text": "\nConvert binary data to a line of ASCII characters in base64 coding. The return\nvalue is the converted line, including a newline char if newline is true. The\noutput of this function conforms to RFC 3548.\n\n"}, {"name": "binascii.b2a_hex()", "path": "library/binascii#binascii.b2a_hex", "type": "Internet Data", "text": "\nReturn the hexadecimal representation of the binary data. Every byte of data\nis converted into the corresponding 2-digit hex representation. The returned\nbytes object is therefore twice as long as the length of data.\n\n"}, {"name": "binascii.b2a_hqx()", "path": "library/binascii#binascii.b2a_hqx", "type": "Internet Data", "text": "\nPerform hexbin4 binary-to-ASCII translation and return the resulting string.\nThe argument should already be RLE-coded, and have a length divisible by 3\n(except possibly the last fragment).\n\n"}, {"name": "binascii.b2a_qp()", "path": "library/binascii#binascii.b2a_qp", "type": "Internet Data", "text": "\nConvert binary data to a line(s) of ASCII characters in quoted-printable\nencoding. The return value is the converted line(s). If the optional argument\nquotetabs is present and true, all tabs and spaces will be encoded. If the\noptional argument istext is present and true, newlines are not encoded but\ntrailing whitespace will be encoded. If the optional argument header is\npresent and true, spaces will be encoded as underscores per RFC 1522. If the\noptional argument header is present and false, newline characters will be\nencoded as well; otherwise linefeed conversion might corrupt the binary data\nstream.\n\n"}, {"name": "binascii.b2a_uu()", "path": "library/binascii#binascii.b2a_uu", "type": "Internet Data", "text": "\nConvert binary data to a line of ASCII characters, the return value is the\nconverted line, including a newline char. The length of data should be at most\n45. If backtick is true, zeros are represented by `'`'` instead of spaces.\n\n"}, {"name": "binascii.crc32()", "path": "library/binascii#binascii.crc32", "type": "Internet Data", "text": "\nCompute CRC-32, the 32-bit checksum of data, starting with an initial CRC of\nvalue. The default initial CRC is zero. The algorithm is consistent with the\nZIP file checksum. Since the algorithm is designed for use as a checksum\nalgorithm, it is not suitable for use as a general hash algorithm. Use as\nfollows:\n\n"}, {"name": "binascii.crc_hqx()", "path": "library/binascii#binascii.crc_hqx", "type": "Internet Data", "text": "\nCompute a 16-bit CRC value of data, starting with value as the initial CRC,\nand return the result. This uses the CRC-CCITT polynomial x16 \\+ x12 \\+ x5 \\+\n1, often represented as 0x1021. This CRC is used in the binhex4 format.\n\n"}, {"name": "binascii.Error", "path": "library/binascii#binascii.Error", "type": "Internet Data", "text": "\nException raised on errors. These are usually programming errors.\n\n"}, {"name": "binascii.hexlify()", "path": "library/binascii#binascii.hexlify", "type": "Internet Data", "text": "\nReturn the hexadecimal representation of the binary data. Every byte of data\nis converted into the corresponding 2-digit hex representation. The returned\nbytes object is therefore twice as long as the length of data.\n\n"}, {"name": "binascii.Incomplete", "path": "library/binascii#binascii.Incomplete", "type": "Internet Data", "text": "\nException raised on incomplete data. These are usually not programming errors,\nbut may be handled by reading a little more data and trying again.\n\n"}, {"name": "binascii.rlecode_hqx()", "path": "library/binascii#binascii.rlecode_hqx", "type": "Internet Data", "text": "\nPerform binhex4 style RLE-compression on data and return the result.\n\n"}, {"name": "binascii.rledecode_hqx()", "path": "library/binascii#binascii.rledecode_hqx", "type": "Internet Data", "text": "\nPerform RLE-decompression on the data, as per the binhex4 standard. The\nalgorithm uses `0x90` after a byte as a repeat indicator, followed by a count.\nA count of `0` specifies a byte value of `0x90`. The routine returns the\ndecompressed data, unless data input data ends in an orphaned repeat\nindicator, in which case the `Incomplete` exception is raised.\n\n"}, {"name": "binascii.unhexlify()", "path": "library/binascii#binascii.unhexlify", "type": "Internet Data", "text": "\nReturn the binary data represented by the hexadecimal string hexstr. This\nfunction is the inverse of `b2a_hex()`. hexstr must contain an even number of\nhexadecimal digits (which can be upper or lower case), otherwise an `Error`\nexception is raised.\n\n"}, {"name": "binhex", "path": "library/binhex", "type": "Internet Data", "text": "\nSource code: Lib/binhex.py\n\n"}, {"name": "binhex.binhex()", "path": "library/binhex#binhex.binhex", "type": "Internet Data", "text": "\nConvert a binary file with filename input to binhex file output. The output\nparameter can either be a filename or a file-like object (any object\nsupporting a `write()` and `close()` method).\n\n"}, {"name": "binhex.Error", "path": "library/binhex#binhex.Error", "type": "Internet Data", "text": "\nException raised when something can\u2019t be encoded using the binhex format (for\nexample, a filename is too long to fit in the filename field), or when input\nis not properly encoded binhex data.\n\n"}, {"name": "binhex.hexbin()", "path": "library/binhex#binhex.hexbin", "type": "Internet Data", "text": "\nDecode a binhex file input. input may be a filename or a file-like object\nsupporting `read()` and `close()` methods. The resulting file is written to a\nfile named output, unless the argument is `None` in which case the output\nfilename is read from the binhex file.\n\n"}, {"name": "bisect", "path": "library/bisect", "type": "Data Types", "text": "\nSource code: Lib/bisect.py\n\n"}, {"name": "bisect.bisect()", "path": "library/bisect#bisect.bisect", "type": "Data Types", "text": "\nSimilar to `bisect_left()`, but returns an insertion point which comes after\n(to the right of) any existing entries of x in a.\n\n"}, {"name": "bisect.bisect_left()", "path": "library/bisect#bisect.bisect_left", "type": "Data Types", "text": "\nLocate the insertion point for x in a to maintain sorted order. The parameters\nlo and hi may be used to specify a subset of the list which should be\nconsidered; by default the entire list is used. If x is already present in a,\nthe insertion point will be before (to the left of) any existing entries. The\nreturn value is suitable for use as the first parameter to `list.insert()`\nassuming that a is already sorted.\n\n"}, {"name": "bisect.bisect_right()", "path": "library/bisect#bisect.bisect_right", "type": "Data Types", "text": "\nSimilar to `bisect_left()`, but returns an insertion point which comes after\n(to the right of) any existing entries of x in a.\n\n"}, {"name": "bisect.insort()", "path": "library/bisect#bisect.insort", "type": "Data Types", "text": "\nSimilar to `insort_left()`, but inserting x in a after any existing entries of\nx.\n\n"}, {"name": "bisect.insort_left()", "path": "library/bisect#bisect.insort_left", "type": "Data Types", "text": "\nInsert x in a in sorted order. This is equivalent to\n`a.insert(bisect.bisect_left(a, x, lo, hi), x)` assuming that a is already\nsorted. Keep in mind that the O(log n) search is dominated by the slow O(n)\ninsertion step.\n\n"}, {"name": "bisect.insort_right()", "path": "library/bisect#bisect.insort_right", "type": "Data Types", "text": "\nSimilar to `insort_left()`, but inserting x in a after any existing entries of\nx.\n\n"}, {"name": "BlockingIOError", "path": "library/exceptions#BlockingIOError", "type": "Built-in Exceptions", "text": "\nRaised when an operation would block on an object (e.g. socket) set for non-\nblocking operation. Corresponds to `errno` `EAGAIN`, `EALREADY`, `EWOULDBLOCK`\nand `EINPROGRESS`.\n\n"}, {"name": "BlockingIOError.characters_written", "path": "library/exceptions#BlockingIOError.characters_written", "type": "Built-in Exceptions", "text": "\nAn integer containing the number of characters written to the stream before it\nblocked. This attribute is available when using the buffered I/O classes from\nthe `io` module.\n\n"}, {"name": "bool", "path": "library/functions#bool", "type": "Built-in Functions", "text": "\nReturn a Boolean value, i.e. one of `True` or `False`. x is converted using\nthe standard truth testing procedure. If x is false or omitted, this returns\n`False`; otherwise it returns `True`. The `bool` class is a subclass of `int`\n(see Numeric Types \u2014 int, float, complex). It cannot be subclassed further.\nIts only instances are `False` and `True` (see Boolean Values).\n\n"}, {"name": "breakpoint()", "path": "library/functions#breakpoint", "type": "Built-in Functions", "text": "\nThis function drops you into the debugger at the call site. Specifically, it\ncalls `sys.breakpointhook()`, passing `args` and `kws` straight through. By\ndefault, `sys.breakpointhook()` calls `pdb.set_trace()` expecting no\narguments. In this case, it is purely a convenience function so you don\u2019t have\nto explicitly import `pdb` or type as much code to enter the debugger.\nHowever, `sys.breakpointhook()` can be set to some other function and\n`breakpoint()` will automatically call that, allowing you to drop into the\ndebugger of choice.\n\n"}, {"name": "BrokenPipeError", "path": "library/exceptions#BrokenPipeError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when trying to write on a pipe while\nthe other end has been closed, or trying to write on a socket which has been\nshutdown for writing. Corresponds to `errno` `EPIPE` and `ESHUTDOWN`.\n\n"}, {"name": "BufferError", "path": "library/exceptions#BufferError", "type": "Built-in Exceptions", "text": "\nRaised when a buffer related operation cannot be performed.\n\n"}, {"name": "builtins", "path": "library/builtins", "type": "Runtime", "text": "\nThis module provides direct access to all \u2018built-in\u2019 identifiers of Python;\nfor example, `builtins.open` is the full name for the built-in function\n`open()`. See Built-in Functions and Built-in Constants for documentation.\n\n"}, {"name": "bytearray", "path": "library/functions#bytearray", "type": "Built-in Functions", "text": "\nReturn a new array of bytes. The `bytearray` class is a mutable sequence of\nintegers in the range 0 <= x < 256\\. It has most of the usual methods of\nmutable sequences, described in Mutable Sequence Types, as well as most\nmethods that the `bytes` type has, see Bytes and Bytearray Operations.\n\n"}, {"name": "bytearray", "path": "library/stdtypes#bytearray", "type": "Built-in Types", "text": "\nThere is no dedicated literal syntax for bytearray objects, instead they are\nalways created by calling the constructor:\n\n"}, {"name": "bytearray.capitalize()", "path": "library/stdtypes#bytearray.capitalize", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with each byte interpreted as an ASCII\ncharacter, and the first byte capitalized and the rest lowercased. Non-ASCII\nbyte values are passed through unchanged.\n\n"}, {"name": "bytearray.center()", "path": "library/stdtypes#bytearray.center", "type": "Built-in Types", "text": "\nReturn a copy of the object centered in a sequence of length width. Padding is\ndone using the specified fillbyte (default is an ASCII space). For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(s)`.\n\n"}, {"name": "bytearray.count()", "path": "library/stdtypes#bytearray.count", "type": "Built-in Types", "text": "\nReturn the number of non-overlapping occurrences of subsequence sub in the\nrange [start, end]. Optional arguments start and end are interpreted as in\nslice notation.\n\n"}, {"name": "bytearray.decode()", "path": "library/stdtypes#bytearray.decode", "type": "Built-in Types", "text": "\nReturn a string decoded from the given bytes. Default encoding is `'utf-8'`.\nerrors may be given to set a different error handling scheme. The default for\nerrors is `'strict'`, meaning that encoding errors raise a `UnicodeError`.\nOther possible values are `'ignore'`, `'replace'` and any other name\nregistered via `codecs.register_error()`, see section Error Handlers. For a\nlist of possible encodings, see section Standard Encodings.\n\n"}, {"name": "bytearray.endswith()", "path": "library/stdtypes#bytearray.endswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data ends with the specified suffix, otherwise\nreturn `False`. suffix can also be a tuple of suffixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytearray.expandtabs()", "path": "library/stdtypes#bytearray.expandtabs", "type": "Built-in Types", "text": "\nReturn a copy of the sequence where all ASCII tab characters are replaced by\none or more ASCII spaces, depending on the current column and the given tab\nsize. Tab positions occur every tabsize bytes (default is 8, giving tab\npositions at columns 0, 8, 16 and so on). To expand the sequence, the current\ncolumn is set to zero and the sequence is examined byte by byte. If the byte\nis an ASCII tab character (`b'\\t'`), one or more space characters are inserted\nin the result until the current column is equal to the next tab position. (The\ntab character itself is not copied.) If the current byte is an ASCII newline\n(`b'\\n'`) or carriage return (`b'\\r'`), it is copied and the current column is\nreset to zero. Any other byte value is copied unchanged and the current column\nis incremented by one regardless of how the byte value is represented when\nprinted:\n\n"}, {"name": "bytearray.find()", "path": "library/stdtypes#bytearray.find", "type": "Built-in Types", "text": "\nReturn the lowest index in the data where the subsequence sub is found, such\nthat sub is contained in the slice `s[start:end]`. Optional arguments start\nand end are interpreted as in slice notation. Return `-1` if sub is not found.\n\n"}, {"name": "bytearray.fromhex()", "path": "library/stdtypes#bytearray.fromhex", "type": "Built-in Types", "text": "\nThis `bytearray` class method returns bytearray object, decoding the given\nstring object. The string must contain two hexadecimal digits per byte, with\nASCII whitespace being ignored.\n\n"}, {"name": "bytearray.hex()", "path": "library/stdtypes#bytearray.hex", "type": "Built-in Types", "text": "\nReturn a string object containing two hexadecimal digits for each byte in the\ninstance.\n\n"}, {"name": "bytearray.index()", "path": "library/stdtypes#bytearray.index", "type": "Built-in Types", "text": "\nLike `find()`, but raise `ValueError` when the subsequence is not found.\n\n"}, {"name": "bytearray.isalnum()", "path": "library/stdtypes#bytearray.isalnum", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetical ASCII characters\nor ASCII decimal digits and the sequence is not empty, `False` otherwise.\nAlphabetic ASCII characters are those byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal\ndigits are those byte values in the sequence `b'0123456789'`.\n\n"}, {"name": "bytearray.isalpha()", "path": "library/stdtypes#bytearray.isalpha", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetic ASCII characters and\nthe sequence is not empty, `False` otherwise. Alphabetic ASCII characters are\nthose byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.\n\n"}, {"name": "bytearray.isascii()", "path": "library/stdtypes#bytearray.isascii", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is empty or all bytes in the sequence are ASCII,\n`False` otherwise. ASCII bytes are in the range 0-0x7F.\n\n"}, {"name": "bytearray.isdigit()", "path": "library/stdtypes#bytearray.isdigit", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII decimal digits and the\nsequence is not empty, `False` otherwise. ASCII decimal digits are those byte\nvalues in the sequence `b'0123456789'`.\n\n"}, {"name": "bytearray.islower()", "path": "library/stdtypes#bytearray.islower", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one lowercase ASCII character in the\nsequence and no uppercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytearray.isspace()", "path": "library/stdtypes#bytearray.isspace", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII whitespace and the\nsequence is not empty, `False` otherwise. ASCII whitespace characters are\nthose byte values in the sequence `b' \\t\\n\\r\\x0b\\f'` (space, tab, newline,\ncarriage return, vertical tab, form feed).\n\n"}, {"name": "bytearray.istitle()", "path": "library/stdtypes#bytearray.istitle", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is ASCII titlecase and the sequence is not\nempty, `False` otherwise. See `bytes.title()` for more details on the\ndefinition of \u201ctitlecase\u201d.\n\n"}, {"name": "bytearray.isupper()", "path": "library/stdtypes#bytearray.isupper", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one uppercase alphabetic ASCII character in\nthe sequence and no lowercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytearray.join()", "path": "library/stdtypes#bytearray.join", "type": "Built-in Types", "text": "\nReturn a bytes or bytearray object which is the concatenation of the binary\ndata sequences in iterable. A `TypeError` will be raised if there are any\nvalues in iterable that are not bytes-like objects, including `str` objects.\nThe separator between elements is the contents of the bytes or bytearray\nobject providing this method.\n\n"}, {"name": "bytearray.ljust()", "path": "library/stdtypes#bytearray.ljust", "type": "Built-in Types", "text": "\nReturn a copy of the object left justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytearray.lower()", "path": "library/stdtypes#bytearray.lower", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the uppercase ASCII characters\nconverted to their corresponding lowercase counterpart.\n\n"}, {"name": "bytearray.lstrip()", "path": "library/stdtypes#bytearray.lstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a prefix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytearray.maketrans()", "path": "library/stdtypes#bytearray.maketrans", "type": "Built-in Types", "text": "\nThis static method returns a translation table usable for `bytes.translate()`\nthat will map each character in from into the character at the same position\nin to; from and to must both be bytes-like objects and have the same length.\n\n"}, {"name": "bytearray.partition()", "path": "library/stdtypes#bytearray.partition", "type": "Built-in Types", "text": "\nSplit the sequence at the first occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing a copy of the original sequence, followed\nby two empty bytes or bytearray objects.\n\n"}, {"name": "bytearray.removeprefix()", "path": "library/stdtypes#bytearray.removeprefix", "type": "Built-in Types", "text": "\nIf the binary data starts with the prefix string, return\n`bytes[len(prefix):]`. Otherwise, return a copy of the original binary data:\n\n"}, {"name": "bytearray.removesuffix()", "path": "library/stdtypes#bytearray.removesuffix", "type": "Built-in Types", "text": "\nIf the binary data ends with the suffix string and that suffix is not empty,\nreturn `bytes[:-len(suffix)]`. Otherwise, return a copy of the original binary\ndata:\n\n"}, {"name": "bytearray.replace()", "path": "library/stdtypes#bytearray.replace", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all occurrences of subsequence old replaced\nby new. If the optional argument count is given, only the first count\noccurrences are replaced.\n\n"}, {"name": "bytearray.rfind()", "path": "library/stdtypes#bytearray.rfind", "type": "Built-in Types", "text": "\nReturn the highest index in the sequence where the subsequence sub is found,\nsuch that sub is contained within `s[start:end]`. Optional arguments start and\nend are interpreted as in slice notation. Return `-1` on failure.\n\n"}, {"name": "bytearray.rindex()", "path": "library/stdtypes#bytearray.rindex", "type": "Built-in Types", "text": "\nLike `rfind()` but raises `ValueError` when the subsequence sub is not found.\n\n"}, {"name": "bytearray.rjust()", "path": "library/stdtypes#bytearray.rjust", "type": "Built-in Types", "text": "\nReturn a copy of the object right justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytearray.rpartition()", "path": "library/stdtypes#bytearray.rpartition", "type": "Built-in Types", "text": "\nSplit the sequence at the last occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing two empty bytes or bytearray objects,\nfollowed by a copy of the original sequence.\n\n"}, {"name": "bytearray.rsplit()", "path": "library/stdtypes#bytearray.rsplit", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given, at most maxsplit splits are done, the\nrightmost ones. If sep is not specified or `None`, any subsequence consisting\nsolely of ASCII whitespace is a separator. Except for splitting from the\nright, `rsplit()` behaves like `split()` which is described in detail below.\n\n"}, {"name": "bytearray.rstrip()", "path": "library/stdtypes#bytearray.rstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified trailing bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a suffix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytearray.split()", "path": "library/stdtypes#bytearray.split", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given and non-negative, at most maxsplit\nsplits are done (thus, the list will have at most `maxsplit+1` elements). If\nmaxsplit is not specified or is `-1`, then there is no limit on the number of\nsplits (all possible splits are made).\n\n"}, {"name": "bytearray.splitlines()", "path": "library/stdtypes#bytearray.splitlines", "type": "Built-in Types", "text": "\nReturn a list of the lines in the binary sequence, breaking at ASCII line\nboundaries. This method uses the universal newlines approach to splitting\nlines. Line breaks are not included in the resulting list unless keepends is\ngiven and true.\n\n"}, {"name": "bytearray.startswith()", "path": "library/stdtypes#bytearray.startswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data starts with the specified prefix, otherwise\nreturn `False`. prefix can also be a tuple of prefixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytearray.strip()", "path": "library/stdtypes#bytearray.strip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading and trailing bytes\nremoved. The chars argument is a binary sequence specifying the set of byte\nvalues to be removed - the name refers to the fact this method is usually used\nwith ASCII characters. If omitted or `None`, the chars argument defaults to\nremoving ASCII whitespace. The chars argument is not a prefix or suffix;\nrather, all combinations of its values are stripped:\n\n"}, {"name": "bytearray.swapcase()", "path": "library/stdtypes#bytearray.swapcase", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart and vice-versa.\n\n"}, {"name": "bytearray.title()", "path": "library/stdtypes#bytearray.title", "type": "Built-in Types", "text": "\nReturn a titlecased version of the binary sequence where words start with an\nuppercase ASCII character and the remaining characters are lowercase. Uncased\nbyte values are left unmodified.\n\n"}, {"name": "bytearray.translate()", "path": "library/stdtypes#bytearray.translate", "type": "Built-in Types", "text": "\nReturn a copy of the bytes or bytearray object where all bytes occurring in\nthe optional argument delete are removed, and the remaining bytes have been\nmapped through the given translation table, which must be a bytes object of\nlength 256.\n\n"}, {"name": "bytearray.upper()", "path": "library/stdtypes#bytearray.upper", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart.\n\n"}, {"name": "bytearray.zfill()", "path": "library/stdtypes#bytearray.zfill", "type": "Built-in Types", "text": "\nReturn a copy of the sequence left filled with ASCII `b'0'` digits to make a\nsequence of length width. A leading sign prefix (`b'+'`/ `b'-'`) is handled by\ninserting the padding after the sign character rather than before. For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(seq)`.\n\n"}, {"name": "bytes", "path": "library/stdtypes#bytes", "type": "Built-in Types", "text": "\nFirstly, the syntax for bytes literals is largely the same as that for string\nliterals, except that a `b` prefix is added:\n\n"}, {"name": "bytes", "path": "library/functions#bytes", "type": "Built-in Functions", "text": "\nReturn a new \u201cbytes\u201d object, which is an immutable sequence of integers in the\nrange `0 <= x < 256`. `bytes` is an immutable version of `bytearray` \u2013 it has\nthe same non-mutating methods and the same indexing and slicing behavior.\n\n"}, {"name": "bytes.capitalize()", "path": "library/stdtypes#bytes.capitalize", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with each byte interpreted as an ASCII\ncharacter, and the first byte capitalized and the rest lowercased. Non-ASCII\nbyte values are passed through unchanged.\n\n"}, {"name": "bytes.center()", "path": "library/stdtypes#bytes.center", "type": "Built-in Types", "text": "\nReturn a copy of the object centered in a sequence of length width. Padding is\ndone using the specified fillbyte (default is an ASCII space). For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(s)`.\n\n"}, {"name": "bytes.count()", "path": "library/stdtypes#bytes.count", "type": "Built-in Types", "text": "\nReturn the number of non-overlapping occurrences of subsequence sub in the\nrange [start, end]. Optional arguments start and end are interpreted as in\nslice notation.\n\n"}, {"name": "bytes.decode()", "path": "library/stdtypes#bytes.decode", "type": "Built-in Types", "text": "\nReturn a string decoded from the given bytes. Default encoding is `'utf-8'`.\nerrors may be given to set a different error handling scheme. The default for\nerrors is `'strict'`, meaning that encoding errors raise a `UnicodeError`.\nOther possible values are `'ignore'`, `'replace'` and any other name\nregistered via `codecs.register_error()`, see section Error Handlers. For a\nlist of possible encodings, see section Standard Encodings.\n\n"}, {"name": "bytes.endswith()", "path": "library/stdtypes#bytes.endswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data ends with the specified suffix, otherwise\nreturn `False`. suffix can also be a tuple of suffixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytes.expandtabs()", "path": "library/stdtypes#bytes.expandtabs", "type": "Built-in Types", "text": "\nReturn a copy of the sequence where all ASCII tab characters are replaced by\none or more ASCII spaces, depending on the current column and the given tab\nsize. Tab positions occur every tabsize bytes (default is 8, giving tab\npositions at columns 0, 8, 16 and so on). To expand the sequence, the current\ncolumn is set to zero and the sequence is examined byte by byte. If the byte\nis an ASCII tab character (`b'\\t'`), one or more space characters are inserted\nin the result until the current column is equal to the next tab position. (The\ntab character itself is not copied.) If the current byte is an ASCII newline\n(`b'\\n'`) or carriage return (`b'\\r'`), it is copied and the current column is\nreset to zero. Any other byte value is copied unchanged and the current column\nis incremented by one regardless of how the byte value is represented when\nprinted:\n\n"}, {"name": "bytes.find()", "path": "library/stdtypes#bytes.find", "type": "Built-in Types", "text": "\nReturn the lowest index in the data where the subsequence sub is found, such\nthat sub is contained in the slice `s[start:end]`. Optional arguments start\nand end are interpreted as in slice notation. Return `-1` if sub is not found.\n\n"}, {"name": "bytes.fromhex()", "path": "library/stdtypes#bytes.fromhex", "type": "Built-in Types", "text": "\nThis `bytes` class method returns a bytes object, decoding the given string\nobject. The string must contain two hexadecimal digits per byte, with ASCII\nwhitespace being ignored.\n\n"}, {"name": "bytes.hex()", "path": "library/stdtypes#bytes.hex", "type": "Built-in Types", "text": "\nReturn a string object containing two hexadecimal digits for each byte in the\ninstance.\n\n"}, {"name": "bytes.index()", "path": "library/stdtypes#bytes.index", "type": "Built-in Types", "text": "\nLike `find()`, but raise `ValueError` when the subsequence is not found.\n\n"}, {"name": "bytes.isalnum()", "path": "library/stdtypes#bytes.isalnum", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetical ASCII characters\nor ASCII decimal digits and the sequence is not empty, `False` otherwise.\nAlphabetic ASCII characters are those byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal\ndigits are those byte values in the sequence `b'0123456789'`.\n\n"}, {"name": "bytes.isalpha()", "path": "library/stdtypes#bytes.isalpha", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetic ASCII characters and\nthe sequence is not empty, `False` otherwise. Alphabetic ASCII characters are\nthose byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.\n\n"}, {"name": "bytes.isascii()", "path": "library/stdtypes#bytes.isascii", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is empty or all bytes in the sequence are ASCII,\n`False` otherwise. ASCII bytes are in the range 0-0x7F.\n\n"}, {"name": "bytes.isdigit()", "path": "library/stdtypes#bytes.isdigit", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII decimal digits and the\nsequence is not empty, `False` otherwise. ASCII decimal digits are those byte\nvalues in the sequence `b'0123456789'`.\n\n"}, {"name": "bytes.islower()", "path": "library/stdtypes#bytes.islower", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one lowercase ASCII character in the\nsequence and no uppercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytes.isspace()", "path": "library/stdtypes#bytes.isspace", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII whitespace and the\nsequence is not empty, `False` otherwise. ASCII whitespace characters are\nthose byte values in the sequence `b' \\t\\n\\r\\x0b\\f'` (space, tab, newline,\ncarriage return, vertical tab, form feed).\n\n"}, {"name": "bytes.istitle()", "path": "library/stdtypes#bytes.istitle", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is ASCII titlecase and the sequence is not\nempty, `False` otherwise. See `bytes.title()` for more details on the\ndefinition of \u201ctitlecase\u201d.\n\n"}, {"name": "bytes.isupper()", "path": "library/stdtypes#bytes.isupper", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one uppercase alphabetic ASCII character in\nthe sequence and no lowercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytes.join()", "path": "library/stdtypes#bytes.join", "type": "Built-in Types", "text": "\nReturn a bytes or bytearray object which is the concatenation of the binary\ndata sequences in iterable. A `TypeError` will be raised if there are any\nvalues in iterable that are not bytes-like objects, including `str` objects.\nThe separator between elements is the contents of the bytes or bytearray\nobject providing this method.\n\n"}, {"name": "bytes.ljust()", "path": "library/stdtypes#bytes.ljust", "type": "Built-in Types", "text": "\nReturn a copy of the object left justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytes.lower()", "path": "library/stdtypes#bytes.lower", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the uppercase ASCII characters\nconverted to their corresponding lowercase counterpart.\n\n"}, {"name": "bytes.lstrip()", "path": "library/stdtypes#bytes.lstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a prefix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytes.maketrans()", "path": "library/stdtypes#bytes.maketrans", "type": "Built-in Types", "text": "\nThis static method returns a translation table usable for `bytes.translate()`\nthat will map each character in from into the character at the same position\nin to; from and to must both be bytes-like objects and have the same length.\n\n"}, {"name": "bytes.partition()", "path": "library/stdtypes#bytes.partition", "type": "Built-in Types", "text": "\nSplit the sequence at the first occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing a copy of the original sequence, followed\nby two empty bytes or bytearray objects.\n\n"}, {"name": "bytes.removeprefix()", "path": "library/stdtypes#bytes.removeprefix", "type": "Built-in Types", "text": "\nIf the binary data starts with the prefix string, return\n`bytes[len(prefix):]`. Otherwise, return a copy of the original binary data:\n\n"}, {"name": "bytes.removesuffix()", "path": "library/stdtypes#bytes.removesuffix", "type": "Built-in Types", "text": "\nIf the binary data ends with the suffix string and that suffix is not empty,\nreturn `bytes[:-len(suffix)]`. Otherwise, return a copy of the original binary\ndata:\n\n"}, {"name": "bytes.replace()", "path": "library/stdtypes#bytes.replace", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all occurrences of subsequence old replaced\nby new. If the optional argument count is given, only the first count\noccurrences are replaced.\n\n"}, {"name": "bytes.rfind()", "path": "library/stdtypes#bytes.rfind", "type": "Built-in Types", "text": "\nReturn the highest index in the sequence where the subsequence sub is found,\nsuch that sub is contained within `s[start:end]`. Optional arguments start and\nend are interpreted as in slice notation. Return `-1` on failure.\n\n"}, {"name": "bytes.rindex()", "path": "library/stdtypes#bytes.rindex", "type": "Built-in Types", "text": "\nLike `rfind()` but raises `ValueError` when the subsequence sub is not found.\n\n"}, {"name": "bytes.rjust()", "path": "library/stdtypes#bytes.rjust", "type": "Built-in Types", "text": "\nReturn a copy of the object right justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytes.rpartition()", "path": "library/stdtypes#bytes.rpartition", "type": "Built-in Types", "text": "\nSplit the sequence at the last occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing two empty bytes or bytearray objects,\nfollowed by a copy of the original sequence.\n\n"}, {"name": "bytes.rsplit()", "path": "library/stdtypes#bytes.rsplit", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given, at most maxsplit splits are done, the\nrightmost ones. If sep is not specified or `None`, any subsequence consisting\nsolely of ASCII whitespace is a separator. Except for splitting from the\nright, `rsplit()` behaves like `split()` which is described in detail below.\n\n"}, {"name": "bytes.rstrip()", "path": "library/stdtypes#bytes.rstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified trailing bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a suffix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytes.split()", "path": "library/stdtypes#bytes.split", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given and non-negative, at most maxsplit\nsplits are done (thus, the list will have at most `maxsplit+1` elements). If\nmaxsplit is not specified or is `-1`, then there is no limit on the number of\nsplits (all possible splits are made).\n\n"}, {"name": "bytes.splitlines()", "path": "library/stdtypes#bytes.splitlines", "type": "Built-in Types", "text": "\nReturn a list of the lines in the binary sequence, breaking at ASCII line\nboundaries. This method uses the universal newlines approach to splitting\nlines. Line breaks are not included in the resulting list unless keepends is\ngiven and true.\n\n"}, {"name": "bytes.startswith()", "path": "library/stdtypes#bytes.startswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data starts with the specified prefix, otherwise\nreturn `False`. prefix can also be a tuple of prefixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytes.strip()", "path": "library/stdtypes#bytes.strip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading and trailing bytes\nremoved. The chars argument is a binary sequence specifying the set of byte\nvalues to be removed - the name refers to the fact this method is usually used\nwith ASCII characters. If omitted or `None`, the chars argument defaults to\nremoving ASCII whitespace. The chars argument is not a prefix or suffix;\nrather, all combinations of its values are stripped:\n\n"}, {"name": "bytes.swapcase()", "path": "library/stdtypes#bytes.swapcase", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart and vice-versa.\n\n"}, {"name": "bytes.title()", "path": "library/stdtypes#bytes.title", "type": "Built-in Types", "text": "\nReturn a titlecased version of the binary sequence where words start with an\nuppercase ASCII character and the remaining characters are lowercase. Uncased\nbyte values are left unmodified.\n\n"}, {"name": "bytes.translate()", "path": "library/stdtypes#bytes.translate", "type": "Built-in Types", "text": "\nReturn a copy of the bytes or bytearray object where all bytes occurring in\nthe optional argument delete are removed, and the remaining bytes have been\nmapped through the given translation table, which must be a bytes object of\nlength 256.\n\n"}, {"name": "bytes.upper()", "path": "library/stdtypes#bytes.upper", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart.\n\n"}, {"name": "bytes.zfill()", "path": "library/stdtypes#bytes.zfill", "type": "Built-in Types", "text": "\nReturn a copy of the sequence left filled with ASCII `b'0'` digits to make a\nsequence of length width. A leading sign prefix (`b'+'`/ `b'-'`) is handled by\ninserting the padding after the sign character rather than before. For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(seq)`.\n\n"}, {"name": "BytesWarning", "path": "library/exceptions#BytesWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings related to `bytes` and `bytearray`.\n\n"}, {"name": "bz2", "path": "library/bz2", "type": "Data Compression", "text": "\nSource code: Lib/bz2.py\n\n"}, {"name": "bz2.BZ2Compressor", "path": "library/bz2#bz2.BZ2Compressor", "type": "Data Compression", "text": "\nCreate a new compressor object. This object may be used to compress data\nincrementally. For one-shot compression, use the `compress()` function\ninstead.\n\n"}, {"name": "bz2.BZ2Compressor.compress()", "path": "library/bz2#bz2.BZ2Compressor.compress", "type": "Data Compression", "text": "\nProvide data to the compressor object. Returns a chunk of compressed data if\npossible, or an empty byte string otherwise.\n\n"}, {"name": "bz2.BZ2Compressor.flush()", "path": "library/bz2#bz2.BZ2Compressor.flush", "type": "Data Compression", "text": "\nFinish the compression process. Returns the compressed data left in internal\nbuffers.\n\n"}, {"name": "bz2.BZ2Decompressor", "path": "library/bz2#bz2.BZ2Decompressor", "type": "Data Compression", "text": "\nCreate a new decompressor object. This object may be used to decompress data\nincrementally. For one-shot compression, use the `decompress()` function\ninstead.\n\n"}, {"name": "bz2.BZ2Decompressor.decompress()", "path": "library/bz2#bz2.BZ2Decompressor.decompress", "type": "Data Compression", "text": "\nDecompress data (a bytes-like object), returning uncompressed data as bytes.\nSome of data may be buffered internally, for use in later calls to\n`decompress()`. The returned data should be concatenated with the output of\nany previous calls to `decompress()`.\n\n"}, {"name": "bz2.BZ2Decompressor.eof", "path": "library/bz2#bz2.BZ2Decompressor.eof", "type": "Data Compression", "text": "\n`True` if the end-of-stream marker has been reached.\n\n"}, {"name": "bz2.BZ2Decompressor.needs_input", "path": "library/bz2#bz2.BZ2Decompressor.needs_input", "type": "Data Compression", "text": "\n`False` if the `decompress()` method can provide more decompressed data before\nrequiring new uncompressed input.\n\n"}, {"name": "bz2.BZ2Decompressor.unused_data", "path": "library/bz2#bz2.BZ2Decompressor.unused_data", "type": "Data Compression", "text": "\nData found after the end of the compressed stream.\n\n"}, {"name": "bz2.BZ2File", "path": "library/bz2#bz2.BZ2File", "type": "Data Compression", "text": "\nOpen a bzip2-compressed file in binary mode.\n\n"}, {"name": "bz2.BZ2File.peek()", "path": "library/bz2#bz2.BZ2File.peek", "type": "Data Compression", "text": "\nReturn buffered data without advancing the file position. At least one byte of\ndata will be returned (unless at EOF). The exact number of bytes returned is\nunspecified.\n\n"}, {"name": "bz2.compress()", "path": "library/bz2#bz2.compress", "type": "Data Compression", "text": "\nCompress data, a bytes-like object.\n\n"}, {"name": "bz2.decompress()", "path": "library/bz2#bz2.decompress", "type": "Data Compression", "text": "\nDecompress data, a bytes-like object.\n\n"}, {"name": "bz2.open()", "path": "library/bz2#bz2.open", "type": "Data Compression", "text": "\nOpen a bzip2-compressed file in binary or text mode, returning a file object.\n\n"}, {"name": "calendar", "path": "library/calendar", "type": "Data Types", "text": "\nSource code: Lib/calendar.py\n\n"}, {"name": "calendar.Calendar", "path": "library/calendar#calendar.Calendar", "type": "Data Types", "text": "\nCreates a `Calendar` object. firstweekday is an integer specifying the first\nday of the week. `0` is Monday (the default), `6` is Sunday.\n\n"}, {"name": "calendar.calendar()", "path": "library/calendar#calendar.calendar", "type": "Data Types", "text": "\nReturns a 3-column calendar for an entire year as a multi-line string using\nthe `formatyear()` of the `TextCalendar` class.\n\n"}, {"name": "calendar.Calendar.itermonthdates()", "path": "library/calendar#calendar.Calendar.itermonthdates", "type": "Data Types", "text": "\nReturn an iterator for the month month (1\u201312) in the year year. This iterator\nwill return all days (as `datetime.date` objects) for the month and all days\nbefore the start of the month or after the end of the month that are required\nto get a complete week.\n\n"}, {"name": "calendar.Calendar.itermonthdays()", "path": "library/calendar#calendar.Calendar.itermonthdays", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will simply be day of the month numbers. For the days outside of the\nspecified month, the day number is `0`.\n\n"}, {"name": "calendar.Calendar.itermonthdays2()", "path": "library/calendar#calendar.Calendar.itermonthdays2", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will be tuples consisting of a day of the month number and a week day\nnumber.\n\n"}, {"name": "calendar.Calendar.itermonthdays3()", "path": "library/calendar#calendar.Calendar.itermonthdays3", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will be tuples consisting of a year, a month and a day of the month\nnumbers.\n\n"}, {"name": "calendar.Calendar.itermonthdays4()", "path": "library/calendar#calendar.Calendar.itermonthdays4", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will be tuples consisting of a year, a month, a day of the month, and\na day of the week numbers.\n\n"}, {"name": "calendar.Calendar.iterweekdays()", "path": "library/calendar#calendar.Calendar.iterweekdays", "type": "Data Types", "text": "\nReturn an iterator for the week day numbers that will be used for one week.\nThe first value from the iterator will be the same as the value of the\n`firstweekday` property.\n\n"}, {"name": "calendar.Calendar.monthdatescalendar()", "path": "library/calendar#calendar.Calendar.monthdatescalendar", "type": "Data Types", "text": "\nReturn a list of the weeks in the month month of the year as full weeks. Weeks\nare lists of seven `datetime.date` objects.\n\n"}, {"name": "calendar.Calendar.monthdays2calendar()", "path": "library/calendar#calendar.Calendar.monthdays2calendar", "type": "Data Types", "text": "\nReturn a list of the weeks in the month month of the year as full weeks. Weeks\nare lists of seven tuples of day numbers and weekday numbers.\n\n"}, {"name": "calendar.Calendar.monthdayscalendar()", "path": "library/calendar#calendar.Calendar.monthdayscalendar", "type": "Data Types", "text": "\nReturn a list of the weeks in the month month of the year as full weeks. Weeks\nare lists of seven day numbers.\n\n"}, {"name": "calendar.Calendar.yeardatescalendar()", "path": "library/calendar#calendar.Calendar.yeardatescalendar", "type": "Data Types", "text": "\nReturn the data for the specified year ready for formatting. The return value\nis a list of month rows. Each month row contains up to width months\n(defaulting to 3). Each month contains between 4 and 6 weeks and each week\ncontains 1\u20137 days. Days are `datetime.date` objects.\n\n"}, {"name": "calendar.Calendar.yeardays2calendar()", "path": "library/calendar#calendar.Calendar.yeardays2calendar", "type": "Data Types", "text": "\nReturn the data for the specified year ready for formatting (similar to\n`yeardatescalendar()`). Entries in the week lists are tuples of day numbers\nand weekday numbers. Day numbers outside this month are zero.\n\n"}, {"name": "calendar.Calendar.yeardayscalendar()", "path": "library/calendar#calendar.Calendar.yeardayscalendar", "type": "Data Types", "text": "\nReturn the data for the specified year ready for formatting (similar to\n`yeardatescalendar()`). Entries in the week lists are day numbers. Day numbers\noutside this month are zero.\n\n"}, {"name": "calendar.day_abbr", "path": "library/calendar#calendar.day_abbr", "type": "Data Types", "text": "\nAn array that represents the abbreviated days of the week in the current\nlocale.\n\n"}, {"name": "calendar.day_name", "path": "library/calendar#calendar.day_name", "type": "Data Types", "text": "\nAn array that represents the days of the week in the current locale.\n\n"}, {"name": "calendar.firstweekday()", "path": "library/calendar#calendar.firstweekday", "type": "Data Types", "text": "\nReturns the current setting for the weekday to start each week.\n\n"}, {"name": "calendar.HTMLCalendar", "path": "library/calendar#calendar.HTMLCalendar", "type": "Data Types", "text": "\nThis class can be used to generate HTML calendars.\n\n"}, {"name": "calendar.HTMLCalendar.cssclasses", "path": "library/calendar#calendar.HTMLCalendar.cssclasses", "type": "Data Types", "text": "\nA list of CSS classes used for each weekday. The default class list is:\n\n"}, {"name": "calendar.HTMLCalendar.cssclasses_weekday_head", "path": "library/calendar#calendar.HTMLCalendar.cssclasses_weekday_head", "type": "Data Types", "text": "\nA list of CSS classes used for weekday names in the header row. The default is\nthe same as `cssclasses`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_month", "path": "library/calendar#calendar.HTMLCalendar.cssclass_month", "type": "Data Types", "text": "\nThe CSS class for the whole month\u2019s table (used by `formatmonth()`). The\ndefault value is `\"month\"`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_month_head", "path": "library/calendar#calendar.HTMLCalendar.cssclass_month_head", "type": "Data Types", "text": "\nThe month\u2019s head CSS class (used by `formatmonthname()`). The default value is\n`\"month\"`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_noday", "path": "library/calendar#calendar.HTMLCalendar.cssclass_noday", "type": "Data Types", "text": "\nThe CSS class for a weekday occurring in the previous or coming month.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_year", "path": "library/calendar#calendar.HTMLCalendar.cssclass_year", "type": "Data Types", "text": "\nThe CSS class for the whole year\u2019s table of tables (used by `formatyear()`).\nThe default value is `\"year\"`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_year_head", "path": "library/calendar#calendar.HTMLCalendar.cssclass_year_head", "type": "Data Types", "text": "\nThe CSS class for the table head for the whole year (used by `formatyear()`).\nThe default value is `\"year\"`.\n\n"}, {"name": "calendar.HTMLCalendar.formatmonth()", "path": "library/calendar#calendar.HTMLCalendar.formatmonth", "type": "Data Types", "text": "\nReturn a month\u2019s calendar as an HTML table. If withyear is true the year will\nbe included in the header, otherwise just the month name will be used.\n\n"}, {"name": "calendar.HTMLCalendar.formatyear()", "path": "library/calendar#calendar.HTMLCalendar.formatyear", "type": "Data Types", "text": "\nReturn a year\u2019s calendar as an HTML table. width (defaulting to 3) specifies\nthe number of months per row.\n\n"}, {"name": "calendar.HTMLCalendar.formatyearpage()", "path": "library/calendar#calendar.HTMLCalendar.formatyearpage", "type": "Data Types", "text": "\nReturn a year\u2019s calendar as a complete HTML page. width (defaulting to 3)\nspecifies the number of months per row. css is the name for the cascading\nstyle sheet to be used. `None` can be passed if no style sheet should be used.\nencoding specifies the encoding to be used for the output (defaulting to the\nsystem default encoding).\n\n"}, {"name": "calendar.isleap()", "path": "library/calendar#calendar.isleap", "type": "Data Types", "text": "\nReturns `True` if year is a leap year, otherwise `False`.\n\n"}, {"name": "calendar.leapdays()", "path": "library/calendar#calendar.leapdays", "type": "Data Types", "text": "\nReturns the number of leap years in the range from y1 to y2 (exclusive), where\ny1 and y2 are years.\n\n"}, {"name": "calendar.LocaleHTMLCalendar", "path": "library/calendar#calendar.LocaleHTMLCalendar", "type": "Data Types", "text": "\nThis subclass of `HTMLCalendar` can be passed a locale name in the constructor\nand will return month and weekday names in the specified locale. If this\nlocale includes an encoding all strings containing month and weekday names\nwill be returned as unicode.\n\n"}, {"name": "calendar.LocaleTextCalendar", "path": "library/calendar#calendar.LocaleTextCalendar", "type": "Data Types", "text": "\nThis subclass of `TextCalendar` can be passed a locale name in the constructor\nand will return month and weekday names in the specified locale. If this\nlocale includes an encoding all strings containing month and weekday names\nwill be returned as unicode.\n\n"}, {"name": "calendar.month()", "path": "library/calendar#calendar.month", "type": "Data Types", "text": "\nReturns a month\u2019s calendar in a multi-line string using the `formatmonth()` of\nthe `TextCalendar` class.\n\n"}, {"name": "calendar.monthcalendar()", "path": "library/calendar#calendar.monthcalendar", "type": "Data Types", "text": "\nReturns a matrix representing a month\u2019s calendar. Each row represents a week;\ndays outside of the month are represented by zeros. Each week begins with\nMonday unless set by `setfirstweekday()`.\n\n"}, {"name": "calendar.monthrange()", "path": "library/calendar#calendar.monthrange", "type": "Data Types", "text": "\nReturns weekday of first day of the month and number of days in month, for the\nspecified year and month.\n\n"}, {"name": "calendar.month_abbr", "path": "library/calendar#calendar.month_abbr", "type": "Data Types", "text": "\nAn array that represents the abbreviated months of the year in the current\nlocale. This follows normal convention of January being month number 1, so it\nhas a length of 13 and `month_abbr[0]` is the empty string.\n\n"}, {"name": "calendar.month_name", "path": "library/calendar#calendar.month_name", "type": "Data Types", "text": "\nAn array that represents the months of the year in the current locale. This\nfollows normal convention of January being month number 1, so it has a length\nof 13 and `month_name[0]` is the empty string.\n\n"}, {"name": "calendar.prcal()", "path": "library/calendar#calendar.prcal", "type": "Data Types", "text": "\nPrints the calendar for an entire year as returned by `calendar()`.\n\n"}, {"name": "calendar.prmonth()", "path": "library/calendar#calendar.prmonth", "type": "Data Types", "text": "\nPrints a month\u2019s calendar as returned by `month()`.\n\n"}, {"name": "calendar.setfirstweekday()", "path": "library/calendar#calendar.setfirstweekday", "type": "Data Types", "text": "\nSets the weekday (`0` is Monday, `6` is Sunday) to start each week. The values\n`MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, and\n`SUNDAY` are provided for convenience. For example, to set the first weekday\nto Sunday:\n\n"}, {"name": "calendar.TextCalendar", "path": "library/calendar#calendar.TextCalendar", "type": "Data Types", "text": "\nThis class can be used to generate plain text calendars.\n\n"}, {"name": "calendar.TextCalendar.formatmonth()", "path": "library/calendar#calendar.TextCalendar.formatmonth", "type": "Data Types", "text": "\nReturn a month\u2019s calendar in a multi-line string. If w is provided, it\nspecifies the width of the date columns, which are centered. If l is given, it\nspecifies the number of lines that each week will use. Depends on the first\nweekday as specified in the constructor or set by the `setfirstweekday()`\nmethod.\n\n"}, {"name": "calendar.TextCalendar.formatyear()", "path": "library/calendar#calendar.TextCalendar.formatyear", "type": "Data Types", "text": "\nReturn a m-column calendar for an entire year as a multi-line string. Optional\nparameters w, l, and c are for date column width, lines per week, and number\nof spaces between month columns, respectively. Depends on the first weekday as\nspecified in the constructor or set by the `setfirstweekday()` method. The\nearliest year for which a calendar can be generated is platform-dependent.\n\n"}, {"name": "calendar.TextCalendar.prmonth()", "path": "library/calendar#calendar.TextCalendar.prmonth", "type": "Data Types", "text": "\nPrint a month\u2019s calendar as returned by `formatmonth()`.\n\n"}, {"name": "calendar.TextCalendar.pryear()", "path": "library/calendar#calendar.TextCalendar.pryear", "type": "Data Types", "text": "\nPrint the calendar for an entire year as returned by `formatyear()`.\n\n"}, {"name": "calendar.timegm()", "path": "library/calendar#calendar.timegm", "type": "Data Types", "text": "\nAn unrelated but handy function that takes a time tuple such as returned by\nthe `gmtime()` function in the `time` module, and returns the corresponding\nUnix timestamp value, assuming an epoch of 1970, and the POSIX encoding. In\nfact, `time.gmtime()` and `timegm()` are each others\u2019 inverse.\n\n"}, {"name": "calendar.weekday()", "path": "library/calendar#calendar.weekday", "type": "Data Types", "text": "\nReturns the day of the week (`0` is Monday) for year (`1970`\u2013\u2026), month\n(`1`\u2013`12`), day (`1`\u2013`31`).\n\n"}, {"name": "calendar.weekheader()", "path": "library/calendar#calendar.weekheader", "type": "Data Types", "text": "\nReturn a header containing abbreviated weekday names. n specifies the width in\ncharacters for one weekday.\n\n"}, {"name": "callable()", "path": "library/functions#callable", "type": "Built-in Functions", "text": "\nReturn `True` if the object argument appears callable, `False` if not. If this\nreturns `True`, it is still possible that a call fails, but if it is `False`,\ncalling object will never succeed. Note that classes are callable (calling a\nclass returns a new instance); instances are callable if their class has a\n`__call__()` method.\n\n"}, {"name": "cgi", "path": "library/cgi", "type": "Internet", "text": "\nSource code: Lib/cgi.py\n\n"}, {"name": "cgi.FieldStorage.getfirst()", "path": "library/cgi#cgi.FieldStorage.getfirst", "type": "Internet", "text": "\nThis method always returns only one value associated with form field name. The\nmethod returns only the first value in case that more values were posted under\nsuch name. Please note that the order in which the values are received may\nvary from browser to browser and should not be counted on. 1 If no such form\nfield or value exists then the method returns the value specified by the\noptional parameter default. This parameter defaults to `None` if not\nspecified.\n\n"}, {"name": "cgi.FieldStorage.getlist()", "path": "library/cgi#cgi.FieldStorage.getlist", "type": "Internet", "text": "\nThis method always returns a list of values associated with form field name.\nThe method returns an empty list if no such form field or value exists for\nname. It returns a list consisting of one item if only one such value exists.\n\n"}, {"name": "cgi.parse()", "path": "library/cgi#cgi.parse", "type": "Internet", "text": "\nParse a query in the environment or from a file (the file defaults to\n`sys.stdin`). The keep_blank_values, strict_parsing and separator parameters\nare passed to `urllib.parse.parse_qs()` unchanged.\n\n"}, {"name": "cgi.parse_header()", "path": "library/cgi#cgi.parse_header", "type": "Internet", "text": "\nParse a MIME header (such as Content-Type) into a main value and a dictionary\nof parameters.\n\n"}, {"name": "cgi.parse_multipart()", "path": "library/cgi#cgi.parse_multipart", "type": "Internet", "text": "\nParse input of type multipart/form-data (for file uploads). Arguments are fp\nfor the input file, pdict for a dictionary containing other parameters in the\nContent-Type header, and encoding, the request encoding.\n\n"}, {"name": "cgi.print_directory()", "path": "library/cgi#cgi.print_directory", "type": "Internet", "text": "\nFormat the current directory in HTML.\n\n"}, {"name": "cgi.print_environ()", "path": "library/cgi#cgi.print_environ", "type": "Internet", "text": "\nFormat the shell environment in HTML.\n\n"}, {"name": "cgi.print_environ_usage()", "path": "library/cgi#cgi.print_environ_usage", "type": "Internet", "text": "\nPrint a list of useful (used by CGI) environment variables in HTML.\n\n"}, {"name": "cgi.print_form()", "path": "library/cgi#cgi.print_form", "type": "Internet", "text": "\nFormat a form in HTML.\n\n"}, {"name": "cgi.test()", "path": "library/cgi#cgi.test", "type": "Internet", "text": "\nRobust test CGI script, usable as main program. Writes minimal HTTP headers\nand formats all information provided to the script in HTML form.\n\n"}, {"name": "cgitb", "path": "library/cgitb", "type": "Internet", "text": "\nSource code: Lib/cgitb.py\n\n"}, {"name": "cgitb.enable()", "path": "library/cgitb#cgitb.enable", "type": "Internet", "text": "\nThis function causes the `cgitb` module to take over the interpreter\u2019s default\nhandling for exceptions by setting the value of `sys.excepthook`.\n\n"}, {"name": "cgitb.handler()", "path": "library/cgitb#cgitb.handler", "type": "Internet", "text": "\nThis function handles an exception using the default settings (that is, show a\nreport in the browser, but don\u2019t log to a file). This can be used when you\u2019ve\ncaught an exception and want to report it using `cgitb`. The optional info\nargument should be a 3-tuple containing an exception type, exception value,\nand traceback object, exactly like the tuple returned by `sys.exc_info()`. If\nthe info argument is not supplied, the current exception is obtained from\n`sys.exc_info()`.\n\n"}, {"name": "cgitb.html()", "path": "library/cgitb#cgitb.html", "type": "Internet", "text": "\nThis function handles the exception described by info (a 3-tuple containing\nthe result of `sys.exc_info()`), formatting its traceback as HTML and\nreturning the result as a string. The optional argument context is the number\nof lines of context to display around the current line of source code in the\ntraceback; this defaults to `5`.\n\n"}, {"name": "cgitb.text()", "path": "library/cgitb#cgitb.text", "type": "Internet", "text": "\nThis function handles the exception described by info (a 3-tuple containing\nthe result of `sys.exc_info()`), formatting its traceback as text and\nreturning the result as a string. The optional argument context is the number\nof lines of context to display around the current line of source code in the\ntraceback; this defaults to `5`.\n\n"}, {"name": "ChildProcessError", "path": "library/exceptions#ChildProcessError", "type": "Built-in Exceptions", "text": "\nRaised when an operation on a child process failed. Corresponds to `errno`\n`ECHILD`.\n\n"}, {"name": "chr()", "path": "library/functions#chr", "type": "Built-in Functions", "text": "\nReturn the string representing a character whose Unicode code point is the\ninteger i. For example, `chr(97)` returns the string `'a'`, while `chr(8364)`\nreturns the string `'\u20ac'`. This is the inverse of `ord()`.\n\n"}, {"name": "chunk", "path": "library/chunk", "type": "Multimedia", "text": "\nSource code: Lib/chunk.py\n\n"}, {"name": "chunk.Chunk", "path": "library/chunk#chunk.Chunk", "type": "Multimedia", "text": "\nClass which represents a chunk. The file argument is expected to be a file-\nlike object. An instance of this class is specifically allowed. The only\nmethod that is needed is `read()`. If the methods `seek()` and `tell()` are\npresent and don\u2019t raise an exception, they are also used. If these methods are\npresent and raise an exception, they are expected to not have altered the\nobject. If the optional argument align is true, chunks are assumed to be\naligned on 2-byte boundaries. If align is false, no alignment is assumed. The\ndefault value is true. If the optional argument bigendian is false, the chunk\nsize is assumed to be in little-endian order. This is needed for WAVE audio\nfiles. The default value is true. If the optional argument inclheader is true,\nthe size given in the chunk header includes the size of the header. The\ndefault value is false.\n\n"}, {"name": "chunk.Chunk.close()", "path": "library/chunk#chunk.Chunk.close", "type": "Multimedia", "text": "\nClose and skip to the end of the chunk. This does not close the underlying\nfile.\n\n"}, {"name": "chunk.Chunk.getname()", "path": "library/chunk#chunk.Chunk.getname", "type": "Multimedia", "text": "\nReturns the name (ID) of the chunk. This is the first 4 bytes of the chunk.\n\n"}, {"name": "chunk.Chunk.getsize()", "path": "library/chunk#chunk.Chunk.getsize", "type": "Multimedia", "text": "\nReturns the size of the chunk.\n\n"}, {"name": "chunk.Chunk.isatty()", "path": "library/chunk#chunk.Chunk.isatty", "type": "Multimedia", "text": "\nReturns `False`.\n\n"}, {"name": "chunk.Chunk.read()", "path": "library/chunk#chunk.Chunk.read", "type": "Multimedia", "text": "\nRead at most size bytes from the chunk (less if the read hits the end of the\nchunk before obtaining size bytes). If the size argument is negative or\nomitted, read all data until the end of the chunk. An empty bytes object is\nreturned when the end of the chunk is encountered immediately.\n\n"}, {"name": "chunk.Chunk.seek()", "path": "library/chunk#chunk.Chunk.seek", "type": "Multimedia", "text": "\nSet the chunk\u2019s current position. The whence argument is optional and defaults\nto `0` (absolute file positioning); other values are `1` (seek relative to the\ncurrent position) and `2` (seek relative to the file\u2019s end). There is no\nreturn value. If the underlying file does not allow seek, only forward seeks\nare allowed.\n\n"}, {"name": "chunk.Chunk.skip()", "path": "library/chunk#chunk.Chunk.skip", "type": "Multimedia", "text": "\nSkip to the end of the chunk. All further calls to `read()` for the chunk will\nreturn `b''`. If you are not interested in the contents of the chunk, this\nmethod should be called so that the file points to the start of the next\nchunk.\n\n"}, {"name": "chunk.Chunk.tell()", "path": "library/chunk#chunk.Chunk.tell", "type": "Multimedia", "text": "\nReturn the current position into the chunk.\n\n"}, {"name": "class.mro()", "path": "library/stdtypes#class.mro", "type": "Built-in Types", "text": "\nThis method can be overridden by a metaclass to customize the method\nresolution order for its instances. It is called at class instantiation, and\nits result is stored in `__mro__`.\n\n"}, {"name": "class.__bases__", "path": "library/stdtypes#class.__bases__", "type": "Built-in Types", "text": "\nThe tuple of base classes of a class object.\n\n"}, {"name": "class.__mro__", "path": "library/stdtypes#class.__mro__", "type": "Built-in Types", "text": "\nThis attribute is a tuple of classes that are considered when looking for base\nclasses during method resolution.\n\n"}, {"name": "class.__subclasses__()", "path": "library/stdtypes#class.__subclasses__", "type": "Built-in Types", "text": "\nEach class keeps a list of weak references to its immediate subclasses. This\nmethod returns a list of all those references still alive. The list is in\ndefinition order. Example:\n\n"}, {"name": "classmethod()", "path": "library/functions#classmethod", "type": "Built-in Functions", "text": "\nTransform a method into a class method.\n\n"}, {"name": "cmath", "path": "library/cmath", "type": "Numeric & Mathematical", "text": "\nThis module provides access to mathematical functions for complex numbers. The\nfunctions in this module accept integers, floating-point numbers or complex\nnumbers as arguments. They will also accept any Python object that has either\na `__complex__()` or a `__float__()` method: these methods are used to convert\nthe object to a complex or floating-point number, respectively, and the\nfunction is then applied to the result of the conversion.\n\n"}, {"name": "cmath.acos()", "path": "library/cmath#cmath.acos", "type": "Numeric & Mathematical", "text": "\nReturn the arc cosine of x. There are two branch cuts: One extends right from\n1 along the real axis to \u221e, continuous from below. The other extends left from\n-1 along the real axis to -\u221e, continuous from above.\n\n"}, {"name": "cmath.acosh()", "path": "library/cmath#cmath.acosh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic cosine of x. There is one branch cut, extending\nleft from 1 along the real axis to -\u221e, continuous from above.\n\n"}, {"name": "cmath.asin()", "path": "library/cmath#cmath.asin", "type": "Numeric & Mathematical", "text": "\nReturn the arc sine of x. This has the same branch cuts as `acos()`.\n\n"}, {"name": "cmath.asinh()", "path": "library/cmath#cmath.asinh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic sine of x. There are two branch cuts: One\nextends from `1j` along the imaginary axis to `\u221ej`, continuous from the right.\nThe other extends from `-1j` along the imaginary axis to `-\u221ej`, continuous\nfrom the left.\n\n"}, {"name": "cmath.atan()", "path": "library/cmath#cmath.atan", "type": "Numeric & Mathematical", "text": "\nReturn the arc tangent of x. There are two branch cuts: One extends from `1j`\nalong the imaginary axis to `\u221ej`, continuous from the right. The other extends\nfrom `-1j` along the imaginary axis to `-\u221ej`, continuous from the left.\n\n"}, {"name": "cmath.atanh()", "path": "library/cmath#cmath.atanh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic tangent of x. There are two branch cuts: One\nextends from `1` along the real axis to `\u221e`, continuous from below. The other\nextends from `-1` along the real axis to `-\u221e`, continuous from above.\n\n"}, {"name": "cmath.cos()", "path": "library/cmath#cmath.cos", "type": "Numeric & Mathematical", "text": "\nReturn the cosine of x.\n\n"}, {"name": "cmath.cosh()", "path": "library/cmath#cmath.cosh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic cosine of x.\n\n"}, {"name": "cmath.e", "path": "library/cmath#cmath.e", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant e, as a float.\n\n"}, {"name": "cmath.exp()", "path": "library/cmath#cmath.exp", "type": "Numeric & Mathematical", "text": "\nReturn e raised to the power x, where e is the base of natural logarithms.\n\n"}, {"name": "cmath.inf", "path": "library/cmath#cmath.inf", "type": "Numeric & Mathematical", "text": "\nFloating-point positive infinity. Equivalent to `float('inf')`.\n\n"}, {"name": "cmath.infj", "path": "library/cmath#cmath.infj", "type": "Numeric & Mathematical", "text": "\nComplex number with zero real part and positive infinity imaginary part.\nEquivalent to `complex(0.0, float('inf'))`.\n\n"}, {"name": "cmath.isclose()", "path": "library/cmath#cmath.isclose", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the values a and b are close to each other and `False`\notherwise.\n\n"}, {"name": "cmath.isfinite()", "path": "library/cmath#cmath.isfinite", "type": "Numeric & Mathematical", "text": "\nReturn `True` if both the real and imaginary parts of x are finite, and\n`False` otherwise.\n\n"}, {"name": "cmath.isinf()", "path": "library/cmath#cmath.isinf", "type": "Numeric & Mathematical", "text": "\nReturn `True` if either the real or the imaginary part of x is an infinity,\nand `False` otherwise.\n\n"}, {"name": "cmath.isnan()", "path": "library/cmath#cmath.isnan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if either the real or the imaginary part of x is a NaN, and\n`False` otherwise.\n\n"}, {"name": "cmath.log()", "path": "library/cmath#cmath.log", "type": "Numeric & Mathematical", "text": "\nReturns the logarithm of x to the given base. If the base is not specified,\nreturns the natural logarithm of x. There is one branch cut, from 0 along the\nnegative real axis to -\u221e, continuous from above.\n\n"}, {"name": "cmath.log10()", "path": "library/cmath#cmath.log10", "type": "Numeric & Mathematical", "text": "\nReturn the base-10 logarithm of x. This has the same branch cut as `log()`.\n\n"}, {"name": "cmath.nan", "path": "library/cmath#cmath.nan", "type": "Numeric & Mathematical", "text": "\nA floating-point \u201cnot a number\u201d (NaN) value. Equivalent to `float('nan')`.\n\n"}, {"name": "cmath.nanj", "path": "library/cmath#cmath.nanj", "type": "Numeric & Mathematical", "text": "\nComplex number with zero real part and NaN imaginary part. Equivalent to\n`complex(0.0, float('nan'))`.\n\n"}, {"name": "cmath.phase()", "path": "library/cmath#cmath.phase", "type": "Numeric & Mathematical", "text": "\nReturn the phase of x (also known as the argument of x), as a float.\n`phase(x)` is equivalent to `math.atan2(x.imag, x.real)`. The result lies in\nthe range [-\u03c0, \u03c0], and the branch cut for this operation lies along the\nnegative real axis, continuous from above. On systems with support for signed\nzeros (which includes most systems in current use), this means that the sign\nof the result is the same as the sign of `x.imag`, even when `x.imag` is zero:\n\n"}, {"name": "cmath.pi", "path": "library/cmath#cmath.pi", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant \u03c0, as a float.\n\n"}, {"name": "cmath.polar()", "path": "library/cmath#cmath.polar", "type": "Numeric & Mathematical", "text": "\nReturn the representation of x in polar coordinates. Returns a pair `(r, phi)`\nwhere r is the modulus of x and phi is the phase of x. `polar(x)` is\nequivalent to `(abs(x), phase(x))`.\n\n"}, {"name": "cmath.rect()", "path": "library/cmath#cmath.rect", "type": "Numeric & Mathematical", "text": "\nReturn the complex number x with polar coordinates r and phi. Equivalent to `r\n* (math.cos(phi) + math.sin(phi)*1j)`.\n\n"}, {"name": "cmath.sin()", "path": "library/cmath#cmath.sin", "type": "Numeric & Mathematical", "text": "\nReturn the sine of x.\n\n"}, {"name": "cmath.sinh()", "path": "library/cmath#cmath.sinh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic sine of x.\n\n"}, {"name": "cmath.sqrt()", "path": "library/cmath#cmath.sqrt", "type": "Numeric & Mathematical", "text": "\nReturn the square root of x. This has the same branch cut as `log()`.\n\n"}, {"name": "cmath.tan()", "path": "library/cmath#cmath.tan", "type": "Numeric & Mathematical", "text": "\nReturn the tangent of x.\n\n"}, {"name": "cmath.tanh()", "path": "library/cmath#cmath.tanh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic tangent of x.\n\n"}, {"name": "cmath.tau", "path": "library/cmath#cmath.tau", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant \u03c4, as a float.\n\n"}, {"name": "cmd", "path": "library/cmd", "type": "Frameworks", "text": "\nSource code: Lib/cmd.py\n\n"}, {"name": "cmd.Cmd", "path": "library/cmd#cmd.Cmd", "type": "Frameworks", "text": "\nA `Cmd` instance or subclass instance is a line-oriented interpreter\nframework. There is no good reason to instantiate `Cmd` itself; rather, it\u2019s\nuseful as a superclass of an interpreter class you define yourself in order to\ninherit `Cmd`\u2019s methods and encapsulate action methods.\n\n"}, {"name": "cmd.Cmd.cmdloop()", "path": "library/cmd#cmd.Cmd.cmdloop", "type": "Frameworks", "text": "\nRepeatedly issue a prompt, accept input, parse an initial prefix off the\nreceived input, and dispatch to action methods, passing them the remainder of\nthe line as argument.\n\n"}, {"name": "cmd.Cmd.cmdqueue", "path": "library/cmd#cmd.Cmd.cmdqueue", "type": "Frameworks", "text": "\nA list of queued input lines. The cmdqueue list is checked in `cmdloop()` when\nnew input is needed; if it is nonempty, its elements will be processed in\norder, as if entered at the prompt.\n\n"}, {"name": "cmd.Cmd.completedefault()", "path": "library/cmd#cmd.Cmd.completedefault", "type": "Frameworks", "text": "\nMethod called to complete an input line when no command-specific\n`complete_*()` method is available. By default, it returns an empty list.\n\n"}, {"name": "cmd.Cmd.default()", "path": "library/cmd#cmd.Cmd.default", "type": "Frameworks", "text": "\nMethod called on an input line when the command prefix is not recognized. If\nthis method is not overridden, it prints an error message and returns.\n\n"}, {"name": "cmd.Cmd.doc_header", "path": "library/cmd#cmd.Cmd.doc_header", "type": "Frameworks", "text": "\nThe header to issue if the help output has a section for documented commands.\n\n"}, {"name": "cmd.Cmd.emptyline()", "path": "library/cmd#cmd.Cmd.emptyline", "type": "Frameworks", "text": "\nMethod called when an empty line is entered in response to the prompt. If this\nmethod is not overridden, it repeats the last nonempty command entered.\n\n"}, {"name": "cmd.Cmd.identchars", "path": "library/cmd#cmd.Cmd.identchars", "type": "Frameworks", "text": "\nThe string of characters accepted for the command prefix.\n\n"}, {"name": "cmd.Cmd.intro", "path": "library/cmd#cmd.Cmd.intro", "type": "Frameworks", "text": "\nA string to issue as an intro or banner. May be overridden by giving the\n`cmdloop()` method an argument.\n\n"}, {"name": "cmd.Cmd.lastcmd", "path": "library/cmd#cmd.Cmd.lastcmd", "type": "Frameworks", "text": "\nThe last nonempty command prefix seen.\n\n"}, {"name": "cmd.Cmd.misc_header", "path": "library/cmd#cmd.Cmd.misc_header", "type": "Frameworks", "text": "\nThe header to issue if the help output has a section for miscellaneous help\ntopics (that is, there are `help_*()` methods without corresponding `do_*()`\nmethods).\n\n"}, {"name": "cmd.Cmd.onecmd()", "path": "library/cmd#cmd.Cmd.onecmd", "type": "Frameworks", "text": "\nInterpret the argument as though it had been typed in response to the prompt.\nThis may be overridden, but should not normally need to be; see the `precmd()`\nand `postcmd()` methods for useful execution hooks. The return value is a flag\nindicating whether interpretation of commands by the interpreter should stop.\nIf there is a `do_*()` method for the command str, the return value of that\nmethod is returned, otherwise the return value from the `default()` method is\nreturned.\n\n"}, {"name": "cmd.Cmd.postcmd()", "path": "library/cmd#cmd.Cmd.postcmd", "type": "Frameworks", "text": "\nHook method executed just after a command dispatch is finished. This method is\na stub in `Cmd`; it exists to be overridden by subclasses. line is the command\nline which was executed, and stop is a flag which indicates whether execution\nwill be terminated after the call to `postcmd()`; this will be the return\nvalue of the `onecmd()` method. The return value of this method will be used\nas the new value for the internal flag which corresponds to stop; returning\nfalse will cause interpretation to continue.\n\n"}, {"name": "cmd.Cmd.postloop()", "path": "library/cmd#cmd.Cmd.postloop", "type": "Frameworks", "text": "\nHook method executed once when `cmdloop()` is about to return. This method is\na stub in `Cmd`; it exists to be overridden by subclasses.\n\n"}, {"name": "cmd.Cmd.precmd()", "path": "library/cmd#cmd.Cmd.precmd", "type": "Frameworks", "text": "\nHook method executed just before the command line line is interpreted, but\nafter the input prompt is generated and issued. This method is a stub in\n`Cmd`; it exists to be overridden by subclasses. The return value is used as\nthe command which will be executed by the `onecmd()` method; the `precmd()`\nimplementation may re-write the command or simply return line unchanged.\n\n"}, {"name": "cmd.Cmd.preloop()", "path": "library/cmd#cmd.Cmd.preloop", "type": "Frameworks", "text": "\nHook method executed once when `cmdloop()` is called. This method is a stub in\n`Cmd`; it exists to be overridden by subclasses.\n\n"}, {"name": "cmd.Cmd.prompt", "path": "library/cmd#cmd.Cmd.prompt", "type": "Frameworks", "text": "\nThe prompt issued to solicit input.\n\n"}, {"name": "cmd.Cmd.ruler", "path": "library/cmd#cmd.Cmd.ruler", "type": "Frameworks", "text": "\nThe character used to draw separator lines under the help-message headers. If\nempty, no ruler line is drawn. It defaults to `'='`.\n\n"}, {"name": "cmd.Cmd.undoc_header", "path": "library/cmd#cmd.Cmd.undoc_header", "type": "Frameworks", "text": "\nThe header to issue if the help output has a section for undocumented commands\n(that is, there are `do_*()` methods without corresponding `help_*()`\nmethods).\n\n"}, {"name": "cmd.Cmd.use_rawinput", "path": "library/cmd#cmd.Cmd.use_rawinput", "type": "Frameworks", "text": "\nA flag, defaulting to true. If true, `cmdloop()` uses `input()` to display a\nprompt and read the next command; if false, `sys.stdout.write()` and\n`sys.stdin.readline()` are used. (This means that by importing `readline`, on\nsystems that support it, the interpreter will automatically support Emacs-like\nline editing and command-history keystrokes.)\n\n"}, {"name": "code", "path": "library/code", "type": "Interpreters", "text": "\nSource code: Lib/code.py\n\n"}, {"name": "code.compile_command()", "path": "library/code#code.compile_command", "type": "Interpreters", "text": "\nThis function is useful for programs that want to emulate Python\u2019s interpreter\nmain loop (a.k.a. the read-eval-print loop). The tricky part is to determine\nwhen the user has entered an incomplete command that can be completed by\nentering more text (as opposed to a complete command or a syntax error). This\nfunction almost always makes the same decision as the real interpreter main\nloop.\n\n"}, {"name": "code.interact()", "path": "library/code#code.interact", "type": "Interpreters", "text": "\nConvenience function to run a read-eval-print loop. This creates a new\ninstance of `InteractiveConsole` and sets readfunc to be used as the\n`InteractiveConsole.raw_input()` method, if provided. If local is provided, it\nis passed to the `InteractiveConsole` constructor for use as the default\nnamespace for the interpreter loop. The `interact()` method of the instance is\nthen run with banner and exitmsg passed as the banner and exit message to use,\nif provided. The console object is discarded after use.\n\n"}, {"name": "code.InteractiveConsole", "path": "library/code#code.InteractiveConsole", "type": "Interpreters", "text": "\nClosely emulate the behavior of the interactive Python interpreter. This class\nbuilds on `InteractiveInterpreter` and adds prompting using the familiar\n`sys.ps1` and `sys.ps2`, and input buffering.\n\n"}, {"name": "code.InteractiveConsole.interact()", "path": "library/code#code.InteractiveConsole.interact", "type": "Interpreters", "text": "\nClosely emulate the interactive Python console. The optional banner argument\nspecify the banner to print before the first interaction; by default it prints\na banner similar to the one printed by the standard Python interpreter,\nfollowed by the class name of the console object in parentheses (so as not to\nconfuse this with the real interpreter \u2013 since it\u2019s so close!).\n\n"}, {"name": "code.InteractiveConsole.push()", "path": "library/code#code.InteractiveConsole.push", "type": "Interpreters", "text": "\nPush a line of source text to the interpreter. The line should not have a\ntrailing newline; it may have internal newlines. The line is appended to a\nbuffer and the interpreter\u2019s `runsource()` method is called with the\nconcatenated contents of the buffer as source. If this indicates that the\ncommand was executed or invalid, the buffer is reset; otherwise, the command\nis incomplete, and the buffer is left as it was after the line was appended.\nThe return value is `True` if more input is required, `False` if the line was\ndealt with in some way (this is the same as `runsource()`).\n\n"}, {"name": "code.InteractiveConsole.raw_input()", "path": "library/code#code.InteractiveConsole.raw_input", "type": "Interpreters", "text": "\nWrite a prompt and read a line. The returned line does not include the\ntrailing newline. When the user enters the EOF key sequence, `EOFError` is\nraised. The base implementation reads from `sys.stdin`; a subclass may replace\nthis with a different implementation.\n\n"}, {"name": "code.InteractiveConsole.resetbuffer()", "path": "library/code#code.InteractiveConsole.resetbuffer", "type": "Interpreters", "text": "\nRemove any unhandled source text from the input buffer.\n\n"}, {"name": "code.InteractiveInterpreter", "path": "library/code#code.InteractiveInterpreter", "type": "Interpreters", "text": "\nThis class deals with parsing and interpreter state (the user\u2019s namespace); it\ndoes not deal with input buffering or prompting or input file naming (the\nfilename is always passed in explicitly). The optional locals argument\nspecifies the dictionary in which code will be executed; it defaults to a\nnewly created dictionary with key `'__name__'` set to `'__console__'` and key\n`'__doc__'` set to `None`.\n\n"}, {"name": "code.InteractiveInterpreter.runcode()", "path": "library/code#code.InteractiveInterpreter.runcode", "type": "Interpreters", "text": "\nExecute a code object. When an exception occurs, `showtraceback()` is called\nto display a traceback. All exceptions are caught except `SystemExit`, which\nis allowed to propagate.\n\n"}, {"name": "code.InteractiveInterpreter.runsource()", "path": "library/code#code.InteractiveInterpreter.runsource", "type": "Interpreters", "text": "\nCompile and run some source in the interpreter. Arguments are the same as for\n`compile_command()`; the default for filename is `'<input>'`, and for symbol\nis `'single'`. One of several things can happen:\n\n"}, {"name": "code.InteractiveInterpreter.showsyntaxerror()", "path": "library/code#code.InteractiveInterpreter.showsyntaxerror", "type": "Interpreters", "text": "\nDisplay the syntax error that just occurred. This does not display a stack\ntrace because there isn\u2019t one for syntax errors. If filename is given, it is\nstuffed into the exception instead of the default filename provided by\nPython\u2019s parser, because it always uses `'<string>'` when reading from a\nstring. The output is written by the `write()` method.\n\n"}, {"name": "code.InteractiveInterpreter.showtraceback()", "path": "library/code#code.InteractiveInterpreter.showtraceback", "type": "Interpreters", "text": "\nDisplay the exception that just occurred. We remove the first stack item\nbecause it is within the interpreter object implementation. The output is\nwritten by the `write()` method.\n\n"}, {"name": "code.InteractiveInterpreter.write()", "path": "library/code#code.InteractiveInterpreter.write", "type": "Interpreters", "text": "\nWrite a string to the standard error stream (`sys.stderr`). Derived classes\nshould override this to provide the appropriate output handling as needed.\n\n"}, {"name": "codecs", "path": "library/codecs", "type": "Binary Data", "text": "\nSource code: Lib/codecs.py\n\n"}, {"name": "codecs.backslashreplace_errors()", "path": "library/codecs#codecs.backslashreplace_errors", "type": "Binary Data", "text": "\nImplements the `'backslashreplace'` error handling (for text encodings only):\nmalformed data is replaced by a backslashed escape sequence.\n\n"}, {"name": "codecs.BOM", "path": "library/codecs#codecs.BOM", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_BE", "path": "library/codecs#codecs.BOM_BE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_LE", "path": "library/codecs#codecs.BOM_LE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF16", "path": "library/codecs#codecs.BOM_UTF16", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF16_BE", "path": "library/codecs#codecs.BOM_UTF16_BE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF16_LE", "path": "library/codecs#codecs.BOM_UTF16_LE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF32", "path": "library/codecs#codecs.BOM_UTF32", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF32_BE", "path": "library/codecs#codecs.BOM_UTF32_BE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF32_LE", "path": "library/codecs#codecs.BOM_UTF32_LE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF8", "path": "library/codecs#codecs.BOM_UTF8", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.Codec.decode()", "path": "library/codecs#codecs.Codec.decode", "type": "Binary Data", "text": "\nDecodes the object input and returns a tuple (output object, length consumed).\nFor instance, for a text encoding, decoding converts a bytes object encoded\nusing a particular character set encoding to a string object.\n\n"}, {"name": "codecs.Codec.encode()", "path": "library/codecs#codecs.Codec.encode", "type": "Binary Data", "text": "\nEncodes the object input and returns a tuple (output object, length consumed).\nFor instance, text encoding converts a string object to a bytes object using a\nparticular character set encoding (e.g., `cp1252` or `iso-8859-1`).\n\n"}, {"name": "codecs.CodecInfo", "path": "library/codecs#codecs.CodecInfo", "type": "Binary Data", "text": "\nCodec details when looking up the codec registry. The constructor arguments\nare stored in attributes of the same name:\n\n"}, {"name": "codecs.CodecInfo.decode", "path": "library/codecs#codecs.CodecInfo.decode", "type": "Binary Data", "text": "\nThe stateless encoding and decoding functions. These must be functions or\nmethods which have the same interface as the `encode()` and `decode()` methods\nof Codec instances (see Codec Interface). The functions or methods are\nexpected to work in a stateless mode.\n\n"}, {"name": "codecs.CodecInfo.encode", "path": "library/codecs#codecs.CodecInfo.encode", "type": "Binary Data", "text": "\nThe stateless encoding and decoding functions. These must be functions or\nmethods which have the same interface as the `encode()` and `decode()` methods\nof Codec instances (see Codec Interface). The functions or methods are\nexpected to work in a stateless mode.\n\n"}, {"name": "codecs.CodecInfo.incrementaldecoder", "path": "library/codecs#codecs.CodecInfo.incrementaldecoder", "type": "Binary Data", "text": "\nIncremental encoder and decoder classes or factory functions. These have to\nprovide the interface defined by the base classes `IncrementalEncoder` and\n`IncrementalDecoder`, respectively. Incremental codecs can maintain state.\n\n"}, {"name": "codecs.CodecInfo.incrementalencoder", "path": "library/codecs#codecs.CodecInfo.incrementalencoder", "type": "Binary Data", "text": "\nIncremental encoder and decoder classes or factory functions. These have to\nprovide the interface defined by the base classes `IncrementalEncoder` and\n`IncrementalDecoder`, respectively. Incremental codecs can maintain state.\n\n"}, {"name": "codecs.CodecInfo.name", "path": "library/codecs#codecs.CodecInfo.name", "type": "Binary Data", "text": "\nThe name of the encoding.\n\n"}, {"name": "codecs.CodecInfo.streamreader", "path": "library/codecs#codecs.CodecInfo.streamreader", "type": "Binary Data", "text": "\nStream writer and reader classes or factory functions. These have to provide\nthe interface defined by the base classes `StreamWriter` and `StreamReader`,\nrespectively. Stream codecs can maintain state.\n\n"}, {"name": "codecs.CodecInfo.streamwriter", "path": "library/codecs#codecs.CodecInfo.streamwriter", "type": "Binary Data", "text": "\nStream writer and reader classes or factory functions. These have to provide\nthe interface defined by the base classes `StreamWriter` and `StreamReader`,\nrespectively. Stream codecs can maintain state.\n\n"}, {"name": "codecs.decode()", "path": "library/codecs#codecs.decode", "type": "Binary Data", "text": "\nDecodes obj using the codec registered for encoding.\n\n"}, {"name": "codecs.encode()", "path": "library/codecs#codecs.encode", "type": "Binary Data", "text": "\nEncodes obj using the codec registered for encoding.\n\n"}, {"name": "codecs.EncodedFile()", "path": "library/codecs#codecs.EncodedFile", "type": "Binary Data", "text": "\nReturn a `StreamRecoder` instance, a wrapped version of file which provides\ntransparent transcoding. The original file is closed when the wrapped version\nis closed.\n\n"}, {"name": "codecs.getdecoder()", "path": "library/codecs#codecs.getdecoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its decoder function.\n\n"}, {"name": "codecs.getencoder()", "path": "library/codecs#codecs.getencoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its encoder function.\n\n"}, {"name": "codecs.getincrementaldecoder()", "path": "library/codecs#codecs.getincrementaldecoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its incremental decoder\nclass or factory function.\n\n"}, {"name": "codecs.getincrementalencoder()", "path": "library/codecs#codecs.getincrementalencoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its incremental encoder\nclass or factory function.\n\n"}, {"name": "codecs.getreader()", "path": "library/codecs#codecs.getreader", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its `StreamReader` class\nor factory function.\n\n"}, {"name": "codecs.getwriter()", "path": "library/codecs#codecs.getwriter", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its `StreamWriter` class\nor factory function.\n\n"}, {"name": "codecs.ignore_errors()", "path": "library/codecs#codecs.ignore_errors", "type": "Binary Data", "text": "\nImplements the `'ignore'` error handling: malformed data is ignored and\nencoding or decoding is continued without further notice.\n\n"}, {"name": "codecs.IncrementalDecoder", "path": "library/codecs#codecs.IncrementalDecoder", "type": "Binary Data", "text": "\nConstructor for an `IncrementalDecoder` instance.\n\n"}, {"name": "codecs.IncrementalDecoder.decode()", "path": "library/codecs#codecs.IncrementalDecoder.decode", "type": "Binary Data", "text": "\nDecodes object (taking the current state of the decoder into account) and\nreturns the resulting decoded object. If this is the last call to `decode()`\nfinal must be true (the default is false). If final is true the decoder must\ndecode the input completely and must flush all buffers. If this isn\u2019t possible\n(e.g. because of incomplete byte sequences at the end of the input) it must\ninitiate error handling just like in the stateless case (which might raise an\nexception).\n\n"}, {"name": "codecs.IncrementalDecoder.getstate()", "path": "library/codecs#codecs.IncrementalDecoder.getstate", "type": "Binary Data", "text": "\nReturn the current state of the decoder. This must be a tuple with two items,\nthe first must be the buffer containing the still undecoded input. The second\nmust be an integer and can be additional state info. (The implementation\nshould make sure that `0` is the most common additional state info.) If this\nadditional state info is `0` it must be possible to set the decoder to the\nstate which has no input buffered and `0` as the additional state info, so\nthat feeding the previously buffered input to the decoder returns it to the\nprevious state without producing any output. (Additional state info that is\nmore complicated than integers can be converted into an integer by\nmarshaling/pickling the info and encoding the bytes of the resulting string\ninto an integer.)\n\n"}, {"name": "codecs.IncrementalDecoder.reset()", "path": "library/codecs#codecs.IncrementalDecoder.reset", "type": "Binary Data", "text": "\nReset the decoder to the initial state.\n\n"}, {"name": "codecs.IncrementalDecoder.setstate()", "path": "library/codecs#codecs.IncrementalDecoder.setstate", "type": "Binary Data", "text": "\nSet the state of the decoder to state. state must be a decoder state returned\nby `getstate()`.\n\n"}, {"name": "codecs.IncrementalEncoder", "path": "library/codecs#codecs.IncrementalEncoder", "type": "Binary Data", "text": "\nConstructor for an `IncrementalEncoder` instance.\n\n"}, {"name": "codecs.IncrementalEncoder.encode()", "path": "library/codecs#codecs.IncrementalEncoder.encode", "type": "Binary Data", "text": "\nEncodes object (taking the current state of the encoder into account) and\nreturns the resulting encoded object. If this is the last call to `encode()`\nfinal must be true (the default is false).\n\n"}, {"name": "codecs.IncrementalEncoder.getstate()", "path": "library/codecs#codecs.IncrementalEncoder.getstate", "type": "Binary Data", "text": "\nReturn the current state of the encoder which must be an integer. The\nimplementation should make sure that `0` is the most common state. (States\nthat are more complicated than integers can be converted into an integer by\nmarshaling/pickling the state and encoding the bytes of the resulting string\ninto an integer.)\n\n"}, {"name": "codecs.IncrementalEncoder.reset()", "path": "library/codecs#codecs.IncrementalEncoder.reset", "type": "Binary Data", "text": "\nReset the encoder to the initial state. The output is discarded: call\n`.encode(object, final=True)`, passing an empty byte or text string if\nnecessary, to reset the encoder and to get the output.\n\n"}, {"name": "codecs.IncrementalEncoder.setstate()", "path": "library/codecs#codecs.IncrementalEncoder.setstate", "type": "Binary Data", "text": "\nSet the state of the encoder to state. state must be an encoder state returned\nby `getstate()`.\n\n"}, {"name": "codecs.iterdecode()", "path": "library/codecs#codecs.iterdecode", "type": "Binary Data", "text": "\nUses an incremental decoder to iteratively decode the input provided by\niterator. This function is a generator. The errors argument (as well as any\nother keyword argument) is passed through to the incremental decoder.\n\n"}, {"name": "codecs.iterencode()", "path": "library/codecs#codecs.iterencode", "type": "Binary Data", "text": "\nUses an incremental encoder to iteratively encode the input provided by\niterator. This function is a generator. The errors argument (as well as any\nother keyword argument) is passed through to the incremental encoder.\n\n"}, {"name": "codecs.lookup()", "path": "library/codecs#codecs.lookup", "type": "Binary Data", "text": "\nLooks up the codec info in the Python codec registry and returns a `CodecInfo`\nobject as defined below.\n\n"}, {"name": "codecs.lookup_error()", "path": "library/codecs#codecs.lookup_error", "type": "Binary Data", "text": "\nReturn the error handler previously registered under the name name.\n\n"}, {"name": "codecs.namereplace_errors()", "path": "library/codecs#codecs.namereplace_errors", "type": "Binary Data", "text": "\nImplements the `'namereplace'` error handling (for encoding with text\nencodings only): the unencodable character is replaced by a `\\N{...}` escape\nsequence.\n\n"}, {"name": "codecs.open()", "path": "library/codecs#codecs.open", "type": "Binary Data", "text": "\nOpen an encoded file using the given mode and return an instance of\n`StreamReaderWriter`, providing transparent encoding/decoding. The default\nfile mode is `'r'`, meaning to open the file in read mode.\n\n"}, {"name": "codecs.register()", "path": "library/codecs#codecs.register", "type": "Binary Data", "text": "\nRegister a codec search function. Search functions are expected to take one\nargument, being the encoding name in all lower case letters with hyphens and\nspaces converted to underscores, and return a `CodecInfo` object. In case a\nsearch function cannot find a given encoding, it should return `None`.\n\n"}, {"name": "codecs.register_error()", "path": "library/codecs#codecs.register_error", "type": "Binary Data", "text": "\nRegister the error handling function error_handler under the name name. The\nerror_handler argument will be called during encoding and decoding in case of\nan error, when name is specified as the errors parameter.\n\n"}, {"name": "codecs.replace_errors()", "path": "library/codecs#codecs.replace_errors", "type": "Binary Data", "text": "\nImplements the `'replace'` error handling (for text encodings only):\nsubstitutes `'?'` for encoding errors (to be encoded by the codec), and\n`'\\ufffd'` (the Unicode replacement character) for decoding errors.\n\n"}, {"name": "codecs.StreamReader", "path": "library/codecs#codecs.StreamReader", "type": "Binary Data", "text": "\nConstructor for a `StreamReader` instance.\n\n"}, {"name": "codecs.StreamReader.read()", "path": "library/codecs#codecs.StreamReader.read", "type": "Binary Data", "text": "\nDecodes data from the stream and returns the resulting object.\n\n"}, {"name": "codecs.StreamReader.readline()", "path": "library/codecs#codecs.StreamReader.readline", "type": "Binary Data", "text": "\nRead one line from the input stream and return the decoded data.\n\n"}, {"name": "codecs.StreamReader.readlines()", "path": "library/codecs#codecs.StreamReader.readlines", "type": "Binary Data", "text": "\nRead all lines available on the input stream and return them as a list of\nlines.\n\n"}, {"name": "codecs.StreamReader.reset()", "path": "library/codecs#codecs.StreamReader.reset", "type": "Binary Data", "text": "\nResets the codec buffers used for keeping internal state.\n\n"}, {"name": "codecs.StreamReaderWriter", "path": "library/codecs#codecs.StreamReaderWriter", "type": "Binary Data", "text": "\nCreates a `StreamReaderWriter` instance. stream must be a file-like object.\nReader and Writer must be factory functions or classes providing the\n`StreamReader` and `StreamWriter` interface resp. Error handling is done in\nthe same way as defined for the stream readers and writers.\n\n"}, {"name": "codecs.StreamRecoder", "path": "library/codecs#codecs.StreamRecoder", "type": "Binary Data", "text": "\nCreates a `StreamRecoder` instance which implements a two-way conversion:\nencode and decode work on the frontend \u2014 the data visible to code calling\n`read()` and `write()`, while Reader and Writer work on the backend \u2014 the data\nin stream.\n\n"}, {"name": "codecs.StreamWriter", "path": "library/codecs#codecs.StreamWriter", "type": "Binary Data", "text": "\nConstructor for a `StreamWriter` instance.\n\n"}, {"name": "codecs.StreamWriter.reset()", "path": "library/codecs#codecs.StreamWriter.reset", "type": "Binary Data", "text": "\nResets the codec buffers used for keeping internal state.\n\n"}, {"name": "codecs.StreamWriter.write()", "path": "library/codecs#codecs.StreamWriter.write", "type": "Binary Data", "text": "\nWrites the object\u2019s contents encoded to the stream.\n\n"}, {"name": "codecs.StreamWriter.writelines()", "path": "library/codecs#codecs.StreamWriter.writelines", "type": "Binary Data", "text": "\nWrites the concatenated list of strings to the stream (possibly by reusing the\n`write()` method). The standard bytes-to-bytes codecs do not support this\nmethod.\n\n"}, {"name": "codecs.strict_errors()", "path": "library/codecs#codecs.strict_errors", "type": "Binary Data", "text": "\nImplements the `'strict'` error handling: each encoding or decoding error\nraises a `UnicodeError`.\n\n"}, {"name": "codecs.xmlcharrefreplace_errors()", "path": "library/codecs#codecs.xmlcharrefreplace_errors", "type": "Binary Data", "text": "\nImplements the `'xmlcharrefreplace'` error handling (for encoding with text\nencodings only): the unencodable character is replaced by an appropriate XML\ncharacter reference.\n\n"}, {"name": "codeop", "path": "library/codeop", "type": "Interpreters", "text": "\nSource code: Lib/codeop.py\n\n"}, {"name": "codeop.CommandCompiler", "path": "library/codeop#codeop.CommandCompiler", "type": "Interpreters", "text": "\nInstances of this class have `__call__()` methods identical in signature to\n`compile_command()`; the difference is that if the instance compiles program\ntext containing a `__future__` statement, the instance \u2018remembers\u2019 and\ncompiles all subsequent program texts with the statement in force.\n\n"}, {"name": "codeop.Compile", "path": "library/codeop#codeop.Compile", "type": "Interpreters", "text": "\nInstances of this class have `__call__()` methods identical in signature to\nthe built-in function `compile()`, but with the difference that if the\ninstance compiles program text containing a `__future__` statement, the\ninstance \u2018remembers\u2019 and compiles all subsequent program texts with the\nstatement in force.\n\n"}, {"name": "codeop.compile_command()", "path": "library/codeop#codeop.compile_command", "type": "Interpreters", "text": "\nTries to compile source, which should be a string of Python code and return a\ncode object if source is valid Python code. In that case, the filename\nattribute of the code object will be filename, which defaults to `'<input>'`.\nReturns `None` if source is not valid Python code, but is a prefix of valid\nPython code.\n\n"}, {"name": "collections", "path": "library/collections", "type": "Data Types", "text": "\nSource code: Lib/collections/__init__.py\n\n"}, {"name": "collections.abc", "path": "library/collections.abc", "type": "Data Types", "text": "\nNew in version 3.3: Formerly, this module was part of the `collections`\nmodule.\n\n"}, {"name": "collections.abc.AsyncGenerator", "path": "library/collections.abc#collections.abc.AsyncGenerator", "type": "Data Types", "text": "\nABC for asynchronous generator classes that implement the protocol defined in\nPEP 525 and PEP 492.\n\n"}, {"name": "collections.abc.AsyncIterable", "path": "library/collections.abc#collections.abc.AsyncIterable", "type": "Data Types", "text": "\nABC for classes that provide `__aiter__` method. See also the definition of\nasynchronous iterable.\n\n"}, {"name": "collections.abc.AsyncIterator", "path": "library/collections.abc#collections.abc.AsyncIterator", "type": "Data Types", "text": "\nABC for classes that provide `__aiter__` and `__anext__` methods. See also the\ndefinition of asynchronous iterator.\n\n"}, {"name": "collections.abc.Awaitable", "path": "library/collections.abc#collections.abc.Awaitable", "type": "Data Types", "text": "\nABC for awaitable objects, which can be used in `await` expressions. Custom\nimplementations must provide the `__await__()` method.\n\n"}, {"name": "collections.abc.ByteString", "path": "library/collections.abc#collections.abc.ByteString", "type": "Data Types", "text": "\nABCs for read-only and mutable sequences.\n\n"}, {"name": "collections.abc.Callable", "path": "library/collections.abc#collections.abc.Callable", "type": "Data Types", "text": "\nABC for classes that provide the `__call__()` method.\n\n"}, {"name": "collections.abc.Collection", "path": "library/collections.abc#collections.abc.Collection", "type": "Data Types", "text": "\nABC for sized iterable container classes.\n\n"}, {"name": "collections.abc.Container", "path": "library/collections.abc#collections.abc.Container", "type": "Data Types", "text": "\nABC for classes that provide the `__contains__()` method.\n\n"}, {"name": "collections.abc.Coroutine", "path": "library/collections.abc#collections.abc.Coroutine", "type": "Data Types", "text": "\nABC for coroutine compatible classes. These implement the following methods,\ndefined in Coroutine Objects: `send()`, `throw()`, and `close()`. Custom\nimplementations must also implement `__await__()`. All `Coroutine` instances\nare also instances of `Awaitable`. See also the definition of coroutine.\n\n"}, {"name": "collections.abc.Generator", "path": "library/collections.abc#collections.abc.Generator", "type": "Data Types", "text": "\nABC for generator classes that implement the protocol defined in PEP 342 that\nextends iterators with the `send()`, `throw()` and `close()` methods. See also\nthe definition of generator.\n\n"}, {"name": "collections.abc.Hashable", "path": "library/collections.abc#collections.abc.Hashable", "type": "Data Types", "text": "\nABC for classes that provide the `__hash__()` method.\n\n"}, {"name": "collections.abc.ItemsView", "path": "library/collections.abc#collections.abc.ItemsView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.abc.Iterable", "path": "library/collections.abc#collections.abc.Iterable", "type": "Data Types", "text": "\nABC for classes that provide the `__iter__()` method.\n\n"}, {"name": "collections.abc.Iterator", "path": "library/collections.abc#collections.abc.Iterator", "type": "Data Types", "text": "\nABC for classes that provide the `__iter__()` and `__next__()` methods. See\nalso the definition of iterator.\n\n"}, {"name": "collections.abc.KeysView", "path": "library/collections.abc#collections.abc.KeysView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.abc.Mapping", "path": "library/collections.abc#collections.abc.Mapping", "type": "Data Types", "text": "\nABCs for read-only and mutable mappings.\n\n"}, {"name": "collections.abc.MappingView", "path": "library/collections.abc#collections.abc.MappingView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.abc.MutableMapping", "path": "library/collections.abc#collections.abc.MutableMapping", "type": "Data Types", "text": "\nABCs for read-only and mutable mappings.\n\n"}, {"name": "collections.abc.MutableSequence", "path": "library/collections.abc#collections.abc.MutableSequence", "type": "Data Types", "text": "\nABCs for read-only and mutable sequences.\n\n"}, {"name": "collections.abc.MutableSet", "path": "library/collections.abc#collections.abc.MutableSet", "type": "Data Types", "text": "\nABCs for read-only and mutable sets.\n\n"}, {"name": "collections.abc.Reversible", "path": "library/collections.abc#collections.abc.Reversible", "type": "Data Types", "text": "\nABC for iterable classes that also provide the `__reversed__()` method.\n\n"}, {"name": "collections.abc.Sequence", "path": "library/collections.abc#collections.abc.Sequence", "type": "Data Types", "text": "\nABCs for read-only and mutable sequences.\n\n"}, {"name": "collections.abc.Set", "path": "library/collections.abc#collections.abc.Set", "type": "Data Types", "text": "\nABCs for read-only and mutable sets.\n\n"}, {"name": "collections.abc.Sized", "path": "library/collections.abc#collections.abc.Sized", "type": "Data Types", "text": "\nABC for classes that provide the `__len__()` method.\n\n"}, {"name": "collections.abc.ValuesView", "path": "library/collections.abc#collections.abc.ValuesView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.ChainMap", "path": "library/collections#collections.ChainMap", "type": "Data Types", "text": "\nA `ChainMap` groups multiple dicts or other mappings together to create a\nsingle, updateable view. If no maps are specified, a single empty dictionary\nis provided so that a new chain always has at least one mapping.\n\n"}, {"name": "collections.ChainMap.maps", "path": "library/collections#collections.ChainMap.maps", "type": "Data Types", "text": "\nA user updateable list of mappings. The list is ordered from first-searched to\nlast-searched. It is the only stored state and can be modified to change which\nmappings are searched. The list should always contain at least one mapping.\n\n"}, {"name": "collections.ChainMap.new_child()", "path": "library/collections#collections.ChainMap.new_child", "type": "Data Types", "text": "\nReturns a new `ChainMap` containing a new map followed by all of the maps in\nthe current instance. If `m` is specified, it becomes the new map at the front\nof the list of mappings; if not specified, an empty dict is used, so that a\ncall to `d.new_child()` is equivalent to: `ChainMap({}, *d.maps)`. This method\nis used for creating subcontexts that can be updated without altering values\nin any of the parent mappings.\n\n"}, {"name": "collections.ChainMap.parents", "path": "library/collections#collections.ChainMap.parents", "type": "Data Types", "text": "\nProperty returning a new `ChainMap` containing all of the maps in the current\ninstance except the first one. This is useful for skipping the first map in\nthe search. Use cases are similar to those for the `nonlocal` keyword used in\nnested scopes. The use cases also parallel those for the built-in `super()`\nfunction. A reference to `d.parents` is equivalent to:\n`ChainMap(*d.maps[1:])`.\n\n"}, {"name": "collections.Counter", "path": "library/collections#collections.Counter", "type": "Data Types", "text": "\nA `Counter` is a `dict` subclass for counting hashable objects. It is a\ncollection where elements are stored as dictionary keys and their counts are\nstored as dictionary values. Counts are allowed to be any integer value\nincluding zero or negative counts. The `Counter` class is similar to bags or\nmultisets in other languages.\n\n"}, {"name": "collections.Counter.elements()", "path": "library/collections#collections.Counter.elements", "type": "Data Types", "text": "\nReturn an iterator over elements repeating each as many times as its count.\nElements are returned in the order first encountered. If an element\u2019s count is\nless than one, `elements()` will ignore it.\n\n"}, {"name": "collections.Counter.fromkeys()", "path": "library/collections#collections.Counter.fromkeys", "type": "Data Types", "text": "\nThis class method is not implemented for `Counter` objects.\n\n"}, {"name": "collections.Counter.most_common()", "path": "library/collections#collections.Counter.most_common", "type": "Data Types", "text": "\nReturn a list of the n most common elements and their counts from the most\ncommon to the least. If n is omitted or `None`, `most_common()` returns all\nelements in the counter. Elements with equal counts are ordered in the order\nfirst encountered:\n\n"}, {"name": "collections.Counter.subtract()", "path": "library/collections#collections.Counter.subtract", "type": "Data Types", "text": "\nElements are subtracted from an iterable or from another mapping (or counter).\nLike `dict.update()` but subtracts counts instead of replacing them. Both\ninputs and outputs may be zero or negative.\n\n"}, {"name": "collections.Counter.update()", "path": "library/collections#collections.Counter.update", "type": "Data Types", "text": "\nElements are counted from an iterable or added-in from another mapping (or\ncounter). Like `dict.update()` but adds counts instead of replacing them.\nAlso, the iterable is expected to be a sequence of elements, not a sequence of\n`(key, value)` pairs.\n\n"}, {"name": "collections.defaultdict", "path": "library/collections#collections.defaultdict", "type": "Data Types", "text": "\nReturns a new dictionary-like object. `defaultdict` is a subclass of the\nbuilt-in `dict` class. It overrides one method and adds one writable instance\nvariable. The remaining functionality is the same as for the `dict` class and\nis not documented here.\n\n"}, {"name": "collections.defaultdict.default_factory", "path": "library/collections#collections.defaultdict.default_factory", "type": "Data Types", "text": "\nThis attribute is used by the `__missing__()` method; it is initialized from\nthe first argument to the constructor, if present, or to `None`, if absent.\n\n"}, {"name": "collections.defaultdict.__missing__()", "path": "library/collections#collections.defaultdict.__missing__", "type": "Data Types", "text": "\nIf the `default_factory` attribute is `None`, this raises a `KeyError`\nexception with the key as argument.\n\n"}, {"name": "collections.deque", "path": "library/collections#collections.deque", "type": "Data Types", "text": "\nReturns a new deque object initialized left-to-right (using `append()`) with\ndata from iterable. If iterable is not specified, the new deque is empty.\n\n"}, {"name": "collections.deque.append()", "path": "library/collections#collections.deque.append", "type": "Data Types", "text": "\nAdd x to the right side of the deque.\n\n"}, {"name": "collections.deque.appendleft()", "path": "library/collections#collections.deque.appendleft", "type": "Data Types", "text": "\nAdd x to the left side of the deque.\n\n"}, {"name": "collections.deque.clear()", "path": "library/collections#collections.deque.clear", "type": "Data Types", "text": "\nRemove all elements from the deque leaving it with length 0.\n\n"}, {"name": "collections.deque.copy()", "path": "library/collections#collections.deque.copy", "type": "Data Types", "text": "\nCreate a shallow copy of the deque.\n\n"}, {"name": "collections.deque.count()", "path": "library/collections#collections.deque.count", "type": "Data Types", "text": "\nCount the number of deque elements equal to x.\n\n"}, {"name": "collections.deque.extend()", "path": "library/collections#collections.deque.extend", "type": "Data Types", "text": "\nExtend the right side of the deque by appending elements from the iterable\nargument.\n\n"}, {"name": "collections.deque.extendleft()", "path": "library/collections#collections.deque.extendleft", "type": "Data Types", "text": "\nExtend the left side of the deque by appending elements from iterable. Note,\nthe series of left appends results in reversing the order of elements in the\niterable argument.\n\n"}, {"name": "collections.deque.index()", "path": "library/collections#collections.deque.index", "type": "Data Types", "text": "\nReturn the position of x in the deque (at or after index start and before\nindex stop). Returns the first match or raises `ValueError` if not found.\n\n"}, {"name": "collections.deque.insert()", "path": "library/collections#collections.deque.insert", "type": "Data Types", "text": "\nInsert x into the deque at position i.\n\n"}, {"name": "collections.deque.maxlen", "path": "library/collections#collections.deque.maxlen", "type": "Data Types", "text": "\nMaximum size of a deque or `None` if unbounded.\n\n"}, {"name": "collections.deque.pop()", "path": "library/collections#collections.deque.pop", "type": "Data Types", "text": "\nRemove and return an element from the right side of the deque. If no elements\nare present, raises an `IndexError`.\n\n"}, {"name": "collections.deque.popleft()", "path": "library/collections#collections.deque.popleft", "type": "Data Types", "text": "\nRemove and return an element from the left side of the deque. If no elements\nare present, raises an `IndexError`.\n\n"}, {"name": "collections.deque.remove()", "path": "library/collections#collections.deque.remove", "type": "Data Types", "text": "\nRemove the first occurrence of value. If not found, raises a `ValueError`.\n\n"}, {"name": "collections.deque.reverse()", "path": "library/collections#collections.deque.reverse", "type": "Data Types", "text": "\nReverse the elements of the deque in-place and then return `None`.\n\n"}, {"name": "collections.deque.rotate()", "path": "library/collections#collections.deque.rotate", "type": "Data Types", "text": "\nRotate the deque n steps to the right. If n is negative, rotate to the left.\n\n"}, {"name": "collections.namedtuple()", "path": "library/collections#collections.namedtuple", "type": "Data Types", "text": "\nReturns a new tuple subclass named typename. The new subclass is used to\ncreate tuple-like objects that have fields accessible by attribute lookup as\nwell as being indexable and iterable. Instances of the subclass also have a\nhelpful docstring (with typename and field_names) and a helpful `__repr__()`\nmethod which lists the tuple contents in a `name=value` format.\n\n"}, {"name": "collections.OrderedDict", "path": "library/collections#collections.OrderedDict", "type": "Data Types", "text": "\nReturn an instance of a `dict` subclass that has methods specialized for\nrearranging dictionary order.\n\n"}, {"name": "collections.OrderedDict.move_to_end()", "path": "library/collections#collections.OrderedDict.move_to_end", "type": "Data Types", "text": "\nMove an existing key to either end of an ordered dictionary. The item is moved\nto the right end if last is true (the default) or to the beginning if last is\nfalse. Raises `KeyError` if the key does not exist:\n\n"}, {"name": "collections.OrderedDict.popitem()", "path": "library/collections#collections.OrderedDict.popitem", "type": "Data Types", "text": "\nThe `popitem()` method for ordered dictionaries returns and removes a (key,\nvalue) pair. The pairs are returned in LIFO order if last is true or FIFO\norder if false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._asdict()", "path": "library/collections#collections.somenamedtuple._asdict", "type": "Data Types", "text": "\nReturn a new `dict` which maps field names to their corresponding values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._fields", "path": "library/collections#collections.somenamedtuple._fields", "type": "Data Types", "text": "\nTuple of strings listing the field names. Useful for introspection and for\ncreating new named tuple types from existing named tuples.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._field_defaults", "path": "library/collections#collections.somenamedtuple._field_defaults", "type": "Data Types", "text": "\nDictionary mapping field names to default values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._make()", "path": "library/collections#collections.somenamedtuple._make", "type": "Data Types", "text": "\nClass method that makes a new instance from an existing sequence or iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._replace()", "path": "library/collections#collections.somenamedtuple._replace", "type": "Data Types", "text": "\nReturn a new instance of the named tuple replacing specified fields with new\nvalues:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserDict", "path": "library/collections#collections.UserDict", "type": "Data Types", "text": "\nClass that simulates a dictionary. The instance\u2019s contents are kept in a\nregular dictionary, which is accessible via the `data` attribute of `UserDict`\ninstances. If initialdata is provided, `data` is initialized with its\ncontents; note that a reference to initialdata will not be kept, allowing it\nbe used for other purposes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserDict.data", "path": "library/collections#collections.UserDict.data", "type": "Data Types", "text": "\nA real dictionary used to store the contents of the `UserDict` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserList", "path": "library/collections#collections.UserList", "type": "Data Types", "text": "\nClass that simulates a list. The instance\u2019s contents are kept in a regular\nlist, which is accessible via the `data` attribute of `UserList` instances.\nThe instance\u2019s contents are initially set to a copy of list, defaulting to the\nempty list `[]`. list can be any iterable, for example a real Python list or a\n`UserList` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserList.data", "path": "library/collections#collections.UserList.data", "type": "Data Types", "text": "\nA real `list` object used to store the contents of the `UserList` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserString", "path": "library/collections#collections.UserString", "type": "Data Types", "text": "\nClass that simulates a string object. The instance\u2019s content is kept in a\nregular string object, which is accessible via the `data` attribute of\n`UserString` instances. The instance\u2019s contents are initially set to a copy of\nseq. The seq argument can be any object which can be converted into a string\nusing the built-in `str()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserString.data", "path": "library/collections#collections.UserString.data", "type": "Data Types", "text": "\nA real `str` object used to store the contents of the `UserString` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys", "path": "library/colorsys", "type": "Multimedia", "text": "\nSource code: Lib/colorsys.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.hls_to_rgb()", "path": "library/colorsys#colorsys.hls_to_rgb", "type": "Multimedia", "text": "\nConvert the color from HLS coordinates to RGB coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.hsv_to_rgb()", "path": "library/colorsys#colorsys.hsv_to_rgb", "type": "Multimedia", "text": "\nConvert the color from HSV coordinates to RGB coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.rgb_to_hls()", "path": "library/colorsys#colorsys.rgb_to_hls", "type": "Multimedia", "text": "\nConvert the color from RGB coordinates to HLS coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.rgb_to_hsv()", "path": "library/colorsys#colorsys.rgb_to_hsv", "type": "Multimedia", "text": "\nConvert the color from RGB coordinates to HSV coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.rgb_to_yiq()", "path": "library/colorsys#colorsys.rgb_to_yiq", "type": "Multimedia", "text": "\nConvert the color from RGB coordinates to YIQ coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.yiq_to_rgb()", "path": "library/colorsys#colorsys.yiq_to_rgb", "type": "Multimedia", "text": "\nConvert the color from YIQ coordinates to RGB coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compile()", "path": "library/functions#compile", "type": "Built-in Functions", "text": "\nCompile the source into a code or AST object. Code objects can be executed by\n`exec()` or `eval()`. source can either be a normal string, a byte string, or\nan AST object. Refer to the `ast` module documentation for information on how\nto work with AST objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall", "path": "library/compileall", "type": "Language", "text": "\nSource code: Lib/compileall.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall.compile_dir()", "path": "library/compileall#compileall.compile_dir", "type": "Language", "text": "\nRecursively descend the directory tree named by dir, compiling all `.py` files\nalong the way. Return a true value if all the files compiled successfully, and\na false value otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall.compile_file()", "path": "library/compileall#compileall.compile_file", "type": "Language", "text": "\nCompile the file with path fullname. Return a true value if the file compiled\nsuccessfully, and a false value otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall.compile_path()", "path": "library/compileall#compileall.compile_path", "type": "Language", "text": "\nByte-compile all the `.py` files found along `sys.path`. Return a true value\nif all the files compiled successfully, and a false value otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "complex", "path": "library/functions#complex", "type": "Built-in Functions", "text": "\nReturn a complex number with the value real \\+ imag*1j or convert a string or\nnumber to a complex number. If the first parameter is a string, it will be\ninterpreted as a complex number and the function must be called without a\nsecond parameter. The second parameter can never be a string. Each argument\nmay be any numeric type (including complex). If imag is omitted, it defaults\nto zero and the constructor serves as a numeric conversion like `int` and\n`float`. If both arguments are omitted, returns `0j`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures", "path": "library/concurrent.futures", "type": "Concurrent Execution", "text": "\nNew in version 3.2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.as_completed()", "path": "library/concurrent.futures#concurrent.futures.as_completed", "type": "Concurrent Execution", "text": "\nReturns an iterator over the `Future` instances (possibly created by different\n`Executor` instances) given by fs that yields futures as they complete\n(finished or cancelled futures). Any futures given by fs that are duplicated\nwill be returned once. Any futures that completed before `as_completed()` is\ncalled will be yielded first. The returned iterator raises a\n`concurrent.futures.TimeoutError` if `__next__()` is called and the result\nisn\u2019t available after timeout seconds from the original call to\n`as_completed()`. timeout can be an int or float. If timeout is not specified\nor `None`, there is no limit to the wait time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.BrokenExecutor", "path": "library/concurrent.futures#concurrent.futures.BrokenExecutor", "type": "Concurrent Execution", "text": "\nDerived from `RuntimeError`, this exception class is raised when an executor\nis broken for some reason, and cannot be used to submit or execute new tasks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.CancelledError", "path": "library/concurrent.futures#concurrent.futures.CancelledError", "type": "Concurrent Execution", "text": "\nRaised when a future is cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor", "path": "library/concurrent.futures#concurrent.futures.Executor", "type": "Concurrent Execution", "text": "\nAn abstract class that provides methods to execute calls asynchronously. It\nshould not be used directly, but through its concrete subclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor.map()", "path": "library/concurrent.futures#concurrent.futures.Executor.map", "type": "Concurrent Execution", "text": "\nSimilar to `map(func, *iterables)` except:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor.shutdown()", "path": "library/concurrent.futures#concurrent.futures.Executor.shutdown", "type": "Concurrent Execution", "text": "\nSignal the executor that it should free any resources that it is using when\nthe currently pending futures are done executing. Calls to `Executor.submit()`\nand `Executor.map()` made after shutdown will raise `RuntimeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor.submit()", "path": "library/concurrent.futures#concurrent.futures.Executor.submit", "type": "Concurrent Execution", "text": "\nSchedules the callable, fn, to be executed as `fn(*args **kwargs)` and returns\na `Future` object representing the execution of the callable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future", "path": "library/concurrent.futures#concurrent.futures.Future", "type": "Concurrent Execution", "text": "\nEncapsulates the asynchronous execution of a callable. `Future` instances are\ncreated by `Executor.submit()` and should not be created directly except for\ntesting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.add_done_callback()", "path": "library/concurrent.futures#concurrent.futures.Future.add_done_callback", "type": "Concurrent Execution", "text": "\nAttaches the callable fn to the future. fn will be called, with the future as\nits only argument, when the future is cancelled or finishes running.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.cancel()", "path": "library/concurrent.futures#concurrent.futures.Future.cancel", "type": "Concurrent Execution", "text": "\nAttempt to cancel the call. If the call is currently being executed or\nfinished running and cannot be cancelled then the method will return `False`,\notherwise the call will be cancelled and the method will return `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.cancelled()", "path": "library/concurrent.futures#concurrent.futures.Future.cancelled", "type": "Concurrent Execution", "text": "\nReturn `True` if the call was successfully cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.done()", "path": "library/concurrent.futures#concurrent.futures.Future.done", "type": "Concurrent Execution", "text": "\nReturn `True` if the call was successfully cancelled or finished running.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.exception()", "path": "library/concurrent.futures#concurrent.futures.Future.exception", "type": "Concurrent Execution", "text": "\nReturn the exception raised by the call. If the call hasn\u2019t yet completed then\nthis method will wait up to timeout seconds. If the call hasn\u2019t completed in\ntimeout seconds, then a `concurrent.futures.TimeoutError` will be raised.\ntimeout can be an int or float. If timeout is not specified or `None`, there\nis no limit to the wait time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.result()", "path": "library/concurrent.futures#concurrent.futures.Future.result", "type": "Concurrent Execution", "text": "\nReturn the value returned by the call. If the call hasn\u2019t yet completed then\nthis method will wait up to timeout seconds. If the call hasn\u2019t completed in\ntimeout seconds, then a `concurrent.futures.TimeoutError` will be raised.\ntimeout can be an int or float. If timeout is not specified or `None`, there\nis no limit to the wait time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.running()", "path": "library/concurrent.futures#concurrent.futures.Future.running", "type": "Concurrent Execution", "text": "\nReturn `True` if the call is currently being executed and cannot be cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.set_exception()", "path": "library/concurrent.futures#concurrent.futures.Future.set_exception", "type": "Concurrent Execution", "text": "\nSets the result of the work associated with the `Future` to the `Exception`\nexception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.set_result()", "path": "library/concurrent.futures#concurrent.futures.Future.set_result", "type": "Concurrent Execution", "text": "\nSets the result of the work associated with the `Future` to result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.set_running_or_notify_cancel()", "path": "library/concurrent.futures#concurrent.futures.Future.set_running_or_notify_cancel", "type": "Concurrent Execution", "text": "\nThis method should only be called by `Executor` implementations before\nexecuting the work associated with the `Future` and by unit tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.InvalidStateError", "path": "library/concurrent.futures#concurrent.futures.InvalidStateError", "type": "Concurrent Execution", "text": "\nRaised when an operation is performed on a future that is not allowed in the\ncurrent state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.process.BrokenProcessPool", "path": "library/concurrent.futures#concurrent.futures.process.BrokenProcessPool", "type": "Concurrent Execution", "text": "\nDerived from `BrokenExecutor` (formerly `RuntimeError`), this exception class\nis raised when one of the workers of a `ProcessPoolExecutor` has terminated in\na non-clean fashion (for example, if it was killed from the outside).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.ProcessPoolExecutor", "path": "library/concurrent.futures#concurrent.futures.ProcessPoolExecutor", "type": "Concurrent Execution", "text": "\nAn `Executor` subclass that executes calls asynchronously using a pool of at\nmost max_workers processes. If max_workers is `None` or not given, it will\ndefault to the number of processors on the machine. If max_workers is less\nthan or equal to `0`, then a `ValueError` will be raised. On Windows,\nmax_workers must be less than or equal to `61`. If it is not then `ValueError`\nwill be raised. If max_workers is `None`, then the default chosen will be at\nmost `61`, even if more processors are available. mp_context can be a\nmultiprocessing context or None. It will be used to launch the workers. If\nmp_context is `None` or not given, the default multiprocessing context is\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.thread.BrokenThreadPool", "path": "library/concurrent.futures#concurrent.futures.thread.BrokenThreadPool", "type": "Concurrent Execution", "text": "\nDerived from `BrokenExecutor`, this exception class is raised when one of the\nworkers of a `ThreadPoolExecutor` has failed initializing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.ThreadPoolExecutor", "path": "library/concurrent.futures#concurrent.futures.ThreadPoolExecutor", "type": "Concurrent Execution", "text": "\nAn `Executor` subclass that uses a pool of at most max_workers threads to\nexecute calls asynchronously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.TimeoutError", "path": "library/concurrent.futures#concurrent.futures.TimeoutError", "type": "Concurrent Execution", "text": "\nRaised when a future operation exceeds the given timeout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.wait()", "path": "library/concurrent.futures#concurrent.futures.wait", "type": "Concurrent Execution", "text": "\nWait for the `Future` instances (possibly created by different `Executor`\ninstances) given by fs to complete. Returns a named 2-tuple of sets. The first\nset, named `done`, contains the futures that completed (finished or cancelled\nfutures) before the wait completed. The second set, named `not_done`, contains\nthe futures that did not complete (pending or running futures).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser", "path": "library/configparser", "type": "File Formats", "text": "\nSource code: Lib/configparser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.BasicInterpolation", "path": "library/configparser#configparser.BasicInterpolation", "type": "File Formats", "text": "\nThe default implementation used by `ConfigParser`. It enables values to\ncontain format strings which refer to other values in the same section, or\nvalues in the special default section 1. Additional default values can be\nprovided on initialization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser", "path": "library/configparser#configparser.ConfigParser", "type": "File Formats", "text": "\nThe main configuration parser. When defaults is given, it is initialized into\nthe dictionary of intrinsic defaults. When dict_type is given, it will be used\nto create the dictionary objects for the list of sections, for the options\nwithin a section, and for the default values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.add_section()", "path": "library/configparser#configparser.ConfigParser.add_section", "type": "File Formats", "text": "\nAdd a section named section to the instance. If a section by the given name\nalready exists, `DuplicateSectionError` is raised. If the default section name\nis passed, `ValueError` is raised. The name of the section must be a string;\nif not, `TypeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.BOOLEAN_STATES", "path": "library/configparser#configparser.ConfigParser.BOOLEAN_STATES", "type": "File Formats", "text": "\nBy default when using `getboolean()`, config parsers consider the following\nvalues `True`: `'1'`, `'yes'`, `'true'`, `'on'` and the following values\n`False`: `'0'`, `'no'`, `'false'`, `'off'`. You can override this by\nspecifying a custom dictionary of strings and their Boolean outcomes. For\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.defaults()", "path": "library/configparser#configparser.ConfigParser.defaults", "type": "File Formats", "text": "\nReturn a dictionary containing the instance-wide defaults.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.get()", "path": "library/configparser#configparser.ConfigParser.get", "type": "File Formats", "text": "\nGet an option value for the named section. If vars is provided, it must be a\ndictionary. The option is looked up in vars (if provided), section, and in\nDEFAULTSECT in that order. If the key is not found and fallback is provided,\nit is used as a fallback value. `None` can be provided as a fallback value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.getboolean()", "path": "library/configparser#configparser.ConfigParser.getboolean", "type": "File Formats", "text": "\nA convenience method which coerces the option in the specified section to a\nBoolean value. Note that the accepted values for the option are `'1'`,\n`'yes'`, `'true'`, and `'on'`, which cause this method to return `True`, and\n`'0'`, `'no'`, `'false'`, and `'off'`, which cause it to return `False`. These\nstring values are checked in a case-insensitive manner. Any other value will\ncause it to raise `ValueError`. See `get()` for explanation of raw, vars and\nfallback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.getfloat()", "path": "library/configparser#configparser.ConfigParser.getfloat", "type": "File Formats", "text": "\nA convenience method which coerces the option in the specified section to a\nfloating point number. See `get()` for explanation of raw, vars and fallback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.getint()", "path": "library/configparser#configparser.ConfigParser.getint", "type": "File Formats", "text": "\nA convenience method which coerces the option in the specified section to an\ninteger. See `get()` for explanation of raw, vars and fallback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.has_option()", "path": "library/configparser#configparser.ConfigParser.has_option", "type": "File Formats", "text": "\nIf the given section exists, and contains the given option, return `True`;\notherwise return `False`. If the specified section is `None` or an empty\nstring, DEFAULT is assumed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.has_section()", "path": "library/configparser#configparser.ConfigParser.has_section", "type": "File Formats", "text": "\nIndicates whether the named section is present in the configuration. The\ndefault section is not acknowledged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.items()", "path": "library/configparser#configparser.ConfigParser.items", "type": "File Formats", "text": "\nWhen section is not given, return a list of section_name, section_proxy pairs,\nincluding DEFAULTSECT.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.options()", "path": "library/configparser#configparser.ConfigParser.options", "type": "File Formats", "text": "\nReturn a list of options available in the specified section.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.optionxform()", "path": "library/configparser#configparser.ConfigParser.optionxform", "type": "File Formats", "text": "\nTransforms the option name option as found in an input file or as passed in by\nclient code to the form that should be used in the internal structures. The\ndefault implementation returns a lower-case version of option; subclasses may\noverride this or client code can set an attribute of this name on instances to\naffect this behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read()", "path": "library/configparser#configparser.ConfigParser.read", "type": "File Formats", "text": "\nAttempt to read and parse an iterable of filenames, returning a list of\nfilenames which were successfully parsed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.readfp()", "path": "library/configparser#configparser.ConfigParser.readfp", "type": "File Formats", "text": "\nDeprecated since version 3.2: Use `read_file()` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read_dict()", "path": "library/configparser#configparser.ConfigParser.read_dict", "type": "File Formats", "text": "\nLoad configuration from any object that provides a dict-like `items()` method.\nKeys are section names, values are dictionaries with keys and values that\nshould be present in the section. If the used dictionary type preserves order,\nsections and their keys will be added in order. Values are automatically\nconverted to strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read_file()", "path": "library/configparser#configparser.ConfigParser.read_file", "type": "File Formats", "text": "\nRead and parse configuration data from f which must be an iterable yielding\nUnicode strings (for example files opened in text mode).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read_string()", "path": "library/configparser#configparser.ConfigParser.read_string", "type": "File Formats", "text": "\nParse configuration data from a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.remove_option()", "path": "library/configparser#configparser.ConfigParser.remove_option", "type": "File Formats", "text": "\nRemove the specified option from the specified section. If the section does\nnot exist, raise `NoSectionError`. If the option existed to be removed, return\n`True`; otherwise return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.remove_section()", "path": "library/configparser#configparser.ConfigParser.remove_section", "type": "File Formats", "text": "\nRemove the specified section from the configuration. If the section in fact\nexisted, return `True`. Otherwise return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.SECTCRE", "path": "library/configparser#configparser.ConfigParser.SECTCRE", "type": "File Formats", "text": "\nA compiled regular expression used to parse section headers. The default\nmatches `[section]` to the name `\"section\"`. Whitespace is considered part of\nthe section name, thus `[ larch ]` will be read as a section of name `\" larch\n\"`. Override this attribute if that\u2019s unsuitable. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.sections()", "path": "library/configparser#configparser.ConfigParser.sections", "type": "File Formats", "text": "\nReturn a list of the sections available; the default section is not included\nin the list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.set()", "path": "library/configparser#configparser.ConfigParser.set", "type": "File Formats", "text": "\nIf the given section exists, set the given option to the specified value;\notherwise raise `NoSectionError`. option and value must be strings; if not,\n`TypeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.write()", "path": "library/configparser#configparser.ConfigParser.write", "type": "File Formats", "text": "\nWrite a representation of the configuration to the specified file object,\nwhich must be opened in text mode (accepting strings). This representation can\nbe parsed by a future `read()` call. If space_around_delimiters is true,\ndelimiters between keys and values are surrounded by spaces.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.DuplicateOptionError", "path": "library/configparser#configparser.DuplicateOptionError", "type": "File Formats", "text": "\nException raised by strict parsers if a single option appears twice during\nreading from a single file, string or dictionary. This catches misspellings\nand case sensitivity-related errors, e.g. a dictionary may have two keys\nrepresenting the same case-insensitive configuration key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.DuplicateSectionError", "path": "library/configparser#configparser.DuplicateSectionError", "type": "File Formats", "text": "\nException raised if `add_section()` is called with the name of a section that\nis already present or in strict parsers when a section if found more than once\nin a single input file, string or dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.Error", "path": "library/configparser#configparser.Error", "type": "File Formats", "text": "\nBase class for all other `configparser` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ExtendedInterpolation", "path": "library/configparser#configparser.ExtendedInterpolation", "type": "File Formats", "text": "\nAn alternative handler for interpolation which implements a more advanced\nsyntax, used for instance in `zc.buildout`. Extended interpolation is using\n`${section:option}` to denote a value from a foreign section. Interpolation\ncan span multiple levels. For convenience, if the `section:` part is omitted,\ninterpolation defaults to the current section (and possibly the default values\nfrom the special section).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationDepthError", "path": "library/configparser#configparser.InterpolationDepthError", "type": "File Formats", "text": "\nException raised when string interpolation cannot be completed because the\nnumber of iterations exceeds `MAX_INTERPOLATION_DEPTH`. Subclass of\n`InterpolationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationError", "path": "library/configparser#configparser.InterpolationError", "type": "File Formats", "text": "\nBase class for exceptions raised when problems occur performing string\ninterpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationMissingOptionError", "path": "library/configparser#configparser.InterpolationMissingOptionError", "type": "File Formats", "text": "\nException raised when an option referenced from a value does not exist.\nSubclass of `InterpolationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationSyntaxError", "path": "library/configparser#configparser.InterpolationSyntaxError", "type": "File Formats", "text": "\nException raised when the source text into which substitutions are made does\nnot conform to the required syntax. Subclass of `InterpolationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.MAX_INTERPOLATION_DEPTH", "path": "library/configparser#configparser.MAX_INTERPOLATION_DEPTH", "type": "File Formats", "text": "\nThe maximum depth for recursive interpolation for `get()` when the raw\nparameter is false. This is relevant only when the default interpolation is\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.MissingSectionHeaderError", "path": "library/configparser#configparser.MissingSectionHeaderError", "type": "File Formats", "text": "\nException raised when attempting to parse a file which has no section headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.NoOptionError", "path": "library/configparser#configparser.NoOptionError", "type": "File Formats", "text": "\nException raised when a specified option is not found in the specified\nsection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.NoSectionError", "path": "library/configparser#configparser.NoSectionError", "type": "File Formats", "text": "\nException raised when a specified section is not found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ParsingError", "path": "library/configparser#configparser.ParsingError", "type": "File Formats", "text": "\nException raised when errors occur attempting to parse a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.RawConfigParser", "path": "library/configparser#configparser.RawConfigParser", "type": "File Formats", "text": "\nLegacy variant of the `ConfigParser`. It has interpolation disabled by default\nand allows for non-string section names, option names, and values via its\nunsafe `add_section` and `set` methods, as well as the legacy `defaults=`\nkeyword argument handling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.RawConfigParser.add_section()", "path": "library/configparser#configparser.RawConfigParser.add_section", "type": "File Formats", "text": "\nAdd a section named section to the instance. If a section by the given name\nalready exists, `DuplicateSectionError` is raised. If the default section name\nis passed, `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.RawConfigParser.set()", "path": "library/configparser#configparser.RawConfigParser.set", "type": "File Formats", "text": "\nIf the given section exists, set the given option to the specified value;\notherwise raise `NoSectionError`. While it is possible to use\n`RawConfigParser` (or `ConfigParser` with raw parameters set to true) for\ninternal storage of non-string values, full functionality (including\ninterpolation and output to files) can only be achieved using string values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionAbortedError", "path": "library/exceptions#ConnectionAbortedError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when a connection attempt is aborted\nby the peer. Corresponds to `errno` `ECONNABORTED`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionError", "path": "library/exceptions#ConnectionError", "type": "Built-in Exceptions", "text": "\nA base class for connection-related issues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionRefusedError", "path": "library/exceptions#ConnectionRefusedError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when a connection attempt is refused\nby the peer. Corresponds to `errno` `ECONNREFUSED`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionResetError", "path": "library/exceptions#ConnectionResetError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when a connection is reset by the\npeer. Corresponds to `errno` `ECONNRESET`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Constants", "path": "library/constants", "type": "Built-in Constants", "text": "\nA small number of constants live in the built-in namespace. They are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "container.__iter__()", "path": "library/stdtypes#container.__iter__", "type": "Built-in Types", "text": "\nReturn an iterator object. The object is required to support the iterator\nprotocol described below. If a container supports different types of\niteration, additional methods can be provided to specifically request\niterators for those iteration types. (An example of an object supporting\nmultiple forms of iteration would be a tree structure which supports both\nbreadth-first and depth-first traversal.) This method corresponds to the\n`tp_iter` slot of the type structure for Python objects in the Python/C API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib", "path": "library/contextlib", "type": "Runtime", "text": "\nSource code: Lib/contextlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AbstractAsyncContextManager", "path": "library/contextlib#contextlib.AbstractAsyncContextManager", "type": "Runtime", "text": "\nAn abstract base class for classes that implement `object.__aenter__()` and\n`object.__aexit__()`. A default implementation for `object.__aenter__()` is\nprovided which returns `self` while `object.__aexit__()` is an abstract method\nwhich by default returns `None`. See also the definition of Asynchronous\nContext Managers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AbstractContextManager", "path": "library/contextlib#contextlib.AbstractContextManager", "type": "Runtime", "text": "\nAn abstract base class for classes that implement `object.__enter__()` and\n`object.__exit__()`. A default implementation for `object.__enter__()` is\nprovided which returns `self` while `object.__exit__()` is an abstract method\nwhich by default returns `None`. See also the definition of Context Manager\nTypes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.asynccontextmanager()", "path": "library/contextlib#contextlib.asynccontextmanager", "type": "Runtime", "text": "\nSimilar to `contextmanager()`, but creates an asynchronous context manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack", "path": "library/contextlib#contextlib.AsyncExitStack", "type": "Runtime", "text": "\nAn asynchronous context manager, similar to `ExitStack`, that supports\ncombining both synchronous and asynchronous context managers, as well as\nhaving coroutines for cleanup logic.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.aclose()", "path": "library/contextlib#contextlib.AsyncExitStack.aclose", "type": "Runtime", "text": "\nSimilar to `close()` but properly handles awaitables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.enter_async_context()", "path": "library/contextlib#contextlib.AsyncExitStack.enter_async_context", "type": "Runtime", "text": "\nSimilar to `enter_context()` but expects an asynchronous context manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.push_async_callback()", "path": "library/contextlib#contextlib.AsyncExitStack.push_async_callback", "type": "Runtime", "text": "\nSimilar to `callback()` but expects a coroutine function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.push_async_exit()", "path": "library/contextlib#contextlib.AsyncExitStack.push_async_exit", "type": "Runtime", "text": "\nSimilar to `push()` but expects either an asynchronous context manager or a\ncoroutine function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.closing()", "path": "library/contextlib#contextlib.closing", "type": "Runtime", "text": "\nReturn a context manager that closes thing upon completion of the block. This\nis basically equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ContextDecorator", "path": "library/contextlib#contextlib.ContextDecorator", "type": "Runtime", "text": "\nA base class that enables a context manager to also be used as a decorator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.contextmanager()", "path": "library/contextlib#contextlib.contextmanager", "type": "Runtime", "text": "\nThis function is a decorator that can be used to define a factory function for\n`with` statement context managers, without needing to create a class or\nseparate `__enter__()` and `__exit__()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack", "path": "library/contextlib#contextlib.ExitStack", "type": "Runtime", "text": "\nA context manager that is designed to make it easy to programmatically combine\nother context managers and cleanup functions, especially those that are\noptional or otherwise driven by input data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.callback()", "path": "library/contextlib#contextlib.ExitStack.callback", "type": "Runtime", "text": "\nAccepts an arbitrary callback function and arguments and adds it to the\ncallback stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.close()", "path": "library/contextlib#contextlib.ExitStack.close", "type": "Runtime", "text": "\nImmediately unwinds the callback stack, invoking callbacks in the reverse\norder of registration. For any context managers and exit callbacks registered,\nthe arguments passed in will indicate that no exception occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.enter_context()", "path": "library/contextlib#contextlib.ExitStack.enter_context", "type": "Runtime", "text": "\nEnters a new context manager and adds its `__exit__()` method to the callback\nstack. The return value is the result of the context manager\u2019s own\n`__enter__()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.pop_all()", "path": "library/contextlib#contextlib.ExitStack.pop_all", "type": "Runtime", "text": "\nTransfers the callback stack to a fresh `ExitStack` instance and returns it.\nNo callbacks are invoked by this operation - instead, they will now be invoked\nwhen the new stack is closed (either explicitly or implicitly at the end of a\n`with` statement).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.push()", "path": "library/contextlib#contextlib.ExitStack.push", "type": "Runtime", "text": "\nAdds a context manager\u2019s `__exit__()` method to the callback stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.nullcontext()", "path": "library/contextlib#contextlib.nullcontext", "type": "Runtime", "text": "\nReturn a context manager that returns enter_result from `__enter__`, but\notherwise does nothing. It is intended to be used as a stand-in for an\noptional context manager, for example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.redirect_stderr()", "path": "library/contextlib#contextlib.redirect_stderr", "type": "Runtime", "text": "\nSimilar to `redirect_stdout()` but redirecting `sys.stderr` to another file or\nfile-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.redirect_stdout()", "path": "library/contextlib#contextlib.redirect_stdout", "type": "Runtime", "text": "\nContext manager for temporarily redirecting `sys.stdout` to another file or\nfile-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.suppress()", "path": "library/contextlib#contextlib.suppress", "type": "Runtime", "text": "\nReturn a context manager that suppresses any of the specified exceptions if\nthey occur in the body of a with statement and then resumes execution with the\nfirst statement following the end of the with statement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextmanager.__enter__()", "path": "library/stdtypes#contextmanager.__enter__", "type": "Built-in Types", "text": "\nEnter the runtime context and return either this object or another object\nrelated to the runtime context. The value returned by this method is bound to\nthe identifier in the `as` clause of `with` statements using this context\nmanager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextmanager.__exit__()", "path": "library/stdtypes#contextmanager.__exit__", "type": "Built-in Types", "text": "\nExit the runtime context and return a Boolean flag indicating if any exception\nthat occurred should be suppressed. If an exception occurred while executing\nthe body of the `with` statement, the arguments contain the exception type,\nvalue and traceback information. Otherwise, all three arguments are `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars", "path": "library/contextvars", "type": "Concurrent Execution", "text": "\nThis module provides APIs to manage, store, and access context-local state.\nThe `ContextVar` class is used to declare and work with Context Variables. The\n`copy_context()` function and the `Context` class should be used to manage the\ncurrent context in asynchronous frameworks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context", "path": "library/contextvars#contextvars.Context", "type": "Concurrent Execution", "text": "\nA mapping of `ContextVars` to their values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.copy()", "path": "library/contextvars#contextvars.Context.copy", "type": "Concurrent Execution", "text": "\nReturn a shallow copy of the context object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.get()", "path": "library/contextvars#contextvars.Context.get", "type": "Concurrent Execution", "text": "\nReturn the value for var if var has the value in the context object. Return\ndefault otherwise. If default is not given, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.items()", "path": "library/contextvars#contextvars.Context.items", "type": "Concurrent Execution", "text": "\nReturn a list of 2-tuples containing all variables and their values in the\ncontext object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.keys()", "path": "library/contextvars#contextvars.Context.keys", "type": "Concurrent Execution", "text": "\nReturn a list of all variables in the context object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.run()", "path": "library/contextvars#contextvars.Context.run", "type": "Concurrent Execution", "text": "\nExecute `callable(*args, **kwargs)` code in the context object the run method\nis called on. Return the result of the execution or propagate an exception if\none occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.values()", "path": "library/contextvars#contextvars.Context.values", "type": "Concurrent Execution", "text": "\nReturn a list of all variables\u2019 values in the context object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar", "path": "library/contextvars#contextvars.ContextVar", "type": "Concurrent Execution", "text": "\nThis class is used to declare a new Context Variable, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.get()", "path": "library/contextvars#contextvars.ContextVar.get", "type": "Concurrent Execution", "text": "\nReturn a value for the context variable for the current context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.name", "path": "library/contextvars#contextvars.ContextVar.name", "type": "Concurrent Execution", "text": "\nThe name of the variable. This is a read-only property.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.reset()", "path": "library/contextvars#contextvars.ContextVar.reset", "type": "Concurrent Execution", "text": "\nReset the context variable to the value it had before the `ContextVar.set()`\nthat created the token was used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.set()", "path": "library/contextvars#contextvars.ContextVar.set", "type": "Concurrent Execution", "text": "\nCall to set a new value for the context variable in the current context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token", "path": "library/contextvars#contextvars.contextvars.Token", "type": "Concurrent Execution", "text": "\nToken objects are returned by the `ContextVar.set()` method. They can be\npassed to the `ContextVar.reset()` method to revert the value of the variable\nto what it was before the corresponding set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token.Token.MISSING", "path": "library/contextvars#contextvars.contextvars.Token.Token.MISSING", "type": "Concurrent Execution", "text": "\nA marker object used by `Token.old_value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token.Token.old_value", "path": "library/contextvars#contextvars.contextvars.Token.Token.old_value", "type": "Concurrent Execution", "text": "\nA read-only property. Set to the value the variable had before the\n`ContextVar.set()` method call that created the token. It points to\n`Token.MISSING` is the variable was not set before the call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token.Token.var", "path": "library/contextvars#contextvars.contextvars.Token.Token.var", "type": "Concurrent Execution", "text": "\nA read-only property. Points to the `ContextVar` object that created the\ntoken.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.copy_context()", "path": "library/contextvars#contextvars.copy_context", "type": "Concurrent Execution", "text": "\nReturns a copy of the current `Context` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy", "path": "library/copy", "type": "Data Types", "text": "\nSource code: Lib/copy.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy.copy()", "path": "library/copy#copy.copy", "type": "Data Types", "text": "\nReturn a shallow copy of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy.deepcopy()", "path": "library/copy#copy.deepcopy", "type": "Data Types", "text": "\nReturn a deep copy of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy.Error", "path": "library/copy#copy.Error", "type": "Data Types", "text": "\nRaised for module specific errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyreg", "path": "library/copyreg", "type": "Data Persistence", "text": "\nSource code: Lib/copyreg.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyreg.constructor()", "path": "library/copyreg#copyreg.constructor", "type": "Data Persistence", "text": "\nDeclares object to be a valid constructor. If object is not callable (and\nhence not valid as a constructor), raises `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyreg.pickle()", "path": "library/copyreg#copyreg.pickle", "type": "Data Persistence", "text": "\nDeclares that function should be used as a \u201creduction\u201d function for objects of\ntype type. function should return either a string or a tuple containing two or\nthree elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyright", "path": "library/constants#copyright", "type": "Built-in Constants", "text": "\nObjects that when printed or called, print the text of copyright or credits,\nrespectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Coroutines and Tasks", "path": "library/asyncio-task", "type": "Asynchronous I/O", "text": "\nThis section outlines high-level asyncio APIs to work with coroutines and\nTasks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "credits", "path": "library/constants#credits", "type": "Built-in Constants", "text": "\nObjects that when printed or called, print the text of copyright or credits,\nrespectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt", "path": "library/crypt", "type": "Unix", "text": "\nSource code: Lib/crypt.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.crypt()", "path": "library/crypt#crypt.crypt", "type": "Unix", "text": "\nword will usually be a user\u2019s password as typed at a prompt or in a graphical\ninterface. The optional salt is either a string as returned from `mksalt()`,\none of the `crypt.METHOD_*` values (though not all may be available on all\nplatforms), or a full encrypted password including salt, as returned by this\nfunction. If salt is not provided, the strongest method will be used (as\nreturned by `methods()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.methods", "path": "library/crypt#crypt.methods", "type": "Unix", "text": "\nA list of available password hashing algorithms, as `crypt.METHOD_*` objects.\nThis list is sorted from strongest to weakest.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_BLOWFISH", "path": "library/crypt#crypt.METHOD_BLOWFISH", "type": "Unix", "text": "\nAnother Modular Crypt Format method with 22 character salt and 31 character\nhash based on the Blowfish cipher.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_CRYPT", "path": "library/crypt#crypt.METHOD_CRYPT", "type": "Unix", "text": "\nThe traditional method with a 2 character salt and 13 characters of hash. This\nis the weakest method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_MD5", "path": "library/crypt#crypt.METHOD_MD5", "type": "Unix", "text": "\nAnother Modular Crypt Format method with 8 character salt and 22 character\nhash based on the MD5 hash function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_SHA256", "path": "library/crypt#crypt.METHOD_SHA256", "type": "Unix", "text": "\nAnother Modular Crypt Format method with 16 character salt and 43 character\nhash based on the SHA-256 hash function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_SHA512", "path": "library/crypt#crypt.METHOD_SHA512", "type": "Unix", "text": "\nA Modular Crypt Format method with 16 character salt and 86 character hash\nbased on the SHA-512 hash function. This is the strongest method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.mksalt()", "path": "library/crypt#crypt.mksalt", "type": "Unix", "text": "\nReturn a randomly generated salt of the specified method. If no method is\ngiven, the strongest method available as returned by `methods()` is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv", "path": "library/csv", "type": "File Formats", "text": "\nSource code: Lib/csv.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.dialect", "path": "library/csv#csv.csvreader.dialect", "type": "File Formats", "text": "\nA read-only description of the dialect in use by the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.fieldnames", "path": "library/csv#csv.csvreader.fieldnames", "type": "File Formats", "text": "\nIf not passed as a parameter when creating the object, this attribute is\ninitialized upon first access or when the first record is read from the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.line_num", "path": "library/csv#csv.csvreader.line_num", "type": "File Formats", "text": "\nThe number of lines read from the source iterator. This is not the same as the\nnumber of records returned, as records can span multiple lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.__next__()", "path": "library/csv#csv.csvreader.__next__", "type": "File Formats", "text": "\nReturn the next row of the reader\u2019s iterable object as a list (if the object\nwas returned from `reader()`) or a dict (if it is a `DictReader` instance),\nparsed according to the current dialect. Usually you should call this as\n`next(reader)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvwriter.dialect", "path": "library/csv#csv.csvwriter.dialect", "type": "File Formats", "text": "\nA read-only description of the dialect in use by the writer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvwriter.writerow()", "path": "library/csv#csv.csvwriter.writerow", "type": "File Formats", "text": "\nWrite the row parameter to the writer\u2019s file object, formatted according to\nthe current dialect. Return the return value of the call to the write method\nof the underlying file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvwriter.writerows()", "path": "library/csv#csv.csvwriter.writerows", "type": "File Formats", "text": "\nWrite all elements in rows (an iterable of row objects as described above) to\nthe writer\u2019s file object, formatted according to the current dialect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect", "path": "library/csv#csv.Dialect", "type": "File Formats", "text": "\nThe `Dialect` class is a container class relied on primarily for its\nattributes, which are used to define the parameters for a specific `reader` or\n`writer` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.delimiter", "path": "library/csv#csv.Dialect.delimiter", "type": "File Formats", "text": "\nA one-character string used to separate fields. It defaults to `','`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.doublequote", "path": "library/csv#csv.Dialect.doublequote", "type": "File Formats", "text": "\nControls how instances of quotechar appearing inside a field should themselves\nbe quoted. When `True`, the character is doubled. When `False`, the escapechar\nis used as a prefix to the quotechar. It defaults to `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.escapechar", "path": "library/csv#csv.Dialect.escapechar", "type": "File Formats", "text": "\nA one-character string used by the writer to escape the delimiter if quoting\nis set to `QUOTE_NONE` and the quotechar if doublequote is `False`. On\nreading, the escapechar removes any special meaning from the following\ncharacter. It defaults to `None`, which disables escaping.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.lineterminator", "path": "library/csv#csv.Dialect.lineterminator", "type": "File Formats", "text": "\nThe string used to terminate lines produced by the `writer`. It defaults to\n`'\\r\\n'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.quotechar", "path": "library/csv#csv.Dialect.quotechar", "type": "File Formats", "text": "\nA one-character string used to quote fields containing special characters,\nsuch as the delimiter or quotechar, or which contain new-line characters. It\ndefaults to `'\"'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.quoting", "path": "library/csv#csv.Dialect.quoting", "type": "File Formats", "text": "\nControls when quotes should be generated by the writer and recognised by the\nreader. It can take on any of the `QUOTE_*` constants (see section Module\nContents) and defaults to `QUOTE_MINIMAL`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.skipinitialspace", "path": "library/csv#csv.Dialect.skipinitialspace", "type": "File Formats", "text": "\nWhen `True`, whitespace immediately following the delimiter is ignored. The\ndefault is `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.strict", "path": "library/csv#csv.Dialect.strict", "type": "File Formats", "text": "\nWhen `True`, raise exception `Error` on bad CSV input. The default is `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.DictReader", "path": "library/csv#csv.DictReader", "type": "File Formats", "text": "\nCreate an object that operates like a regular reader but maps the information\nin each row to a `dict` whose keys are given by the optional fieldnames\nparameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.DictWriter", "path": "library/csv#csv.DictWriter", "type": "File Formats", "text": "\nCreate an object which operates like a regular writer but maps dictionaries\nonto output rows. The fieldnames parameter is a `sequence` of keys that\nidentify the order in which values in the dictionary passed to the\n`writerow()` method are written to file f. The optional restval parameter\nspecifies the value to be written if the dictionary is missing a key in\nfieldnames. If the dictionary passed to the `writerow()` method contains a key\nnot found in fieldnames, the optional extrasaction parameter indicates what\naction to take. If it is set to `'raise'`, the default value, a `ValueError`\nis raised. If it is set to `'ignore'`, extra values in the dictionary are\nignored. Any other optional or keyword arguments are passed to the underlying\n`writer` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.DictWriter.writeheader()", "path": "library/csv#csv.DictWriter.writeheader", "type": "File Formats", "text": "\nWrite a row with the field names (as specified in the constructor) to the\nwriter\u2019s file object, formatted according to the current dialect. Return the\nreturn value of the `csvwriter.writerow()` call used internally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Error", "path": "library/csv#csv.Error", "type": "File Formats", "text": "\nRaised by any of the functions when an error is detected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.excel", "path": "library/csv#csv.excel", "type": "File Formats", "text": "\nThe `excel` class defines the usual properties of an Excel-generated CSV file.\nIt is registered with the dialect name `'excel'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.excel_tab", "path": "library/csv#csv.excel_tab", "type": "File Formats", "text": "\nThe `excel_tab` class defines the usual properties of an Excel-generated TAB-\ndelimited file. It is registered with the dialect name `'excel-tab'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.field_size_limit()", "path": "library/csv#csv.field_size_limit", "type": "File Formats", "text": "\nReturns the current maximum field size allowed by the parser. If new_limit is\ngiven, this becomes the new limit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.get_dialect()", "path": "library/csv#csv.get_dialect", "type": "File Formats", "text": "\nReturn the dialect associated with name. An `Error` is raised if name is not a\nregistered dialect name. This function returns an immutable `Dialect`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.list_dialects()", "path": "library/csv#csv.list_dialects", "type": "File Formats", "text": "\nReturn the names of all registered dialects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_ALL", "path": "library/csv#csv.QUOTE_ALL", "type": "File Formats", "text": "\nInstructs `writer` objects to quote all fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_MINIMAL", "path": "library/csv#csv.QUOTE_MINIMAL", "type": "File Formats", "text": "\nInstructs `writer` objects to only quote those fields which contain special\ncharacters such as delimiter, quotechar or any of the characters in\nlineterminator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_NONE", "path": "library/csv#csv.QUOTE_NONE", "type": "File Formats", "text": "\nInstructs `writer` objects to never quote fields. When the current delimiter\noccurs in output data it is preceded by the current escapechar character. If\nescapechar is not set, the writer will raise `Error` if any characters that\nrequire escaping are encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_NONNUMERIC", "path": "library/csv#csv.QUOTE_NONNUMERIC", "type": "File Formats", "text": "\nInstructs `writer` objects to quote all non-numeric fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.reader()", "path": "library/csv#csv.reader", "type": "File Formats", "text": "\nReturn a reader object which will iterate over lines in the given csvfile.\ncsvfile can be any object which supports the iterator protocol and returns a\nstring each time its `__next__()` method is called \u2014 file objects and list\nobjects are both suitable. If csvfile is a file object, it should be opened\nwith `newline=''`. 1 An optional dialect parameter can be given which is used\nto define a set of parameters specific to a particular CSV dialect. It may be\nan instance of a subclass of the `Dialect` class or one of the strings\nreturned by the `list_dialects()` function. The other optional fmtparams\nkeyword arguments can be given to override individual formatting parameters in\nthe current dialect. For full details about the dialect and formatting\nparameters, see section Dialects and Formatting Parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.register_dialect()", "path": "library/csv#csv.register_dialect", "type": "File Formats", "text": "\nAssociate dialect with name. name must be a string. The dialect can be\nspecified either by passing a sub-class of `Dialect`, or by fmtparams keyword\narguments, or both, with keyword arguments overriding parameters of the\ndialect. For full details about the dialect and formatting parameters, see\nsection Dialects and Formatting Parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Sniffer", "path": "library/csv#csv.Sniffer", "type": "File Formats", "text": "\nThe `Sniffer` class is used to deduce the format of a CSV file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Sniffer.has_header()", "path": "library/csv#csv.Sniffer.has_header", "type": "File Formats", "text": "\nAnalyze the sample text (presumed to be in CSV format) and return `True` if\nthe first row appears to be a series of column headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Sniffer.sniff()", "path": "library/csv#csv.Sniffer.sniff", "type": "File Formats", "text": "\nAnalyze the given sample and return a `Dialect` subclass reflecting the\nparameters found. If the optional delimiters parameter is given, it is\ninterpreted as a string containing possible valid delimiter characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.unix_dialect", "path": "library/csv#csv.unix_dialect", "type": "File Formats", "text": "\nThe `unix_dialect` class defines the usual properties of a CSV file generated\non UNIX systems, i.e. using `'\\n'` as line terminator and quoting all fields.\nIt is registered with the dialect name `'unix'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.unregister_dialect()", "path": "library/csv#csv.unregister_dialect", "type": "File Formats", "text": "\nDelete the dialect associated with name from the dialect registry. An `Error`\nis raised if name is not a registered dialect name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.writer()", "path": "library/csv#csv.writer", "type": "File Formats", "text": "\nReturn a writer object responsible for converting the user\u2019s data into\ndelimited strings on the given file-like object. csvfile can be any object\nwith a `write()` method. If csvfile is a file object, it should be opened with\n`newline=''` 1. An optional dialect parameter can be given which is used to\ndefine a set of parameters specific to a particular CSV dialect. It may be an\ninstance of a subclass of the `Dialect` class or one of the strings returned\nby the `list_dialects()` function. The other optional fmtparams keyword\narguments can be given to override individual formatting parameters in the\ncurrent dialect. For full details about the dialect and formatting parameters,\nsee section Dialects and Formatting Parameters. To make it as easy as possible\nto interface with modules which implement the DB API, the value `None` is\nwritten as the empty string. While this isn\u2019t a reversible transformation, it\nmakes it easier to dump SQL NULL data values to CSV files without\npreprocessing the data returned from a `cursor.fetch*` call. All other non-\nstring data are stringified with `str()` before being written.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes", "path": "library/ctypes", "type": "Operating System", "text": "\n`ctypes` is a foreign function library for Python. It provides C compatible\ndata types, and allows calling functions in DLLs or shared libraries. It can\nbe used to wrap these libraries in pure Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.addressof()", "path": "library/ctypes#ctypes.addressof", "type": "Operating System", "text": "\nReturns the address of the memory buffer as integer. obj must be an instance\nof a ctypes type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.alignment()", "path": "library/ctypes#ctypes.alignment", "type": "Operating System", "text": "\nReturns the alignment requirements of a ctypes type. obj_or_type must be a\nctypes type or instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.ArgumentError", "path": "library/ctypes#ctypes.ArgumentError", "type": "Operating System", "text": "\nThis exception is raised when a foreign function call cannot convert one of\nthe passed arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Array", "path": "library/ctypes#ctypes.Array", "type": "Operating System", "text": "\nAbstract base class for arrays.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Array._length_", "path": "library/ctypes#ctypes.Array._length_", "type": "Operating System", "text": "\nA positive integer specifying the number of elements in the array. Out-of-\nrange subscripts result in an `IndexError`. Will be returned by `len()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Array._type_", "path": "library/ctypes#ctypes.Array._type_", "type": "Operating System", "text": "\nSpecifies the type of each element in the array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.BigEndianStructure", "path": "library/ctypes#ctypes.BigEndianStructure", "type": "Operating System", "text": "\nAbstract base class for structures in big endian byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.byref()", "path": "library/ctypes#ctypes.byref", "type": "Operating System", "text": "\nReturns a light-weight pointer to obj, which must be an instance of a ctypes\ntype. offset defaults to zero, and must be an integer that will be added to\nthe internal pointer value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.cast()", "path": "library/ctypes#ctypes.cast", "type": "Operating System", "text": "\nThis function is similar to the cast operator in C. It returns a new instance\nof type which points to the same memory block as obj. type must be a pointer\ntype, and obj must be an object that can be interpreted as a pointer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.CDLL", "path": "library/ctypes#ctypes.CDLL", "type": "Operating System", "text": "\nInstances of this class represent loaded shared libraries. Functions in these\nlibraries use the standard C calling convention, and are assumed to return\n`int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.CFUNCTYPE()", "path": "library/ctypes#ctypes.CFUNCTYPE", "type": "Operating System", "text": "\nThe returned function prototype creates functions that use the standard C\ncalling convention. The function will release the GIL during the call. If\nuse_errno is set to true, the ctypes private copy of the system `errno`\nvariable is exchanged with the real `errno` value before and after the call;\nuse_last_error does the same for the Windows error code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.create_string_buffer()", "path": "library/ctypes#ctypes.create_string_buffer", "type": "Operating System", "text": "\nThis function creates a mutable character buffer. The returned object is a\nctypes array of `c_char`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.create_unicode_buffer()", "path": "library/ctypes#ctypes.create_unicode_buffer", "type": "Operating System", "text": "\nThis function creates a mutable unicode character buffer. The returned object\nis a ctypes array of `c_wchar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_bool", "path": "library/ctypes#ctypes.c_bool", "type": "Operating System", "text": "\nRepresent the C `bool` datatype (more accurately, `_Bool` from C99). Its value\ncan be `True` or `False`, and the constructor accepts any object that has a\ntruth value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_byte", "path": "library/ctypes#ctypes.c_byte", "type": "Operating System", "text": "\nRepresents the C `signed char` datatype, and interprets the value as small\ninteger. The constructor accepts an optional integer initializer; no overflow\nchecking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_char", "path": "library/ctypes#ctypes.c_char", "type": "Operating System", "text": "\nRepresents the C `char` datatype, and interprets the value as a single\ncharacter. The constructor accepts an optional string initializer, the length\nof the string must be exactly one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_char_p", "path": "library/ctypes#ctypes.c_char_p", "type": "Operating System", "text": "\nRepresents the C `char *` datatype when it points to a zero-terminated string.\nFor a general character pointer that may also point to binary data,\n`POINTER(c_char)` must be used. The constructor accepts an integer address, or\na bytes object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_double", "path": "library/ctypes#ctypes.c_double", "type": "Operating System", "text": "\nRepresents the C `double` datatype. The constructor accepts an optional float\ninitializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_float", "path": "library/ctypes#ctypes.c_float", "type": "Operating System", "text": "\nRepresents the C `float` datatype. The constructor accepts an optional float\ninitializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int", "path": "library/ctypes#ctypes.c_int", "type": "Operating System", "text": "\nRepresents the C `signed int` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done. On platforms where\n`sizeof(int) == sizeof(long)` it is an alias to `c_long`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int16", "path": "library/ctypes#ctypes.c_int16", "type": "Operating System", "text": "\nRepresents the C 16-bit `signed int` datatype. Usually an alias for `c_short`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int32", "path": "library/ctypes#ctypes.c_int32", "type": "Operating System", "text": "\nRepresents the C 32-bit `signed int` datatype. Usually an alias for `c_int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int64", "path": "library/ctypes#ctypes.c_int64", "type": "Operating System", "text": "\nRepresents the C 64-bit `signed int` datatype. Usually an alias for\n`c_longlong`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int8", "path": "library/ctypes#ctypes.c_int8", "type": "Operating System", "text": "\nRepresents the C 8-bit `signed int` datatype. Usually an alias for `c_byte`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_long", "path": "library/ctypes#ctypes.c_long", "type": "Operating System", "text": "\nRepresents the C `signed long` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_longdouble", "path": "library/ctypes#ctypes.c_longdouble", "type": "Operating System", "text": "\nRepresents the C `long double` datatype. The constructor accepts an optional\nfloat initializer. On platforms where `sizeof(long double) == sizeof(double)`\nit is an alias to `c_double`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_longlong", "path": "library/ctypes#ctypes.c_longlong", "type": "Operating System", "text": "\nRepresents the C `signed long long` datatype. The constructor accepts an\noptional integer initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_short", "path": "library/ctypes#ctypes.c_short", "type": "Operating System", "text": "\nRepresents the C `signed short` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_size_t", "path": "library/ctypes#ctypes.c_size_t", "type": "Operating System", "text": "\nRepresents the C `size_t` datatype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ssize_t", "path": "library/ctypes#ctypes.c_ssize_t", "type": "Operating System", "text": "\nRepresents the C `ssize_t` datatype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ubyte", "path": "library/ctypes#ctypes.c_ubyte", "type": "Operating System", "text": "\nRepresents the C `unsigned char` datatype, it interprets the value as small\ninteger. The constructor accepts an optional integer initializer; no overflow\nchecking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint", "path": "library/ctypes#ctypes.c_uint", "type": "Operating System", "text": "\nRepresents the C `unsigned int` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done. On platforms where\n`sizeof(int) == sizeof(long)` it is an alias for `c_ulong`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint16", "path": "library/ctypes#ctypes.c_uint16", "type": "Operating System", "text": "\nRepresents the C 16-bit `unsigned int` datatype. Usually an alias for\n`c_ushort`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint32", "path": "library/ctypes#ctypes.c_uint32", "type": "Operating System", "text": "\nRepresents the C 32-bit `unsigned int` datatype. Usually an alias for\n`c_uint`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint64", "path": "library/ctypes#ctypes.c_uint64", "type": "Operating System", "text": "\nRepresents the C 64-bit `unsigned int` datatype. Usually an alias for\n`c_ulonglong`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint8", "path": "library/ctypes#ctypes.c_uint8", "type": "Operating System", "text": "\nRepresents the C 8-bit `unsigned int` datatype. Usually an alias for\n`c_ubyte`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ulong", "path": "library/ctypes#ctypes.c_ulong", "type": "Operating System", "text": "\nRepresents the C `unsigned long` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ulonglong", "path": "library/ctypes#ctypes.c_ulonglong", "type": "Operating System", "text": "\nRepresents the C `unsigned long long` datatype. The constructor accepts an\noptional integer initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ushort", "path": "library/ctypes#ctypes.c_ushort", "type": "Operating System", "text": "\nRepresents the C `unsigned short` datatype. The constructor accepts an\noptional integer initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_void_p", "path": "library/ctypes#ctypes.c_void_p", "type": "Operating System", "text": "\nRepresents the C `void *` type. The value is represented as integer. The\nconstructor accepts an optional integer initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_wchar", "path": "library/ctypes#ctypes.c_wchar", "type": "Operating System", "text": "\nRepresents the C `wchar_t` datatype, and interprets the value as a single\ncharacter unicode string. The constructor accepts an optional string\ninitializer, the length of the string must be exactly one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_wchar_p", "path": "library/ctypes#ctypes.c_wchar_p", "type": "Operating System", "text": "\nRepresents the C `wchar_t *` datatype, which must be a pointer to a zero-\nterminated wide character string. The constructor accepts an integer address,\nor a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.DllCanUnloadNow()", "path": "library/ctypes#ctypes.DllCanUnloadNow", "type": "Operating System", "text": "\nWindows only: This function is a hook which allows implementing in-process COM\nservers with ctypes. It is called from the DllCanUnloadNow function that the\n_ctypes extension dll exports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.DllGetClassObject()", "path": "library/ctypes#ctypes.DllGetClassObject", "type": "Operating System", "text": "\nWindows only: This function is a hook which allows implementing in-process COM\nservers with ctypes. It is called from the DllGetClassObject function that the\n`_ctypes` extension dll exports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.FormatError()", "path": "library/ctypes#ctypes.FormatError", "type": "Operating System", "text": "\nWindows only: Returns a textual description of the error code code. If no\nerror code is specified, the last error code is used by calling the Windows\napi function GetLastError.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.GetLastError()", "path": "library/ctypes#ctypes.GetLastError", "type": "Operating System", "text": "\nWindows only: Returns the last error code set by Windows in the calling\nthread. This function calls the Windows `GetLastError()` function directly, it\ndoes not return the ctypes-private copy of the error code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.get_errno()", "path": "library/ctypes#ctypes.get_errno", "type": "Operating System", "text": "\nReturns the current value of the ctypes-private copy of the system `errno`\nvariable in the calling thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.get_last_error()", "path": "library/ctypes#ctypes.get_last_error", "type": "Operating System", "text": "\nWindows only: returns the current value of the ctypes-private copy of the\nsystem `LastError` variable in the calling thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.HRESULT", "path": "library/ctypes#ctypes.HRESULT", "type": "Operating System", "text": "\nWindows only: Represents a `HRESULT` value, which contains success or error\ninformation for a function or method call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.LibraryLoader", "path": "library/ctypes#ctypes.LibraryLoader", "type": "Operating System", "text": "\nClass which loads shared libraries. dlltype should be one of the `CDLL`,\n`PyDLL`, `WinDLL`, or `OleDLL` types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.LibraryLoader.LoadLibrary()", "path": "library/ctypes#ctypes.LibraryLoader.LoadLibrary", "type": "Operating System", "text": "\nLoad a shared library into the process and return it. This method always\nreturns a new instance of the library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.LittleEndianStructure", "path": "library/ctypes#ctypes.LittleEndianStructure", "type": "Operating System", "text": "\nAbstract base class for structures in little endian byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.memmove()", "path": "library/ctypes#ctypes.memmove", "type": "Operating System", "text": "\nSame as the standard C memmove library function: copies count bytes from src\nto dst. dst and src must be integers or ctypes instances that can be converted\nto pointers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.memset()", "path": "library/ctypes#ctypes.memset", "type": "Operating System", "text": "\nSame as the standard C memset library function: fills the memory block at\naddress dst with count bytes of value c. dst must be an integer specifying an\naddress, or a ctypes instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.OleDLL", "path": "library/ctypes#ctypes.OleDLL", "type": "Operating System", "text": "\nWindows only: Instances of this class represent loaded shared libraries,\nfunctions in these libraries use the `stdcall` calling convention, and are\nassumed to return the windows specific `HRESULT` code. `HRESULT` values\ncontain information specifying whether the function call failed or succeeded,\ntogether with additional error code. If the return value signals a failure, an\n`OSError` is automatically raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.POINTER()", "path": "library/ctypes#ctypes.POINTER", "type": "Operating System", "text": "\nThis factory function creates and returns a new ctypes pointer type. Pointer\ntypes are cached and reused internally, so calling this function repeatedly is\ncheap. type must be a ctypes type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.pointer()", "path": "library/ctypes#ctypes.pointer", "type": "Operating System", "text": "\nThis function creates a new pointer instance, pointing to obj. The returned\nobject is of the type `POINTER(type(obj))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PyDLL", "path": "library/ctypes#ctypes.PyDLL", "type": "Operating System", "text": "\nInstances of this class behave like `CDLL` instances, except that the Python\nGIL is not released during the function call, and after the function execution\nthe Python error flag is checked. If the error flag is set, a Python exception\nis raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PyDLL._handle", "path": "library/ctypes#ctypes.PyDLL._handle", "type": "Operating System", "text": "\nThe system handle used to access the library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PyDLL._name", "path": "library/ctypes#ctypes.PyDLL._name", "type": "Operating System", "text": "\nThe name of the library passed in the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PYFUNCTYPE()", "path": "library/ctypes#ctypes.PYFUNCTYPE", "type": "Operating System", "text": "\nThe returned function prototype creates functions that use the Python calling\nconvention. The function will not release the GIL during the call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.py_object", "path": "library/ctypes#ctypes.py_object", "type": "Operating System", "text": "\nRepresents the C `PyObject *` datatype. Calling this without an argument\ncreates a `NULL` `PyObject *` pointer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.resize()", "path": "library/ctypes#ctypes.resize", "type": "Operating System", "text": "\nThis function resizes the internal memory buffer of obj, which must be an\ninstance of a ctypes type. It is not possible to make the buffer smaller than\nthe native size of the objects type, as given by `sizeof(type(obj))`, but it\nis possible to enlarge the buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.set_errno()", "path": "library/ctypes#ctypes.set_errno", "type": "Operating System", "text": "\nSet the current value of the ctypes-private copy of the system `errno`\nvariable in the calling thread to value and return the previous value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.set_last_error()", "path": "library/ctypes#ctypes.set_last_error", "type": "Operating System", "text": "\nWindows only: set the current value of the ctypes-private copy of the system\n`LastError` variable in the calling thread to value and return the previous\nvalue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.sizeof()", "path": "library/ctypes#ctypes.sizeof", "type": "Operating System", "text": "\nReturns the size in bytes of a ctypes type or instance memory buffer. Does the\nsame as the C `sizeof` operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.string_at()", "path": "library/ctypes#ctypes.string_at", "type": "Operating System", "text": "\nThis function returns the C string starting at memory address address as a\nbytes object. If size is specified, it is used as size, otherwise the string\nis assumed to be zero-terminated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure", "path": "library/ctypes#ctypes.Structure", "type": "Operating System", "text": "\nAbstract base class for structures in native byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure._anonymous_", "path": "library/ctypes#ctypes.Structure._anonymous_", "type": "Operating System", "text": "\nAn optional sequence that lists the names of unnamed (anonymous) fields.\n`_anonymous_` must be already defined when `_fields_` is assigned, otherwise\nit will have no effect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure._fields_", "path": "library/ctypes#ctypes.Structure._fields_", "type": "Operating System", "text": "\nA sequence defining the structure fields. The items must be 2-tuples or\n3-tuples. The first item is the name of the field, the second item specifies\nthe type of the field; it can be any ctypes data type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure._pack_", "path": "library/ctypes#ctypes.Structure._pack_", "type": "Operating System", "text": "\nAn optional small integer that allows overriding the alignment of structure\nfields in the instance. `_pack_` must already be defined when `_fields_` is\nassigned, otherwise it will have no effect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Union", "path": "library/ctypes#ctypes.Union", "type": "Operating System", "text": "\nAbstract base class for unions in native byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.util.find_library()", "path": "library/ctypes#ctypes.util.find_library", "type": "Operating System", "text": "\nTry to find a library and return a pathname. name is the library name without\nany prefix like `lib`, suffix like `.so`, `.dylib` or version number (this is\nthe form used for the posix linker option `-l`). If no library can be found,\nreturns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.util.find_msvcrt()", "path": "library/ctypes#ctypes.util.find_msvcrt", "type": "Operating System", "text": "\nWindows only: return the filename of the VC runtime library used by Python,\nand by the extension modules. If the name of the library cannot be determined,\n`None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.WinDLL", "path": "library/ctypes#ctypes.WinDLL", "type": "Operating System", "text": "\nWindows only: Instances of this class represent loaded shared libraries,\nfunctions in these libraries use the `stdcall` calling convention, and are\nassumed to return `int` by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.WinError()", "path": "library/ctypes#ctypes.WinError", "type": "Operating System", "text": "\nWindows only: this function is probably the worst-named thing in ctypes. It\ncreates an instance of OSError. If code is not specified, `GetLastError` is\ncalled to determine the error code. If descr is not specified, `FormatError()`\nis called to get a textual description of the error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.WINFUNCTYPE()", "path": "library/ctypes#ctypes.WINFUNCTYPE", "type": "Operating System", "text": "\nWindows only: The returned function prototype creates functions that use the\n`stdcall` calling convention, except on Windows CE where `WINFUNCTYPE()` is\nthe same as `CFUNCTYPE()`. The function will release the GIL during the call.\nuse_errno and use_last_error have the same meaning as above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.wstring_at()", "path": "library/ctypes#ctypes.wstring_at", "type": "Operating System", "text": "\nThis function returns the wide character string starting at memory address\naddress as a string. If size is specified, it is used as the number of\ncharacters of the string, otherwise the string is assumed to be zero-\nterminated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData", "path": "library/ctypes#ctypes._CData", "type": "Operating System", "text": "\nThis non-public class is the common base class of all ctypes data types. Among\nother things, all ctypes type instances contain a memory block that hold C\ncompatible data; the address of the memory block is returned by the\n`addressof()` helper function. Another instance variable is exposed as\n`_objects`; this contains other Python objects that need to be kept alive in\ncase the memory block contains pointers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_address()", "path": "library/ctypes#ctypes._CData.from_address", "type": "Operating System", "text": "\nThis method returns a ctypes type instance using the memory specified by\naddress which must be an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_buffer()", "path": "library/ctypes#ctypes._CData.from_buffer", "type": "Operating System", "text": "\nThis method returns a ctypes instance that shares the buffer of the source\nobject. The source object must support the writeable buffer interface. The\noptional offset parameter specifies an offset into the source buffer in bytes;\nthe default is zero. If the source buffer is not large enough a `ValueError`\nis raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_buffer_copy()", "path": "library/ctypes#ctypes._CData.from_buffer_copy", "type": "Operating System", "text": "\nThis method creates a ctypes instance, copying the buffer from the source\nobject buffer which must be readable. The optional offset parameter specifies\nan offset into the source buffer in bytes; the default is zero. If the source\nbuffer is not large enough a `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_param()", "path": "library/ctypes#ctypes._CData.from_param", "type": "Operating System", "text": "\nThis method adapts obj to a ctypes type. It is called with the actual object\nused in a foreign function call when the type is present in the foreign\nfunction\u2019s `argtypes` tuple; it must return an object that can be used as a\nfunction call parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.in_dll()", "path": "library/ctypes#ctypes._CData.in_dll", "type": "Operating System", "text": "\nThis method returns a ctypes type instance exported by a shared library. name\nis the name of the symbol that exports the data, library is the loaded shared\nlibrary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData._b_base_", "path": "library/ctypes#ctypes._CData._b_base_", "type": "Operating System", "text": "\nSometimes ctypes data instances do not own the memory block they contain,\ninstead they share part of the memory block of a base object. The `_b_base_`\nread-only member is the root ctypes object that owns the memory block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData._b_needsfree_", "path": "library/ctypes#ctypes._CData._b_needsfree_", "type": "Operating System", "text": "\nThis read-only variable is true when the ctypes data instance has allocated\nthe memory block itself, false otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData._objects", "path": "library/ctypes#ctypes._CData._objects", "type": "Operating System", "text": "\nThis member is either `None` or a dictionary containing Python objects that\nneed to be kept alive so that the memory block contents is kept valid. This\nobject is only exposed for debugging; never modify the contents of this\ndictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr", "path": "library/ctypes#ctypes._FuncPtr", "type": "Operating System", "text": "\nBase class for C callable foreign functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr.argtypes", "path": "library/ctypes#ctypes._FuncPtr.argtypes", "type": "Operating System", "text": "\nAssign a tuple of ctypes types to specify the argument types that the function\naccepts. Functions using the `stdcall` calling convention can only be called\nwith the same number of arguments as the length of this tuple; functions using\nthe C calling convention accept additional, unspecified arguments as well.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr.errcheck", "path": "library/ctypes#ctypes._FuncPtr.errcheck", "type": "Operating System", "text": "\nAssign a Python function or another callable to this attribute. The callable\nwill be called with three or more arguments:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr.restype", "path": "library/ctypes#ctypes._FuncPtr.restype", "type": "Operating System", "text": "\nAssign a ctypes type to specify the result type of the foreign function. Use\n`None` for `void`, a function not returning anything.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._Pointer", "path": "library/ctypes#ctypes._Pointer", "type": "Operating System", "text": "\nPrivate, abstract base class for pointers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._Pointer.contents", "path": "library/ctypes#ctypes._Pointer.contents", "type": "Operating System", "text": "\nReturns the object to which to pointer points. Assigning to this attribute\nchanges the pointer to point to the assigned object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._Pointer._type_", "path": "library/ctypes#ctypes._Pointer._type_", "type": "Operating System", "text": "\nSpecifies the type pointed to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._SimpleCData", "path": "library/ctypes#ctypes._SimpleCData", "type": "Operating System", "text": "\nThis non-public class is the base class of all fundamental ctypes data types.\nIt is mentioned here because it contains the common attributes of the\nfundamental ctypes data types. `_SimpleCData` is a subclass of `_CData`, so it\ninherits their methods and attributes. ctypes data types that are not and do\nnot contain pointers can now be pickled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._SimpleCData.value", "path": "library/ctypes#ctypes._SimpleCData.value", "type": "Operating System", "text": "\nThis attribute contains the actual value of the instance. For integer and\npointer types, it is an integer, for character types, it is a single character\nbytes object or string, for character pointer types it is a Python bytes\nobject or string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses", "path": "library/curses", "type": "Operating System", "text": "\nThe `curses` module provides an interface to the curses library, the de-facto\nstandard for portable advanced terminal handling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii", "path": "library/curses.ascii", "type": "Operating System", "text": "\nThe `curses.ascii` module supplies name constants for ASCII characters and\nfunctions to test membership in various ASCII character classes. The constants\nsupplied are names for control characters as follows:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.alt()", "path": "library/curses.ascii#curses.ascii.alt", "type": "Operating System", "text": "\nReturn the 8-bit character corresponding to the given ASCII character (the\ncharacter bit value is bitwise-ored with 0x80).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ascii()", "path": "library/curses.ascii#curses.ascii.ascii", "type": "Operating System", "text": "\nReturn the ASCII value corresponding to the low 7 bits of c.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.controlnames", "path": "library/curses.ascii#curses.ascii.controlnames", "type": "Operating System", "text": "\nA 33-element string array that contains the ASCII mnemonics for the thirty-two\nASCII control characters from 0 (NUL) to 0x1f (US), in order, plus the\nmnemonic `SP` for the space character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ctrl()", "path": "library/curses.ascii#curses.ascii.ctrl", "type": "Operating System", "text": "\nReturn the control character corresponding to the given character (the\ncharacter bit value is bitwise-anded with 0x1f).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isalnum()", "path": "library/curses.ascii#curses.ascii.isalnum", "type": "Operating System", "text": "\nChecks for an ASCII alphanumeric character; it is equivalent to `isalpha(c) or\nisdigit(c)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isalpha()", "path": "library/curses.ascii#curses.ascii.isalpha", "type": "Operating System", "text": "\nChecks for an ASCII alphabetic character; it is equivalent to `isupper(c) or\nislower(c)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isascii()", "path": "library/curses.ascii#curses.ascii.isascii", "type": "Operating System", "text": "\nChecks for a character value that fits in the 7-bit ASCII set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isblank()", "path": "library/curses.ascii#curses.ascii.isblank", "type": "Operating System", "text": "\nChecks for an ASCII whitespace character; space or horizontal tab.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.iscntrl()", "path": "library/curses.ascii#curses.ascii.iscntrl", "type": "Operating System", "text": "\nChecks for an ASCII control character (in the range 0x00 to 0x1f or 0x7f).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isctrl()", "path": "library/curses.ascii#curses.ascii.isctrl", "type": "Operating System", "text": "\nChecks for an ASCII control character (ordinal values 0 to 31).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isdigit()", "path": "library/curses.ascii#curses.ascii.isdigit", "type": "Operating System", "text": "\nChecks for an ASCII decimal digit, `'0'` through `'9'`. This is equivalent to\n`c in string.digits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isgraph()", "path": "library/curses.ascii#curses.ascii.isgraph", "type": "Operating System", "text": "\nChecks for ASCII any printable character except space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.islower()", "path": "library/curses.ascii#curses.ascii.islower", "type": "Operating System", "text": "\nChecks for an ASCII lower-case character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ismeta()", "path": "library/curses.ascii#curses.ascii.ismeta", "type": "Operating System", "text": "\nChecks for a non-ASCII character (ordinal values 0x80 and above).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isprint()", "path": "library/curses.ascii#curses.ascii.isprint", "type": "Operating System", "text": "\nChecks for any ASCII printable character including space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ispunct()", "path": "library/curses.ascii#curses.ascii.ispunct", "type": "Operating System", "text": "\nChecks for any printable ASCII character which is not a space or an\nalphanumeric character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isspace()", "path": "library/curses.ascii#curses.ascii.isspace", "type": "Operating System", "text": "\nChecks for ASCII white-space characters; space, line feed, carriage return,\nform feed, horizontal tab, vertical tab.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isupper()", "path": "library/curses.ascii#curses.ascii.isupper", "type": "Operating System", "text": "\nChecks for an ASCII uppercase letter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isxdigit()", "path": "library/curses.ascii#curses.ascii.isxdigit", "type": "Operating System", "text": "\nChecks for an ASCII hexadecimal digit. This is equivalent to `c in\nstring.hexdigits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.unctrl()", "path": "library/curses.ascii#curses.ascii.unctrl", "type": "Operating System", "text": "\nReturn a string representation of the ASCII character c. If c is printable,\nthis string is the character itself. If the character is a control character\n(0x00\u20130x1f) the string consists of a caret (`'^'`) followed by the\ncorresponding uppercase letter. If the character is an ASCII delete (0x7f) the\nstring is `'^?'`. If the character has its meta bit (0x80) set, the meta bit\nis stripped, the preceding rules applied, and `'!'` prepended to the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.baudrate()", "path": "library/curses#curses.baudrate", "type": "Operating System", "text": "\nReturn the output speed of the terminal in bits per second. On software\nterminal emulators it will have a fixed high value. Included for historical\nreasons; in former times, it was used to write output loops for time delays\nand occasionally to change interfaces depending on the line speed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.beep()", "path": "library/curses#curses.beep", "type": "Operating System", "text": "\nEmit a short attention sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.can_change_color()", "path": "library/curses#curses.can_change_color", "type": "Operating System", "text": "\nReturn `True` or `False`, depending on whether the programmer can change the\ncolors displayed by the terminal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.cbreak()", "path": "library/curses#curses.cbreak", "type": "Operating System", "text": "\nEnter cbreak mode. In cbreak mode (sometimes called \u201crare\u201d mode) normal tty\nline buffering is turned off and characters are available to be read one by\none. However, unlike raw mode, special characters (interrupt, quit, suspend,\nand flow control) retain their effects on the tty driver and calling program.\nCalling first `raw()` then `cbreak()` leaves the terminal in cbreak mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.color_content()", "path": "library/curses#curses.color_content", "type": "Operating System", "text": "\nReturn the intensity of the red, green, and blue (RGB) components in the color\ncolor_number, which must be between `0` and `COLORS - 1`. Return a 3-tuple,\ncontaining the R,G,B values for the given color, which will be between `0` (no\ncomponent) and `1000` (maximum amount of component).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.color_pair()", "path": "library/curses#curses.color_pair", "type": "Operating System", "text": "\nReturn the attribute value for displaying text in the specified color pair.\nOnly the first 256 color pairs are supported. This attribute value can be\ncombined with `A_STANDOUT`, `A_REVERSE`, and the other `A_*` attributes.\n`pair_number()` is the counterpart to this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.curs_set()", "path": "library/curses#curses.curs_set", "type": "Operating System", "text": "\nSet the cursor state. visibility can be set to `0`, `1`, or `2`, for\ninvisible, normal, or very visible. If the terminal supports the visibility\nrequested, return the previous cursor state; otherwise raise an exception. On\nmany terminals, the \u201cvisible\u201d mode is an underline cursor and the \u201cvery\nvisible\u201d mode is a block cursor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.def_prog_mode()", "path": "library/curses#curses.def_prog_mode", "type": "Operating System", "text": "\nSave the current terminal mode as the \u201cprogram\u201d mode, the mode when the\nrunning program is using curses. (Its counterpart is the \u201cshell\u201d mode, for\nwhen the program is not in curses.) Subsequent calls to `reset_prog_mode()`\nwill restore this mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.def_shell_mode()", "path": "library/curses#curses.def_shell_mode", "type": "Operating System", "text": "\nSave the current terminal mode as the \u201cshell\u201d mode, the mode when the running\nprogram is not using curses. (Its counterpart is the \u201cprogram\u201d mode, when the\nprogram is using curses capabilities.) Subsequent calls to\n`reset_shell_mode()` will restore this mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.delay_output()", "path": "library/curses#curses.delay_output", "type": "Operating System", "text": "\nInsert an ms millisecond pause in output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.doupdate()", "path": "library/curses#curses.doupdate", "type": "Operating System", "text": "\nUpdate the physical screen. The curses library keeps two data structures, one\nrepresenting the current physical screen contents and a virtual screen\nrepresenting the desired next state. The `doupdate()` ground updates the\nphysical screen to match the virtual screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.echo()", "path": "library/curses#curses.echo", "type": "Operating System", "text": "\nEnter echo mode. In echo mode, each character input is echoed to the screen as\nit is entered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.endwin()", "path": "library/curses#curses.endwin", "type": "Operating System", "text": "\nDe-initialize the library, and return terminal to normal status.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.erasechar()", "path": "library/curses#curses.erasechar", "type": "Operating System", "text": "\nReturn the user\u2019s current erase character as a one-byte bytes object. Under\nUnix operating systems this is a property of the controlling tty of the curses\nprogram, and is not set by the curses library itself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ERR", "path": "library/curses#curses.ERR", "type": "Operating System", "text": "\nSome curses routines that return an integer, such as `getch()`, return `ERR`\nupon failure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.error", "path": "library/curses#curses.error", "type": "Operating System", "text": "\nException raised when a curses library function returns an error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.filter()", "path": "library/curses#curses.filter", "type": "Operating System", "text": "\nThe `filter()` routine, if used, must be called before `initscr()` is called.\nThe effect is that, during those calls, `LINES` is set to `1`; the\ncapabilities `clear`, `cup`, `cud`, `cud1`, `cuu1`, `cuu`, `vpa` are disabled;\nand the `home` string is set to the value of `cr`. The effect is that the\ncursor is confined to the current line, and so are screen updates. This may be\nused for enabling character-at-a-time line editing without touching the rest\nof the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.flash()", "path": "library/curses#curses.flash", "type": "Operating System", "text": "\nFlash the screen. That is, change it to reverse-video and then change it back\nin a short interval. Some people prefer such as \u2018visible bell\u2019 to the audible\nattention signal produced by `beep()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.flushinp()", "path": "library/curses#curses.flushinp", "type": "Operating System", "text": "\nFlush all input buffers. This throws away any typeahead that has been typed by\nthe user and has not yet been processed by the program.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.getmouse()", "path": "library/curses#curses.getmouse", "type": "Operating System", "text": "\nAfter `getch()` returns `KEY_MOUSE` to signal a mouse event, this method\nshould be called to retrieve the queued mouse event, represented as a 5-tuple\n`(id, x, y, z, bstate)`. id is an ID value used to distinguish multiple\ndevices, and x, y, z are the event\u2019s coordinates. (z is currently unused.)\nbstate is an integer value whose bits will be set to indicate the type of\nevent, and will be the bitwise OR of one or more of the following constants,\nwhere n is the button number from 1 to 4: `BUTTONn_PRESSED`,\n`BUTTONn_RELEASED`, `BUTTONn_CLICKED`, `BUTTONn_DOUBLE_CLICKED`,\n`BUTTONn_TRIPLE_CLICKED`, `BUTTON_SHIFT`, `BUTTON_CTRL`, `BUTTON_ALT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.getsyx()", "path": "library/curses#curses.getsyx", "type": "Operating System", "text": "\nReturn the current coordinates of the virtual screen cursor as a tuple `(y,\nx)`. If `leaveok` is currently `True`, then return `(-1, -1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.getwin()", "path": "library/curses#curses.getwin", "type": "Operating System", "text": "\nRead window related data stored in the file by an earlier `putwin()` call. The\nroutine then creates and initializes a new window using that data, returning\nthe new window object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.get_escdelay()", "path": "library/curses#curses.get_escdelay", "type": "Operating System", "text": "\nRetrieves the value set by `set_escdelay()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.get_tabsize()", "path": "library/curses#curses.get_tabsize", "type": "Operating System", "text": "\nRetrieves the value set by `set_tabsize()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.halfdelay()", "path": "library/curses#curses.halfdelay", "type": "Operating System", "text": "\nUsed for half-delay mode, which is similar to cbreak mode in that characters\ntyped by the user are immediately available to the program. However, after\nblocking for tenths tenths of seconds, raise an exception if nothing has been\ntyped. The value of tenths must be a number between `1` and `255`. Use\n`nocbreak()` to leave half-delay mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_colors()", "path": "library/curses#curses.has_colors", "type": "Operating System", "text": "\nReturn `True` if the terminal can display colors; otherwise, return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_ic()", "path": "library/curses#curses.has_ic", "type": "Operating System", "text": "\nReturn `True` if the terminal has insert- and delete-character capabilities.\nThis function is included for historical reasons only, as all modern software\nterminal emulators have such capabilities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_il()", "path": "library/curses#curses.has_il", "type": "Operating System", "text": "\nReturn `True` if the terminal has insert- and delete-line capabilities, or can\nsimulate them using scrolling regions. This function is included for\nhistorical reasons only, as all modern software terminal emulators have such\ncapabilities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_key()", "path": "library/curses#curses.has_key", "type": "Operating System", "text": "\nTake a key value ch, and return `True` if the current terminal type recognizes\na key with that value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.initscr()", "path": "library/curses#curses.initscr", "type": "Operating System", "text": "\nInitialize the library. Return a window object which represents the whole\nscreen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.init_color()", "path": "library/curses#curses.init_color", "type": "Operating System", "text": "\nChange the definition of a color, taking the number of the color to be changed\nfollowed by three RGB values (for the amounts of red, green, and blue\ncomponents). The value of color_number must be between `0` and `COLORS - 1`.\nEach of r, g, b, must be a value between `0` and `1000`. When `init_color()`\nis used, all occurrences of that color on the screen immediately change to the\nnew definition. This function is a no-op on most terminals; it is active only\nif `can_change_color()` returns `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.init_pair()", "path": "library/curses#curses.init_pair", "type": "Operating System", "text": "\nChange the definition of a color-pair. It takes three arguments: the number of\nthe color-pair to be changed, the foreground color number, and the background\ncolor number. The value of pair_number must be between `1` and `COLOR_PAIRS -\n1` (the `0` color pair is wired to white on black and cannot be changed). The\nvalue of fg and bg arguments must be between `0` and `COLORS - 1`, or, after\ncalling `use_default_colors()`, `-1`. If the color-pair was previously\ninitialized, the screen is refreshed and all occurrences of that color-pair\nare changed to the new definition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.isendwin()", "path": "library/curses#curses.isendwin", "type": "Operating System", "text": "\nReturn `True` if `endwin()` has been called (that is, the curses library has\nbeen deinitialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.is_term_resized()", "path": "library/curses#curses.is_term_resized", "type": "Operating System", "text": "\nReturn `True` if `resize_term()` would modify the window structure, `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.keyname()", "path": "library/curses#curses.keyname", "type": "Operating System", "text": "\nReturn the name of the key numbered k as a bytes object. The name of a key\ngenerating printable ASCII character is the key\u2019s character. The name of a\ncontrol-key combination is a two-byte bytes object consisting of a caret\n(`b'^'`) followed by the corresponding printable ASCII character. The name of\nan alt-key combination (128\u2013255) is a bytes object consisting of the prefix\n`b'M-'` followed by the name of the corresponding ASCII character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.killchar()", "path": "library/curses#curses.killchar", "type": "Operating System", "text": "\nReturn the user\u2019s current line kill character as a one-byte bytes object.\nUnder Unix operating systems this is a property of the controlling tty of the\ncurses program, and is not set by the curses library itself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.longname()", "path": "library/curses#curses.longname", "type": "Operating System", "text": "\nReturn a bytes object containing the terminfo long name field describing the\ncurrent terminal. The maximum length of a verbose description is 128\ncharacters. It is defined only after the call to `initscr()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.meta()", "path": "library/curses#curses.meta", "type": "Operating System", "text": "\nIf flag is `True`, allow 8-bit characters to be input. If flag is `False`,\nallow only 7-bit chars.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.mouseinterval()", "path": "library/curses#curses.mouseinterval", "type": "Operating System", "text": "\nSet the maximum time in milliseconds that can elapse between press and release\nevents in order for them to be recognized as a click, and return the previous\ninterval value. The default value is 200 msec, or one fifth of a second.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.mousemask()", "path": "library/curses#curses.mousemask", "type": "Operating System", "text": "\nSet the mouse events to be reported, and return a tuple `(availmask,\noldmask)`. availmask indicates which of the specified mouse events can be\nreported; on complete failure it returns `0`. oldmask is the previous value of\nthe given window\u2019s mouse event mask. If this function is never called, no\nmouse events are ever reported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.napms()", "path": "library/curses#curses.napms", "type": "Operating System", "text": "\nSleep for ms milliseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ncurses_version", "path": "library/curses#curses.ncurses_version", "type": "Operating System", "text": "\nA named tuple containing the three components of the ncurses library version:\nmajor, minor, and patch. All values are integers. The components can also be\naccessed by name, so `curses.ncurses_version[0]` is equivalent to\n`curses.ncurses_version.major` and so on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.newpad()", "path": "library/curses#curses.newpad", "type": "Operating System", "text": "\nCreate and return a pointer to a new pad data structure with the given number\nof lines and columns. Return a pad as a window object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.newwin()", "path": "library/curses#curses.newwin", "type": "Operating System", "text": "\nReturn a new window, whose left-upper corner is at `(begin_y, begin_x)`, and\nwhose height/width is nlines/ncols.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.nl()", "path": "library/curses#curses.nl", "type": "Operating System", "text": "\nEnter newline mode. This mode translates the return key into newline on input,\nand translates newline into return and line-feed on output. Newline mode is\ninitially on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.nocbreak()", "path": "library/curses#curses.nocbreak", "type": "Operating System", "text": "\nLeave cbreak mode. Return to normal \u201ccooked\u201d mode with line buffering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.noecho()", "path": "library/curses#curses.noecho", "type": "Operating System", "text": "\nLeave echo mode. Echoing of input characters is turned off.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.nonl()", "path": "library/curses#curses.nonl", "type": "Operating System", "text": "\nLeave newline mode. Disable translation of return into newline on input, and\ndisable low-level translation of newline into newline/return on output (but\nthis does not change the behavior of `addch('\\n')`, which always does the\nequivalent of return and line feed on the virtual screen). With translation\noff, curses can sometimes speed up vertical motion a little; also, it will be\nable to detect the return key on input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.noqiflush()", "path": "library/curses#curses.noqiflush", "type": "Operating System", "text": "\nWhen the `noqiflush()` routine is used, normal flush of input and output\nqueues associated with the `INTR`, `QUIT` and `SUSP` characters will not be\ndone. You may want to call `noqiflush()` in a signal handler if you want\noutput to continue as though the interrupt had not occurred, after the handler\nexits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.noraw()", "path": "library/curses#curses.noraw", "type": "Operating System", "text": "\nLeave raw mode. Return to normal \u201ccooked\u201d mode with line buffering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.OK", "path": "library/curses#curses.OK", "type": "Operating System", "text": "\nSome curses routines that return an integer, such as `napms()`, return `OK`\nupon success.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.pair_content()", "path": "library/curses#curses.pair_content", "type": "Operating System", "text": "\nReturn a tuple `(fg, bg)` containing the colors for the requested color pair.\nThe value of pair_number must be between `0` and `COLOR_PAIRS - 1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.pair_number()", "path": "library/curses#curses.pair_number", "type": "Operating System", "text": "\nReturn the number of the color-pair set by the attribute value attr.\n`color_pair()` is the counterpart to this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel", "path": "library/curses.panel", "type": "Operating System", "text": "\nPanels are windows with the added feature of depth, so they can be stacked on\ntop of each other, and only the visible portions of each window will be\ndisplayed. Panels can be added, moved up or down in the stack, and removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.bottom_panel()", "path": "library/curses.panel#curses.panel.bottom_panel", "type": "Operating System", "text": "\nReturns the bottom panel in the panel stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.new_panel()", "path": "library/curses.panel#curses.panel.new_panel", "type": "Operating System", "text": "\nReturns a panel object, associating it with the given window win. Be aware\nthat you need to keep the returned panel object referenced explicitly. If you\ndon\u2019t, the panel object is garbage collected and removed from the panel stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.above()", "path": "library/curses.panel#curses.panel.Panel.above", "type": "Operating System", "text": "\nReturns the panel above the current panel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.below()", "path": "library/curses.panel#curses.panel.Panel.below", "type": "Operating System", "text": "\nReturns the panel below the current panel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.bottom()", "path": "library/curses.panel#curses.panel.Panel.bottom", "type": "Operating System", "text": "\nPush the panel to the bottom of the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.hidden()", "path": "library/curses.panel#curses.panel.Panel.hidden", "type": "Operating System", "text": "\nReturns `True` if the panel is hidden (not visible), `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.hide()", "path": "library/curses.panel#curses.panel.Panel.hide", "type": "Operating System", "text": "\nHide the panel. This does not delete the object, it just makes the window on\nscreen invisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.move()", "path": "library/curses.panel#curses.panel.Panel.move", "type": "Operating System", "text": "\nMove the panel to the screen coordinates `(y, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.replace()", "path": "library/curses.panel#curses.panel.Panel.replace", "type": "Operating System", "text": "\nChange the window associated with the panel to the window win.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.set_userptr()", "path": "library/curses.panel#curses.panel.Panel.set_userptr", "type": "Operating System", "text": "\nSet the panel\u2019s user pointer to obj. This is used to associate an arbitrary\npiece of data with the panel, and can be any Python object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.show()", "path": "library/curses.panel#curses.panel.Panel.show", "type": "Operating System", "text": "\nDisplay the panel (which might have been hidden).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.top()", "path": "library/curses.panel#curses.panel.Panel.top", "type": "Operating System", "text": "\nPush panel to the top of the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.userptr()", "path": "library/curses.panel#curses.panel.Panel.userptr", "type": "Operating System", "text": "\nReturns the user pointer for the panel. This might be any Python object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.window()", "path": "library/curses.panel#curses.panel.Panel.window", "type": "Operating System", "text": "\nReturns the window object associated with the panel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.top_panel()", "path": "library/curses.panel#curses.panel.top_panel", "type": "Operating System", "text": "\nReturns the top panel in the panel stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.update_panels()", "path": "library/curses.panel#curses.panel.update_panels", "type": "Operating System", "text": "\nUpdates the virtual screen after changes in the panel stack. This does not\ncall `curses.doupdate()`, so you\u2019ll have to do this yourself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.putp()", "path": "library/curses#curses.putp", "type": "Operating System", "text": "\nEquivalent to `tputs(str, 1, putchar)`; emit the value of a specified terminfo\ncapability for the current terminal. Note that the output of `putp()` always\ngoes to standard output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.qiflush()", "path": "library/curses#curses.qiflush", "type": "Operating System", "text": "\nIf flag is `False`, the effect is the same as calling `noqiflush()`. If flag\nis `True`, or no argument is provided, the queues will be flushed when these\ncontrol characters are read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.raw()", "path": "library/curses#curses.raw", "type": "Operating System", "text": "\nEnter raw mode. In raw mode, normal line buffering and processing of\ninterrupt, quit, suspend, and flow control keys are turned off; characters are\npresented to curses input functions one by one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.resetty()", "path": "library/curses#curses.resetty", "type": "Operating System", "text": "\nRestore the state of the terminal modes to what it was at the last call to\n`savetty()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.reset_prog_mode()", "path": "library/curses#curses.reset_prog_mode", "type": "Operating System", "text": "\nRestore the terminal to \u201cprogram\u201d mode, as previously saved by\n`def_prog_mode()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.reset_shell_mode()", "path": "library/curses#curses.reset_shell_mode", "type": "Operating System", "text": "\nRestore the terminal to \u201cshell\u201d mode, as previously saved by\n`def_shell_mode()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.resizeterm()", "path": "library/curses#curses.resizeterm", "type": "Operating System", "text": "\nResize the standard and current windows to the specified dimensions, and\nadjusts other bookkeeping data used by the curses library that record the\nwindow dimensions (in particular the SIGWINCH handler).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.resize_term()", "path": "library/curses#curses.resize_term", "type": "Operating System", "text": "\nBackend function used by `resizeterm()`, performing most of the work; when\nresizing the windows, `resize_term()` blank-fills the areas that are extended.\nThe calling application should fill in these areas with appropriate data. The\n`resize_term()` function attempts to resize all windows. However, due to the\ncalling convention of pads, it is not possible to resize these without\nadditional interaction with the application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.savetty()", "path": "library/curses#curses.savetty", "type": "Operating System", "text": "\nSave the current state of the terminal modes in a buffer, usable by\n`resetty()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.setsyx()", "path": "library/curses#curses.setsyx", "type": "Operating System", "text": "\nSet the virtual screen cursor to y, x. If y and x are both `-1`, then\n`leaveok` is set `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.setupterm()", "path": "library/curses#curses.setupterm", "type": "Operating System", "text": "\nInitialize the terminal. term is a string giving the terminal name, or `None`;\nif omitted or `None`, the value of the `TERM` environment variable will be\nused. fd is the file descriptor to which any initialization sequences will be\nsent; if not supplied or `-1`, the file descriptor for `sys.stdout` will be\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.set_escdelay()", "path": "library/curses#curses.set_escdelay", "type": "Operating System", "text": "\nSets the number of milliseconds to wait after reading an escape character, to\ndistinguish between an individual escape character entered on the keyboard\nfrom escape sequences sent by cursor and function keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.set_tabsize()", "path": "library/curses#curses.set_tabsize", "type": "Operating System", "text": "\nSets the number of columns used by the curses library when converting a tab\ncharacter to spaces as it adds the tab to a window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.start_color()", "path": "library/curses#curses.start_color", "type": "Operating System", "text": "\nMust be called if the programmer wants to use colors, and before any other\ncolor manipulation routine is called. It is good practice to call this routine\nright after `initscr()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.termattrs()", "path": "library/curses#curses.termattrs", "type": "Operating System", "text": "\nReturn a logical OR of all video attributes supported by the terminal. This\ninformation is useful when a curses program needs complete control over the\nappearance of the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.termname()", "path": "library/curses#curses.termname", "type": "Operating System", "text": "\nReturn the value of the environment variable `TERM`, as a bytes object,\ntruncated to 14 characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.rectangle()", "path": "library/curses#curses.textpad.rectangle", "type": "Operating System", "text": "\nDraw a rectangle. The first argument must be a window object; the remaining\narguments are coordinates relative to that window. The second and third\narguments are the y and x coordinates of the upper left hand corner of the\nrectangle to be drawn; the fourth and fifth arguments are the y and x\ncoordinates of the lower right hand corner. The rectangle will be drawn using\nVT100/IBM PC forms characters on terminals that make this possible (including\nxterm and most other software terminal emulators). Otherwise it will be drawn\nwith ASCII dashes, vertical bars, and plus signs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox", "path": "library/curses#curses.textpad.Textbox", "type": "Operating System", "text": "\nReturn a textbox widget object. The win argument should be a curses window\nobject in which the textbox is to be contained. The edit cursor of the textbox\nis initially located at the upper left hand corner of the containing window,\nwith coordinates `(0, 0)`. The instance\u2019s `stripspaces` flag is initially on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.do_command()", "path": "library/curses#curses.textpad.Textbox.do_command", "type": "Operating System", "text": "\nProcess a single command keystroke. Here are the supported special keystrokes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.edit()", "path": "library/curses#curses.textpad.Textbox.edit", "type": "Operating System", "text": "\nThis is the entry point you will normally use. It accepts editing keystrokes\nuntil one of the termination keystrokes is entered. If validator is supplied,\nit must be a function. It will be called for each keystroke entered with the\nkeystroke as a parameter; command dispatch is done on the result. This method\nreturns the window contents as a string; whether blanks in the window are\nincluded is affected by the `stripspaces` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.gather()", "path": "library/curses#curses.textpad.Textbox.gather", "type": "Operating System", "text": "\nReturn the window contents as a string; whether blanks in the window are\nincluded is affected by the `stripspaces` member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.stripspaces", "path": "library/curses#curses.textpad.Textbox.stripspaces", "type": "Operating System", "text": "\nThis attribute is a flag which controls the interpretation of blanks in the\nwindow. When it is on, trailing blanks on each line are ignored; any cursor\nmotion that would land the cursor on a trailing blank goes to the end of that\nline instead, and trailing blanks are stripped when the window contents are\ngathered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tigetflag()", "path": "library/curses#curses.tigetflag", "type": "Operating System", "text": "\nReturn the value of the Boolean capability corresponding to the terminfo\ncapability name capname as an integer. Return the value `-1` if capname is not\na Boolean capability, or `0` if it is canceled or absent from the terminal\ndescription.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tigetnum()", "path": "library/curses#curses.tigetnum", "type": "Operating System", "text": "\nReturn the value of the numeric capability corresponding to the terminfo\ncapability name capname as an integer. Return the value `-2` if capname is not\na numeric capability, or `-1` if it is canceled or absent from the terminal\ndescription.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tigetstr()", "path": "library/curses#curses.tigetstr", "type": "Operating System", "text": "\nReturn the value of the string capability corresponding to the terminfo\ncapability name capname as a bytes object. Return `None` if capname is not a\nterminfo \u201cstring capability\u201d, or is canceled or absent from the terminal\ndescription.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tparm()", "path": "library/curses#curses.tparm", "type": "Operating System", "text": "\nInstantiate the bytes object str with the supplied parameters, where str\nshould be a parameterized string obtained from the terminfo database. E.g.\n`tparm(tigetstr(\"cup\"), 5, 3)` could result in `b'\\033[6;4H'`, the exact\nresult depending on terminal type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.typeahead()", "path": "library/curses#curses.typeahead", "type": "Operating System", "text": "\nSpecify that the file descriptor fd be used for typeahead checking. If fd is\n`-1`, then no typeahead checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.unctrl()", "path": "library/curses#curses.unctrl", "type": "Operating System", "text": "\nReturn a bytes object which is a printable representation of the character ch.\nControl characters are represented as a caret followed by the character, for\nexample as `b'^C'`. Printing characters are left as they are.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ungetch()", "path": "library/curses#curses.ungetch", "type": "Operating System", "text": "\nPush ch so the next `getch()` will return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ungetmouse()", "path": "library/curses#curses.ungetmouse", "type": "Operating System", "text": "\nPush a `KEY_MOUSE` event onto the input queue, associating the given state\ndata with it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.unget_wch()", "path": "library/curses#curses.unget_wch", "type": "Operating System", "text": "\nPush ch so the next `get_wch()` will return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.update_lines_cols()", "path": "library/curses#curses.update_lines_cols", "type": "Operating System", "text": "\nUpdate `LINES` and `COLS`. Useful for detecting manual screen resize.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.use_default_colors()", "path": "library/curses#curses.use_default_colors", "type": "Operating System", "text": "\nAllow use of default values for colors on terminals supporting this feature.\nUse this to support transparency in your application. The default color is\nassigned to the color number `-1`. After calling this function, `init_pair(x,\ncurses.COLOR_RED, -1)` initializes, for instance, color pair x to a red\nforeground color on the default background.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.use_env()", "path": "library/curses#curses.use_env", "type": "Operating System", "text": "\nIf used, this function should be called before `initscr()` or newterm are\ncalled. When flag is `False`, the values of lines and columns specified in the\nterminfo database will be used, even if environment variables `LINES` and\n`COLUMNS` (used by default) are set, or if curses is running in a window (in\nwhich case default behavior would be to use the window size if `LINES` and\n`COLUMNS` are not set).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.version", "path": "library/curses#curses.version", "type": "Operating System", "text": "\nA bytes object representing the current version of the module. Also available\nas `__version__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.addch()", "path": "library/curses#curses.window.addch", "type": "Operating System", "text": "\nPaint character ch at `(y, x)` with attributes attr, overwriting any character\npreviously painted at that location. By default, the character position and\nattributes are the current settings for the window object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.addnstr()", "path": "library/curses#curses.window.addnstr", "type": "Operating System", "text": "\nPaint at most n characters of the character string str at `(y, x)` with\nattributes attr, overwriting anything previously on the display.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.addstr()", "path": "library/curses#curses.window.addstr", "type": "Operating System", "text": "\nPaint the character string str at `(y, x)` with attributes attr, overwriting\nanything previously on the display.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.attroff()", "path": "library/curses#curses.window.attroff", "type": "Operating System", "text": "\nRemove attribute attr from the \u201cbackground\u201d set applied to all writes to the\ncurrent window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.attron()", "path": "library/curses#curses.window.attron", "type": "Operating System", "text": "\nAdd attribute attr from the \u201cbackground\u201d set applied to all writes to the\ncurrent window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.attrset()", "path": "library/curses#curses.window.attrset", "type": "Operating System", "text": "\nSet the \u201cbackground\u201d set of attributes to attr. This set is initially `0` (no\nattributes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.bkgd()", "path": "library/curses#curses.window.bkgd", "type": "Operating System", "text": "\nSet the background property of the window to the character ch, with attributes\nattr. The change is then applied to every character position in that window:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.bkgdset()", "path": "library/curses#curses.window.bkgdset", "type": "Operating System", "text": "\nSet the window\u2019s background. A window\u2019s background consists of a character and\nany combination of attributes. The attribute part of the background is\ncombined (OR\u2019ed) with all non-blank characters that are written into the\nwindow. Both the character and attribute parts of the background are combined\nwith the blank characters. The background becomes a property of the character\nand moves with the character through any scrolling and insert/delete\nline/character operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.border()", "path": "library/curses#curses.window.border", "type": "Operating System", "text": "\nDraw a border around the edges of the window. Each parameter specifies the\ncharacter to use for a specific part of the border; see the table below for\nmore details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.box()", "path": "library/curses#curses.window.box", "type": "Operating System", "text": "\nSimilar to `border()`, but both ls and rs are vertch and both ts and bs are\nhorch. The default corner characters are always used by this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.chgat()", "path": "library/curses#curses.window.chgat", "type": "Operating System", "text": "\nSet the attributes of num characters at the current cursor position, or at\nposition `(y, x)` if supplied. If num is not given or is `-1`, the attribute\nwill be set on all the characters to the end of the line. This function moves\ncursor to position `(y, x)` if supplied. The changed line will be touched\nusing the `touchline()` method so that the contents will be redisplayed by the\nnext window refresh.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clear()", "path": "library/curses#curses.window.clear", "type": "Operating System", "text": "\nLike `erase()`, but also cause the whole window to be repainted upon next call\nto `refresh()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clearok()", "path": "library/curses#curses.window.clearok", "type": "Operating System", "text": "\nIf flag is `True`, the next call to `refresh()` will clear the window\ncompletely.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clrtobot()", "path": "library/curses#curses.window.clrtobot", "type": "Operating System", "text": "\nErase from cursor to the end of the window: all lines below the cursor are\ndeleted, and then the equivalent of `clrtoeol()` is performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clrtoeol()", "path": "library/curses#curses.window.clrtoeol", "type": "Operating System", "text": "\nErase from cursor to the end of the line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.cursyncup()", "path": "library/curses#curses.window.cursyncup", "type": "Operating System", "text": "\nUpdate the current cursor position of all the ancestors of the window to\nreflect the current cursor position of the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.delch()", "path": "library/curses#curses.window.delch", "type": "Operating System", "text": "\nDelete any character at `(y, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.deleteln()", "path": "library/curses#curses.window.deleteln", "type": "Operating System", "text": "\nDelete the line under the cursor. All following lines are moved up by one\nline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.derwin()", "path": "library/curses#curses.window.derwin", "type": "Operating System", "text": "\nAn abbreviation for \u201cderive window\u201d, `derwin()` is the same as calling\n`subwin()`, except that begin_y and begin_x are relative to the origin of the\nwindow, rather than relative to the entire screen. Return a window object for\nthe derived window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.echochar()", "path": "library/curses#curses.window.echochar", "type": "Operating System", "text": "\nAdd character ch with attribute attr, and immediately call `refresh()` on the\nwindow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.enclose()", "path": "library/curses#curses.window.enclose", "type": "Operating System", "text": "\nTest whether the given pair of screen-relative character-cell coordinates are\nenclosed by the given window, returning `True` or `False`. It is useful for\ndetermining what subset of the screen windows enclose the location of a mouse\nevent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.encoding", "path": "library/curses#curses.window.encoding", "type": "Operating System", "text": "\nEncoding used to encode method arguments (Unicode strings and characters). The\nencoding attribute is inherited from the parent window when a subwindow is\ncreated, for example with `window.subwin()`. By default, the locale encoding\nis used (see `locale.getpreferredencoding()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.erase()", "path": "library/curses#curses.window.erase", "type": "Operating System", "text": "\nClear the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getbegyx()", "path": "library/curses#curses.window.getbegyx", "type": "Operating System", "text": "\nReturn a tuple `(y, x)` of co-ordinates of upper-left corner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getbkgd()", "path": "library/curses#curses.window.getbkgd", "type": "Operating System", "text": "\nReturn the given window\u2019s current background character/attribute pair.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getch()", "path": "library/curses#curses.window.getch", "type": "Operating System", "text": "\nGet a character. Note that the integer returned does not have to be in ASCII\nrange: function keys, keypad keys and so on are represented by numbers higher\nthan 255. In no-delay mode, return `-1` if there is no input, otherwise wait\nuntil a key is pressed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getkey()", "path": "library/curses#curses.window.getkey", "type": "Operating System", "text": "\nGet a character, returning a string instead of an integer, as `getch()` does.\nFunction keys, keypad keys and other special keys return a multibyte string\ncontaining the key name. In no-delay mode, raise an exception if there is no\ninput.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getmaxyx()", "path": "library/curses#curses.window.getmaxyx", "type": "Operating System", "text": "\nReturn a tuple `(y, x)` of the height and width of the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getparyx()", "path": "library/curses#curses.window.getparyx", "type": "Operating System", "text": "\nReturn the beginning coordinates of this window relative to its parent window\nas a tuple `(y, x)`. Return `(-1, -1)` if this window has no parent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getstr()", "path": "library/curses#curses.window.getstr", "type": "Operating System", "text": "\nRead a bytes object from the user, with primitive line editing capacity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getyx()", "path": "library/curses#curses.window.getyx", "type": "Operating System", "text": "\nReturn a tuple `(y, x)` of current cursor position relative to the window\u2019s\nupper-left corner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.get_wch()", "path": "library/curses#curses.window.get_wch", "type": "Operating System", "text": "\nGet a wide character. Return a character for most keys, or an integer for\nfunction keys, keypad keys, and other special keys. In no-delay mode, raise an\nexception if there is no input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.hline()", "path": "library/curses#curses.window.hline", "type": "Operating System", "text": "\nDisplay a horizontal line starting at `(y, x)` with length n consisting of the\ncharacter ch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.idcok()", "path": "library/curses#curses.window.idcok", "type": "Operating System", "text": "\nIf flag is `False`, curses no longer considers using the hardware\ninsert/delete character feature of the terminal; if flag is `True`, use of\ncharacter insertion and deletion is enabled. When curses is first initialized,\nuse of character insert/delete is enabled by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.idlok()", "path": "library/curses#curses.window.idlok", "type": "Operating System", "text": "\nIf flag is `True`, `curses` will try and use hardware line editing facilities.\nOtherwise, line insertion/deletion are disabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.immedok()", "path": "library/curses#curses.window.immedok", "type": "Operating System", "text": "\nIf flag is `True`, any change in the window image automatically causes the\nwindow to be refreshed; you no longer have to call `refresh()` yourself.\nHowever, it may degrade performance considerably, due to repeated calls to\nwrefresh. This option is disabled by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.inch()", "path": "library/curses#curses.window.inch", "type": "Operating System", "text": "\nReturn the character at the given position in the window. The bottom 8 bits\nare the character proper, and upper bits are the attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insch()", "path": "library/curses#curses.window.insch", "type": "Operating System", "text": "\nPaint character ch at `(y, x)` with attributes attr, moving the line from\nposition x right by one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insdelln()", "path": "library/curses#curses.window.insdelln", "type": "Operating System", "text": "\nInsert nlines lines into the specified window above the current line. The\nnlines bottom lines are lost. For negative nlines, delete nlines lines\nstarting with the one under the cursor, and move the remaining lines up. The\nbottom nlines lines are cleared. The current cursor position remains the same.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insertln()", "path": "library/curses#curses.window.insertln", "type": "Operating System", "text": "\nInsert a blank line under the cursor. All following lines are moved down by\none line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insnstr()", "path": "library/curses#curses.window.insnstr", "type": "Operating System", "text": "\nInsert a character string (as many characters as will fit on the line) before\nthe character under the cursor, up to n characters. If n is zero or negative,\nthe entire string is inserted. All characters to the right of the cursor are\nshifted right, with the rightmost characters on the line being lost. The\ncursor position does not change (after moving to y, x, if specified).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insstr()", "path": "library/curses#curses.window.insstr", "type": "Operating System", "text": "\nInsert a character string (as many characters as will fit on the line) before\nthe character under the cursor. All characters to the right of the cursor are\nshifted right, with the rightmost characters on the line being lost. The\ncursor position does not change (after moving to y, x, if specified).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.instr()", "path": "library/curses#curses.window.instr", "type": "Operating System", "text": "\nReturn a bytes object of characters, extracted from the window starting at the\ncurrent cursor position, or at y, x if specified. Attributes are stripped from\nthe characters. If n is specified, `instr()` returns a string at most n\ncharacters long (exclusive of the trailing NUL).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.is_linetouched()", "path": "library/curses#curses.window.is_linetouched", "type": "Operating System", "text": "\nReturn `True` if the specified line was modified since the last call to\n`refresh()`; otherwise return `False`. Raise a `curses.error` exception if\nline is not valid for the given window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.is_wintouched()", "path": "library/curses#curses.window.is_wintouched", "type": "Operating System", "text": "\nReturn `True` if the specified window was modified since the last call to\n`refresh()`; otherwise return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.keypad()", "path": "library/curses#curses.window.keypad", "type": "Operating System", "text": "\nIf flag is `True`, escape sequences generated by some keys (keypad, function\nkeys) will be interpreted by `curses`. If flag is `False`, escape sequences\nwill be left as is in the input stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.leaveok()", "path": "library/curses#curses.window.leaveok", "type": "Operating System", "text": "\nIf flag is `True`, cursor is left where it is on update, instead of being at\n\u201ccursor position.\u201d This reduces cursor movement where possible. If possible\nthe cursor will be made invisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.move()", "path": "library/curses#curses.window.move", "type": "Operating System", "text": "\nMove cursor to `(new_y, new_x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.mvderwin()", "path": "library/curses#curses.window.mvderwin", "type": "Operating System", "text": "\nMove the window inside its parent window. The screen-relative parameters of\nthe window are not changed. This routine is used to display different parts of\nthe parent window at the same physical position on the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.mvwin()", "path": "library/curses#curses.window.mvwin", "type": "Operating System", "text": "\nMove the window so its upper-left corner is at `(new_y, new_x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.nodelay()", "path": "library/curses#curses.window.nodelay", "type": "Operating System", "text": "\nIf flag is `True`, `getch()` will be non-blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.notimeout()", "path": "library/curses#curses.window.notimeout", "type": "Operating System", "text": "\nIf flag is `True`, escape sequences will not be timed out.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.noutrefresh()", "path": "library/curses#curses.window.noutrefresh", "type": "Operating System", "text": "\nMark for refresh but wait. This function updates the data structure\nrepresenting the desired state of the window, but does not force an update of\nthe physical screen. To accomplish that, call `doupdate()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.overlay()", "path": "library/curses#curses.window.overlay", "type": "Operating System", "text": "\nOverlay the window on top of destwin. The windows need not be the same size,\nonly the overlapping region is copied. This copy is non-destructive, which\nmeans that the current background character does not overwrite the old\ncontents of destwin.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.overwrite()", "path": "library/curses#curses.window.overwrite", "type": "Operating System", "text": "\nOverwrite the window on top of destwin. The windows need not be the same size,\nin which case only the overlapping region is copied. This copy is destructive,\nwhich means that the current background character overwrites the old contents\nof destwin.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.putwin()", "path": "library/curses#curses.window.putwin", "type": "Operating System", "text": "\nWrite all data associated with the window into the provided file object. This\ninformation can be later retrieved using the `getwin()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.redrawln()", "path": "library/curses#curses.window.redrawln", "type": "Operating System", "text": "\nIndicate that the num screen lines, starting at line beg, are corrupted and\nshould be completely redrawn on the next `refresh()` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.redrawwin()", "path": "library/curses#curses.window.redrawwin", "type": "Operating System", "text": "\nTouch the entire window, causing it to be completely redrawn on the next\n`refresh()` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.refresh()", "path": "library/curses#curses.window.refresh", "type": "Operating System", "text": "\nUpdate the display immediately (sync actual screen with previous\ndrawing/deleting methods).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.resize()", "path": "library/curses#curses.window.resize", "type": "Operating System", "text": "\nReallocate storage for a curses window to adjust its dimensions to the\nspecified values. If either dimension is larger than the current values, the\nwindow\u2019s data is filled with blanks that have the current background rendition\n(as set by `bkgdset()`) merged into them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.scroll()", "path": "library/curses#curses.window.scroll", "type": "Operating System", "text": "\nScroll the screen or scrolling region upward by lines lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.scrollok()", "path": "library/curses#curses.window.scrollok", "type": "Operating System", "text": "\nControl what happens when the cursor of a window is moved off the edge of the\nwindow or scrolling region, either as a result of a newline action on the\nbottom line, or typing the last character of the last line. If flag is\n`False`, the cursor is left on the bottom line. If flag is `True`, the window\nis scrolled up one line. Note that in order to get the physical scrolling\neffect on the terminal, it is also necessary to call `idlok()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.setscrreg()", "path": "library/curses#curses.window.setscrreg", "type": "Operating System", "text": "\nSet the scrolling region from line top to line bottom. All scrolling actions\nwill take place in this region.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.standend()", "path": "library/curses#curses.window.standend", "type": "Operating System", "text": "\nTurn off the standout attribute. On some terminals this has the side effect of\nturning off all attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.standout()", "path": "library/curses#curses.window.standout", "type": "Operating System", "text": "\nTurn on attribute A_STANDOUT.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.subpad()", "path": "library/curses#curses.window.subpad", "type": "Operating System", "text": "\nReturn a sub-window, whose upper-left corner is at `(begin_y, begin_x)`, and\nwhose width/height is ncols/nlines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.subwin()", "path": "library/curses#curses.window.subwin", "type": "Operating System", "text": "\nReturn a sub-window, whose upper-left corner is at `(begin_y, begin_x)`, and\nwhose width/height is ncols/nlines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.syncdown()", "path": "library/curses#curses.window.syncdown", "type": "Operating System", "text": "\nTouch each location in the window that has been touched in any of its ancestor\nwindows. This routine is called by `refresh()`, so it should almost never be\nnecessary to call it manually.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.syncok()", "path": "library/curses#curses.window.syncok", "type": "Operating System", "text": "\nIf flag is `True`, then `syncup()` is called automatically whenever there is a\nchange in the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.syncup()", "path": "library/curses#curses.window.syncup", "type": "Operating System", "text": "\nTouch all locations in ancestors of the window that have been changed in the\nwindow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.timeout()", "path": "library/curses#curses.window.timeout", "type": "Operating System", "text": "\nSet blocking or non-blocking read behavior for the window. If delay is\nnegative, blocking read is used (which will wait indefinitely for input). If\ndelay is zero, then non-blocking read is used, and `getch()` will return `-1`\nif no input is waiting. If delay is positive, then `getch()` will block for\ndelay milliseconds, and return `-1` if there is still no input at the end of\nthat time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.touchline()", "path": "library/curses#curses.window.touchline", "type": "Operating System", "text": "\nPretend count lines have been changed, starting with line start. If changed is\nsupplied, it specifies whether the affected lines are marked as having been\nchanged (changed`=True`) or unchanged (changed`=False`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.touchwin()", "path": "library/curses#curses.window.touchwin", "type": "Operating System", "text": "\nPretend the whole window has been changed, for purposes of drawing\noptimizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.untouchwin()", "path": "library/curses#curses.window.untouchwin", "type": "Operating System", "text": "\nMark all lines in the window as unchanged since the last call to `refresh()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.vline()", "path": "library/curses#curses.window.vline", "type": "Operating System", "text": "\nDisplay a vertical line starting at `(y, x)` with length n consisting of the\ncharacter ch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.wrapper()", "path": "library/curses#curses.wrapper", "type": "Operating System", "text": "\nInitialize curses and call another callable object, func, which should be the\nrest of your curses-using application. If the application raises an exception,\nthis function will restore the terminal to a sane state before re-raising the\nexception and generating a traceback. The callable object func is then passed\nthe main window \u2018stdscr\u2019 as its first argument, followed by any other\narguments passed to `wrapper()`. Before calling func, `wrapper()` turns on\ncbreak mode, turns off echo, enables the terminal keypad, and initializes\ncolors if the terminal has color support. On exit (whether normally or by\nexception) it restores cooked mode, turns on echo, and disables the terminal\nkeypad.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses", "path": "library/dataclasses", "type": "Runtime", "text": "\nSource code: Lib/dataclasses.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.asdict()", "path": "library/dataclasses#dataclasses.asdict", "type": "Runtime", "text": "\nConverts the dataclass `instance` to a dict (by using the factory function\n`dict_factory`). Each dataclass is converted to a dict of its fields, as\n`name: value` pairs. dataclasses, dicts, lists, and tuples are recursed into.\nFor example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.astuple()", "path": "library/dataclasses#dataclasses.astuple", "type": "Runtime", "text": "\nConverts the dataclass `instance` to a tuple (by using the factory function\n`tuple_factory`). Each dataclass is converted to a tuple of its field values.\ndataclasses, dicts, lists, and tuples are recursed into.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.dataclass()", "path": "library/dataclasses#dataclasses.dataclass", "type": "Runtime", "text": "\nThis function is a decorator that is used to add generated special methods to\nclasses, as described below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.Field", "path": "library/dataclasses#dataclasses.Field", "type": "Runtime", "text": "\n`Field` objects describe each defined field. These objects are created\ninternally, and are returned by the `fields()` module-level method (see\nbelow). Users should never instantiate a `Field` object directly. Its\ndocumented attributes are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.field()", "path": "library/dataclasses#dataclasses.field", "type": "Runtime", "text": "\nFor common and simple use cases, no other functionality is required. There\nare, however, some dataclass features that require additional per-field\ninformation. To satisfy this need for additional information, you can replace\nthe default field value with a call to the provided `field()` function. For\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.fields()", "path": "library/dataclasses#dataclasses.fields", "type": "Runtime", "text": "\nReturns a tuple of `Field` objects that define the fields for this dataclass.\nAccepts either a dataclass, or an instance of a dataclass. Raises `TypeError`\nif not passed a dataclass or instance of one. Does not return pseudo-fields\nwhich are `ClassVar` or `InitVar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.FrozenInstanceError", "path": "library/dataclasses#dataclasses.FrozenInstanceError", "type": "Runtime", "text": "\nRaised when an implicitly defined `__setattr__()` or `__delattr__()` is called\non a dataclass which was defined with `frozen=True`. It is a subclass of\n`AttributeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.is_dataclass()", "path": "library/dataclasses#dataclasses.is_dataclass", "type": "Runtime", "text": "\nReturn `True` if its parameter is a dataclass or an instance of one, otherwise\nreturn `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.make_dataclass()", "path": "library/dataclasses#dataclasses.make_dataclass", "type": "Runtime", "text": "\nCreates a new dataclass with name `cls_name`, fields as defined in `fields`,\nbase classes as given in `bases`, and initialized with a namespace as given in\n`namespace`. `fields` is an iterable whose elements are each either `name`,\n`(name, type)`, or `(name, type, Field)`. If just `name` is supplied,\n`typing.Any` is used for `type`. The values of `init`, `repr`, `eq`, `order`,\n`unsafe_hash`, and `frozen` have the same meaning as they do in `dataclass()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.replace()", "path": "library/dataclasses#dataclasses.replace", "type": "Runtime", "text": "\nCreates a new object of the same type of `instance`, replacing fields with\nvalues from `changes`. If `instance` is not a Data Class, raises `TypeError`.\nIf values in `changes` do not specify fields, raises `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime", "path": "library/datetime", "type": "Data Types", "text": "\nSource code: Lib/datetime.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date", "path": "library/datetime#datetime.date", "type": "Data Types", "text": "\nAll arguments are required. Arguments must be integers, in the following\nranges:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.ctime()", "path": "library/datetime#datetime.date.ctime", "type": "Data Types", "text": "\nReturn a string representing the date:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.day", "path": "library/datetime#datetime.date.day", "type": "Data Types", "text": "\nBetween 1 and the number of days in the given month of the given year.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromisocalendar()", "path": "library/datetime#datetime.date.fromisocalendar", "type": "Data Types", "text": "\nReturn a `date` corresponding to the ISO calendar date specified by year, week\nand day. This is the inverse of the function `date.isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromisoformat()", "path": "library/datetime#datetime.date.fromisoformat", "type": "Data Types", "text": "\nReturn a `date` corresponding to a date_string given in the format `YYYY-MM-\nDD`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromordinal()", "path": "library/datetime#datetime.date.fromordinal", "type": "Data Types", "text": "\nReturn the date corresponding to the proleptic Gregorian ordinal, where\nJanuary 1 of year 1 has ordinal 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromtimestamp()", "path": "library/datetime#datetime.date.fromtimestamp", "type": "Data Types", "text": "\nReturn the local date corresponding to the POSIX timestamp, such as is\nreturned by `time.time()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.isocalendar()", "path": "library/datetime#datetime.date.isocalendar", "type": "Data Types", "text": "\nReturn a named tuple object with three components: `year`, `week` and\n`weekday`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.isoformat()", "path": "library/datetime#datetime.date.isoformat", "type": "Data Types", "text": "\nReturn a string representing the date in ISO 8601 format, `YYYY-MM-DD`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.isoweekday()", "path": "library/datetime#datetime.date.isoweekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 1 and Sunday is 7.\nFor example, `date(2002, 12, 4).isoweekday() == 3`, a Wednesday. See also\n`weekday()`, `isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.max", "path": "library/datetime#datetime.date.max", "type": "Data Types", "text": "\nThe latest representable date, `date(MAXYEAR, 12, 31)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.min", "path": "library/datetime#datetime.date.min", "type": "Data Types", "text": "\nThe earliest representable date, `date(MINYEAR, 1, 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.month", "path": "library/datetime#datetime.date.month", "type": "Data Types", "text": "\nBetween 1 and 12 inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.replace()", "path": "library/datetime#datetime.date.replace", "type": "Data Types", "text": "\nReturn a date with the same value, except for those parameters given new\nvalues by whichever keyword arguments are specified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.resolution", "path": "library/datetime#datetime.date.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal date objects,\n`timedelta(days=1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.strftime()", "path": "library/datetime#datetime.date.strftime", "type": "Data Types", "text": "\nReturn a string representing the date, controlled by an explicit format\nstring. Format codes referring to hours, minutes or seconds will see 0 values.\nFor a complete list of formatting directives, see strftime() and strptime()\nBehavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.timetuple()", "path": "library/datetime#datetime.date.timetuple", "type": "Data Types", "text": "\nReturn a `time.struct_time` such as returned by `time.localtime()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.today()", "path": "library/datetime#datetime.date.today", "type": "Data Types", "text": "\nReturn the current local date.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.toordinal()", "path": "library/datetime#datetime.date.toordinal", "type": "Data Types", "text": "\nReturn the proleptic Gregorian ordinal of the date, where January 1 of year 1\nhas ordinal 1. For any `date` object d, `date.fromordinal(d.toordinal()) ==\nd`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.weekday()", "path": "library/datetime#datetime.date.weekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 0 and Sunday is 6.\nFor example, `date(2002, 12, 4).weekday() == 2`, a Wednesday. See also\n`isoweekday()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.year", "path": "library/datetime#datetime.date.year", "type": "Data Types", "text": "\nBetween `MINYEAR` and `MAXYEAR` inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.__format__()", "path": "library/datetime#datetime.date.__format__", "type": "Data Types", "text": "\nSame as `date.strftime()`. This makes it possible to specify a format string\nfor a `date` object in formatted string literals and when using\n`str.format()`. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.__str__()", "path": "library/datetime#datetime.date.__str__", "type": "Data Types", "text": "\nFor a date d, `str(d)` is equivalent to `d.isoformat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime", "path": "library/datetime#datetime.datetime", "type": "Data Types", "text": "\nThe year, month and day arguments are required. tzinfo may be `None`, or an\ninstance of a `tzinfo` subclass. The remaining arguments must be integers in\nthe following ranges:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.astimezone()", "path": "library/datetime#datetime.datetime.astimezone", "type": "Data Types", "text": "\nReturn a `datetime` object with new `tzinfo` attribute tz, adjusting the date\nand time data so the result is the same UTC time as self, but in tz\u2019s local\ntime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.combine()", "path": "library/datetime#datetime.datetime.combine", "type": "Data Types", "text": "\nReturn a new `datetime` object whose date components are equal to the given\n`date` object\u2019s, and whose time components are equal to the given `time`\nobject\u2019s. If the tzinfo argument is provided, its value is used to set the\n`tzinfo` attribute of the result, otherwise the `tzinfo` attribute of the time\nargument is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.ctime()", "path": "library/datetime#datetime.datetime.ctime", "type": "Data Types", "text": "\nReturn a string representing the date and time:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.date()", "path": "library/datetime#datetime.datetime.date", "type": "Data Types", "text": "\nReturn `date` object with same year, month and day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.day", "path": "library/datetime#datetime.datetime.day", "type": "Data Types", "text": "\nBetween 1 and the number of days in the given month of the given year.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.dst()", "path": "library/datetime#datetime.datetime.dst", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns `self.tzinfo.dst(self)`,\nand raises an exception if the latter doesn\u2019t return `None` or a `timedelta`\nobject with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fold", "path": "library/datetime#datetime.datetime.fold", "type": "Data Types", "text": "\nIn `[0, 1]`. Used to disambiguate wall times during a repeated interval. (A\nrepeated interval occurs when clocks are rolled back at the end of daylight\nsaving time or when the UTC offset for the current zone is decreased for\npolitical reasons.) The value 0 (1) represents the earlier (later) of the two\nmoments with the same wall time representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromisocalendar()", "path": "library/datetime#datetime.datetime.fromisocalendar", "type": "Data Types", "text": "\nReturn a `datetime` corresponding to the ISO calendar date specified by year,\nweek and day. The non-date components of the datetime are populated with their\nnormal default values. This is the inverse of the function\n`datetime.isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromisoformat()", "path": "library/datetime#datetime.datetime.fromisoformat", "type": "Data Types", "text": "\nReturn a `datetime` corresponding to a date_string in one of the formats\nemitted by `date.isoformat()` and `datetime.isoformat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromordinal()", "path": "library/datetime#datetime.datetime.fromordinal", "type": "Data Types", "text": "\nReturn the `datetime` corresponding to the proleptic Gregorian ordinal, where\nJanuary 1 of year 1 has ordinal 1. `ValueError` is raised unless `1 <= ordinal\n<= datetime.max.toordinal()`. The hour, minute, second and microsecond of the\nresult are all 0, and `tzinfo` is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromtimestamp()", "path": "library/datetime#datetime.datetime.fromtimestamp", "type": "Data Types", "text": "\nReturn the local date and time corresponding to the POSIX timestamp, such as\nis returned by `time.time()`. If optional argument tz is `None` or not\nspecified, the timestamp is converted to the platform\u2019s local date and time,\nand the returned `datetime` object is naive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.hour", "path": "library/datetime#datetime.datetime.hour", "type": "Data Types", "text": "\nIn `range(24)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.isocalendar()", "path": "library/datetime#datetime.datetime.isocalendar", "type": "Data Types", "text": "\nReturn a named tuple with three components: `year`, `week` and `weekday`. The\nsame as `self.date().isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.isoformat()", "path": "library/datetime#datetime.datetime.isoformat", "type": "Data Types", "text": "\nReturn a string representing the date and time in ISO 8601 format:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.isoweekday()", "path": "library/datetime#datetime.datetime.isoweekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 1 and Sunday is 7.\nThe same as `self.date().isoweekday()`. See also `weekday()`, `isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.max", "path": "library/datetime#datetime.datetime.max", "type": "Data Types", "text": "\nThe latest representable `datetime`, `datetime(MAXYEAR, 12, 31, 23, 59, 59,\n999999, tzinfo=None)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.microsecond", "path": "library/datetime#datetime.datetime.microsecond", "type": "Data Types", "text": "\nIn `range(1000000)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.min", "path": "library/datetime#datetime.datetime.min", "type": "Data Types", "text": "\nThe earliest representable `datetime`, `datetime(MINYEAR, 1, 1, tzinfo=None)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.minute", "path": "library/datetime#datetime.datetime.minute", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.month", "path": "library/datetime#datetime.datetime.month", "type": "Data Types", "text": "\nBetween 1 and 12 inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.now()", "path": "library/datetime#datetime.datetime.now", "type": "Data Types", "text": "\nReturn the current local date and time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.replace()", "path": "library/datetime#datetime.datetime.replace", "type": "Data Types", "text": "\nReturn a datetime with the same attributes, except for those attributes given\nnew values by whichever keyword arguments are specified. Note that\n`tzinfo=None` can be specified to create a naive datetime from an aware\ndatetime with no conversion of date and time data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.resolution", "path": "library/datetime#datetime.datetime.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal `datetime` objects,\n`timedelta(microseconds=1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.second", "path": "library/datetime#datetime.datetime.second", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.strftime()", "path": "library/datetime#datetime.datetime.strftime", "type": "Data Types", "text": "\nReturn a string representing the date and time, controlled by an explicit\nformat string. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.strptime()", "path": "library/datetime#datetime.datetime.strptime", "type": "Data Types", "text": "\nReturn a `datetime` corresponding to date_string, parsed according to format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.time()", "path": "library/datetime#datetime.datetime.time", "type": "Data Types", "text": "\nReturn `time` object with same hour, minute, second, microsecond and fold.\n`tzinfo` is `None`. See also method `timetz()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.timestamp()", "path": "library/datetime#datetime.datetime.timestamp", "type": "Data Types", "text": "\nReturn POSIX timestamp corresponding to the `datetime` instance. The return\nvalue is a `float` similar to that returned by `time.time()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.timetuple()", "path": "library/datetime#datetime.datetime.timetuple", "type": "Data Types", "text": "\nReturn a `time.struct_time` such as returned by `time.localtime()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.timetz()", "path": "library/datetime#datetime.datetime.timetz", "type": "Data Types", "text": "\nReturn `time` object with same hour, minute, second, microsecond, fold, and\ntzinfo attributes. See also method `time()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.today()", "path": "library/datetime#datetime.datetime.today", "type": "Data Types", "text": "\nReturn the current local datetime, with `tzinfo` `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.toordinal()", "path": "library/datetime#datetime.datetime.toordinal", "type": "Data Types", "text": "\nReturn the proleptic Gregorian ordinal of the date. The same as\n`self.date().toordinal()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.tzinfo", "path": "library/datetime#datetime.datetime.tzinfo", "type": "Data Types", "text": "\nThe object passed as the tzinfo argument to the `datetime` constructor, or\n`None` if none was passed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.tzname()", "path": "library/datetime#datetime.datetime.tzname", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.tzname(self)`, raises an exception if the latter doesn\u2019t return\n`None` or a string object,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utcfromtimestamp()", "path": "library/datetime#datetime.datetime.utcfromtimestamp", "type": "Data Types", "text": "\nReturn the UTC `datetime` corresponding to the POSIX timestamp, with `tzinfo`\n`None`. (The resulting object is naive.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utcnow()", "path": "library/datetime#datetime.datetime.utcnow", "type": "Data Types", "text": "\nReturn the current UTC date and time, with `tzinfo` `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utcoffset()", "path": "library/datetime#datetime.datetime.utcoffset", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.utcoffset(self)`, and raises an exception if the latter doesn\u2019t\nreturn `None` or a `timedelta` object with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utctimetuple()", "path": "library/datetime#datetime.datetime.utctimetuple", "type": "Data Types", "text": "\nIf `datetime` instance d is naive, this is the same as `d.timetuple()` except\nthat `tm_isdst` is forced to 0 regardless of what `d.dst()` returns. DST is\nnever in effect for a UTC time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.weekday()", "path": "library/datetime#datetime.datetime.weekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 0 and Sunday is 6.\nThe same as `self.date().weekday()`. See also `isoweekday()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.year", "path": "library/datetime#datetime.datetime.year", "type": "Data Types", "text": "\nBetween `MINYEAR` and `MAXYEAR` inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.__format__()", "path": "library/datetime#datetime.datetime.__format__", "type": "Data Types", "text": "\nSame as `datetime.strftime()`. This makes it possible to specify a format\nstring for a `datetime` object in formatted string literals and when using\n`str.format()`. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.__str__()", "path": "library/datetime#datetime.datetime.__str__", "type": "Data Types", "text": "\nFor a `datetime` instance d, `str(d)` is equivalent to `d.isoformat(' ')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.MAXYEAR", "path": "library/datetime#datetime.MAXYEAR", "type": "Data Types", "text": "\nThe largest year number allowed in a `date` or `datetime` object. `MAXYEAR` is\n`9999`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.MINYEAR", "path": "library/datetime#datetime.MINYEAR", "type": "Data Types", "text": "\nThe smallest year number allowed in a `date` or `datetime` object. `MINYEAR`\nis `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time", "path": "library/datetime#datetime.time", "type": "Data Types", "text": "\nAll arguments are optional. tzinfo may be `None`, or an instance of a `tzinfo`\nsubclass. The remaining arguments must be integers in the following ranges:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.dst()", "path": "library/datetime#datetime.time.dst", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns `self.tzinfo.dst(None)`,\nand raises an exception if the latter doesn\u2019t return `None`, or a `timedelta`\nobject with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.fold", "path": "library/datetime#datetime.time.fold", "type": "Data Types", "text": "\nIn `[0, 1]`. Used to disambiguate wall times during a repeated interval. (A\nrepeated interval occurs when clocks are rolled back at the end of daylight\nsaving time or when the UTC offset for the current zone is decreased for\npolitical reasons.) The value 0 (1) represents the earlier (later) of the two\nmoments with the same wall time representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.fromisoformat()", "path": "library/datetime#datetime.time.fromisoformat", "type": "Data Types", "text": "\nReturn a `time` corresponding to a time_string in one of the formats emitted\nby `time.isoformat()`. Specifically, this function supports strings in the\nformat:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.hour", "path": "library/datetime#datetime.time.hour", "type": "Data Types", "text": "\nIn `range(24)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.isoformat()", "path": "library/datetime#datetime.time.isoformat", "type": "Data Types", "text": "\nReturn a string representing the time in ISO 8601 format, one of:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.max", "path": "library/datetime#datetime.time.max", "type": "Data Types", "text": "\nThe latest representable `time`, `time(23, 59, 59, 999999)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.microsecond", "path": "library/datetime#datetime.time.microsecond", "type": "Data Types", "text": "\nIn `range(1000000)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.min", "path": "library/datetime#datetime.time.min", "type": "Data Types", "text": "\nThe earliest representable `time`, `time(0, 0, 0, 0)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.minute", "path": "library/datetime#datetime.time.minute", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.replace()", "path": "library/datetime#datetime.time.replace", "type": "Data Types", "text": "\nReturn a `time` with the same value, except for those attributes given new\nvalues by whichever keyword arguments are specified. Note that `tzinfo=None`\ncan be specified to create a naive `time` from an aware `time`, without\nconversion of the time data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.resolution", "path": "library/datetime#datetime.time.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal `time` objects,\n`timedelta(microseconds=1)`, although note that arithmetic on `time` objects\nis not supported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.second", "path": "library/datetime#datetime.time.second", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.strftime()", "path": "library/datetime#datetime.time.strftime", "type": "Data Types", "text": "\nReturn a string representing the time, controlled by an explicit format\nstring. For a complete list of formatting directives, see strftime() and\nstrptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.tzinfo", "path": "library/datetime#datetime.time.tzinfo", "type": "Data Types", "text": "\nThe object passed as the tzinfo argument to the `time` constructor, or `None`\nif none was passed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.tzname()", "path": "library/datetime#datetime.time.tzname", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.tzname(None)`, or raises an exception if the latter doesn\u2019t\nreturn `None` or a string object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.utcoffset()", "path": "library/datetime#datetime.time.utcoffset", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.utcoffset(None)`, and raises an exception if the latter doesn\u2019t\nreturn `None` or a `timedelta` object with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.__format__()", "path": "library/datetime#datetime.time.__format__", "type": "Data Types", "text": "\nSame as `time.strftime()`. This makes it possible to specify a format string\nfor a `time` object in formatted string literals and when using\n`str.format()`. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.__str__()", "path": "library/datetime#datetime.time.__str__", "type": "Data Types", "text": "\nFor a time t, `str(t)` is equivalent to `t.isoformat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta", "path": "library/datetime#datetime.timedelta", "type": "Data Types", "text": "\nAll arguments are optional and default to `0`. Arguments may be integers or\nfloats, and may be positive or negative.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.max", "path": "library/datetime#datetime.timedelta.max", "type": "Data Types", "text": "\nThe most positive `timedelta` object, `timedelta(days=999999999, hours=23,\nminutes=59, seconds=59, microseconds=999999)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.min", "path": "library/datetime#datetime.timedelta.min", "type": "Data Types", "text": "\nThe most negative `timedelta` object, `timedelta(-999999999)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.resolution", "path": "library/datetime#datetime.timedelta.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal `timedelta` objects,\n`timedelta(microseconds=1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.total_seconds()", "path": "library/datetime#datetime.timedelta.total_seconds", "type": "Data Types", "text": "\nReturn the total number of seconds contained in the duration. Equivalent to\n`td / timedelta(seconds=1)`. For interval units other than seconds, use the\ndivision form directly (e.g. `td / timedelta(microseconds=1)`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone", "path": "library/datetime#datetime.timezone", "type": "Data Types", "text": "\nThe offset argument must be specified as a `timedelta` object representing the\ndifference between the local time and UTC. It must be strictly between\n`-timedelta(hours=24)` and `timedelta(hours=24)`, otherwise `ValueError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.dst()", "path": "library/datetime#datetime.timezone.dst", "type": "Data Types", "text": "\nAlways returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.fromutc()", "path": "library/datetime#datetime.timezone.fromutc", "type": "Data Types", "text": "\nReturn `dt + offset`. The dt argument must be an aware `datetime` instance,\nwith `tzinfo` set to `self`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.tzname()", "path": "library/datetime#datetime.timezone.tzname", "type": "Data Types", "text": "\nReturn the fixed value specified when the `timezone` instance is constructed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.utc", "path": "library/datetime#datetime.timezone.utc", "type": "Data Types", "text": "\nThe UTC timezone, `timezone(timedelta(0))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.utcoffset()", "path": "library/datetime#datetime.timezone.utcoffset", "type": "Data Types", "text": "\nReturn the fixed value specified when the `timezone` instance is constructed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo", "path": "library/datetime#datetime.tzinfo", "type": "Data Types", "text": "\nThis is an abstract base class, meaning that this class should not be\ninstantiated directly. Define a subclass of `tzinfo` to capture information\nabout a particular time zone.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.dst()", "path": "library/datetime#datetime.tzinfo.dst", "type": "Data Types", "text": "\nReturn the daylight saving time (DST) adjustment, as a `timedelta` object or\n`None` if DST information isn\u2019t known.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.fromutc()", "path": "library/datetime#datetime.tzinfo.fromutc", "type": "Data Types", "text": "\nThis is called from the default `datetime.astimezone()` implementation. When\ncalled from that, `dt.tzinfo` is self, and dt\u2019s date and time data are to be\nviewed as expressing a UTC time. The purpose of `fromutc()` is to adjust the\ndate and time data, returning an equivalent datetime in self\u2019s local time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.tzname()", "path": "library/datetime#datetime.tzinfo.tzname", "type": "Data Types", "text": "\nReturn the time zone name corresponding to the `datetime` object dt, as a\nstring. Nothing about string names is defined by the `datetime` module, and\nthere\u2019s no requirement that it mean anything in particular. For example,\n\u201cGMT\u201d, \u201cUTC\u201d, \u201c-500\u201d, \u201c-5:00\u201d, \u201cEDT\u201d, \u201cUS/Eastern\u201d, \u201cAmerica/New York\u201d are all\nvalid replies. Return `None` if a string name isn\u2019t known. Note that this is a\nmethod rather than a fixed string primarily because some `tzinfo` subclasses\nwill wish to return different names depending on the specific value of dt\npassed, especially if the `tzinfo` class is accounting for daylight time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.utcoffset()", "path": "library/datetime#datetime.tzinfo.utcoffset", "type": "Data Types", "text": "\nReturn offset of local time from UTC, as a `timedelta` object that is positive\neast of UTC. If local time is west of UTC, this should be negative.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm", "path": "library/dbm", "type": "Data Persistence", "text": "\nSource code: Lib/dbm/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.dumbdbm.close()", "path": "library/dbm#dbm.dumb.dumbdbm.close", "type": "Data Persistence", "text": "\nClose the `dumbdbm` database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.dumbdbm.sync()", "path": "library/dbm#dbm.dumb.dumbdbm.sync", "type": "Data Persistence", "text": "\nSynchronize the on-disk directory and data files. This method is called by the\n`Shelve.sync()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.error", "path": "library/dbm#dbm.dumb.error", "type": "Data Persistence", "text": "\nRaised on `dbm.dumb`-specific errors, such as I/O errors. `KeyError` is raised\nfor general mapping errors like specifying an incorrect key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.open()", "path": "library/dbm#dbm.dumb.open", "type": "Data Persistence", "text": "\nOpen a `dumbdbm` database and return a dumbdbm object. The filename argument\nis the basename of the database file (without any specific extensions). When a\ndumbdbm database is created, files with `.dat` and `.dir` extensions are\ncreated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.error", "path": "library/dbm#dbm.error", "type": "Data Persistence", "text": "\nA tuple containing the exceptions that can be raised by each of the supported\nmodules, with a unique exception also named `dbm.error` as the first item \u2014\nthe latter is used when `dbm.error` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.error", "path": "library/dbm#dbm.gnu.error", "type": "Data Persistence", "text": "\nRaised on `dbm.gnu`-specific errors, such as I/O errors. `KeyError` is raised\nfor general mapping errors like specifying an incorrect key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.close()", "path": "library/dbm#dbm.gnu.gdbm.close", "type": "Data Persistence", "text": "\nClose the `gdbm` database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.firstkey()", "path": "library/dbm#dbm.gnu.gdbm.firstkey", "type": "Data Persistence", "text": "\nIt\u2019s possible to loop over every key in the database using this method and the\n`nextkey()` method. The traversal is ordered by `gdbm`\u2019s internal hash values,\nand won\u2019t be sorted by the key values. This method returns the starting key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.nextkey()", "path": "library/dbm#dbm.gnu.gdbm.nextkey", "type": "Data Persistence", "text": "\nReturns the key that follows key in the traversal. The following code prints\nevery key in the database `db`, without having to create a list in memory that\ncontains them all:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.reorganize()", "path": "library/dbm#dbm.gnu.gdbm.reorganize", "type": "Data Persistence", "text": "\nIf you have carried out a lot of deletions and would like to shrink the space\nused by the `gdbm` file, this routine will reorganize the database. `gdbm`\nobjects will not shorten the length of a database file except by using this\nreorganization; otherwise, deleted file space will be kept and reused as new\n(key, value) pairs are added.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.sync()", "path": "library/dbm#dbm.gnu.gdbm.sync", "type": "Data Persistence", "text": "\nWhen the database has been opened in fast mode, this method forces any\nunwritten data to be written to the disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.open()", "path": "library/dbm#dbm.gnu.open", "type": "Data Persistence", "text": "\nOpen a `gdbm` database and return a `gdbm` object. The filename argument is\nthe name of the database file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.error", "path": "library/dbm#dbm.ndbm.error", "type": "Data Persistence", "text": "\nRaised on `dbm.ndbm`-specific errors, such as I/O errors. `KeyError` is raised\nfor general mapping errors like specifying an incorrect key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.library", "path": "library/dbm#dbm.ndbm.library", "type": "Data Persistence", "text": "\nName of the `ndbm` implementation library used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.ndbm.close()", "path": "library/dbm#dbm.ndbm.ndbm.close", "type": "Data Persistence", "text": "\nClose the `ndbm` database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.open()", "path": "library/dbm#dbm.ndbm.open", "type": "Data Persistence", "text": "\nOpen a dbm database and return a `ndbm` object. The filename argument is the\nname of the database file (without the `.dir` or `.pag` extensions).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.open()", "path": "library/dbm#dbm.open", "type": "Data Persistence", "text": "\nOpen the database file file and return a corresponding object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.whichdb()", "path": "library/dbm#dbm.whichdb", "type": "Data Persistence", "text": "\nThis function attempts to guess which of the several simple database modules\navailable \u2014 `dbm.gnu`, `dbm.ndbm` or `dbm.dumb` \u2014 should be used to open a\ngiven file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal", "path": "library/decimal", "type": "Numeric & Mathematical", "text": "\nSource code: Lib/decimal.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.BasicContext", "path": "library/decimal#decimal.BasicContext", "type": "Numeric & Mathematical", "text": "\nThis is a standard context defined by the General Decimal Arithmetic\nSpecification. Precision is set to nine. Rounding is set to `ROUND_HALF_UP`.\nAll flags are cleared. All traps are enabled (treated as exceptions) except\n`Inexact`, `Rounded`, and `Subnormal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Clamped", "path": "library/decimal#decimal.Clamped", "type": "Numeric & Mathematical", "text": "\nAltered an exponent to fit representation constraints.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context", "path": "library/decimal#decimal.Context", "type": "Numeric & Mathematical", "text": "\nCreates a new context. If a field is not specified or is `None`, the default\nvalues are copied from the `DefaultContext`. If the flags field is not\nspecified or is `None`, all flags are cleared.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.abs()", "path": "library/decimal#decimal.Context.abs", "type": "Numeric & Mathematical", "text": "\nReturns the absolute value of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.add()", "path": "library/decimal#decimal.Context.add", "type": "Numeric & Mathematical", "text": "\nReturn the sum of x and y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.canonical()", "path": "library/decimal#decimal.Context.canonical", "type": "Numeric & Mathematical", "text": "\nReturns the same Decimal object x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.clear_flags()", "path": "library/decimal#decimal.Context.clear_flags", "type": "Numeric & Mathematical", "text": "\nResets all of the flags to `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.clear_traps()", "path": "library/decimal#decimal.Context.clear_traps", "type": "Numeric & Mathematical", "text": "\nResets all of the traps to `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare()", "path": "library/decimal#decimal.Context.compare", "type": "Numeric & Mathematical", "text": "\nCompares x and y numerically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare_signal()", "path": "library/decimal#decimal.Context.compare_signal", "type": "Numeric & Mathematical", "text": "\nCompares the values of the two operands numerically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare_total()", "path": "library/decimal#decimal.Context.compare_total", "type": "Numeric & Mathematical", "text": "\nCompares two operands using their abstract representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare_total_mag()", "path": "library/decimal#decimal.Context.compare_total_mag", "type": "Numeric & Mathematical", "text": "\nCompares two operands using their abstract representation, ignoring sign.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy()", "path": "library/decimal#decimal.Context.copy", "type": "Numeric & Mathematical", "text": "\nReturn a duplicate of the context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_abs()", "path": "library/decimal#decimal.Context.copy_abs", "type": "Numeric & Mathematical", "text": "\nReturns a copy of x with the sign set to 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_decimal()", "path": "library/decimal#decimal.Context.copy_decimal", "type": "Numeric & Mathematical", "text": "\nReturn a copy of the Decimal instance num.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_negate()", "path": "library/decimal#decimal.Context.copy_negate", "type": "Numeric & Mathematical", "text": "\nReturns a copy of x with the sign inverted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_sign()", "path": "library/decimal#decimal.Context.copy_sign", "type": "Numeric & Mathematical", "text": "\nCopies the sign from y to x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.create_decimal()", "path": "library/decimal#decimal.Context.create_decimal", "type": "Numeric & Mathematical", "text": "\nCreates a new Decimal instance from num but using self as context. Unlike the\n`Decimal` constructor, the context precision, rounding method, flags, and\ntraps are applied to the conversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.create_decimal_from_float()", "path": "library/decimal#decimal.Context.create_decimal_from_float", "type": "Numeric & Mathematical", "text": "\nCreates a new Decimal instance from a float f but rounding using self as the\ncontext. Unlike the `Decimal.from_float()` class method, the context\nprecision, rounding method, flags, and traps are applied to the conversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.divide()", "path": "library/decimal#decimal.Context.divide", "type": "Numeric & Mathematical", "text": "\nReturn x divided by y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.divide_int()", "path": "library/decimal#decimal.Context.divide_int", "type": "Numeric & Mathematical", "text": "\nReturn x divided by y, truncated to an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.divmod()", "path": "library/decimal#decimal.Context.divmod", "type": "Numeric & Mathematical", "text": "\nDivides two numbers and returns the integer part of the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.Etiny()", "path": "library/decimal#decimal.Context.Etiny", "type": "Numeric & Mathematical", "text": "\nReturns a value equal to `Emin - prec + 1` which is the minimum exponent value\nfor subnormal results. When underflow occurs, the exponent is set to `Etiny`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.Etop()", "path": "library/decimal#decimal.Context.Etop", "type": "Numeric & Mathematical", "text": "\nReturns a value equal to `Emax - prec + 1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.exp()", "path": "library/decimal#decimal.Context.exp", "type": "Numeric & Mathematical", "text": "\nReturns `e ** x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.fma()", "path": "library/decimal#decimal.Context.fma", "type": "Numeric & Mathematical", "text": "\nReturns x multiplied by y, plus z.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_canonical()", "path": "library/decimal#decimal.Context.is_canonical", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is canonical; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_finite()", "path": "library/decimal#decimal.Context.is_finite", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is finite; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_infinite()", "path": "library/decimal#decimal.Context.is_infinite", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is infinite; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_nan()", "path": "library/decimal#decimal.Context.is_nan", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a qNaN or sNaN; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_normal()", "path": "library/decimal#decimal.Context.is_normal", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a normal number; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_qnan()", "path": "library/decimal#decimal.Context.is_qnan", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a quiet NaN; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_signed()", "path": "library/decimal#decimal.Context.is_signed", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is negative; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_snan()", "path": "library/decimal#decimal.Context.is_snan", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a signaling NaN; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_subnormal()", "path": "library/decimal#decimal.Context.is_subnormal", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is subnormal; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_zero()", "path": "library/decimal#decimal.Context.is_zero", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a zero; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.ln()", "path": "library/decimal#decimal.Context.ln", "type": "Numeric & Mathematical", "text": "\nReturns the natural (base e) logarithm of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.log10()", "path": "library/decimal#decimal.Context.log10", "type": "Numeric & Mathematical", "text": "\nReturns the base 10 logarithm of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logb()", "path": "library/decimal#decimal.Context.logb", "type": "Numeric & Mathematical", "text": "\nReturns the exponent of the magnitude of the operand\u2019s MSD.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_and()", "path": "library/decimal#decimal.Context.logical_and", "type": "Numeric & Mathematical", "text": "\nApplies the logical operation and between each operand\u2019s digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_invert()", "path": "library/decimal#decimal.Context.logical_invert", "type": "Numeric & Mathematical", "text": "\nInvert all the digits in x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_or()", "path": "library/decimal#decimal.Context.logical_or", "type": "Numeric & Mathematical", "text": "\nApplies the logical operation or between each operand\u2019s digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_xor()", "path": "library/decimal#decimal.Context.logical_xor", "type": "Numeric & Mathematical", "text": "\nApplies the logical operation xor between each operand\u2019s digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.max()", "path": "library/decimal#decimal.Context.max", "type": "Numeric & Mathematical", "text": "\nCompares two values numerically and returns the maximum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.max_mag()", "path": "library/decimal#decimal.Context.max_mag", "type": "Numeric & Mathematical", "text": "\nCompares the values numerically with their sign ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.min()", "path": "library/decimal#decimal.Context.min", "type": "Numeric & Mathematical", "text": "\nCompares two values numerically and returns the minimum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.minus()", "path": "library/decimal#decimal.Context.minus", "type": "Numeric & Mathematical", "text": "\nMinus corresponds to the unary prefix minus operator in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.min_mag()", "path": "library/decimal#decimal.Context.min_mag", "type": "Numeric & Mathematical", "text": "\nCompares the values numerically with their sign ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.multiply()", "path": "library/decimal#decimal.Context.multiply", "type": "Numeric & Mathematical", "text": "\nReturn the product of x and y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.next_minus()", "path": "library/decimal#decimal.Context.next_minus", "type": "Numeric & Mathematical", "text": "\nReturns the largest representable number smaller than x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.next_plus()", "path": "library/decimal#decimal.Context.next_plus", "type": "Numeric & Mathematical", "text": "\nReturns the smallest representable number larger than x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.next_toward()", "path": "library/decimal#decimal.Context.next_toward", "type": "Numeric & Mathematical", "text": "\nReturns the number closest to x, in direction towards y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.normalize()", "path": "library/decimal#decimal.Context.normalize", "type": "Numeric & Mathematical", "text": "\nReduces x to its simplest form.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.number_class()", "path": "library/decimal#decimal.Context.number_class", "type": "Numeric & Mathematical", "text": "\nReturns an indication of the class of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.plus()", "path": "library/decimal#decimal.Context.plus", "type": "Numeric & Mathematical", "text": "\nPlus corresponds to the unary prefix plus operator in Python. This operation\napplies the context precision and rounding, so it is not an identity\noperation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.power()", "path": "library/decimal#decimal.Context.power", "type": "Numeric & Mathematical", "text": "\nReturn `x` to the power of `y`, reduced modulo `modulo` if given.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.quantize()", "path": "library/decimal#decimal.Context.quantize", "type": "Numeric & Mathematical", "text": "\nReturns a value equal to x (rounded), having the exponent of y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.radix()", "path": "library/decimal#decimal.Context.radix", "type": "Numeric & Mathematical", "text": "\nJust returns 10, as this is Decimal, :)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.remainder()", "path": "library/decimal#decimal.Context.remainder", "type": "Numeric & Mathematical", "text": "\nReturns the remainder from integer division.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.remainder_near()", "path": "library/decimal#decimal.Context.remainder_near", "type": "Numeric & Mathematical", "text": "\nReturns `x - y * n`, where n is the integer nearest the exact value of `x / y`\n(if the result is 0 then its sign will be the sign of x).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.rotate()", "path": "library/decimal#decimal.Context.rotate", "type": "Numeric & Mathematical", "text": "\nReturns a rotated copy of x, y times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.same_quantum()", "path": "library/decimal#decimal.Context.same_quantum", "type": "Numeric & Mathematical", "text": "\nReturns `True` if the two operands have the same exponent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.scaleb()", "path": "library/decimal#decimal.Context.scaleb", "type": "Numeric & Mathematical", "text": "\nReturns the first operand after adding the second value its exp.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.shift()", "path": "library/decimal#decimal.Context.shift", "type": "Numeric & Mathematical", "text": "\nReturns a shifted copy of x, y times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.sqrt()", "path": "library/decimal#decimal.Context.sqrt", "type": "Numeric & Mathematical", "text": "\nSquare root of a non-negative number to context precision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.subtract()", "path": "library/decimal#decimal.Context.subtract", "type": "Numeric & Mathematical", "text": "\nReturn the difference between x and y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.to_eng_string()", "path": "library/decimal#decimal.Context.to_eng_string", "type": "Numeric & Mathematical", "text": "\nConvert to a string, using engineering notation if an exponent is needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.to_integral_exact()", "path": "library/decimal#decimal.Context.to_integral_exact", "type": "Numeric & Mathematical", "text": "\nRounds to an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.to_sci_string()", "path": "library/decimal#decimal.Context.to_sci_string", "type": "Numeric & Mathematical", "text": "\nConverts a number to a string using scientific notation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal", "path": "library/decimal#decimal.Decimal", "type": "Numeric & Mathematical", "text": "\nConstruct a new `Decimal` object based from value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.adjusted()", "path": "library/decimal#decimal.Decimal.adjusted", "type": "Numeric & Mathematical", "text": "\nReturn the adjusted exponent after shifting out the coefficient\u2019s rightmost\ndigits until only the lead digit remains: `Decimal('321e+5').adjusted()`\nreturns seven. Used for determining the position of the most significant digit\nwith respect to the decimal point.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.as_integer_ratio()", "path": "library/decimal#decimal.Decimal.as_integer_ratio", "type": "Numeric & Mathematical", "text": "\nReturn a pair `(n, d)` of integers that represent the given `Decimal` instance\nas a fraction, in lowest terms and with a positive denominator:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.as_tuple()", "path": "library/decimal#decimal.Decimal.as_tuple", "type": "Numeric & Mathematical", "text": "\nReturn a named tuple representation of the number: `DecimalTuple(sign, digits,\nexponent)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.canonical()", "path": "library/decimal#decimal.Decimal.canonical", "type": "Numeric & Mathematical", "text": "\nReturn the canonical encoding of the argument. Currently, the encoding of a\n`Decimal` instance is always canonical, so this operation returns its argument\nunchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare()", "path": "library/decimal#decimal.Decimal.compare", "type": "Numeric & Mathematical", "text": "\nCompare the values of two Decimal instances. `compare()` returns a Decimal\ninstance, and if either operand is a NaN then the result is a NaN:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare_signal()", "path": "library/decimal#decimal.Decimal.compare_signal", "type": "Numeric & Mathematical", "text": "\nThis operation is identical to the `compare()` method, except that all NaNs\nsignal. That is, if neither operand is a signaling NaN then any quiet NaN\noperand is treated as though it were a signaling NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare_total()", "path": "library/decimal#decimal.Decimal.compare_total", "type": "Numeric & Mathematical", "text": "\nCompare two operands using their abstract representation rather than their\nnumerical value. Similar to the `compare()` method, but the result gives a\ntotal ordering on `Decimal` instances. Two `Decimal` instances with the same\nnumeric value but different representations compare unequal in this ordering:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare_total_mag()", "path": "library/decimal#decimal.Decimal.compare_total_mag", "type": "Numeric & Mathematical", "text": "\nCompare two operands using their abstract representation rather than their\nvalue as in `compare_total()`, but ignoring the sign of each operand.\n`x.compare_total_mag(y)` is equivalent to\n`x.copy_abs().compare_total(y.copy_abs())`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.conjugate()", "path": "library/decimal#decimal.Decimal.conjugate", "type": "Numeric & Mathematical", "text": "\nJust returns self, this method is only to comply with the Decimal\nSpecification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.copy_abs()", "path": "library/decimal#decimal.Decimal.copy_abs", "type": "Numeric & Mathematical", "text": "\nReturn the absolute value of the argument. This operation is unaffected by the\ncontext and is quiet: no flags are changed and no rounding is performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.copy_negate()", "path": "library/decimal#decimal.Decimal.copy_negate", "type": "Numeric & Mathematical", "text": "\nReturn the negation of the argument. This operation is unaffected by the\ncontext and is quiet: no flags are changed and no rounding is performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.copy_sign()", "path": "library/decimal#decimal.Decimal.copy_sign", "type": "Numeric & Mathematical", "text": "\nReturn a copy of the first operand with the sign set to be the same as the\nsign of the second operand. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.exp()", "path": "library/decimal#decimal.Decimal.exp", "type": "Numeric & Mathematical", "text": "\nReturn the value of the (natural) exponential function `e**x` at the given\nnumber. The result is correctly rounded using the `ROUND_HALF_EVEN` rounding\nmode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.fma()", "path": "library/decimal#decimal.Decimal.fma", "type": "Numeric & Mathematical", "text": "\nFused multiply-add. Return self*other+third with no rounding of the\nintermediate product self*other.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.from_float()", "path": "library/decimal#decimal.Decimal.from_float", "type": "Numeric & Mathematical", "text": "\nClassmethod that converts a float to a decimal number, exactly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_canonical()", "path": "library/decimal#decimal.Decimal.is_canonical", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is canonical and `False` otherwise. Currently, a\n`Decimal` instance is always canonical, so this operation always returns\n`True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_finite()", "path": "library/decimal#decimal.Decimal.is_finite", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a finite number, and `False` if the argument\nis an infinity or a NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_infinite()", "path": "library/decimal#decimal.Decimal.is_infinite", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is either positive or negative infinity and\n`False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_nan()", "path": "library/decimal#decimal.Decimal.is_nan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a (quiet or signaling) NaN and `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_normal()", "path": "library/decimal#decimal.Decimal.is_normal", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a normal finite number. Return `False` if the\nargument is zero, subnormal, infinite or a NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_qnan()", "path": "library/decimal#decimal.Decimal.is_qnan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a quiet NaN, and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_signed()", "path": "library/decimal#decimal.Decimal.is_signed", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument has a negative sign and `False` otherwise. Note\nthat zeros and NaNs can both carry signs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_snan()", "path": "library/decimal#decimal.Decimal.is_snan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a signaling NaN and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_subnormal()", "path": "library/decimal#decimal.Decimal.is_subnormal", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is subnormal, and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_zero()", "path": "library/decimal#decimal.Decimal.is_zero", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a (positive or negative) zero and `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.ln()", "path": "library/decimal#decimal.Decimal.ln", "type": "Numeric & Mathematical", "text": "\nReturn the natural (base e) logarithm of the operand. The result is correctly\nrounded using the `ROUND_HALF_EVEN` rounding mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.log10()", "path": "library/decimal#decimal.Decimal.log10", "type": "Numeric & Mathematical", "text": "\nReturn the base ten logarithm of the operand. The result is correctly rounded\nusing the `ROUND_HALF_EVEN` rounding mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logb()", "path": "library/decimal#decimal.Decimal.logb", "type": "Numeric & Mathematical", "text": "\nFor a nonzero number, return the adjusted exponent of its operand as a\n`Decimal` instance. If the operand is a zero then `Decimal('-Infinity')` is\nreturned and the `DivisionByZero` flag is raised. If the operand is an\ninfinity then `Decimal('Infinity')` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_and()", "path": "library/decimal#decimal.Decimal.logical_and", "type": "Numeric & Mathematical", "text": "\n`logical_and()` is a logical operation which takes two logical operands (see\nLogical operands). The result is the digit-wise `and` of the two operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_invert()", "path": "library/decimal#decimal.Decimal.logical_invert", "type": "Numeric & Mathematical", "text": "\n`logical_invert()` is a logical operation. The result is the digit-wise\ninversion of the operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_or()", "path": "library/decimal#decimal.Decimal.logical_or", "type": "Numeric & Mathematical", "text": "\n`logical_or()` is a logical operation which takes two logical operands (see\nLogical operands). The result is the digit-wise `or` of the two operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_xor()", "path": "library/decimal#decimal.Decimal.logical_xor", "type": "Numeric & Mathematical", "text": "\n`logical_xor()` is a logical operation which takes two logical operands (see\nLogical operands). The result is the digit-wise exclusive or of the two\noperands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.max()", "path": "library/decimal#decimal.Decimal.max", "type": "Numeric & Mathematical", "text": "\nLike `max(self, other)` except that the context rounding rule is applied\nbefore returning and that `NaN` values are either signaled or ignored\n(depending on the context and whether they are signaling or quiet).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.max_mag()", "path": "library/decimal#decimal.Decimal.max_mag", "type": "Numeric & Mathematical", "text": "\nSimilar to the `max()` method, but the comparison is done using the absolute\nvalues of the operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.min()", "path": "library/decimal#decimal.Decimal.min", "type": "Numeric & Mathematical", "text": "\nLike `min(self, other)` except that the context rounding rule is applied\nbefore returning and that `NaN` values are either signaled or ignored\n(depending on the context and whether they are signaling or quiet).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.min_mag()", "path": "library/decimal#decimal.Decimal.min_mag", "type": "Numeric & Mathematical", "text": "\nSimilar to the `min()` method, but the comparison is done using the absolute\nvalues of the operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.next_minus()", "path": "library/decimal#decimal.Decimal.next_minus", "type": "Numeric & Mathematical", "text": "\nReturn the largest number representable in the given context (or in the\ncurrent thread\u2019s context if no context is given) that is smaller than the\ngiven operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.next_plus()", "path": "library/decimal#decimal.Decimal.next_plus", "type": "Numeric & Mathematical", "text": "\nReturn the smallest number representable in the given context (or in the\ncurrent thread\u2019s context if no context is given) that is larger than the given\noperand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.next_toward()", "path": "library/decimal#decimal.Decimal.next_toward", "type": "Numeric & Mathematical", "text": "\nIf the two operands are unequal, return the number closest to the first\noperand in the direction of the second operand. If both operands are\nnumerically equal, return a copy of the first operand with the sign set to be\nthe same as the sign of the second operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.normalize()", "path": "library/decimal#decimal.Decimal.normalize", "type": "Numeric & Mathematical", "text": "\nNormalize the number by stripping the rightmost trailing zeros and converting\nany result equal to `Decimal('0')` to `Decimal('0e0')`. Used for producing\ncanonical values for attributes of an equivalence class. For example,\n`Decimal('32.100')` and `Decimal('0.321000e+2')` both normalize to the\nequivalent value `Decimal('32.1')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.number_class()", "path": "library/decimal#decimal.Decimal.number_class", "type": "Numeric & Mathematical", "text": "\nReturn a string describing the class of the operand. The returned value is one\nof the following ten strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.quantize()", "path": "library/decimal#decimal.Decimal.quantize", "type": "Numeric & Mathematical", "text": "\nReturn a value equal to the first operand after rounding and having the\nexponent of the second operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.radix()", "path": "library/decimal#decimal.Decimal.radix", "type": "Numeric & Mathematical", "text": "\nReturn `Decimal(10)`, the radix (base) in which the `Decimal` class does all\nits arithmetic. Included for compatibility with the specification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.remainder_near()", "path": "library/decimal#decimal.Decimal.remainder_near", "type": "Numeric & Mathematical", "text": "\nReturn the remainder from dividing self by other. This differs from `self %\nother` in that the sign of the remainder is chosen so as to minimize its\nabsolute value. More precisely, the return value is `self - n * other` where\n`n` is the integer nearest to the exact value of `self / other`, and if two\nintegers are equally near then the even one is chosen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.rotate()", "path": "library/decimal#decimal.Decimal.rotate", "type": "Numeric & Mathematical", "text": "\nReturn the result of rotating the digits of the first operand by an amount\nspecified by the second operand. The second operand must be an integer in the\nrange -precision through precision. The absolute value of the second operand\ngives the number of places to rotate. If the second operand is positive then\nrotation is to the left; otherwise rotation is to the right. The coefficient\nof the first operand is padded on the left with zeros to length precision if\nnecessary. The sign and exponent of the first operand are unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.same_quantum()", "path": "library/decimal#decimal.Decimal.same_quantum", "type": "Numeric & Mathematical", "text": "\nTest whether self and other have the same exponent or whether both are `NaN`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.scaleb()", "path": "library/decimal#decimal.Decimal.scaleb", "type": "Numeric & Mathematical", "text": "\nReturn the first operand with exponent adjusted by the second. Equivalently,\nreturn the first operand multiplied by `10**other`. The second operand must be\nan integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.shift()", "path": "library/decimal#decimal.Decimal.shift", "type": "Numeric & Mathematical", "text": "\nReturn the result of shifting the digits of the first operand by an amount\nspecified by the second operand. The second operand must be an integer in the\nrange -precision through precision. The absolute value of the second operand\ngives the number of places to shift. If the second operand is positive then\nthe shift is to the left; otherwise the shift is to the right. Digits shifted\ninto the coefficient are zeros. The sign and exponent of the first operand are\nunchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.sqrt()", "path": "library/decimal#decimal.Decimal.sqrt", "type": "Numeric & Mathematical", "text": "\nReturn the square root of the argument to full precision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_eng_string()", "path": "library/decimal#decimal.Decimal.to_eng_string", "type": "Numeric & Mathematical", "text": "\nConvert to a string, using engineering notation if an exponent is needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_integral()", "path": "library/decimal#decimal.Decimal.to_integral", "type": "Numeric & Mathematical", "text": "\nIdentical to the `to_integral_value()` method. The `to_integral` name has been\nkept for compatibility with older versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_integral_exact()", "path": "library/decimal#decimal.Decimal.to_integral_exact", "type": "Numeric & Mathematical", "text": "\nRound to the nearest integer, signaling `Inexact` or `Rounded` as appropriate\nif rounding occurs. The rounding mode is determined by the `rounding`\nparameter if given, else by the given `context`. If neither parameter is given\nthen the rounding mode of the current context is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_integral_value()", "path": "library/decimal#decimal.Decimal.to_integral_value", "type": "Numeric & Mathematical", "text": "\nRound to the nearest integer without signaling `Inexact` or `Rounded`. If\ngiven, applies rounding; otherwise, uses the rounding method in either the\nsupplied context or the current context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.DecimalException", "path": "library/decimal#decimal.DecimalException", "type": "Numeric & Mathematical", "text": "\nBase class for other signals and a subclass of `ArithmeticError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.DefaultContext", "path": "library/decimal#decimal.DefaultContext", "type": "Numeric & Mathematical", "text": "\nThis context is used by the `Context` constructor as a prototype for new\ncontexts. Changing a field (such a precision) has the effect of changing the\ndefault for new contexts created by the `Context` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.DivisionByZero", "path": "library/decimal#decimal.DivisionByZero", "type": "Numeric & Mathematical", "text": "\nSignals the division of a non-infinite number by zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ExtendedContext", "path": "library/decimal#decimal.ExtendedContext", "type": "Numeric & Mathematical", "text": "\nThis is a standard context defined by the General Decimal Arithmetic\nSpecification. Precision is set to nine. Rounding is set to `ROUND_HALF_EVEN`.\nAll flags are cleared. No traps are enabled (so that exceptions are not raised\nduring computations).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.FloatOperation", "path": "library/decimal#decimal.FloatOperation", "type": "Numeric & Mathematical", "text": "\nEnable stricter semantics for mixing floats and Decimals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.getcontext()", "path": "library/decimal#decimal.getcontext", "type": "Numeric & Mathematical", "text": "\nReturn the current context for the active thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.HAVE_CONTEXTVAR", "path": "library/decimal#decimal.HAVE_CONTEXTVAR", "type": "Numeric & Mathematical", "text": "\nThe default value is `True`. If Python is compiled `--without-decimal-\ncontextvar`, the C version uses a thread-local rather than a coroutine-local\ncontext and the value is `False`. This is slightly faster in some nested\ncontext scenarios.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.HAVE_THREADS", "path": "library/decimal#decimal.HAVE_THREADS", "type": "Numeric & Mathematical", "text": "\nThe value is `True`. Deprecated, because Python now always has threads.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Inexact", "path": "library/decimal#decimal.Inexact", "type": "Numeric & Mathematical", "text": "\nIndicates that rounding occurred and the result is not exact.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.InvalidOperation", "path": "library/decimal#decimal.InvalidOperation", "type": "Numeric & Mathematical", "text": "\nAn invalid operation was performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.localcontext()", "path": "library/decimal#decimal.localcontext", "type": "Numeric & Mathematical", "text": "\nReturn a context manager that will set the current context for the active\nthread to a copy of ctx on entry to the with-statement and restore the\nprevious context when exiting the with-statement. If no context is specified,\na copy of the current context is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MAX_EMAX", "path": "library/decimal#decimal.MAX_EMAX", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MAX_PREC", "path": "library/decimal#decimal.MAX_PREC", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MIN_EMIN", "path": "library/decimal#decimal.MIN_EMIN", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MIN_ETINY", "path": "library/decimal#decimal.MIN_ETINY", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Overflow", "path": "library/decimal#decimal.Overflow", "type": "Numeric & Mathematical", "text": "\nNumerical overflow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Rounded", "path": "library/decimal#decimal.Rounded", "type": "Numeric & Mathematical", "text": "\nRounding occurred though possibly no information was lost.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_05UP", "path": "library/decimal#decimal.ROUND_05UP", "type": "Numeric & Mathematical", "text": "\nRound away from zero if last digit after rounding towards zero would have been\n0 or 5; otherwise round towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_CEILING", "path": "library/decimal#decimal.ROUND_CEILING", "type": "Numeric & Mathematical", "text": "\nRound towards `Infinity`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_DOWN", "path": "library/decimal#decimal.ROUND_DOWN", "type": "Numeric & Mathematical", "text": "\nRound towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_FLOOR", "path": "library/decimal#decimal.ROUND_FLOOR", "type": "Numeric & Mathematical", "text": "\nRound towards `-Infinity`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_HALF_DOWN", "path": "library/decimal#decimal.ROUND_HALF_DOWN", "type": "Numeric & Mathematical", "text": "\nRound to nearest with ties going towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_HALF_EVEN", "path": "library/decimal#decimal.ROUND_HALF_EVEN", "type": "Numeric & Mathematical", "text": "\nRound to nearest with ties going to nearest even integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_HALF_UP", "path": "library/decimal#decimal.ROUND_HALF_UP", "type": "Numeric & Mathematical", "text": "\nRound to nearest with ties going away from zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_UP", "path": "library/decimal#decimal.ROUND_UP", "type": "Numeric & Mathematical", "text": "\nRound away from zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.setcontext()", "path": "library/decimal#decimal.setcontext", "type": "Numeric & Mathematical", "text": "\nSet the current context for the active thread to c.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Subnormal", "path": "library/decimal#decimal.Subnormal", "type": "Numeric & Mathematical", "text": "\nExponent was lower than `Emin` prior to rounding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Underflow", "path": "library/decimal#decimal.Underflow", "type": "Numeric & Mathematical", "text": "\nNumerical underflow with result rounded to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "definition.__name__", "path": "library/stdtypes#definition.__name__", "type": "Built-in Types", "text": "\nThe name of the class, function, method, descriptor, or generator instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "definition.__qualname__", "path": "library/stdtypes#definition.__qualname__", "type": "Built-in Types", "text": "\nThe qualified name of the class, function, method, descriptor, or generator\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "delattr()", "path": "library/functions#delattr", "type": "Built-in Functions", "text": "\nThis is a relative of `setattr()`. The arguments are an object and a string.\nThe string must be the name of one of the object\u2019s attributes. The function\ndeletes the named attribute, provided the object allows it. For example,\n`delattr(x, 'foobar')` is equivalent to `del x.foobar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "DeprecationWarning", "path": "library/exceptions#DeprecationWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about deprecated features when those warnings are\nintended for other Python developers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Developing with asyncio", "path": "library/asyncio-dev", "type": "Asynchronous I/O", "text": "\nAsynchronous programming is different from classic \u201csequential\u201d programming.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict", "path": "library/functions#dict", "type": "Built-in Functions", "text": "\nCreate a new dictionary. The `dict` object is the dictionary class. See `dict`\nand Mapping Types \u2014 dict for documentation about this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict", "path": "library/stdtypes#dict", "type": "Built-in Types", "text": "\nReturn a new dictionary initialized from an optional positional argument and a\npossibly empty set of keyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.clear()", "path": "library/stdtypes#dict.clear", "type": "Built-in Types", "text": "\nRemove all items from the dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.copy()", "path": "library/stdtypes#dict.copy", "type": "Built-in Types", "text": "\nReturn a shallow copy of the dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.fromkeys()", "path": "library/stdtypes#dict.fromkeys", "type": "Built-in Types", "text": "\nCreate a new dictionary with keys from iterable and values set to value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.get()", "path": "library/stdtypes#dict.get", "type": "Built-in Types", "text": "\nReturn the value for key if key is in the dictionary, else default. If default\nis not given, it defaults to `None`, so that this method never raises a\n`KeyError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.items()", "path": "library/stdtypes#dict.items", "type": "Built-in Types", "text": "\nReturn a new view of the dictionary\u2019s items (`(key, value)` pairs). See the\ndocumentation of view objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.keys()", "path": "library/stdtypes#dict.keys", "type": "Built-in Types", "text": "\nReturn a new view of the dictionary\u2019s keys. See the documentation of view\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.pop()", "path": "library/stdtypes#dict.pop", "type": "Built-in Types", "text": "\nIf key is in the dictionary, remove it and return its value, else return\ndefault. If default is not given and key is not in the dictionary, a\n`KeyError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.popitem()", "path": "library/stdtypes#dict.popitem", "type": "Built-in Types", "text": "\nRemove and return a `(key, value)` pair from the dictionary. Pairs are\nreturned in LIFO order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.setdefault()", "path": "library/stdtypes#dict.setdefault", "type": "Built-in Types", "text": "\nIf key is in the dictionary, return its value. If not, insert key with a value\nof default and return default. default defaults to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.update()", "path": "library/stdtypes#dict.update", "type": "Built-in Types", "text": "\nUpdate the dictionary with the key/value pairs from other, overwriting\nexisting keys. Return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.values()", "path": "library/stdtypes#dict.values", "type": "Built-in Types", "text": "\nReturn a new view of the dictionary\u2019s values. See the documentation of view\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib", "path": "library/difflib", "type": "Text Processing", "text": "\nSource code: Lib/difflib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.context_diff()", "path": "library/difflib#difflib.context_diff", "type": "Text Processing", "text": "\nCompare a and b (lists of strings); return a delta (a generator generating the\ndelta lines) in context diff format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.Differ", "path": "library/difflib#difflib.Differ", "type": "Text Processing", "text": "\nThis is a class for comparing sequences of lines of text, and producing human-\nreadable differences or deltas. Differ uses `SequenceMatcher` both to compare\nsequences of lines, and to compare sequences of characters within similar\n(near-matching) lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.Differ.compare()", "path": "library/difflib#difflib.Differ.compare", "type": "Text Processing", "text": "\nCompare two sequences of lines, and generate the delta (a sequence of lines).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.diff_bytes()", "path": "library/difflib#difflib.diff_bytes", "type": "Text Processing", "text": "\nCompare a and b (lists of bytes objects) using dfunc; yield a sequence of\ndelta lines (also bytes) in the format returned by dfunc. dfunc must be a\ncallable, typically either `unified_diff()` or `context_diff()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.get_close_matches()", "path": "library/difflib#difflib.get_close_matches", "type": "Text Processing", "text": "\nReturn a list of the best \u201cgood enough\u201d matches. word is a sequence for which\nclose matches are desired (typically a string), and possibilities is a list of\nsequences against which to match word (typically a list of strings).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff", "path": "library/difflib#difflib.HtmlDiff", "type": "Text Processing", "text": "\nThis class can be used to create an HTML table (or a complete HTML file\ncontaining the table) showing a side by side, line by line comparison of text\nwith inter-line and intra-line change highlights. The table can be generated\nin either full or contextual difference mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff.make_file()", "path": "library/difflib#difflib.HtmlDiff.make_file", "type": "Text Processing", "text": "\nCompares fromlines and tolines (lists of strings) and returns a string which\nis a complete HTML file containing a table showing line by line differences\nwith inter-line and intra-line changes highlighted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff.make_table()", "path": "library/difflib#difflib.HtmlDiff.make_table", "type": "Text Processing", "text": "\nCompares fromlines and tolines (lists of strings) and returns a string which\nis a complete HTML table showing line by line differences with inter-line and\nintra-line changes highlighted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff.__init__()", "path": "library/difflib#difflib.HtmlDiff.__init__", "type": "Text Processing", "text": "\nInitializes instance of `HtmlDiff`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.IS_CHARACTER_JUNK()", "path": "library/difflib#difflib.IS_CHARACTER_JUNK", "type": "Text Processing", "text": "\nReturn `True` for ignorable characters. The character ch is ignorable if ch is\na space or tab, otherwise it is not ignorable. Used as a default for parameter\ncharjunk in `ndiff()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.IS_LINE_JUNK()", "path": "library/difflib#difflib.IS_LINE_JUNK", "type": "Text Processing", "text": "\nReturn `True` for ignorable lines. The line line is ignorable if line is blank\nor contains a single `'#'`, otherwise it is not ignorable. Used as a default\nfor parameter linejunk in `ndiff()` in older versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.ndiff()", "path": "library/difflib#difflib.ndiff", "type": "Text Processing", "text": "\nCompare a and b (lists of strings); return a `Differ`-style delta (a generator\ngenerating the delta lines).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.restore()", "path": "library/difflib#difflib.restore", "type": "Text Processing", "text": "\nReturn one of the two sequences that generated a delta.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher", "path": "library/difflib#difflib.SequenceMatcher", "type": "Text Processing", "text": "\nOptional argument isjunk must be `None` (the default) or a one-argument\nfunction that takes a sequence element and returns true if and only if the\nelement is \u201cjunk\u201d and should be ignored. Passing `None` for isjunk is\nequivalent to passing `lambda x: False`; in other words, no elements are\nignored. For example, pass:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.find_longest_match()", "path": "library/difflib#difflib.SequenceMatcher.find_longest_match", "type": "Text Processing", "text": "\nFind longest matching block in `a[alo:ahi]` and `b[blo:bhi]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.get_grouped_opcodes()", "path": "library/difflib#difflib.SequenceMatcher.get_grouped_opcodes", "type": "Text Processing", "text": "\nReturn a generator of groups with up to n lines of context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.get_matching_blocks()", "path": "library/difflib#difflib.SequenceMatcher.get_matching_blocks", "type": "Text Processing", "text": "\nReturn list of triples describing non-overlapping matching subsequences. Each\ntriple is of the form `(i, j, n)`, and means that `a[i:i+n] == b[j:j+n]`. The\ntriples are monotonically increasing in i and j.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.get_opcodes()", "path": "library/difflib#difflib.SequenceMatcher.get_opcodes", "type": "Text Processing", "text": "\nReturn list of 5-tuples describing how to turn a into b. Each tuple is of the\nform `(tag, i1, i2, j1, j2)`. The first tuple has `i1 == j1 == 0`, and\nremaining tuples have i1 equal to the i2 from the preceding tuple, and,\nlikewise, j1 equal to the previous j2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.quick_ratio()", "path": "library/difflib#difflib.SequenceMatcher.quick_ratio", "type": "Text Processing", "text": "\nReturn an upper bound on `ratio()` relatively quickly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.ratio()", "path": "library/difflib#difflib.SequenceMatcher.ratio", "type": "Text Processing", "text": "\nReturn a measure of the sequences\u2019 similarity as a float in the range [0, 1].\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.real_quick_ratio()", "path": "library/difflib#difflib.SequenceMatcher.real_quick_ratio", "type": "Text Processing", "text": "\nReturn an upper bound on `ratio()` very quickly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.set_seq1()", "path": "library/difflib#difflib.SequenceMatcher.set_seq1", "type": "Text Processing", "text": "\nSet the first sequence to be compared. The second sequence to be compared is\nnot changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.set_seq2()", "path": "library/difflib#difflib.SequenceMatcher.set_seq2", "type": "Text Processing", "text": "\nSet the second sequence to be compared. The first sequence to be compared is\nnot changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.set_seqs()", "path": "library/difflib#difflib.SequenceMatcher.set_seqs", "type": "Text Processing", "text": "\nSet the two sequences to be compared.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.unified_diff()", "path": "library/difflib#difflib.unified_diff", "type": "Text Processing", "text": "\nCompare a and b (lists of strings); return a delta (a generator generating the\ndelta lines) in unified diff format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dir()", "path": "library/functions#dir", "type": "Built-in Functions", "text": "\nWithout arguments, return the list of names in the current local scope. With\nan argument, attempt to return a list of valid attributes for that object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis", "path": "library/dis", "type": "Language", "text": "\nSource code: Lib/dis.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode", "path": "library/dis#dis.Bytecode", "type": "Language", "text": "\nAnalyse the bytecode corresponding to a function, generator, asynchronous\ngenerator, coroutine, method, string of source code, or a code object (as\nreturned by `compile()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.codeobj", "path": "library/dis#dis.Bytecode.codeobj", "type": "Language", "text": "\nThe compiled code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.dis()", "path": "library/dis#dis.Bytecode.dis", "type": "Language", "text": "\nReturn a formatted view of the bytecode operations (the same as printed by\n`dis.dis()`, but returned as a multi-line string).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.first_line", "path": "library/dis#dis.Bytecode.first_line", "type": "Language", "text": "\nThe first source line of the code object (if available)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.from_traceback()", "path": "library/dis#dis.Bytecode.from_traceback", "type": "Language", "text": "\nConstruct a `Bytecode` instance from the given traceback, setting\ncurrent_offset to the instruction responsible for the exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.info()", "path": "library/dis#dis.Bytecode.info", "type": "Language", "text": "\nReturn a formatted multi-line string with detailed information about the code\nobject, like `code_info()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.cmp_op", "path": "library/dis#dis.cmp_op", "type": "Language", "text": "\nSequence of all compare operation names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.code_info()", "path": "library/dis#dis.code_info", "type": "Language", "text": "\nReturn a formatted multi-line string with detailed code object information for\nthe supplied function, generator, asynchronous generator, coroutine, method,\nsource code string or code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.dis()", "path": "library/dis#dis.dis", "type": "Language", "text": "\nDisassemble the x object. x can denote either a module, a class, a method, a\nfunction, a generator, an asynchronous generator, a coroutine, a code object,\na string of source code or a byte sequence of raw bytecode. For a module, it\ndisassembles all functions. For a class, it disassembles all methods\n(including class and static methods). For a code object or sequence of raw\nbytecode, it prints one line per bytecode instruction. It also recursively\ndisassembles nested code objects (the code of comprehensions, generator\nexpressions and nested functions, and the code used for building nested\nclasses). Strings are first compiled to code objects with the `compile()`\nbuilt-in function before being disassembled. If no object is provided, this\nfunction disassembles the last traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.disassemble()", "path": "library/dis#dis.disassemble", "type": "Language", "text": "\nDisassemble a code object, indicating the last instruction if lasti was\nprovided. The output is divided in the following columns:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.disco()", "path": "library/dis#dis.disco", "type": "Language", "text": "\nDisassemble a code object, indicating the last instruction if lasti was\nprovided. The output is divided in the following columns:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.distb()", "path": "library/dis#dis.distb", "type": "Language", "text": "\nDisassemble the top-of-stack function of a traceback, using the last traceback\nif none was passed. The instruction causing the exception is indicated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.findlabels()", "path": "library/dis#dis.findlabels", "type": "Language", "text": "\nDetect all offsets in the raw compiled bytecode string code which are jump\ntargets, and return a list of these offsets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.findlinestarts()", "path": "library/dis#dis.findlinestarts", "type": "Language", "text": "\nThis generator function uses the `co_firstlineno` and `co_lnotab` attributes\nof the code object code to find the offsets which are starts of lines in the\nsource code. They are generated as `(offset, lineno)` pairs. See\nObjects/lnotab_notes.txt for the `co_lnotab` format and how to decode it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.get_instructions()", "path": "library/dis#dis.get_instructions", "type": "Language", "text": "\nReturn an iterator over the instructions in the supplied function, method,\nsource code string or code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hascompare", "path": "library/dis#dis.hascompare", "type": "Language", "text": "\nSequence of bytecodes of Boolean operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasconst", "path": "library/dis#dis.hasconst", "type": "Language", "text": "\nSequence of bytecodes that access a constant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasfree", "path": "library/dis#dis.hasfree", "type": "Language", "text": "\nSequence of bytecodes that access a free variable (note that \u2018free\u2019 in this\ncontext refers to names in the current scope that are referenced by inner\nscopes or names in outer scopes that are referenced from this scope. It does\nnot include references to global or builtin scopes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasjabs", "path": "library/dis#dis.hasjabs", "type": "Language", "text": "\nSequence of bytecodes that have an absolute jump target.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasjrel", "path": "library/dis#dis.hasjrel", "type": "Language", "text": "\nSequence of bytecodes that have a relative jump target.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.haslocal", "path": "library/dis#dis.haslocal", "type": "Language", "text": "\nSequence of bytecodes that access a local variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasname", "path": "library/dis#dis.hasname", "type": "Language", "text": "\nSequence of bytecodes that access an attribute by name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction", "path": "library/dis#dis.Instruction", "type": "Language", "text": "\nDetails for a bytecode operation\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.arg", "path": "library/dis#dis.Instruction.arg", "type": "Language", "text": "\nnumeric argument to operation (if any), otherwise `None`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.argrepr", "path": "library/dis#dis.Instruction.argrepr", "type": "Language", "text": "\nhuman readable description of operation argument\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.argval", "path": "library/dis#dis.Instruction.argval", "type": "Language", "text": "\nresolved arg value (if known), otherwise same as arg\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.is_jump_target", "path": "library/dis#dis.Instruction.is_jump_target", "type": "Language", "text": "\n`True` if other code jumps to here, otherwise `False`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.offset", "path": "library/dis#dis.Instruction.offset", "type": "Language", "text": "\nstart index of operation within bytecode sequence\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.opcode", "path": "library/dis#dis.Instruction.opcode", "type": "Language", "text": "\nnumeric code for operation, corresponding to the opcode values listed below\nand the bytecode values in the Opcode collections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.opname", "path": "library/dis#dis.Instruction.opname", "type": "Language", "text": "\nhuman readable name for operation\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.starts_line", "path": "library/dis#dis.Instruction.starts_line", "type": "Language", "text": "\nline started by this opcode (if any), otherwise `None`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.opmap", "path": "library/dis#dis.opmap", "type": "Language", "text": "\nDictionary mapping operation names to bytecodes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.opname", "path": "library/dis#dis.opname", "type": "Language", "text": "\nSequence of operation names, indexable using the bytecode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.show_code()", "path": "library/dis#dis.show_code", "type": "Language", "text": "\nPrint detailed code object information for the supplied function, method,\nsource code string or code object to file (or `sys.stdout` if file is not\nspecified).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.stack_effect()", "path": "library/dis#dis.stack_effect", "type": "Language", "text": "\nCompute the stack effect of opcode with argument oparg.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "distutils", "path": "library/distutils", "type": "Software Packaging & Distribution", "text": "\nThe `distutils` package provides support for building and installing\nadditional modules into a Python installation. The new modules may be either\n100%-pure Python, or may be extension modules written in C, or may be\ncollections of Python packages which include modules coded in both Python and\nC.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "divmod()", "path": "library/functions#divmod", "type": "Built-in Functions", "text": "\nTake two (non complex) numbers as arguments and return a pair of numbers\nconsisting of their quotient and remainder when using integer division. With\nmixed operand types, the rules for binary arithmetic operators apply. For\nintegers, the result is the same as `(a // b, a % b)`. For floating point\nnumbers the result is `(q, a % b)`, where q is usually `math.floor(a / b)` but\nmay be 1 less than that. In any case `q * b + a % b` is very close to a, if `a\n% b` is non-zero it has the same sign as b, and `0 <= abs(a % b) < abs(b)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest", "path": "library/doctest", "type": "Development Tools", "text": "\nSource code: Lib/doctest.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.COMPARISON_FLAGS", "path": "library/doctest#doctest.COMPARISON_FLAGS", "type": "Development Tools", "text": "\nA bitmask or\u2019ing together all the comparison flags above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.debug()", "path": "library/doctest#doctest.debug", "type": "Development Tools", "text": "\nDebug the doctests for an object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DebugRunner", "path": "library/doctest#doctest.DebugRunner", "type": "Development Tools", "text": "\nA subclass of `DocTestRunner` that raises an exception as soon as a failure is\nencountered. If an unexpected exception occurs, an `UnexpectedException`\nexception is raised, containing the test, the example, and the original\nexception. If the output doesn\u2019t match, then a `DocTestFailure` exception is\nraised, containing the test, the example, and the actual output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.debug_src()", "path": "library/doctest#doctest.debug_src", "type": "Development Tools", "text": "\nDebug the doctests in a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocFileSuite()", "path": "library/doctest#doctest.DocFileSuite", "type": "Development Tools", "text": "\nConvert doctest tests from one or more text files to a `unittest.TestSuite`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest", "path": "library/doctest#doctest.DocTest", "type": "Development Tools", "text": "\nA collection of doctest examples that should be run in a single namespace. The\nconstructor arguments are used to initialize the attributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.docstring", "path": "library/doctest#doctest.DocTest.docstring", "type": "Development Tools", "text": "\nThe string that the test was extracted from, or `None` if the string is\nunavailable, or if the test was not extracted from a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.examples", "path": "library/doctest#doctest.DocTest.examples", "type": "Development Tools", "text": "\nA list of `Example` objects encoding the individual interactive Python\nexamples that should be run by this test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.filename", "path": "library/doctest#doctest.DocTest.filename", "type": "Development Tools", "text": "\nThe name of the file that this `DocTest` was extracted from; or `None` if the\nfilename is unknown, or if the `DocTest` was not extracted from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.globs", "path": "library/doctest#doctest.DocTest.globs", "type": "Development Tools", "text": "\nThe namespace (aka globals) that the examples should be run in. This is a\ndictionary mapping names to values. Any changes to the namespace made by the\nexamples (such as binding new variables) will be reflected in `globs` after\nthe test is run.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.lineno", "path": "library/doctest#doctest.DocTest.lineno", "type": "Development Tools", "text": "\nThe line number within `filename` where this `DocTest` begins, or `None` if\nthe line number is unavailable. This line number is zero-based with respect to\nthe beginning of the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.name", "path": "library/doctest#doctest.DocTest.name", "type": "Development Tools", "text": "\nA string name identifying the `DocTest`. Typically, this is the name of the\nobject or file that the test was extracted from.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure", "path": "library/doctest#doctest.DocTestFailure", "type": "Development Tools", "text": "\nAn exception raised by `DocTestRunner` to signal that a doctest example\u2019s\nactual output did not match its expected output. The constructor arguments are\nused to initialize the attributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure.example", "path": "library/doctest#doctest.DocTestFailure.example", "type": "Development Tools", "text": "\nThe `Example` that failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure.got", "path": "library/doctest#doctest.DocTestFailure.got", "type": "Development Tools", "text": "\nThe example\u2019s actual output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure.test", "path": "library/doctest#doctest.DocTestFailure.test", "type": "Development Tools", "text": "\nThe `DocTest` object that was being run when the example failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFinder", "path": "library/doctest#doctest.DocTestFinder", "type": "Development Tools", "text": "\nA processing class used to extract the `DocTest`s that are relevant to a given\nobject, from its docstring and the docstrings of its contained objects.\n`DocTest`s can be extracted from modules, classes, functions, methods,\nstaticmethods, classmethods, and properties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFinder.find()", "path": "library/doctest#doctest.DocTestFinder.find", "type": "Development Tools", "text": "\nReturn a list of the `DocTest`s that are defined by obj\u2019s docstring, or by any\nof its contained objects\u2019 docstrings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser", "path": "library/doctest#doctest.DocTestParser", "type": "Development Tools", "text": "\nA processing class used to extract interactive examples from a string, and use\nthem to create a `DocTest` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser.get_doctest()", "path": "library/doctest#doctest.DocTestParser.get_doctest", "type": "Development Tools", "text": "\nExtract all doctest examples from the given string, and collect them into a\n`DocTest` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser.get_examples()", "path": "library/doctest#doctest.DocTestParser.get_examples", "type": "Development Tools", "text": "\nExtract all doctest examples from the given string, and return them as a list\nof `Example` objects. Line numbers are 0-based. The optional argument name is\na name identifying this string, and is only used for error messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser.parse()", "path": "library/doctest#doctest.DocTestParser.parse", "type": "Development Tools", "text": "\nDivide the given string into examples and intervening text, and return them as\na list of alternating `Example`s and strings. Line numbers for the `Example`s\nare 0-based. The optional argument name is a name identifying this string, and\nis only used for error messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner", "path": "library/doctest#doctest.DocTestRunner", "type": "Development Tools", "text": "\nA processing class used to execute and verify the interactive examples in a\n`DocTest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_failure()", "path": "library/doctest#doctest.DocTestRunner.report_failure", "type": "Development Tools", "text": "\nReport that the given example failed. This method is provided to allow\nsubclasses of `DocTestRunner` to customize their output; it should not be\ncalled directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_start()", "path": "library/doctest#doctest.DocTestRunner.report_start", "type": "Development Tools", "text": "\nReport that the test runner is about to process the given example. This method\nis provided to allow subclasses of `DocTestRunner` to customize their output;\nit should not be called directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_success()", "path": "library/doctest#doctest.DocTestRunner.report_success", "type": "Development Tools", "text": "\nReport that the given example ran successfully. This method is provided to\nallow subclasses of `DocTestRunner` to customize their output; it should not\nbe called directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_unexpected_exception()", "path": "library/doctest#doctest.DocTestRunner.report_unexpected_exception", "type": "Development Tools", "text": "\nReport that the given example raised an unexpected exception. This method is\nprovided to allow subclasses of `DocTestRunner` to customize their output; it\nshould not be called directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.run()", "path": "library/doctest#doctest.DocTestRunner.run", "type": "Development Tools", "text": "\nRun the examples in test (a `DocTest` object), and display the results using\nthe writer function out.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.summarize()", "path": "library/doctest#doctest.DocTestRunner.summarize", "type": "Development Tools", "text": "\nPrint a summary of all the test cases that have been run by this\nDocTestRunner, and return a named tuple `TestResults(failed, attempted)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestSuite()", "path": "library/doctest#doctest.DocTestSuite", "type": "Development Tools", "text": "\nConvert doctest tests for a module to a `unittest.TestSuite`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DONT_ACCEPT_BLANKLINE", "path": "library/doctest#doctest.DONT_ACCEPT_BLANKLINE", "type": "Development Tools", "text": "\nBy default, if an expected output block contains a line containing only the\nstring `<BLANKLINE>`, then that line will match a blank line in the actual\noutput. Because a genuinely blank line delimits the expected output, this is\nthe only way to communicate that a blank line is expected. When\n`DONT_ACCEPT_BLANKLINE` is specified, this substitution is not allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DONT_ACCEPT_TRUE_FOR_1", "path": "library/doctest#doctest.DONT_ACCEPT_TRUE_FOR_1", "type": "Development Tools", "text": "\nBy default, if an expected output block contains just `1`, an actual output\nblock containing just `1` or just `True` is considered to be a match, and\nsimilarly for `0` versus `False`. When `DONT_ACCEPT_TRUE_FOR_1` is specified,\nneither substitution is allowed. The default behavior caters to that Python\nchanged the return type of many functions from integer to boolean; doctests\nexpecting \u201clittle integer\u201d output still work in these cases. This option will\nprobably go away, but not for several years.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.ELLIPSIS", "path": "library/doctest#doctest.ELLIPSIS", "type": "Development Tools", "text": "\nWhen specified, an ellipsis marker (`...`) in the expected output can match\nany substring in the actual output. This includes substrings that span line\nboundaries, and empty substrings, so it\u2019s best to keep usage of this simple.\nComplicated uses can lead to the same kinds of \u201coops, it matched too much!\u201d\nsurprises that `.*` is prone to in regular expressions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example", "path": "library/doctest#doctest.Example", "type": "Development Tools", "text": "\nA single interactive example, consisting of a Python statement and its\nexpected output. The constructor arguments are used to initialize the\nattributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.exc_msg", "path": "library/doctest#doctest.Example.exc_msg", "type": "Development Tools", "text": "\nThe exception message generated by the example, if the example is expected to\ngenerate an exception; or `None` if it is not expected to generate an\nexception. This exception message is compared against the return value of\n`traceback.format_exception_only()`. `exc_msg` ends with a newline unless it\u2019s\n`None`. The constructor adds a newline if needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.indent", "path": "library/doctest#doctest.Example.indent", "type": "Development Tools", "text": "\nThe example\u2019s indentation in the containing string, i.e., the number of space\ncharacters that precede the example\u2019s first prompt.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.lineno", "path": "library/doctest#doctest.Example.lineno", "type": "Development Tools", "text": "\nThe line number within the string containing this example where the example\nbegins. This line number is zero-based with respect to the beginning of the\ncontaining string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.options", "path": "library/doctest#doctest.Example.options", "type": "Development Tools", "text": "\nA dictionary mapping from option flags to `True` or `False`, which is used to\noverride default options for this example. Any option flags not contained in\nthis dictionary are left at their default value (as specified by the\n`DocTestRunner`\u2019s `optionflags`). By default, no options are set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.source", "path": "library/doctest#doctest.Example.source", "type": "Development Tools", "text": "\nA string containing the example\u2019s source code. This source code consists of a\nsingle Python statement, and always ends with a newline; the constructor adds\na newline when necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.want", "path": "library/doctest#doctest.Example.want", "type": "Development Tools", "text": "\nThe expected output from running the example\u2019s source code (either from\nstdout, or a traceback in case of exception). `want` ends with a newline\nunless no output is expected, in which case it\u2019s an empty string. The\nconstructor adds a newline when necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.FAIL_FAST", "path": "library/doctest#doctest.FAIL_FAST", "type": "Development Tools", "text": "\nWhen specified, exit after the first failing example and don\u2019t attempt to run\nthe remaining examples. Thus, the number of failures reported will be at most\n1. This flag may be useful during debugging, since examples after the first\nfailure won\u2019t even produce debugging output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.IGNORE_EXCEPTION_DETAIL", "path": "library/doctest#doctest.IGNORE_EXCEPTION_DETAIL", "type": "Development Tools", "text": "\nWhen specified, an example that expects an exception passes if an exception of\nthe expected type is raised, even if the exception detail does not match. For\nexample, an example expecting `ValueError: 42` will pass if the actual\nexception raised is `ValueError: 3*14`, but will fail, e.g., if `TypeError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.NORMALIZE_WHITESPACE", "path": "library/doctest#doctest.NORMALIZE_WHITESPACE", "type": "Development Tools", "text": "\nWhen specified, all sequences of whitespace (blanks and newlines) are treated\nas equal. Any sequence of whitespace within the expected output will match any\nsequence of whitespace within the actual output. By default, whitespace must\nmatch exactly. `NORMALIZE_WHITESPACE` is especially useful when a line of\nexpected output is very long, and you want to wrap it across multiple lines in\nyour source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.OutputChecker", "path": "library/doctest#doctest.OutputChecker", "type": "Development Tools", "text": "\nA class used to check the whether the actual output from a doctest example\nmatches the expected output. `OutputChecker` defines two methods:\n`check_output()`, which compares a given pair of outputs, and returns `True`\nif they match; and `output_difference()`, which returns a string describing\nthe differences between two outputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.OutputChecker.check_output()", "path": "library/doctest#doctest.OutputChecker.check_output", "type": "Development Tools", "text": "\nReturn `True` iff the actual output from an example (got) matches the expected\noutput (want). These strings are always considered to match if they are\nidentical; but depending on what option flags the test runner is using,\nseveral non-exact match types are also possible. See section Option Flags for\nmore information about option flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.OutputChecker.output_difference()", "path": "library/doctest#doctest.OutputChecker.output_difference", "type": "Development Tools", "text": "\nReturn a string describing the differences between the expected output for a\ngiven example (example) and the actual output (got). optionflags is the set of\noption flags used to compare want and got.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.register_optionflag()", "path": "library/doctest#doctest.register_optionflag", "type": "Development Tools", "text": "\nCreate a new option flag with a given name, and return the new flag\u2019s integer\nvalue. `register_optionflag()` can be used when subclassing `OutputChecker` or\n`DocTestRunner` to create new options that are supported by your subclasses.\n`register_optionflag()` should always be called using the following idiom:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORTING_FLAGS", "path": "library/doctest#doctest.REPORTING_FLAGS", "type": "Development Tools", "text": "\nA bitmask or\u2019ing together all the reporting flags above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_CDIFF", "path": "library/doctest#doctest.REPORT_CDIFF", "type": "Development Tools", "text": "\nWhen specified, failures that involve multi-line expected and actual outputs\nwill be displayed using a context diff.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_NDIFF", "path": "library/doctest#doctest.REPORT_NDIFF", "type": "Development Tools", "text": "\nWhen specified, differences are computed by `difflib.Differ`, using the same\nalgorithm as the popular `ndiff.py` utility. This is the only method that\nmarks differences within lines as well as across lines. For example, if a line\nof expected output contains digit `1` where actual output contains letter `l`,\na line is inserted with a caret marking the mismatching column positions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_ONLY_FIRST_FAILURE", "path": "library/doctest#doctest.REPORT_ONLY_FIRST_FAILURE", "type": "Development Tools", "text": "\nWhen specified, display the first failing example in each doctest, but\nsuppress output for all remaining examples. This will prevent doctest from\nreporting correct examples that break because of earlier failures; but it\nmight also hide incorrect examples that fail independently of the first\nfailure. When `REPORT_ONLY_FIRST_FAILURE` is specified, the remaining examples\nare still run, and still count towards the total number of failures reported;\nonly the output is suppressed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_UDIFF", "path": "library/doctest#doctest.REPORT_UDIFF", "type": "Development Tools", "text": "\nWhen specified, failures that involve multi-line expected and actual outputs\nare displayed using a unified diff.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.run_docstring_examples()", "path": "library/doctest#doctest.run_docstring_examples", "type": "Development Tools", "text": "\nTest examples associated with object f; for example, f may be a string, a\nmodule, a function, or a class object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.script_from_examples()", "path": "library/doctest#doctest.script_from_examples", "type": "Development Tools", "text": "\nConvert text with examples to a script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.set_unittest_reportflags()", "path": "library/doctest#doctest.set_unittest_reportflags", "type": "Development Tools", "text": "\nSet the `doctest` reporting flags to use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.SKIP", "path": "library/doctest#doctest.SKIP", "type": "Development Tools", "text": "\nWhen specified, do not run the example at all. This can be useful in contexts\nwhere doctest examples serve as both documentation and test cases, and an\nexample should be included for documentation purposes, but should not be\nchecked. E.g., the example\u2019s output might be random; or the example might\ndepend on resources which would be unavailable to the test driver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.testfile()", "path": "library/doctest#doctest.testfile", "type": "Development Tools", "text": "\nAll arguments except filename are optional, and should be specified in keyword\nform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.testmod()", "path": "library/doctest#doctest.testmod", "type": "Development Tools", "text": "\nAll arguments are optional, and all except for m should be specified in\nkeyword form.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.testsource()", "path": "library/doctest#doctest.testsource", "type": "Development Tools", "text": "\nConvert the doctest for an object to a script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException", "path": "library/doctest#doctest.UnexpectedException", "type": "Development Tools", "text": "\nAn exception raised by `DocTestRunner` to signal that a doctest example raised\nan unexpected exception. The constructor arguments are used to initialize the\nattributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException.example", "path": "library/doctest#doctest.UnexpectedException.example", "type": "Development Tools", "text": "\nThe `Example` that failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException.exc_info", "path": "library/doctest#doctest.UnexpectedException.exc_info", "type": "Development Tools", "text": "\nA tuple containing information about the unexpected exception, as returned by\n`sys.exc_info()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException.test", "path": "library/doctest#doctest.UnexpectedException.test", "type": "Development Tools", "text": "\nThe `DocTest` object that was being run when the example failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Ellipsis", "path": "library/constants#Ellipsis", "type": "Built-in Constants", "text": "\nThe same as the ellipsis literal \u201c`...`\u201d. Special value used mostly in\nconjunction with extended slicing syntax for user-defined container data\ntypes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email", "path": "library/email", "type": "Internet Data", "text": "\nSource code: Lib/email/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.add_alias()", "path": "library/email.charset#email.charset.add_alias", "type": "Email", "text": "\nAdd a character set alias. alias is the alias name, e.g. `latin-1`. canonical\nis the character set\u2019s canonical name, e.g. `iso-8859-1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.add_charset()", "path": "library/email.charset#email.charset.add_charset", "type": "Email", "text": "\nAdd character properties to the global registry.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.add_codec()", "path": "library/email.charset#email.charset.add_codec", "type": "Email", "text": "\nAdd a codec that map characters in the given character set to and from\nUnicode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset", "path": "library/email.charset#email.charset.Charset", "type": "Email", "text": "\nMap character sets to their email properties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.body_encode()", "path": "library/email.charset#email.charset.Charset.body_encode", "type": "Email", "text": "\nBody-encode the string string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.body_encoding", "path": "library/email.charset#email.charset.Charset.body_encoding", "type": "Email", "text": "\nSame as header_encoding, but describes the encoding for the mail message\u2019s\nbody, which indeed may be different than the header encoding.\n`Charset.SHORTEST` is not allowed for body_encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.get_body_encoding()", "path": "library/email.charset#email.charset.Charset.get_body_encoding", "type": "Email", "text": "\nReturn the content transfer encoding used for body encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.get_output_charset()", "path": "library/email.charset#email.charset.Charset.get_output_charset", "type": "Email", "text": "\nReturn the output character set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.header_encode()", "path": "library/email.charset#email.charset.Charset.header_encode", "type": "Email", "text": "\nHeader-encode the string string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.header_encode_lines()", "path": "library/email.charset#email.charset.Charset.header_encode_lines", "type": "Email", "text": "\nHeader-encode a string by converting it first to bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.header_encoding", "path": "library/email.charset#email.charset.Charset.header_encoding", "type": "Email", "text": "\nIf the character set must be encoded before it can be used in an email header,\nthis attribute will be set to `Charset.QP` (for quoted-printable),\n`Charset.BASE64` (for base64 encoding), or `Charset.SHORTEST` for the shortest\nof QP or BASE64 encoding. Otherwise, it will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.input_charset", "path": "library/email.charset#email.charset.Charset.input_charset", "type": "Email", "text": "\nThe initial character set specified. Common aliases are converted to their\nofficial email names (e.g. `latin_1` is converted to `iso-8859-1`). Defaults\nto 7-bit `us-ascii`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.input_codec", "path": "library/email.charset#email.charset.Charset.input_codec", "type": "Email", "text": "\nThe name of the Python codec used to convert the input_charset to Unicode. If\nno conversion codec is necessary, this attribute will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.output_charset", "path": "library/email.charset#email.charset.Charset.output_charset", "type": "Email", "text": "\nSome character sets must be converted before they can be used in email headers\nor bodies. If the input_charset is one of them, this attribute will contain\nthe name of the character set output will be converted to. Otherwise, it will\nbe `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.output_codec", "path": "library/email.charset#email.charset.Charset.output_codec", "type": "Email", "text": "\nThe name of the Python codec used to convert Unicode to the output_charset. If\nno conversion codec is necessary, this attribute will have the same value as\nthe input_codec.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.__eq__()", "path": "library/email.charset#email.charset.Charset.__eq__", "type": "Email", "text": "\nThis method allows you to compare two `Charset` instances for equality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.__ne__()", "path": "library/email.charset#email.charset.Charset.__ne__", "type": "Email", "text": "\nThis method allows you to compare two `Charset` instances for inequality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.__str__()", "path": "library/email.charset#email.charset.Charset.__str__", "type": "Email", "text": "\nReturns input_charset as a string coerced to lower case. `__repr__()` is an\nalias for `__str__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset: Representing character sets", "path": "library/email.charset", "type": "Email", "text": "\nSource code: Lib/email/charset.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager", "path": "library/email.contentmanager#email.contentmanager.ContentManager", "type": "Email", "text": "\nBase class for content managers. Provides the standard registry mechanisms to\nregister converters between MIME content and other representations, as well as\nthe `get_content` and `set_content` dispatch methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.add_get_handler()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.add_get_handler", "type": "Email", "text": "\nRecord the function handler as the handler for key. For the possible values of\nkey, see `get_content()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.add_set_handler()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.add_set_handler", "type": "Email", "text": "\nRecord handler as the function to call when an object of a type matching\ntypekey is passed to `set_content()`. For the possible values of typekey, see\n`set_content()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.get_content()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.get_content", "type": "Email", "text": "\nLook up a handler function based on the `mimetype` of msg (see next\nparagraph), call it, passing through all arguments, and return the result of\nthe call. The expectation is that the handler will extract the payload from\nmsg and return an object that encodes information about the extracted data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.set_content()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.set_content", "type": "Email", "text": "\nIf the `maintype` is `multipart`, raise a `TypeError`; otherwise look up a\nhandler function based on the type of obj (see next paragraph), call\n`clear_content()` on the msg, and call the handler function, passing through\nall arguments. The expectation is that the handler will transform and store\nobj into msg, possibly making other changes to msg as well, such as adding\nvarious MIME headers to encode information needed to interpret the stored\ndata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.get_content()", "path": "library/email.contentmanager#email.contentmanager.get_content", "type": "Email", "text": "\nReturn the payload of the part as either a string (for `text` parts), an\n`EmailMessage` object (for `message/rfc822` parts), or a `bytes` object (for\nall other non-multipart types). Raise a `KeyError` if called on a `multipart`.\nIf the part is a `text` part and errors is specified, use it as the error\nhandler when decoding the payload to unicode. The default error handler is\n`replace`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.raw_data_manager", "path": "library/email.contentmanager#email.contentmanager.raw_data_manager", "type": "Email", "text": "\nThis content manager provides only a minimum interface beyond that provided by\n`Message` itself: it deals only with text, raw byte strings, and `Message`\nobjects. Nevertheless, it provides significant advantages compared to the base\nAPI: `get_content` on a text part will return a unicode string without the\napplication needing to manually decode it, `set_content` provides a rich set\nof options for controlling the headers added to a part and controlling the\ncontent transfer encoding, and it enables the use of the various `add_`\nmethods, thereby simplifying the creation of multipart messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.set_content()", "path": "library/email.contentmanager#email.contentmanager.set_content", "type": "Email", "text": "\nAdd headers and payload to msg:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager: Managing MIME Content", "path": "library/email.contentmanager", "type": "Email", "text": "\nSource code: Lib/email/contentmanager.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_7or8bit()", "path": "library/email.encoders#email.encoders.encode_7or8bit", "type": "Email", "text": "\nThis doesn\u2019t actually modify the message\u2019s payload, but it does set the\nContent-Transfer-Encoding header to either `7bit` or `8bit` as appropriate,\nbased on the payload data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_base64()", "path": "library/email.encoders#email.encoders.encode_base64", "type": "Email", "text": "\nEncodes the payload into base64 form and sets the Content-Transfer-Encoding\nheader to `base64`. This is a good encoding to use when most of your payload\nis unprintable data since it is a more compact form than quoted-printable. The\ndrawback of base64 encoding is that it renders the text non-human readable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_noop()", "path": "library/email.encoders#email.encoders.encode_noop", "type": "Email", "text": "\nThis does nothing; it doesn\u2019t even set the Content-Transfer-Encoding header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_quopri()", "path": "library/email.encoders#email.encoders.encode_quopri", "type": "Email", "text": "\nEncodes the payload into quoted-printable form and sets the Content-Transfer-\nEncoding header to `quoted-printable` 1. This is a good encoding to use when\nmost of your payload is normal printable data, but contains a few unprintable\ncharacters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders: Encoders", "path": "library/email.encoders", "type": "Email", "text": "\nSource code: Lib/email/encoders.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.BoundaryError", "path": "library/email.errors#email.errors.BoundaryError", "type": "Email", "text": "\nDeprecated and no longer used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.HeaderParseError", "path": "library/email.errors#email.errors.HeaderParseError", "type": "Email", "text": "\nRaised under some error conditions when parsing the RFC 5322 headers of a\nmessage, this class is derived from `MessageParseError`. The `set_boundary()`\nmethod will raise this error if the content type is unknown when the method is\ncalled. `Header` may raise this error for certain base64 decoding errors, and\nwhen an attempt is made to create a header that appears to contain an embedded\nheader (that is, there is what is supposed to be a continuation line that has\nno leading whitespace and looks like a header).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.MessageError", "path": "library/email.errors#email.errors.MessageError", "type": "Email", "text": "\nThis is the base class for all exceptions that the `email` package can raise.\nIt is derived from the standard `Exception` class and defines no additional\nmethods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.MessageParseError", "path": "library/email.errors#email.errors.MessageParseError", "type": "Email", "text": "\nThis is the base class for exceptions raised by the `Parser` class. It is\nderived from `MessageError`. This class is also used internally by the parser\nused by `headerregistry`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.MultipartConversionError", "path": "library/email.errors#email.errors.MultipartConversionError", "type": "Email", "text": "\nRaised when a payload is added to a `Message` object using `add_payload()`,\nbut the payload is already a scalar and the message\u2019s Content-Type main type\nis not either multipart or missing. `MultipartConversionError` multiply\ninherits from `MessageError` and the built-in `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors: Exception and Defect classes", "path": "library/email.errors", "type": "Email", "text": "\nSource code: Lib/email/errors.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator", "path": "library/email.generator#email.generator.BytesGenerator", "type": "Email", "text": "\nReturn a `BytesGenerator` object that will write any message provided to the\n`flatten()` method, or any surrogateescape encoded text provided to the\n`write()` method, to the file-like object outfp. outfp must support a `write`\nmethod that accepts binary data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator.clone()", "path": "library/email.generator#email.generator.BytesGenerator.clone", "type": "Email", "text": "\nReturn an independent clone of this `BytesGenerator` instance with the exact\nsame option settings, and fp as the new outfp.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator.flatten()", "path": "library/email.generator#email.generator.BytesGenerator.flatten", "type": "Email", "text": "\nPrint the textual representation of the message object structure rooted at msg\nto the output file specified when the `BytesGenerator` instance was created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator.write()", "path": "library/email.generator#email.generator.BytesGenerator.write", "type": "Email", "text": "\nEncode s using the `ASCII` codec and the `surrogateescape` error handler, and\npass it to the write method of the outfp passed to the `BytesGenerator`\u2019s\nconstructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.DecodedGenerator", "path": "library/email.generator#email.generator.DecodedGenerator", "type": "Email", "text": "\nAct like `Generator`, except that for any subpart of the message passed to\n`Generator.flatten()`, if the subpart is of main type text, print the decoded\npayload of the subpart, and if the main type is not text, instead of printing\nit fill in the string fmt using information from the part and print the\nresulting filled-in string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator", "path": "library/email.generator#email.generator.Generator", "type": "Email", "text": "\nReturn a `Generator` object that will write any message provided to the\n`flatten()` method, or any text provided to the `write()` method, to the file-\nlike object outfp. outfp must support a `write` method that accepts string\ndata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator.clone()", "path": "library/email.generator#email.generator.Generator.clone", "type": "Email", "text": "\nReturn an independent clone of this `Generator` instance with the exact same\noptions, and fp as the new outfp.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator.flatten()", "path": "library/email.generator#email.generator.Generator.flatten", "type": "Email", "text": "\nPrint the textual representation of the message object structure rooted at msg\nto the output file specified when the `Generator` instance was created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator.write()", "path": "library/email.generator#email.generator.Generator.write", "type": "Email", "text": "\nWrite s to the write method of the outfp passed to the `Generator`\u2019s\nconstructor. This provides just enough file-like API for `Generator` instances\nto be used in the `print()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator: Generating MIME documents", "path": "library/email.generator", "type": "Email", "text": "\nSource code: Lib/email/generator.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.decode_header()", "path": "library/email.header#email.header.decode_header", "type": "Email", "text": "\nDecode a message header value without converting the character set. The header\nvalue is in header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header", "path": "library/email.header#email.header.Header", "type": "Email", "text": "\nCreate a MIME-compliant header that can contain strings in different character\nsets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.append()", "path": "library/email.header#email.header.Header.append", "type": "Email", "text": "\nAppend the string s to the MIME header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.encode()", "path": "library/email.header#email.header.Header.encode", "type": "Email", "text": "\nEncode a message header into an RFC-compliant format, possibly wrapping long\nlines and encapsulating non-ASCII parts in base64 or quoted-printable\nencodings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.__eq__()", "path": "library/email.header#email.header.Header.__eq__", "type": "Email", "text": "\nThis method allows you to compare two `Header` instances for equality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.__ne__()", "path": "library/email.header#email.header.Header.__ne__", "type": "Email", "text": "\nThis method allows you to compare two `Header` instances for inequality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.__str__()", "path": "library/email.header#email.header.Header.__str__", "type": "Email", "text": "\nReturns an approximation of the `Header` as a string, using an unlimited line\nlength. All pieces are converted to unicode using the specified encoding and\njoined together appropriately. Any pieces with a charset of `'unknown-8bit'`\nare decoded as ASCII using the `'replace'` error handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.make_header()", "path": "library/email.header#email.header.make_header", "type": "Email", "text": "\nCreate a `Header` instance from a sequence of pairs as returned by\n`decode_header()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header: Internationalized headers", "path": "library/email.header", "type": "Email", "text": "\nSource code: Lib/email/header.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address", "path": "library/email.headerregistry#email.headerregistry.Address", "type": "Email", "text": "\nThe class used to represent an email address. The general form of an address\nis:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.addr_spec", "path": "library/email.headerregistry#email.headerregistry.Address.addr_spec", "type": "Email", "text": "\nThe `username@domain` portion of the address, correctly quoted for use as a\nbare address (the second form shown above). This attribute is not mutable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.display_name", "path": "library/email.headerregistry#email.headerregistry.Address.display_name", "type": "Email", "text": "\nThe display name portion of the address, if any, with all quoting removed. If\nthe address does not have a display name, this attribute will be an empty\nstring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.domain", "path": "library/email.headerregistry#email.headerregistry.Address.domain", "type": "Email", "text": "\nThe `domain` portion of the address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.username", "path": "library/email.headerregistry#email.headerregistry.Address.username", "type": "Email", "text": "\nThe `username` portion of the address, with all quoting removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.__str__()", "path": "library/email.headerregistry#email.headerregistry.Address.__str__", "type": "Email", "text": "\nThe `str` value of the object is the address quoted according to RFC 5322\nrules, but with no Content Transfer Encoding of any non-ASCII characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.AddressHeader", "path": "library/email.headerregistry#email.headerregistry.AddressHeader", "type": "Email", "text": "\nAddress headers are one of the most complex structured header types. The\n`AddressHeader` class provides a generic interface to any address header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.AddressHeader.addresses", "path": "library/email.headerregistry#email.headerregistry.AddressHeader.addresses", "type": "Email", "text": "\nA tuple of `Address` objects encoding all of the individual addresses from the\nheader value. If the header value contains any groups, the individual\naddresses from the group are included in the list at the point where the group\noccurs in the value (that is, the list of addresses is \u201cflattened\u201d into a one\ndimensional list).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.AddressHeader.groups", "path": "library/email.headerregistry#email.headerregistry.AddressHeader.groups", "type": "Email", "text": "\nA tuple of `Group` objects encoding the addresses and groups found in the\nheader value. Addresses that are not part of a group are represented in this\nlist as single-address `Groups` whose `display_name` is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader", "path": "library/email.headerregistry#email.headerregistry.BaseHeader", "type": "Email", "text": "\nname and value are passed to `BaseHeader` from the `header_factory` call. The\nstring value of any header object is the value fully decoded to unicode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.defects", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.defects", "type": "Email", "text": "\nA tuple of `HeaderDefect` instances reporting any RFC compliance problems\nfound during parsing. The email package tries to be complete about detecting\ncompliance issues. See the `errors` module for a discussion of the types of\ndefects that may be reported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.fold()", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.fold", "type": "Email", "text": "\nReturn a string containing `linesep` characters as required to correctly fold\nthe header according to policy. A `cte_type` of `8bit` will be treated as if\nit were `7bit`, since headers may not contain arbitrary binary data. If `utf8`\nis `False`, non-ASCII data will be RFC 2047 encoded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.max_count", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.max_count", "type": "Email", "text": "\nThe maximum number of headers of this type that can have the same `name`. A\nvalue of `None` means unlimited. The `BaseHeader` value for this attribute is\n`None`; it is expected that specialized header classes will override this\nvalue as needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.name", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.name", "type": "Email", "text": "\nThe name of the header (the portion of the field before the \u2018:\u2019). This is\nexactly the value passed in the `header_factory` call for name; that is, case\nis preserved.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentDispositionHeader", "path": "library/email.headerregistry#email.headerregistry.ContentDispositionHeader", "type": "Email", "text": "\nA `ParameterizedMIMEHeader` class that handles the Content-Disposition header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentDispositionHeader.content_disposition", "path": "library/email.headerregistry#email.headerregistry.ContentDispositionHeader.content_disposition", "type": "Email", "text": "\n`inline` and `attachment` are the only valid values in common use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTransferEncoding", "path": "library/email.headerregistry#email.headerregistry.ContentTransferEncoding", "type": "Email", "text": "\nHandles the Content-Transfer-Encoding header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTransferEncoding.cte", "path": "library/email.headerregistry#email.headerregistry.ContentTransferEncoding.cte", "type": "Email", "text": "\nValid values are `7bit`, `8bit`, `base64`, and `quoted-printable`. See RFC\n2045 for more information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader", "type": "Email", "text": "\nA `ParameterizedMIMEHeader` class that handles the Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader.content_type", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader.content_type", "type": "Email", "text": "\nThe content type string, in the form `maintype/subtype`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader.maintype", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader.maintype", "type": "Email", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader.subtype", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader.subtype", "type": "Email", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.DateHeader", "path": "library/email.headerregistry#email.headerregistry.DateHeader", "type": "Email", "text": "\nRFC 5322 specifies a very specific format for dates within email headers. The\n`DateHeader` parser recognizes that date format, as well as recognizing a\nnumber of variant forms that are sometimes found \u201cin the wild\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.DateHeader.datetime", "path": "library/email.headerregistry#email.headerregistry.DateHeader.datetime", "type": "Email", "text": "\nIf the header value can be recognized as a valid date of one form or another,\nthis attribute will contain a `datetime` instance representing that date. If\nthe timezone of the input date is specified as `-0000` (indicating it is in\nUTC but contains no information about the source timezone), then `datetime`\nwill be a naive `datetime`. If a specific timezone offset is found (including\n`+0000`), then `datetime` will contain an aware `datetime` that uses\n`datetime.timezone` to record the timezone offset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group", "path": "library/email.headerregistry#email.headerregistry.Group", "type": "Email", "text": "\nThe class used to represent an address group. The general form of an address\ngroup is:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group.addresses", "path": "library/email.headerregistry#email.headerregistry.Group.addresses", "type": "Email", "text": "\nA possibly empty tuple of `Address` objects representing the addresses in the\ngroup.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group.display_name", "path": "library/email.headerregistry#email.headerregistry.Group.display_name", "type": "Email", "text": "\nThe `display_name` of the group. If it is `None` and there is exactly one\n`Address` in `addresses`, then the `Group` represents a single address that is\nnot in a group.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group.__str__()", "path": "library/email.headerregistry#email.headerregistry.Group.__str__", "type": "Email", "text": "\nThe `str` value of a `Group` is formatted according to RFC 5322, but with no\nContent Transfer Encoding of any non-ASCII characters. If `display_name` is\nnone and there is a single `Address` in the `addresses` list, the `str` value\nwill be the same as the `str` of that single `Address`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry", "type": "Email", "text": "\nThis is the factory used by `EmailPolicy` by default. `HeaderRegistry` builds\nthe class used to create a header instance dynamically, using base_class and a\nspecialized class retrieved from a registry that it holds. When a given header\nname does not appear in the registry, the class specified by default_class is\nused as the specialized class. When use_default_map is `True` (the default),\nthe standard mapping of header names to classes is copied in to the registry\nduring initialization. base_class is always the last class in the generated\nclass\u2019s `__bases__` list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry.map_to_type()", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry.map_to_type", "type": "Email", "text": "\nname is the name of the header to be mapped. It will be converted to lower\ncase in the registry. cls is the specialized class to be used, along with\nbase_class, to create the class used to instantiate headers that match name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry.__call__()", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry.__call__", "type": "Email", "text": "\nRetrieves the specialized header associated with name from the registry (using\ndefault_class if name does not appear in the registry) and composes it with\nbase_class to produce a class, calls the constructed class\u2019s constructor,\npassing it the same argument list, and finally returns the class instance\ncreated thereby.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry.__getitem__()", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry.__getitem__", "type": "Email", "text": "\nConstruct and return a class to handle creating a name header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader", "type": "Email", "text": "\nThere is really only one valid value for the MIME-Version header, and that is\n`1.0`. For future proofing, this header class supports other valid version\nnumbers. If a version number has a valid value per RFC 2045, then the header\nobject will have non-`None` values for the following attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader.major", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader.major", "type": "Email", "text": "\nThe major version number as an integer\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader.minor", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader.minor", "type": "Email", "text": "\nThe minor version number as an integer\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader.version", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader.version", "type": "Email", "text": "\nThe version number as a string, with any whitespace and/or comments removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ParameterizedMIMEHeader", "path": "library/email.headerregistry#email.headerregistry.ParameterizedMIMEHeader", "type": "Email", "text": "\nMIME headers all start with the prefix \u2018Content-\u2018. Each specific header has a\ncertain value, described under the class for that header. Some can also take a\nlist of supplemental parameters, which have a common format. This class serves\nas a base for all the MIME headers that take parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ParameterizedMIMEHeader.params", "path": "library/email.headerregistry#email.headerregistry.ParameterizedMIMEHeader.params", "type": "Email", "text": "\nA dictionary mapping parameter names to parameter values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.SingleAddressHeader", "path": "library/email.headerregistry#email.headerregistry.SingleAddressHeader", "type": "Email", "text": "\nA subclass of `AddressHeader` that adds one additional attribute:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.SingleAddressHeader.address", "path": "library/email.headerregistry#email.headerregistry.SingleAddressHeader.address", "type": "Email", "text": "\nThe single address encoded by the header value. If the header value actually\ncontains more than one address (which would be a violation of the RFC under\nthe default `policy`), accessing this attribute will result in a `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.UnstructuredHeader", "path": "library/email.headerregistry#email.headerregistry.UnstructuredHeader", "type": "Email", "text": "\nAn \u201cunstructured\u201d header is the default type of header in RFC 5322. Any header\nthat does not have a specified syntax is treated as unstructured. The classic\nexample of an unstructured header is the Subject header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry: Custom Header Objects", "path": "library/email.headerregistry", "type": "Email", "text": "\nSource code: Lib/email/headerregistry.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators.body_line_iterator()", "path": "library/email.iterators#email.iterators.body_line_iterator", "type": "Email", "text": "\nThis iterates over all the payloads in all the subparts of msg, returning the\nstring payloads line-by-line. It skips over all the subpart headers, and it\nskips over any subpart with a payload that isn\u2019t a Python string. This is\nsomewhat equivalent to reading the flat text representation of the message\nfrom a file using `readline()`, skipping over all the intervening headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators.typed_subpart_iterator()", "path": "library/email.iterators#email.iterators.typed_subpart_iterator", "type": "Email", "text": "\nThis iterates over all the subparts of msg, returning only those subparts that\nmatch the MIME type specified by maintype and subtype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators._structure()", "path": "library/email.iterators#email.iterators._structure", "type": "Email", "text": "\nPrints an indented representation of the content types of the message object\nstructure. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators: Iterators", "path": "library/email.iterators", "type": "Email", "text": "\nSource code: Lib/email/iterators.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage", "path": "library/email.message#email.message.EmailMessage", "type": "Email", "text": "\nIf policy is specified use the rules it specifies to update and serialize the\nrepresentation of the message. If policy is not set, use the `default` policy,\nwhich follows the rules of the email RFCs except for line endings (instead of\nthe RFC mandated `\\r\\n`, it uses the Python standard `\\n` line endings). For\nmore information see the `policy` documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_alternative()", "path": "library/email.message#email.message.EmailMessage.add_alternative", "type": "Email", "text": "\nIf the message is a `multipart/alternative`, create a new message object, pass\nall of the arguments to its `set_content()` method, and `attach()` it to the\n`multipart`. If the message is a non-`multipart` or `multipart/related`, call\n`make_alternative()` and then proceed as above. If the message is any other\ntype of `multipart`, raise a `TypeError`. If content_manager is not specified,\nuse the `content_manager` specified by the current `policy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_attachment()", "path": "library/email.message#email.message.EmailMessage.add_attachment", "type": "Email", "text": "\nIf the message is a `multipart/mixed`, create a new message object, pass all\nof the arguments to its `set_content()` method, and `attach()` it to the\n`multipart`. If the message is a non-`multipart`, `multipart/related`, or\n`multipart/alternative`, call `make_mixed()` and then proceed as above. If\ncontent_manager is not specified, use the `content_manager` specified by the\ncurrent `policy`. If the added part has no Content-Disposition header, add one\nwith the value `attachment`. This method can be used both for explicit\nattachments (Content-Disposition: attachment) and `inline` attachments\n(Content-Disposition: inline), by passing appropriate options to the\n`content_manager`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_header()", "path": "library/email.message#email.message.EmailMessage.add_header", "type": "Email", "text": "\nExtended header setting. This method is similar to `__setitem__()` except that\nadditional header parameters can be provided as keyword arguments. _name is\nthe header field to add and _value is the primary value for the header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_related()", "path": "library/email.message#email.message.EmailMessage.add_related", "type": "Email", "text": "\nIf the message is a `multipart/related`, create a new message object, pass all\nof the arguments to its `set_content()` method, and `attach()` it to the\n`multipart`. If the message is a non-`multipart`, call `make_related()` and\nthen proceed as above. If the message is any other type of `multipart`, raise\na `TypeError`. If content_manager is not specified, use the `content_manager`\nspecified by the current `policy`. If the added part has no Content-\nDisposition header, add one with the value `inline`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.as_bytes()", "path": "library/email.message#email.message.EmailMessage.as_bytes", "type": "Email", "text": "\nReturn the entire message flattened as a bytes object. When optional unixfrom\nis true, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. The policy argument may be used to override the default\npolicy obtained from the message instance. This can be used to control some of\nthe formatting produced by the method, since the specified policy will be\npassed to the `BytesGenerator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.as_string()", "path": "library/email.message#email.message.EmailMessage.as_string", "type": "Email", "text": "\nReturn the entire message flattened as a string. When optional unixfrom is\ntrue, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. For backward compatibility with the base `Message` class\nmaxheaderlen is accepted, but defaults to `None`, which means that by default\nthe line length is controlled by the `max_line_length` of the policy. The\npolicy argument may be used to override the default policy obtained from the\nmessage instance. This can be used to control some of the formatting produced\nby the method, since the specified policy will be passed to the `Generator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.clear()", "path": "library/email.message#email.message.EmailMessage.clear", "type": "Email", "text": "\nRemove the payload and all of the headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.clear_content()", "path": "library/email.message#email.message.EmailMessage.clear_content", "type": "Email", "text": "\nRemove the payload and all of the `Content-` headers, leaving all other\nheaders intact and in their original order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.defects", "path": "library/email.message#email.message.EmailMessage.defects", "type": "Email", "text": "\nThe defects attribute contains a list of all the problems found when parsing\nthis message. See `email.errors` for a detailed description of the possible\nparsing defects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.del_param()", "path": "library/email.message#email.message.EmailMessage.del_param", "type": "Email", "text": "\nRemove the given parameter completely from the Content-Type header. The header\nwill be re-written in place without the parameter or its value. Optional\nheader specifies an alternative to Content-Type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.epilogue", "path": "library/email.message#email.message.EmailMessage.epilogue", "type": "Email", "text": "\nThe epilogue attribute acts the same way as the preamble attribute, except\nthat it contains text that appears between the last boundary and the end of\nthe message. As with the `preamble`, if there is no epilog text this attribute\nwill be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get()", "path": "library/email.message#email.message.EmailMessage.get", "type": "Email", "text": "\nReturn the value of the named header field. This is identical to\n`__getitem__()` except that optional failobj is returned if the named header\nis missing (failobj defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_all()", "path": "library/email.message#email.message.EmailMessage.get_all", "type": "Email", "text": "\nReturn a list of all the values for the field named name. If there are no such\nnamed headers in the message, failobj is returned (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_body()", "path": "library/email.message#email.message.EmailMessage.get_body", "type": "Email", "text": "\nReturn the MIME part that is the best candidate to be the \u201cbody\u201d of the\nmessage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_boundary()", "path": "library/email.message#email.message.EmailMessage.get_boundary", "type": "Email", "text": "\nReturn the value of the `boundary` parameter of the Content-Type header of the\nmessage, or failobj if either the header is missing, or has no `boundary`\nparameter. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_charsets()", "path": "library/email.message#email.message.EmailMessage.get_charsets", "type": "Email", "text": "\nReturn a list containing the character set names in the message. If the\nmessage is a multipart, then the list will contain one element for each\nsubpart in the payload, otherwise, it will be a list of length 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content()", "path": "library/email.message#email.message.EmailMessage.get_content", "type": "Email", "text": "\nCall the `get_content()` method of the content_manager, passing self as the\nmessage object, and passing along any other arguments or keywords as\nadditional arguments. If content_manager is not specified, use the\n`content_manager` specified by the current `policy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_charset()", "path": "library/email.message#email.message.EmailMessage.get_content_charset", "type": "Email", "text": "\nReturn the `charset` parameter of the Content-Type header, coerced to lower\ncase. If there is no Content-Type header, or if that header has no `charset`\nparameter, failobj is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_disposition()", "path": "library/email.message#email.message.EmailMessage.get_content_disposition", "type": "Email", "text": "\nReturn the lowercased value (without parameters) of the message\u2019s Content-\nDisposition header if it has one, or `None`. The possible values for this\nmethod are inline, attachment or `None` if the message follows RFC 2183.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_maintype()", "path": "library/email.message#email.message.EmailMessage.get_content_maintype", "type": "Email", "text": "\nReturn the message\u2019s main content type. This is the maintype part of the\nstring returned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_subtype()", "path": "library/email.message#email.message.EmailMessage.get_content_subtype", "type": "Email", "text": "\nReturn the message\u2019s sub-content type. This is the subtype part of the string\nreturned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_type()", "path": "library/email.message#email.message.EmailMessage.get_content_type", "type": "Email", "text": "\nReturn the message\u2019s content type, coerced to lower case of the form\nmaintype/subtype. If there is no Content-Type header in the message return the\nvalue returned by `get_default_type()`. If the Content-Type header is invalid,\nreturn `text/plain`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_default_type()", "path": "library/email.message#email.message.EmailMessage.get_default_type", "type": "Email", "text": "\nReturn the default content type. Most messages have a default content type of\ntext/plain, except for messages that are subparts of multipart/digest\ncontainers. Such subparts have a default content type of message/rfc822.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_filename()", "path": "library/email.message#email.message.EmailMessage.get_filename", "type": "Email", "text": "\nReturn the value of the `filename` parameter of the Content-Disposition header\nof the message. If the header does not have a `filename` parameter, this\nmethod falls back to looking for the `name` parameter on the Content-Type\nheader. If neither is found, or the header is missing, then failobj is\nreturned. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_unixfrom()", "path": "library/email.message#email.message.EmailMessage.get_unixfrom", "type": "Email", "text": "\nReturn the message\u2019s envelope header. Defaults to `None` if the envelope\nheader was never set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.is_attachment()", "path": "library/email.message#email.message.EmailMessage.is_attachment", "type": "Email", "text": "\nReturn `True` if there is a Content-Disposition header and its (case\ninsensitive) value is `attachment`, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.is_multipart()", "path": "library/email.message#email.message.EmailMessage.is_multipart", "type": "Email", "text": "\nReturn `True` if the message\u2019s payload is a list of sub-`EmailMessage`\nobjects, otherwise return `False`. When `is_multipart()` returns `False`, the\npayload should be a string object (which might be a CTE encoded binary\npayload). Note that `is_multipart()` returning `True` does not necessarily\nmean that \u201cmsg.get_content_maintype() == \u2018multipart\u2019\u201d will return the `True`.\nFor example, `is_multipart` will return `True` when the `EmailMessage` is of\ntype `message/rfc822`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.items()", "path": "library/email.message#email.message.EmailMessage.items", "type": "Email", "text": "\nReturn a list of 2-tuples containing all the message\u2019s field headers and\nvalues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.iter_attachments()", "path": "library/email.message#email.message.EmailMessage.iter_attachments", "type": "Email", "text": "\nReturn an iterator over all of the immediate sub-parts of the message that are\nnot candidate \u201cbody\u201d parts. That is, skip the first occurrence of each of\n`text/plain`, `text/html`, `multipart/related`, or `multipart/alternative`\n(unless they are explicitly marked as attachments via Content-Disposition:\nattachment), and return all remaining parts. When applied directly to a\n`multipart/related`, return an iterator over the all the related parts except\nthe root part (ie: the part pointed to by the `start` parameter, or the first\npart if there is no `start` parameter or the `start` parameter doesn\u2019t match\nthe Content-ID of any of the parts). When applied directly to a\n`multipart/alternative` or a non-`multipart`, return an empty iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.iter_parts()", "path": "library/email.message#email.message.EmailMessage.iter_parts", "type": "Email", "text": "\nReturn an iterator over all of the immediate sub-parts of the message, which\nwill be empty for a non-`multipart`. (See also `walk()`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.keys()", "path": "library/email.message#email.message.EmailMessage.keys", "type": "Email", "text": "\nReturn a list of all the message\u2019s header field names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.make_alternative()", "path": "library/email.message#email.message.EmailMessage.make_alternative", "type": "Email", "text": "\nConvert a non-`multipart` or a `multipart/related` into a\n`multipart/alternative`, moving any existing Content- headers and payload into\na (new) first part of the `multipart`. If boundary is specified, use it as the\nboundary string in the multipart, otherwise leave the boundary to be\nautomatically created when it is needed (for example, when the message is\nserialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.make_mixed()", "path": "library/email.message#email.message.EmailMessage.make_mixed", "type": "Email", "text": "\nConvert a non-`multipart`, a `multipart/related`, or a `multipart-alternative`\ninto a `multipart/mixed`, moving any existing Content- headers and payload\ninto a (new) first part of the `multipart`. If boundary is specified, use it\nas the boundary string in the multipart, otherwise leave the boundary to be\nautomatically created when it is needed (for example, when the message is\nserialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.make_related()", "path": "library/email.message#email.message.EmailMessage.make_related", "type": "Email", "text": "\nConvert a non-`multipart` message into a `multipart/related` message, moving\nany existing Content- headers and payload into a (new) first part of the\n`multipart`. If boundary is specified, use it as the boundary string in the\nmultipart, otherwise leave the boundary to be automatically created when it is\nneeded (for example, when the message is serialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.preamble", "path": "library/email.message#email.message.EmailMessage.preamble", "type": "Email", "text": "\nThe format of a MIME document allows for some text between the blank line\nfollowing the headers, and the first multipart boundary string. Normally, this\ntext is never visible in a MIME-aware mail reader because it falls outside the\nstandard MIME armor. However, when viewing the raw text of the message, or\nwhen viewing the message in a non-MIME aware reader, this text can become\nvisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.replace_header()", "path": "library/email.message#email.message.EmailMessage.replace_header", "type": "Email", "text": "\nReplace a header. Replace the first header found in the message that matches\n_name, retaining header order and field name case of the original header. If\nno matching header is found, raise a `KeyError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_boundary()", "path": "library/email.message#email.message.EmailMessage.set_boundary", "type": "Email", "text": "\nSet the `boundary` parameter of the Content-Type header to boundary.\n`set_boundary()` will always quote boundary if necessary. A `HeaderParseError`\nis raised if the message object has no Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_content()", "path": "library/email.message#email.message.EmailMessage.set_content", "type": "Email", "text": "\nCall the `set_content()` method of the content_manager, passing self as the\nmessage object, and passing along any other arguments or keywords as\nadditional arguments. If content_manager is not specified, use the\n`content_manager` specified by the current `policy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_default_type()", "path": "library/email.message#email.message.EmailMessage.set_default_type", "type": "Email", "text": "\nSet the default content type. ctype should either be text/plain or\nmessage/rfc822, although this is not enforced. The default content type is not\nstored in the Content-Type header, so it only affects the return value of the\n`get_content_type` methods when no Content-Type header is present in the\nmessage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_param()", "path": "library/email.message#email.message.EmailMessage.set_param", "type": "Email", "text": "\nSet a parameter in the Content-Type header. If the parameter already exists in\nthe header, replace its value with value. When header is `Content-Type` (the\ndefault) and the header does not yet exist in the message, add it, set its\nvalue to text/plain, and append the new parameter value. Optional header\nspecifies an alternative header to Content-Type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_unixfrom()", "path": "library/email.message#email.message.EmailMessage.set_unixfrom", "type": "Email", "text": "\nSet the message\u2019s envelope header to unixfrom, which should be a string. (See\n`mboxMessage` for a brief description of this header.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.values()", "path": "library/email.message#email.message.EmailMessage.values", "type": "Email", "text": "\nReturn a list of all the message\u2019s field values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.walk()", "path": "library/email.message#email.message.EmailMessage.walk", "type": "Email", "text": "\nThe `walk()` method is an all-purpose generator which can be used to iterate\nover all the parts and subparts of a message object tree, in depth-first\ntraversal order. You will typically use `walk()` as the iterator in a `for`\nloop; each iteration returns the next subpart.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__bytes__()", "path": "library/email.message#email.message.EmailMessage.__bytes__", "type": "Email", "text": "\nEquivalent to `as_bytes()`. Allows `bytes(msg)` to produce a bytes object\ncontaining the serialized message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__contains__()", "path": "library/email.message#email.message.EmailMessage.__contains__", "type": "Email", "text": "\nReturn `True` if the message object has a field named name. Matching is done\nwithout regard to case and name does not include the trailing colon. Used for\nthe `in` operator. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__delitem__()", "path": "library/email.message#email.message.EmailMessage.__delitem__", "type": "Email", "text": "\nDelete all occurrences of the field with name name from the message\u2019s headers.\nNo exception is raised if the named field isn\u2019t present in the headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__getitem__()", "path": "library/email.message#email.message.EmailMessage.__getitem__", "type": "Email", "text": "\nReturn the value of the named header field. name does not include the colon\nfield separator. If the header is missing, `None` is returned; a `KeyError` is\nnever raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__len__()", "path": "library/email.message#email.message.EmailMessage.__len__", "type": "Email", "text": "\nReturn the total number of headers, including duplicates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__setitem__()", "path": "library/email.message#email.message.EmailMessage.__setitem__", "type": "Email", "text": "\nAdd a header to the message with field name name and value val. The field is\nappended to the end of the message\u2019s existing headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__str__()", "path": "library/email.message#email.message.EmailMessage.__str__", "type": "Email", "text": "\nEquivalent to `as_string(policy=self.policy.clone(utf8=True))`. Allows\n`str(msg)` to produce a string containing the serialized message in a readable\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message", "path": "library/email.compat32-message#email.message.Message", "type": "Email", "text": "\nIf policy is specified (it must be an instance of a `policy` class) use the\nrules it specifies to update and serialize the representation of the message.\nIf policy is not set, use the `compat32` policy, which maintains backward\ncompatibility with the Python 3.2 version of the email package. For more\ninformation see the `policy` documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.add_header()", "path": "library/email.compat32-message#email.message.Message.add_header", "type": "Email", "text": "\nExtended header setting. This method is similar to `__setitem__()` except that\nadditional header parameters can be provided as keyword arguments. _name is\nthe header field to add and _value is the primary value for the header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.as_bytes()", "path": "library/email.compat32-message#email.message.Message.as_bytes", "type": "Email", "text": "\nReturn the entire message flattened as a bytes object. When optional unixfrom\nis true, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. The policy argument may be used to override the default\npolicy obtained from the message instance. This can be used to control some of\nthe formatting produced by the method, since the specified policy will be\npassed to the `BytesGenerator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.as_string()", "path": "library/email.compat32-message#email.message.Message.as_string", "type": "Email", "text": "\nReturn the entire message flattened as a string. When optional unixfrom is\ntrue, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. For backward compatibility reasons, maxheaderlen defaults\nto `0`, so if you want a different value you must override it explicitly (the\nvalue specified for max_line_length in the policy will be ignored by this\nmethod). The policy argument may be used to override the default policy\nobtained from the message instance. This can be used to control some of the\nformatting produced by the method, since the specified policy will be passed\nto the `Generator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.attach()", "path": "library/email.compat32-message#email.message.Message.attach", "type": "Email", "text": "\nAdd the given payload to the current payload, which must be `None` or a list\nof `Message` objects before the call. After the call, the payload will always\nbe a list of `Message` objects. If you want to set the payload to a scalar\nobject (e.g. a string), use `set_payload()` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.defects", "path": "library/email.compat32-message#email.message.Message.defects", "type": "Email", "text": "\nThe defects attribute contains a list of all the problems found when parsing\nthis message. See `email.errors` for a detailed description of the possible\nparsing defects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.del_param()", "path": "library/email.compat32-message#email.message.Message.del_param", "type": "Email", "text": "\nRemove the given parameter completely from the Content-Type header. The header\nwill be re-written in place without the parameter or its value. All values\nwill be quoted as necessary unless requote is `False` (the default is `True`).\nOptional header specifies an alternative to Content-Type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.epilogue", "path": "library/email.compat32-message#email.message.Message.epilogue", "type": "Email", "text": "\nThe epilogue attribute acts the same way as the preamble attribute, except\nthat it contains text that appears between the last boundary and the end of\nthe message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get()", "path": "library/email.compat32-message#email.message.Message.get", "type": "Email", "text": "\nReturn the value of the named header field. This is identical to\n`__getitem__()` except that optional failobj is returned if the named header\nis missing (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_all()", "path": "library/email.compat32-message#email.message.Message.get_all", "type": "Email", "text": "\nReturn a list of all the values for the field named name. If there are no such\nnamed headers in the message, failobj is returned (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_boundary()", "path": "library/email.compat32-message#email.message.Message.get_boundary", "type": "Email", "text": "\nReturn the value of the `boundary` parameter of the Content-Type header of the\nmessage, or failobj if either the header is missing, or has no `boundary`\nparameter. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_charset()", "path": "library/email.compat32-message#email.message.Message.get_charset", "type": "Email", "text": "\nReturn the `Charset` instance associated with the message\u2019s payload.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_charsets()", "path": "library/email.compat32-message#email.message.Message.get_charsets", "type": "Email", "text": "\nReturn a list containing the character set names in the message. If the\nmessage is a multipart, then the list will contain one element for each\nsubpart in the payload, otherwise, it will be a list of length 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_charset()", "path": "library/email.compat32-message#email.message.Message.get_content_charset", "type": "Email", "text": "\nReturn the `charset` parameter of the Content-Type header, coerced to lower\ncase. If there is no Content-Type header, or if that header has no `charset`\nparameter, failobj is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_disposition()", "path": "library/email.compat32-message#email.message.Message.get_content_disposition", "type": "Email", "text": "\nReturn the lowercased value (without parameters) of the message\u2019s Content-\nDisposition header if it has one, or `None`. The possible values for this\nmethod are inline, attachment or `None` if the message follows RFC 2183.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_maintype()", "path": "library/email.compat32-message#email.message.Message.get_content_maintype", "type": "Email", "text": "\nReturn the message\u2019s main content type. This is the maintype part of the\nstring returned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_subtype()", "path": "library/email.compat32-message#email.message.Message.get_content_subtype", "type": "Email", "text": "\nReturn the message\u2019s sub-content type. This is the subtype part of the string\nreturned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_type()", "path": "library/email.compat32-message#email.message.Message.get_content_type", "type": "Email", "text": "\nReturn the message\u2019s content type. The returned string is coerced to lower\ncase of the form maintype/subtype. If there was no Content-Type header in the\nmessage the default type as given by `get_default_type()` will be returned.\nSince according to RFC 2045, messages always have a default type,\n`get_content_type()` will always return a value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_default_type()", "path": "library/email.compat32-message#email.message.Message.get_default_type", "type": "Email", "text": "\nReturn the default content type. Most messages have a default content type of\ntext/plain, except for messages that are subparts of multipart/digest\ncontainers. Such subparts have a default content type of message/rfc822.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_filename()", "path": "library/email.compat32-message#email.message.Message.get_filename", "type": "Email", "text": "\nReturn the value of the `filename` parameter of the Content-Disposition header\nof the message. If the header does not have a `filename` parameter, this\nmethod falls back to looking for the `name` parameter on the Content-Type\nheader. If neither is found, or the header is missing, then failobj is\nreturned. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_param()", "path": "library/email.compat32-message#email.message.Message.get_param", "type": "Email", "text": "\nReturn the value of the Content-Type header\u2019s parameter param as a string. If\nthe message has no Content-Type header or if there is no such parameter, then\nfailobj is returned (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_params()", "path": "library/email.compat32-message#email.message.Message.get_params", "type": "Email", "text": "\nReturn the message\u2019s Content-Type parameters, as a list. The elements of the\nreturned list are 2-tuples of key/value pairs, as split on the `'='` sign. The\nleft hand side of the `'='` is the key, while the right hand side is the\nvalue. If there is no `'='` sign in the parameter the value is the empty\nstring, otherwise the value is as described in `get_param()` and is unquoted\nif optional unquote is `True` (the default).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_payload()", "path": "library/email.compat32-message#email.message.Message.get_payload", "type": "Email", "text": "\nReturn the current payload, which will be a list of `Message` objects when\n`is_multipart()` is `True`, or a string when `is_multipart()` is `False`. If\nthe payload is a list and you mutate the list object, you modify the message\u2019s\npayload in place.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_unixfrom()", "path": "library/email.compat32-message#email.message.Message.get_unixfrom", "type": "Email", "text": "\nReturn the message\u2019s envelope header. Defaults to `None` if the envelope\nheader was never set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.is_multipart()", "path": "library/email.compat32-message#email.message.Message.is_multipart", "type": "Email", "text": "\nReturn `True` if the message\u2019s payload is a list of sub-`Message` objects,\notherwise return `False`. When `is_multipart()` returns `False`, the payload\nshould be a string object (which might be a CTE encoded binary payload). (Note\nthat `is_multipart()` returning `True` does not necessarily mean that\n\u201cmsg.get_content_maintype() == \u2018multipart\u2019\u201d will return the `True`. For\nexample, `is_multipart` will return `True` when the `Message` is of type\n`message/rfc822`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.items()", "path": "library/email.compat32-message#email.message.Message.items", "type": "Email", "text": "\nReturn a list of 2-tuples containing all the message\u2019s field headers and\nvalues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.keys()", "path": "library/email.compat32-message#email.message.Message.keys", "type": "Email", "text": "\nReturn a list of all the message\u2019s header field names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.preamble", "path": "library/email.compat32-message#email.message.Message.preamble", "type": "Email", "text": "\nThe format of a MIME document allows for some text between the blank line\nfollowing the headers, and the first multipart boundary string. Normally, this\ntext is never visible in a MIME-aware mail reader because it falls outside the\nstandard MIME armor. However, when viewing the raw text of the message, or\nwhen viewing the message in a non-MIME aware reader, this text can become\nvisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.replace_header()", "path": "library/email.compat32-message#email.message.Message.replace_header", "type": "Email", "text": "\nReplace a header. Replace the first header found in the message that matches\n_name, retaining header order and field name case. If no matching header was\nfound, a `KeyError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_boundary()", "path": "library/email.compat32-message#email.message.Message.set_boundary", "type": "Email", "text": "\nSet the `boundary` parameter of the Content-Type header to boundary.\n`set_boundary()` will always quote boundary if necessary. A `HeaderParseError`\nis raised if the message object has no Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_charset()", "path": "library/email.compat32-message#email.message.Message.set_charset", "type": "Email", "text": "\nSet the character set of the payload to charset, which can either be a\n`Charset` instance (see `email.charset`), a string naming a character set, or\n`None`. If it is a string, it will be converted to a `Charset` instance. If\ncharset is `None`, the `charset` parameter will be removed from the Content-\nType header (the message will not be otherwise modified). Anything else will\ngenerate a `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_default_type()", "path": "library/email.compat32-message#email.message.Message.set_default_type", "type": "Email", "text": "\nSet the default content type. ctype should either be text/plain or\nmessage/rfc822, although this is not enforced. The default content type is not\nstored in the Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_param()", "path": "library/email.compat32-message#email.message.Message.set_param", "type": "Email", "text": "\nSet a parameter in the Content-Type header. If the parameter already exists in\nthe header, its value will be replaced with value. If the Content-Type header\nas not yet been defined for this message, it will be set to text/plain and the\nnew parameter value will be appended as per RFC 2045.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_payload()", "path": "library/email.compat32-message#email.message.Message.set_payload", "type": "Email", "text": "\nSet the entire message object\u2019s payload to payload. It is the client\u2019s\nresponsibility to ensure the payload invariants. Optional charset sets the\nmessage\u2019s default character set; see `set_charset()` for details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_type()", "path": "library/email.compat32-message#email.message.Message.set_type", "type": "Email", "text": "\nSet the main type and subtype for the Content-Type header. type must be a\nstring in the form maintype/subtype, otherwise a `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_unixfrom()", "path": "library/email.compat32-message#email.message.Message.set_unixfrom", "type": "Email", "text": "\nSet the message\u2019s envelope header to unixfrom, which should be a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.values()", "path": "library/email.compat32-message#email.message.Message.values", "type": "Email", "text": "\nReturn a list of all the message\u2019s field values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.walk()", "path": "library/email.compat32-message#email.message.Message.walk", "type": "Email", "text": "\nThe `walk()` method is an all-purpose generator which can be used to iterate\nover all the parts and subparts of a message object tree, in depth-first\ntraversal order. You will typically use `walk()` as the iterator in a `for`\nloop; each iteration returns the next subpart.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__bytes__()", "path": "library/email.compat32-message#email.message.Message.__bytes__", "type": "Email", "text": "\nEquivalent to `as_bytes()`. Allows `bytes(msg)` to produce a bytes object\ncontaining the formatted message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__contains__()", "path": "library/email.compat32-message#email.message.Message.__contains__", "type": "Email", "text": "\nReturn `True` if the message object has a field named name. Matching is done\ncase-insensitively and name should not include the trailing colon. Used for\nthe `in` operator, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__delitem__()", "path": "library/email.compat32-message#email.message.Message.__delitem__", "type": "Email", "text": "\nDelete all occurrences of the field with name name from the message\u2019s headers.\nNo exception is raised if the named field isn\u2019t present in the headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__getitem__()", "path": "library/email.compat32-message#email.message.Message.__getitem__", "type": "Email", "text": "\nReturn the value of the named header field. name should not include the colon\nfield separator. If the header is missing, `None` is returned; a `KeyError` is\nnever raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__len__()", "path": "library/email.compat32-message#email.message.Message.__len__", "type": "Email", "text": "\nReturn the total number of headers, including duplicates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__setitem__()", "path": "library/email.compat32-message#email.message.Message.__setitem__", "type": "Email", "text": "\nAdd a header to the message with field name name and value val. The field is\nappended to the end of the message\u2019s existing fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__str__()", "path": "library/email.compat32-message#email.message.Message.__str__", "type": "Email", "text": "\nEquivalent to `as_string()`. Allows `str(msg)` to produce a string containing\nthe formatted message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message: Representing an email message using the compat32 API", "path": "library/email.compat32-message", "type": "Email", "text": "\nThe `Message` class is very similar to the `EmailMessage` class, without the\nmethods added by that class, and with the default behavior of certain other\nmethods being slightly different. We also document here some methods that,\nwhile supported by the `EmailMessage` class, are not recommended unless you\nare dealing with legacy code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.MIMEPart", "path": "library/email.message#email.message.MIMEPart", "type": "Email", "text": "\nThis class represents a subpart of a MIME message. It is identical to\n`EmailMessage`, except that no MIME-Version headers are added when\n`set_content()` is called, since sub-parts do not need their own MIME-Version\nheaders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message: Representing an email message", "path": "library/email.message", "type": "Email", "text": "\nSource code: Lib/email/message.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_binary_file()", "path": "library/email.parser#email.message_from_binary_file", "type": "Email", "text": "\nReturn a message object structure tree from an open binary file object. This\nis equivalent to `BytesParser().parse(fp)`. _class and policy are interpreted\nas with the `BytesParser` class constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_bytes()", "path": "library/email.parser#email.message_from_bytes", "type": "Email", "text": "\nReturn a message object structure from a bytes-like object. This is equivalent\nto `BytesParser().parsebytes(s)`. Optional _class and policy are interpreted\nas with the `BytesParser` class constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_file()", "path": "library/email.parser#email.message_from_file", "type": "Email", "text": "\nReturn a message object structure tree from an open file object. This is\nequivalent to `Parser().parse(fp)`. _class and policy are interpreted as with\nthe `Parser` class constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_string()", "path": "library/email.parser#email.message_from_string", "type": "Email", "text": "\nReturn a message object structure from a string. This is equivalent to\n`Parser().parsestr(s)`. _class and policy are interpreted as with the `Parser`\nclass constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.application.MIMEApplication", "path": "library/email.mime#email.mime.application.MIMEApplication", "type": "Email", "text": "\nModule: `email.mime.application`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.audio.MIMEAudio", "path": "library/email.mime#email.mime.audio.MIMEAudio", "type": "Email", "text": "\nModule: `email.mime.audio`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.base.MIMEBase", "path": "library/email.mime#email.mime.base.MIMEBase", "type": "Email", "text": "\nModule: `email.mime.base`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.image.MIMEImage", "path": "library/email.mime#email.mime.image.MIMEImage", "type": "Email", "text": "\nModule: `email.mime.image`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.message.MIMEMessage", "path": "library/email.mime#email.mime.message.MIMEMessage", "type": "Email", "text": "\nModule: `email.mime.message`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.multipart.MIMEMultipart", "path": "library/email.mime#email.mime.multipart.MIMEMultipart", "type": "Email", "text": "\nModule: `email.mime.multipart`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.nonmultipart.MIMENonMultipart", "path": "library/email.mime#email.mime.nonmultipart.MIMENonMultipart", "type": "Email", "text": "\nModule: `email.mime.nonmultipart`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.text.MIMEText", "path": "library/email.mime#email.mime.text.MIMEText", "type": "Email", "text": "\nModule: `email.mime.text`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime: Creating email and MIME objects from scratch", "path": "library/email.mime", "type": "Email", "text": "\nSource code: Lib/email/mime/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesFeedParser", "path": "library/email.parser#email.parser.BytesFeedParser", "type": "Email", "text": "\nCreate a `BytesFeedParser` instance. Optional _factory is a no-argument\ncallable; if not specified use the `message_factory` from the policy. Call\n_factory whenever a new message object is needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesFeedParser.close()", "path": "library/email.parser#email.parser.BytesFeedParser.close", "type": "Email", "text": "\nComplete the parsing of all previously fed data and return the root message\nobject. It is undefined what happens if `feed()` is called after this method\nhas been called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesFeedParser.feed()", "path": "library/email.parser#email.parser.BytesFeedParser.feed", "type": "Email", "text": "\nFeed the parser some more data. data should be a bytes-like object containing\none or more lines. The lines can be partial and the parser will stitch such\npartial lines together properly. The lines can have any of the three common\nline endings: carriage return, newline, or carriage return and newline (they\ncan even be mixed).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesHeaderParser", "path": "library/email.parser#email.parser.BytesHeaderParser", "type": "Email", "text": "\nExactly like `BytesParser`, except that headersonly defaults to `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesParser", "path": "library/email.parser#email.parser.BytesParser", "type": "Email", "text": "\nCreate a `BytesParser` instance. The _class and policy arguments have the same\nmeaning and semantics as the _factory and policy arguments of\n`BytesFeedParser`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesParser.parse()", "path": "library/email.parser#email.parser.BytesParser.parse", "type": "Email", "text": "\nRead all the data from the binary file-like object fp, parse the resulting\nbytes, and return the message object. fp must support both the `readline()`\nand the `read()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesParser.parsebytes()", "path": "library/email.parser#email.parser.BytesParser.parsebytes", "type": "Email", "text": "\nSimilar to the `parse()` method, except it takes a bytes-like object instead\nof a file-like object. Calling this method on a bytes-like object is\nequivalent to wrapping bytes in a `BytesIO` instance first and calling\n`parse()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.FeedParser", "path": "library/email.parser#email.parser.FeedParser", "type": "Email", "text": "\nWorks like `BytesFeedParser` except that the input to the `feed()` method must\nbe a string. This is of limited utility, since the only way for such a message\nto be valid is for it to contain only ASCII text or, if `utf8` is `True`, no\nbinary attachments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.HeaderParser", "path": "library/email.parser#email.parser.HeaderParser", "type": "Email", "text": "\nExactly like `Parser`, except that headersonly defaults to `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.Parser", "path": "library/email.parser#email.parser.Parser", "type": "Email", "text": "\nThis class is parallel to `BytesParser`, but handles string input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.Parser.parse()", "path": "library/email.parser#email.parser.Parser.parse", "type": "Email", "text": "\nRead all the data from the text-mode file-like object fp, parse the resulting\ntext, and return the root message object. fp must support both the\n`readline()` and the `read()` methods on file-like objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.Parser.parsestr()", "path": "library/email.parser#email.parser.Parser.parsestr", "type": "Email", "text": "\nSimilar to the `parse()` method, except it takes a string object instead of a\nfile-like object. Calling this method on a string is equivalent to wrapping\ntext in a `StringIO` instance first and calling `parse()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser: Parsing email messages", "path": "library/email.parser", "type": "Email", "text": "\nSource code: Lib/email/parser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.compat32", "path": "library/email.policy#email.policy.compat32", "type": "Email", "text": "\nAn instance of `Compat32`, providing backward compatibility with the behavior\nof the email package in Python 3.2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32", "path": "library/email.policy#email.policy.Compat32", "type": "Email", "text": "\nThis concrete `Policy` is the backward compatibility policy. It replicates the\nbehavior of the email package in Python 3.2. The `policy` module also defines\nan instance of this class, `compat32`, that is used as the default policy.\nThus the default behavior of the email package is to maintain compatibility\nwith Python 3.2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.fold()", "path": "library/email.policy#email.policy.Compat32.fold", "type": "Email", "text": "\nHeaders are folded using the `Header` folding algorithm, which preserves\nexisting line breaks in the value, and wraps each resulting line to the\n`max_line_length`. Non-ASCII binary data are CTE encoded using the\n`unknown-8bit` charset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.fold_binary()", "path": "library/email.policy#email.policy.Compat32.fold_binary", "type": "Email", "text": "\nHeaders are folded using the `Header` folding algorithm, which preserves\nexisting line breaks in the value, and wraps each resulting line to the\n`max_line_length`. If `cte_type` is `7bit`, non-ascii binary data is CTE\nencoded using the `unknown-8bit` charset. Otherwise the original source header\nis used, with its existing line breaks and any (RFC invalid) binary data it\nmay contain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.header_fetch_parse()", "path": "library/email.policy#email.policy.Compat32.header_fetch_parse", "type": "Email", "text": "\nIf the value contains binary data, it is converted into a `Header` object\nusing the `unknown-8bit` charset. Otherwise it is returned unmodified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.header_source_parse()", "path": "library/email.policy#email.policy.Compat32.header_source_parse", "type": "Email", "text": "\nThe name is parsed as everything up to the \u2018`:`\u2019 and returned unmodified. The\nvalue is determined by stripping leading whitespace off the remainder of the\nfirst line, joining all subsequent lines together, and stripping any trailing\ncarriage return or linefeed characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.header_store_parse()", "path": "library/email.policy#email.policy.Compat32.header_store_parse", "type": "Email", "text": "\nThe name and value are returned unmodified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.mangle_from_", "path": "library/email.policy#email.policy.Compat32.mangle_from_", "type": "Email", "text": "\nThe default is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.default", "path": "library/email.policy#email.policy.default", "type": "Email", "text": "\nAn instance of `EmailPolicy` with all defaults unchanged. This policy uses the\nstandard Python `\\n` line endings rather than the RFC-correct `\\r\\n`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy", "path": "library/email.policy#email.policy.EmailPolicy", "type": "Email", "text": "\nThis concrete `Policy` provides behavior that is intended to be fully\ncompliant with the current email RFCs. These include (but are not limited to)\nRFC 5322, RFC 2047, and the current MIME RFCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.content_manager", "path": "library/email.policy#email.policy.EmailPolicy.content_manager", "type": "Email", "text": "\nAn object with at least two methods: get_content and set_content. When the\n`get_content()` or `set_content()` method of an `EmailMessage` object is\ncalled, it calls the corresponding method of this object, passing it the\nmessage object as its first argument, and any arguments or keywords that were\npassed to it as additional arguments. By default `content_manager` is set to\n`raw_data_manager`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.fold()", "path": "library/email.policy#email.policy.EmailPolicy.fold", "type": "Email", "text": "\nHeader folding is controlled by the `refold_source` policy setting. A value is\nconsidered to be a \u2018source value\u2019 if and only if it does not have a `name`\nattribute (having a `name` attribute means it is a header object of some\nsort). If a source value needs to be refolded according to the policy, it is\nconverted into a header object by passing the name and the value with any CR\nand LF characters removed to the `header_factory`. Folding of a header object\nis done by calling its `fold` method with the current policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.fold_binary()", "path": "library/email.policy#email.policy.EmailPolicy.fold_binary", "type": "Email", "text": "\nThe same as `fold()` if `cte_type` is `7bit`, except that the returned value\nis bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_factory", "path": "library/email.policy#email.policy.EmailPolicy.header_factory", "type": "Email", "text": "\nA callable that takes two arguments, `name` and `value`, where `name` is a\nheader field name and `value` is an unfolded header field value, and returns a\nstring subclass that represents that header. A default `header_factory` (see\n`headerregistry`) is provided that supports custom parsing for the various\naddress and date RFC 5322 header field types, and the major MIME header field\nstypes. Support for additional custom parsing will be added in the future.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_fetch_parse()", "path": "library/email.policy#email.policy.EmailPolicy.header_fetch_parse", "type": "Email", "text": "\nIf the value has a `name` attribute, it is returned to unmodified. Otherwise\nthe name, and the value with any CR or LF characters removed, are passed to\nthe `header_factory`, and the resulting header object is returned. Any\nsurrogateescaped bytes get turned into the unicode unknown-character glyph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_max_count()", "path": "library/email.policy#email.policy.EmailPolicy.header_max_count", "type": "Email", "text": "\nReturns the value of the `max_count` attribute of the specialized class used\nto represent the header with the given name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_source_parse()", "path": "library/email.policy#email.policy.EmailPolicy.header_source_parse", "type": "Email", "text": "\nThe name is parsed as everything up to the \u2018`:`\u2019 and returned unmodified. The\nvalue is determined by stripping leading whitespace off the remainder of the\nfirst line, joining all subsequent lines together, and stripping any trailing\ncarriage return or linefeed characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_store_parse()", "path": "library/email.policy#email.policy.EmailPolicy.header_store_parse", "type": "Email", "text": "\nThe name is returned unchanged. If the input value has a `name` attribute and\nit matches name ignoring case, the value is returned unchanged. Otherwise the\nname and value are passed to `header_factory`, and the resulting header object\nis returned as the value. In this case a `ValueError` is raised if the input\nvalue contains CR or LF characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.refold_source", "path": "library/email.policy#email.policy.EmailPolicy.refold_source", "type": "Email", "text": "\nIf the value for a header in the `Message` object originated from a `parser`\n(as opposed to being set by a program), this attribute indicates whether or\nnot a generator should refold that value when transforming the message back\ninto serialized form. The possible values are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.utf8", "path": "library/email.policy#email.policy.EmailPolicy.utf8", "type": "Email", "text": "\nIf `False`, follow RFC 5322, supporting non-ASCII characters in headers by\nencoding them as \u201cencoded words\u201d. If `True`, follow RFC 6532 and use `utf-8`\nencoding for headers. Messages formatted in this way may be passed to SMTP\nservers that support the `SMTPUTF8` extension (RFC 6531).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.HTTP", "path": "library/email.policy#email.policy.HTTP", "type": "Email", "text": "\nSuitable for serializing headers with for use in HTTP traffic. Like `SMTP`\nexcept that `max_line_length` is set to `None` (unlimited).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy", "path": "library/email.policy#email.policy.Policy", "type": "Email", "text": "\nThis is the abstract base class for all policy classes. It provides default\nimplementations for a couple of trivial methods, as well as the implementation\nof the immutability property, the `clone()` method, and the constructor\nsemantics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.clone()", "path": "library/email.policy#email.policy.Policy.clone", "type": "Email", "text": "\nReturn a new `Policy` instance whose attributes have the same values as the\ncurrent instance, except where those attributes are given new values by the\nkeyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.cte_type", "path": "library/email.policy#email.policy.Policy.cte_type", "type": "Email", "text": "\nControls the type of Content Transfer Encodings that may be or are required to\nbe used. The possible values are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.fold()", "path": "library/email.policy#email.policy.Policy.fold", "type": "Email", "text": "\nThe email package calls this method with the name and value currently stored\nin the `Message` for a given header. The method should return a string that\nrepresents that header \u201cfolded\u201d correctly (according to the policy settings)\nby composing the name with the value and inserting `linesep` characters at the\nappropriate places. See RFC 5322 for a discussion of the rules for folding\nemail headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.fold_binary()", "path": "library/email.policy#email.policy.Policy.fold_binary", "type": "Email", "text": "\nThe same as `fold()`, except that the returned value should be a bytes object\nrather than a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.handle_defect()", "path": "library/email.policy#email.policy.Policy.handle_defect", "type": "Email", "text": "\nHandle a defect found on obj. When the email package calls this method, defect\nwill always be a subclass of `Defect`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_fetch_parse()", "path": "library/email.policy#email.policy.Policy.header_fetch_parse", "type": "Email", "text": "\nThe email package calls this method with the name and value currently stored\nin the `Message` when that header is requested by the application program, and\nwhatever the method returns is what is passed back to the application as the\nvalue of the header being retrieved. Note that there may be more than one\nheader with the same name stored in the `Message`; the method is passed the\nspecific name and value of the header destined to be returned to the\napplication.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_max_count()", "path": "library/email.policy#email.policy.Policy.header_max_count", "type": "Email", "text": "\nReturn the maximum allowed number of headers named name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_source_parse()", "path": "library/email.policy#email.policy.Policy.header_source_parse", "type": "Email", "text": "\nThe email package calls this method with a list of strings, each string ending\nwith the line separation characters found in the source being parsed. The\nfirst line includes the field header name and separator. All whitespace in the\nsource is preserved. The method should return the `(name, value)` tuple that\nis to be stored in the `Message` to represent the parsed header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_store_parse()", "path": "library/email.policy#email.policy.Policy.header_store_parse", "type": "Email", "text": "\nThe email package calls this method with the name and value provided by the\napplication program when the application program is modifying a `Message`\nprogrammatically (as opposed to a `Message` created by a parser). The method\nshould return the `(name, value)` tuple that is to be stored in the `Message`\nto represent the header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.linesep", "path": "library/email.policy#email.policy.Policy.linesep", "type": "Email", "text": "\nThe string to be used to terminate lines in serialized output. The default is\n`\\n` because that\u2019s the internal end-of-line discipline used by Python, though\n`\\r\\n` is required by the RFCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.mangle_from_", "path": "library/email.policy#email.policy.Policy.mangle_from_", "type": "Email", "text": "\nIf `True`, lines starting with \u201cFrom \u201c in the body are escaped by putting a\n`>` in front of them. This parameter is used when the message is being\nserialized by a generator. Default: `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.max_line_length", "path": "library/email.policy#email.policy.Policy.max_line_length", "type": "Email", "text": "\nThe maximum length of any line in the serialized output, not counting the end\nof line character(s). Default is 78, per RFC 5322. A value of `0` or `None`\nindicates that no line wrapping should be done at all.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.message_factory", "path": "library/email.policy#email.policy.Policy.message_factory", "type": "Email", "text": "\nA factory function for constructing a new empty message object. Used by the\nparser when building messages. Defaults to `None`, in which case `Message` is\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.raise_on_defect", "path": "library/email.policy#email.policy.Policy.raise_on_defect", "type": "Email", "text": "\nIf `True`, any defects encountered will be raised as errors. If `False` (the\ndefault), defects will be passed to the `register_defect()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.register_defect()", "path": "library/email.policy#email.policy.Policy.register_defect", "type": "Email", "text": "\nRegister a defect on obj. In the email package, defect will always be a\nsubclass of `Defect`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.SMTP", "path": "library/email.policy#email.policy.SMTP", "type": "Email", "text": "\nSuitable for serializing messages in conformance with the email RFCs. Like\n`default`, but with `linesep` set to `\\r\\n`, which is RFC compliant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.SMTPUTF8", "path": "library/email.policy#email.policy.SMTPUTF8", "type": "Email", "text": "\nThe same as `SMTP` except that `utf8` is `True`. Useful for serializing\nmessages to a message store without using encoded words in the headers. Should\nonly be used for SMTP transmission if the sender or recipient addresses have\nnon-ASCII characters (the `smtplib.SMTP.send_message()` method handles this\nautomatically).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.strict", "path": "library/email.policy#email.policy.strict", "type": "Email", "text": "\nConvenience instance. The same as `default` except that `raise_on_defect` is\nset to `True`. This allows any policy to be made strict by writing:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy: Policy Objects", "path": "library/email.policy", "type": "Email", "text": "\nNew in version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.collapse_rfc2231_value()", "path": "library/email.utils#email.utils.collapse_rfc2231_value", "type": "Email", "text": "\nWhen a header parameter is encoded in RFC 2231 format, `Message.get_param` may\nreturn a 3-tuple containing the character set, language, and value.\n`collapse_rfc2231_value()` turns this into a unicode string. Optional errors\nis passed to the errors argument of `str`\u2019s `encode()` method; it defaults to\n`'replace'`. Optional fallback_charset specifies the character set to use if\nthe one in the RFC 2231 header is not known by Python; it defaults to `'us-\nascii'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.decode_params()", "path": "library/email.utils#email.utils.decode_params", "type": "Email", "text": "\nDecode parameters list according to RFC 2231. params is a sequence of 2-tuples\ncontaining elements of the form `(content-type, string-value)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.decode_rfc2231()", "path": "library/email.utils#email.utils.decode_rfc2231", "type": "Email", "text": "\nDecode the string s according to RFC 2231.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.encode_rfc2231()", "path": "library/email.utils#email.utils.encode_rfc2231", "type": "Email", "text": "\nEncode the string s according to RFC 2231. Optional charset and language, if\ngiven is the character set name and language name to use. If neither is given,\ns is returned as-is. If charset is given but language is not, the string is\nencoded using the empty string for language.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.formataddr()", "path": "library/email.utils#email.utils.formataddr", "type": "Email", "text": "\nThe inverse of `parseaddr()`, this takes a 2-tuple of the form `(realname,\nemail_address)` and returns the string value suitable for a To or Cc header.\nIf the first element of pair is false, then the second element is returned\nunmodified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.formatdate()", "path": "library/email.utils#email.utils.formatdate", "type": "Email", "text": "\nReturns a date string as per RFC 2822, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.format_datetime()", "path": "library/email.utils#email.utils.format_datetime", "type": "Email", "text": "\nLike `formatdate`, but the input is a `datetime` instance. If it is a naive\ndatetime, it is assumed to be \u201cUTC with no information about the source\ntimezone\u201d, and the conventional `-0000` is used for the timezone. If it is an\naware `datetime`, then the numeric timezone offset is used. If it is an aware\ntimezone with offset zero, then usegmt may be set to `True`, in which case the\nstring `GMT` is used instead of the numeric timezone offset. This provides a\nway to generate standards conformant HTTP date headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.getaddresses()", "path": "library/email.utils#email.utils.getaddresses", "type": "Email", "text": "\nThis method returns a list of 2-tuples of the form returned by `parseaddr()`.\nfieldvalues is a sequence of header field values as might be returned by\n`Message.get_all`. Here\u2019s a simple example that gets all the recipients of a\nmessage:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.localtime()", "path": "library/email.utils#email.utils.localtime", "type": "Email", "text": "\nReturn local time as an aware datetime object. If called without arguments,\nreturn current time. Otherwise dt argument should be a `datetime` instance,\nand it is converted to the local time zone according to the system time zone\ndatabase. If dt is naive (that is, `dt.tzinfo` is `None`), it is assumed to be\nin local time. In this case, a positive or zero value for isdst causes\n`localtime` to presume initially that summer time (for example, Daylight\nSaving Time) is or is not (respectively) in effect for the specified time. A\nnegative value for isdst causes the `localtime` to attempt to divine whether\nsummer time is in effect for the specified time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.make_msgid()", "path": "library/email.utils#email.utils.make_msgid", "type": "Email", "text": "\nReturns a string suitable for an RFC 2822-compliant Message-ID header.\nOptional idstring if given, is a string used to strengthen the uniqueness of\nthe message id. Optional domain if given provides the portion of the msgid\nafter the \u2018@\u2019. The default is the local hostname. It is not normally necessary\nto override this default, but may be useful certain cases, such as a\nconstructing distributed system that uses a consistent domain name across\nmultiple hosts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.mktime_tz()", "path": "library/email.utils#email.utils.mktime_tz", "type": "Email", "text": "\nTurn a 10-tuple as returned by `parsedate_tz()` into a UTC timestamp (seconds\nsince the Epoch). If the timezone item in the tuple is `None`, assume local\ntime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parseaddr()", "path": "library/email.utils#email.utils.parseaddr", "type": "Email", "text": "\nParse address \u2013 which should be the value of some address-containing field\nsuch as To or Cc \u2013 into its constituent realname and email address parts.\nReturns a tuple of that information, unless the parse fails, in which case a\n2-tuple of `('', '')` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parsedate()", "path": "library/email.utils#email.utils.parsedate", "type": "Email", "text": "\nAttempts to parse a date according to the rules in RFC 2822. however, some\nmailers don\u2019t follow that format as specified, so `parsedate()` tries to guess\ncorrectly in such cases. date is a string containing an RFC 2822 date, such as\n`\"Mon, 20 Nov 1995 19:12:08 -0500\"`. If it succeeds in parsing the date,\n`parsedate()` returns a 9-tuple that can be passed directly to\n`time.mktime()`; otherwise `None` will be returned. Note that indexes 6, 7,\nand 8 of the result tuple are not usable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parsedate_to_datetime()", "path": "library/email.utils#email.utils.parsedate_to_datetime", "type": "Email", "text": "\nThe inverse of `format_datetime()`. Performs the same function as\n`parsedate()`, but on success returns a `datetime`. If the input date has a\ntimezone of `-0000`, the `datetime` will be a naive `datetime`, and if the\ndate is conforming to the RFCs it will represent a time in UTC but with no\nindication of the actual source timezone of the message the date comes from.\nIf the input date has any other valid timezone offset, the `datetime` will be\nan aware `datetime` with the corresponding a `timezone` `tzinfo`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parsedate_tz()", "path": "library/email.utils#email.utils.parsedate_tz", "type": "Email", "text": "\nPerforms the same function as `parsedate()`, but returns either `None` or a\n10-tuple; the first 9 elements make up a tuple that can be passed directly to\n`time.mktime()`, and the tenth is the offset of the date\u2019s timezone from UTC\n(which is the official term for Greenwich Mean Time) 1. If the input string\nhas no timezone, the last element of the tuple returned is `0`, which\nrepresents UTC. Note that indexes 6, 7, and 8 of the result tuple are not\nusable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.quote()", "path": "library/email.utils#email.utils.quote", "type": "Email", "text": "\nReturn a new string with backslashes in str replaced by two backslashes, and\ndouble quotes replaced by backslash-double quote.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.unquote()", "path": "library/email.utils#email.utils.unquote", "type": "Email", "text": "\nReturn a new string which is an unquoted version of str. If str ends and\nbegins with double quotes, they are stripped off. Likewise if str ends and\nbegins with angle brackets, they are stripped off.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils: Miscellaneous utilities", "path": "library/email.utils", "type": "Email", "text": "\nSource code: Lib/email/utils.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email: Examples", "path": "library/email.examples", "type": "Email", "text": "\nHere are a few examples of how to use the `email` package to read, write, and\nsend simple email messages, as well as more complex MIME messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "encodings.idna.nameprep()", "path": "library/codecs#encodings.idna.nameprep", "type": "Binary Data", "text": "\nReturn the nameprepped version of label. The implementation currently assumes\nquery strings, so `AllowUnassigned` is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "encodings.idna.ToASCII()", "path": "library/codecs#encodings.idna.ToASCII", "type": "Binary Data", "text": "\nConvert a label to ASCII, as specified in RFC 3490. `UseSTD3ASCIIRules` is\nassumed to be false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "encodings.idna.ToUnicode()", "path": "library/codecs#encodings.idna.ToUnicode", "type": "Binary Data", "text": "\nConvert a label to Unicode, as specified in RFC 3490.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ensurepip", "path": "library/ensurepip", "type": "Software Packaging & Distribution", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ensurepip.bootstrap()", "path": "library/ensurepip#ensurepip.bootstrap", "type": "Software Packaging & Distribution", "text": "\nBootstraps `pip` into the current or designated environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ensurepip.version()", "path": "library/ensurepip#ensurepip.version", "type": "Software Packaging & Distribution", "text": "\nReturns a string specifying the bundled version of pip that will be installed\nwhen bootstrapping an environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum", "path": "library/enum", "type": "Data Types", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.auto", "path": "library/enum#enum.auto", "type": "Data Types", "text": "\nInstances are replaced with an appropriate value for Enum members. By default,\nthe initial value starts at 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.Enum", "path": "library/enum#enum.Enum", "type": "Data Types", "text": "\nBase class for creating enumerated constants. See section Functional API for\nan alternate construction syntax.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.Flag", "path": "library/enum#enum.Flag", "type": "Data Types", "text": "\nBase class for creating enumerated constants that can be combined using the\nbitwise operations without losing their `Flag` membership.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.IntEnum", "path": "library/enum#enum.IntEnum", "type": "Data Types", "text": "\nBase class for creating enumerated constants that are also subclasses of\n`int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.IntFlag", "path": "library/enum#enum.IntFlag", "type": "Data Types", "text": "\nBase class for creating enumerated constants that can be combined using the\nbitwise operators without losing their `IntFlag` membership. `IntFlag` members\nare also subclasses of `int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.unique()", "path": "library/enum#enum.unique", "type": "Data Types", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enumerate()", "path": "library/functions#enumerate", "type": "Built-in Functions", "text": "\nReturn an enumerate object. iterable must be a sequence, an iterator, or some\nother object which supports iteration. The `__next__()` method of the iterator\nreturned by `enumerate()` returns a tuple containing a count (from start which\ndefaults to 0) and the values obtained from iterating over iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironmentError", "path": "library/exceptions#EnvironmentError", "type": "Built-in Exceptions", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EOFError", "path": "library/exceptions#EOFError", "type": "Built-in Exceptions", "text": "\nRaised when the `input()` function hits an end-of-file condition (EOF) without\nreading any data. (N.B.: the `io.IOBase.read()` and `io.IOBase.readline()`\nmethods return an empty string when they hit EOF.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "errno", "path": "library/errno", "type": "Operating System", "text": "\nThis module makes available standard `errno` system symbols. The value of each\nsymbol is the corresponding integer value. The names and descriptions are\nborrowed from `linux/include/errno.h`, which should be pretty all-inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "eval()", "path": "library/functions#eval", "type": "Built-in Functions", "text": "\nThe arguments are a string and optional globals and locals. If provided,\nglobals must be a dictionary. If provided, locals can be any mapping object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Event Loop", "path": "library/asyncio-eventloop", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/events.py, Lib/asyncio/base_events.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Exception", "path": "library/exceptions#Exception", "type": "Built-in Exceptions", "text": "\nAll built-in, non-system-exiting exceptions are derived from this class. All\nuser-defined exceptions should also be derived from this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Exceptions", "path": "library/asyncio-exceptions", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/exceptions.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Exceptions", "path": "library/exceptions", "type": "Built-in Exceptions", "text": "\nIn Python, all exceptions must be instances of a class that derives from\n`BaseException`. In a `try` statement with an `except` clause that mentions a\nparticular class, that clause also handles any exception classes derived from\nthat class (but not exception classes from which it is derived). Two exception\nclasses that are not related via subclassing are never equivalent, even if\nthey have the same name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "exec()", "path": "library/functions#exec", "type": "Built-in Functions", "text": "\nThis function supports dynamic execution of Python code. object must be either\na string or a code object. If it is a string, the string is parsed as a suite\nof Python statements which is then executed (unless a syntax error occurs). 1\nIf it is a code object, it is simply executed. In all cases, the code that\u2019s\nexecuted is expected to be valid as file input (see the section \u201cFile input\u201d\nin the Reference Manual). Be aware that the `nonlocal`, `yield`, and `return`\nstatements may not be used outside of function definitions even within the\ncontext of code passed to the `exec()` function. The return value is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "exit", "path": "library/constants#exit", "type": "Built-in Constants", "text": "\nObjects that when printed, print a message like \u201cUse quit() or Ctrl-D (i.e.\nEOF) to exit\u201d, and when called, raise `SystemExit` with the specified exit\ncode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "False", "path": "library/constants#False", "type": "Built-in Constants", "text": "\nThe false value of the `bool` type. Assignments to `False` are illegal and\nraise a `SyntaxError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler", "path": "library/faulthandler", "type": "Debugging & Profiling", "text": "\nNew in version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.cancel_dump_traceback_later()", "path": "library/faulthandler#faulthandler.cancel_dump_traceback_later", "type": "Debugging & Profiling", "text": "\nCancel the last call to `dump_traceback_later()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.disable()", "path": "library/faulthandler#faulthandler.disable", "type": "Debugging & Profiling", "text": "\nDisable the fault handler: uninstall the signal handlers installed by\n`enable()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.dump_traceback()", "path": "library/faulthandler#faulthandler.dump_traceback", "type": "Debugging & Profiling", "text": "\nDump the tracebacks of all threads into file. If all_threads is `False`, dump\nonly the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.dump_traceback_later()", "path": "library/faulthandler#faulthandler.dump_traceback_later", "type": "Debugging & Profiling", "text": "\nDump the tracebacks of all threads, after a timeout of timeout seconds, or\nevery timeout seconds if repeat is `True`. If exit is `True`, call `_exit()`\nwith status=1 after dumping the tracebacks. (Note `_exit()` exits the process\nimmediately, which means it doesn\u2019t do any cleanup like flushing file\nbuffers.) If the function is called twice, the new call replaces previous\nparameters and resets the timeout. The timer has a sub-second resolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.enable()", "path": "library/faulthandler#faulthandler.enable", "type": "Debugging & Profiling", "text": "\nEnable the fault handler: install handlers for the `SIGSEGV`, `SIGFPE`,\n`SIGABRT`, `SIGBUS` and `SIGILL` signals to dump the Python traceback. If\nall_threads is `True`, produce tracebacks for every running thread. Otherwise,\ndump only the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.is_enabled()", "path": "library/faulthandler#faulthandler.is_enabled", "type": "Debugging & Profiling", "text": "\nCheck if the fault handler is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.register()", "path": "library/faulthandler#faulthandler.register", "type": "Debugging & Profiling", "text": "\nRegister a user signal: install a handler for the signum signal to dump the\ntraceback of all threads, or of the current thread if all_threads is `False`,\ninto file. Call the previous handler if chain is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.unregister()", "path": "library/faulthandler#faulthandler.unregister", "type": "Debugging & Profiling", "text": "\nUnregister a user signal: uninstall the handler of the signum signal installed\nby `register()`. Return `True` if the signal was registered, `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl", "path": "library/fcntl", "type": "Unix", "text": "\nThis module performs file control and I/O control on file descriptors. It is\nan interface to the `fcntl()` and `ioctl()` Unix routines. For a complete\ndescription of these calls, see fcntl(2) and ioctl(2) Unix manual pages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.fcntl()", "path": "library/fcntl#fcntl.fcntl", "type": "Unix", "text": "\nPerform the operation cmd on file descriptor fd (file objects providing a\n`fileno()` method are accepted as well). The values used for cmd are operating\nsystem dependent, and are available as constants in the `fcntl` module, using\nthe same names as used in the relevant C header files. The argument arg can\neither be an integer value, or a `bytes` object. With an integer value, the\nreturn value of this function is the integer return value of the C `fcntl()`\ncall. When the argument is bytes it represents a binary structure, e.g.\ncreated by `struct.pack()`. The binary data is copied to a buffer whose\naddress is passed to the C `fcntl()` call. The return value after a successful\ncall is the contents of the buffer, converted to a `bytes` object. The length\nof the returned object will be the same as the length of the arg argument.\nThis is limited to 1024 bytes. If the information returned in the buffer by\nthe operating system is larger than 1024 bytes, this is most likely to result\nin a segmentation violation or a more subtle data corruption.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.flock()", "path": "library/fcntl#fcntl.flock", "type": "Unix", "text": "\nPerform the lock operation operation on file descriptor fd (file objects\nproviding a `fileno()` method are accepted as well). See the Unix manual\nflock(2) for details. (On some systems, this function is emulated using\n`fcntl()`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.ioctl()", "path": "library/fcntl#fcntl.ioctl", "type": "Unix", "text": "\nThis function is identical to the `fcntl()` function, except that the argument\nhandling is even more complicated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.lockf()", "path": "library/fcntl#fcntl.lockf", "type": "Unix", "text": "\nThis is essentially a wrapper around the `fcntl()` locking calls. fd is the\nfile descriptor (file objects providing a `fileno()` method are accepted as\nwell) of the file to lock or unlock, and cmd is one of the following values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "File and Directory Access", "path": "library/filesys", "type": "File & Directory Access", "text": "\nThe modules described in this chapter deal with disk files and directories.\nFor example, there are modules for reading the properties of files,\nmanipulating paths in a portable way, and creating temporary files. The full\nlist of modules in this chapter is:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp", "path": "library/filecmp", "type": "File & Directory Access", "text": "\nSource code: Lib/filecmp.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.clear_cache()", "path": "library/filecmp#filecmp.clear_cache", "type": "File & Directory Access", "text": "\nClear the filecmp cache. This may be useful if a file is compared so quickly\nafter it is modified that it is within the mtime resolution of the underlying\nfilesystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.cmp()", "path": "library/filecmp#filecmp.cmp", "type": "File & Directory Access", "text": "\nCompare the files named f1 and f2, returning `True` if they seem equal,\n`False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.cmpfiles()", "path": "library/filecmp#filecmp.cmpfiles", "type": "File & Directory Access", "text": "\nCompare the files in the two directories dir1 and dir2 whose names are given\nby common.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.DEFAULT_IGNORES", "path": "library/filecmp#filecmp.DEFAULT_IGNORES", "type": "File & Directory Access", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp", "path": "library/filecmp#filecmp.dircmp", "type": "File & Directory Access", "text": "\nConstruct a new directory comparison object, to compare the directories a and\nb. ignore is a list of names to ignore, and defaults to\n`filecmp.DEFAULT_IGNORES`. hide is a list of names to hide, and defaults to\n`[os.curdir, os.pardir]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common", "path": "library/filecmp#filecmp.dircmp.common", "type": "File & Directory Access", "text": "\nFiles and subdirectories in both a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common_dirs", "path": "library/filecmp#filecmp.dircmp.common_dirs", "type": "File & Directory Access", "text": "\nSubdirectories in both a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common_files", "path": "library/filecmp#filecmp.dircmp.common_files", "type": "File & Directory Access", "text": "\nFiles in both a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common_funny", "path": "library/filecmp#filecmp.dircmp.common_funny", "type": "File & Directory Access", "text": "\nNames in both a and b, such that the type differs between the directories, or\nnames for which `os.stat()` reports an error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.diff_files", "path": "library/filecmp#filecmp.dircmp.diff_files", "type": "File & Directory Access", "text": "\nFiles which are in both a and b, whose contents differ according to the\nclass\u2019s file comparison operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.funny_files", "path": "library/filecmp#filecmp.dircmp.funny_files", "type": "File & Directory Access", "text": "\nFiles which are in both a and b, but could not be compared.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.left", "path": "library/filecmp#filecmp.dircmp.left", "type": "File & Directory Access", "text": "\nThe directory a.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.left_list", "path": "library/filecmp#filecmp.dircmp.left_list", "type": "File & Directory Access", "text": "\nFiles and subdirectories in a, filtered by hide and ignore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.left_only", "path": "library/filecmp#filecmp.dircmp.left_only", "type": "File & Directory Access", "text": "\nFiles and subdirectories only in a.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.report()", "path": "library/filecmp#filecmp.dircmp.report", "type": "File & Directory Access", "text": "\nPrint (to `sys.stdout`) a comparison between a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.report_full_closure()", "path": "library/filecmp#filecmp.dircmp.report_full_closure", "type": "File & Directory Access", "text": "\nPrint a comparison between a and b and common subdirectories (recursively).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.report_partial_closure()", "path": "library/filecmp#filecmp.dircmp.report_partial_closure", "type": "File & Directory Access", "text": "\nPrint a comparison between a and b and common immediate subdirectories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.right", "path": "library/filecmp#filecmp.dircmp.right", "type": "File & Directory Access", "text": "\nThe directory b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.right_list", "path": "library/filecmp#filecmp.dircmp.right_list", "type": "File & Directory Access", "text": "\nFiles and subdirectories in b, filtered by hide and ignore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.right_only", "path": "library/filecmp#filecmp.dircmp.right_only", "type": "File & Directory Access", "text": "\nFiles and subdirectories only in b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.same_files", "path": "library/filecmp#filecmp.dircmp.same_files", "type": "File & Directory Access", "text": "\nFiles which are identical in both a and b, using the class\u2019s file comparison\noperator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.subdirs", "path": "library/filecmp#filecmp.dircmp.subdirs", "type": "File & Directory Access", "text": "\nA dictionary mapping names in `common_dirs` to `dircmp` objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileExistsError", "path": "library/exceptions#FileExistsError", "type": "Built-in Exceptions", "text": "\nRaised when trying to create a file or directory which already exists.\nCorresponds to `errno` `EEXIST`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput", "path": "library/fileinput", "type": "File & Directory Access", "text": "\nSource code: Lib/fileinput.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.close()", "path": "library/fileinput#fileinput.close", "type": "File & Directory Access", "text": "\nClose the sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.FileInput", "path": "library/fileinput#fileinput.FileInput", "type": "File & Directory Access", "text": "\nClass `FileInput` is the implementation; its methods `filename()`, `fileno()`,\n`lineno()`, `filelineno()`, `isfirstline()`, `isstdin()`, `nextfile()` and\n`close()` correspond to the functions of the same name in the module. In\naddition it has a `readline()` method which returns the next input line, and a\n`__getitem__()` method which implements the sequence behavior. The sequence\nmust be accessed in strictly sequential order; random access and `readline()`\ncannot be mixed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.filelineno()", "path": "library/fileinput#fileinput.filelineno", "type": "File & Directory Access", "text": "\nReturn the line number in the current file. Before the first line has been\nread, returns `0`. After the last line of the last file has been read, returns\nthe line number of that line within the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.filename()", "path": "library/fileinput#fileinput.filename", "type": "File & Directory Access", "text": "\nReturn the name of the file currently being read. Before the first line has\nbeen read, returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.fileno()", "path": "library/fileinput#fileinput.fileno", "type": "File & Directory Access", "text": "\nReturn the integer \u201cfile descriptor\u201d for the current file. When no file is\nopened (before the first line and between files), returns `-1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.hook_compressed()", "path": "library/fileinput#fileinput.hook_compressed", "type": "File & Directory Access", "text": "\nTransparently opens files compressed with gzip and bzip2 (recognized by the\nextensions `'.gz'` and `'.bz2'`) using the `gzip` and `bz2` modules. If the\nfilename extension is not `'.gz'` or `'.bz2'`, the file is opened normally\n(ie, using `open()` without any decompression).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.hook_encoded()", "path": "library/fileinput#fileinput.hook_encoded", "type": "File & Directory Access", "text": "\nReturns a hook which opens each file with `open()`, using the given encoding\nand errors to read the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.input()", "path": "library/fileinput#fileinput.input", "type": "File & Directory Access", "text": "\nCreate an instance of the `FileInput` class. The instance will be used as\nglobal state for the functions of this module, and is also returned to use\nduring iteration. The parameters to this function will be passed along to the\nconstructor of the `FileInput` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.isfirstline()", "path": "library/fileinput#fileinput.isfirstline", "type": "File & Directory Access", "text": "\nReturn `True` if the line just read is the first line of its file, otherwise\nreturn `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.isstdin()", "path": "library/fileinput#fileinput.isstdin", "type": "File & Directory Access", "text": "\nReturn `True` if the last line was read from `sys.stdin`, otherwise return\n`False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.lineno()", "path": "library/fileinput#fileinput.lineno", "type": "File & Directory Access", "text": "\nReturn the cumulative line number of the line that has just been read. Before\nthe first line has been read, returns `0`. After the last line of the last\nfile has been read, returns the line number of that line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.nextfile()", "path": "library/fileinput#fileinput.nextfile", "type": "File & Directory Access", "text": "\nClose the current file so that the next iteration will read the first line\nfrom the next file (if any); lines not read from the file will not count\ntowards the cumulative line count. The filename is not changed until after the\nfirst line of the next file has been read. Before the first line has been\nread, this function has no effect; it cannot be used to skip the first file.\nAfter the last line of the last file has been read, this function has no\neffect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileNotFoundError", "path": "library/exceptions#FileNotFoundError", "type": "Built-in Exceptions", "text": "\nRaised when a file or directory is requested but doesn\u2019t exist. Corresponds to\n`errno` `ENOENT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filter()", "path": "library/functions#filter", "type": "Built-in Functions", "text": "\nConstruct an iterator from those elements of iterable for which function\nreturns true. iterable may be either a sequence, a container which supports\niteration, or an iterator. If function is `None`, the identity function is\nassumed, that is, all elements of iterable that are false are removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float", "path": "library/functions#float", "type": "Built-in Functions", "text": "\nReturn a floating point number constructed from a number or string x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.as_integer_ratio()", "path": "library/stdtypes#float.as_integer_ratio", "type": "Built-in Types", "text": "\nReturn a pair of integers whose ratio is exactly equal to the original float\nand with a positive denominator. Raises `OverflowError` on infinities and a\n`ValueError` on NaNs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.fromhex()", "path": "library/stdtypes#float.fromhex", "type": "Built-in Types", "text": "\nClass method to return the float represented by a hexadecimal string s. The\nstring s may have leading and trailing whitespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.hex()", "path": "library/stdtypes#float.hex", "type": "Built-in Types", "text": "\nReturn a representation of a floating-point number as a hexadecimal string.\nFor finite floating-point numbers, this representation will always include a\nleading `0x` and a trailing `p` and exponent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.is_integer()", "path": "library/stdtypes#float.is_integer", "type": "Built-in Types", "text": "\nReturn `True` if the float instance is finite with integral value, and `False`\notherwise:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FloatingPointError", "path": "library/exceptions#FloatingPointError", "type": "Built-in Exceptions", "text": "\nNot currently used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch", "path": "library/fnmatch", "type": "File & Directory Access", "text": "\nSource code: Lib/fnmatch.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.filter()", "path": "library/fnmatch#fnmatch.filter", "type": "File & Directory Access", "text": "\nConstruct a list from those elements of the iterable names that match pattern.\nIt is the same as `[n for n in names if fnmatch(n, pattern)]`, but implemented\nmore efficiently.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.fnmatch()", "path": "library/fnmatch#fnmatch.fnmatch", "type": "File & Directory Access", "text": "\nTest whether the filename string matches the pattern string, returning `True`\nor `False`. Both parameters are case-normalized using `os.path.normcase()`.\n`fnmatchcase()` can be used to perform a case-sensitive comparison, regardless\nof whether that\u2019s standard for the operating system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.fnmatchcase()", "path": "library/fnmatch#fnmatch.fnmatchcase", "type": "File & Directory Access", "text": "\nTest whether filename matches pattern, returning `True` or `False`; the\ncomparison is case-sensitive and does not apply `os.path.normcase()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.translate()", "path": "library/fnmatch#fnmatch.translate", "type": "File & Directory Access", "text": "\nReturn the shell-style pattern converted to a regular expression for using\nwith `re.match()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "format()", "path": "library/functions#format", "type": "Built-in Functions", "text": "\nConvert a value to a \u201cformatted\u201d representation, as controlled by format_spec.\nThe interpretation of format_spec will depend on the type of the value\nargument, however there is a standard formatting syntax that is used by most\nbuilt-in types: Format Specification Mini-Language.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions", "path": "library/fractions", "type": "Numeric & Mathematical", "text": "\nSource code: Lib/fractions.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction", "path": "library/fractions#fractions.Fraction", "type": "Numeric & Mathematical", "text": "\nThe first version requires that numerator and denominator are instances of\n`numbers.Rational` and returns a new `Fraction` instance with value\n`numerator/denominator`. If denominator is `0`, it raises a\n`ZeroDivisionError`. The second version requires that other_fraction is an\ninstance of `numbers.Rational` and returns a `Fraction` instance with the same\nvalue. The next two versions accept either a `float` or a `decimal.Decimal`\ninstance, and return a `Fraction` instance with exactly the same value. Note\nthat due to the usual issues with binary floating-point (see Floating Point\nArithmetic: Issues and Limitations), the argument to `Fraction(1.1)` is not\nexactly equal to 11/10, and so `Fraction(1.1)` does not return `Fraction(11,\n10)` as one might expect. (But see the documentation for the\n`limit_denominator()` method below.) The last version of the constructor\nexpects a string or unicode instance. The usual form for this instance is:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.as_integer_ratio()", "path": "library/fractions#fractions.Fraction.as_integer_ratio", "type": "Numeric & Mathematical", "text": "\nReturn a tuple of two integers, whose ratio is equal to the Fraction and with\na positive denominator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.denominator", "path": "library/fractions#fractions.Fraction.denominator", "type": "Numeric & Mathematical", "text": "\nDenominator of the Fraction in lowest term.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.from_decimal()", "path": "library/fractions#fractions.Fraction.from_decimal", "type": "Numeric & Mathematical", "text": "\nThis class method constructs a `Fraction` representing the exact value of dec,\nwhich must be a `decimal.Decimal` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.from_float()", "path": "library/fractions#fractions.Fraction.from_float", "type": "Numeric & Mathematical", "text": "\nThis class method constructs a `Fraction` representing the exact value of flt,\nwhich must be a `float`. Beware that `Fraction.from_float(0.3)` is not the\nsame value as `Fraction(3, 10)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.limit_denominator()", "path": "library/fractions#fractions.Fraction.limit_denominator", "type": "Numeric & Mathematical", "text": "\nFinds and returns the closest `Fraction` to `self` that has denominator at\nmost max_denominator. This method is useful for finding rational\napproximations to a given floating-point number:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.numerator", "path": "library/fractions#fractions.Fraction.numerator", "type": "Numeric & Mathematical", "text": "\nNumerator of the Fraction in lowest term.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.__ceil__()", "path": "library/fractions#fractions.Fraction.__ceil__", "type": "Numeric & Mathematical", "text": "\nReturns the least `int` `>= self`. This method can also be accessed through\nthe `math.ceil()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.__floor__()", "path": "library/fractions#fractions.Fraction.__floor__", "type": "Numeric & Mathematical", "text": "\nReturns the greatest `int` `<= self`. This method can also be accessed through\nthe `math.floor()` function:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.__round__()", "path": "library/fractions#fractions.Fraction.__round__", "type": "Numeric & Mathematical", "text": "\nThe first version returns the nearest `int` to `self`, rounding half to even.\nThe second version rounds `self` to the nearest multiple of `Fraction(1,\n10**ndigits)` (logically, if `ndigits` is negative), again rounding half\ntoward even. This method can also be accessed through the `round()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset", "path": "library/functions#frozenset", "type": "Built-in Functions", "text": "\nReturn a new `frozenset` object, optionally with elements taken from iterable.\n`frozenset` is a built-in class. See `frozenset` and Set Types \u2014 set,\nfrozenset for documentation about this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset", "path": "library/stdtypes#frozenset", "type": "Built-in Types", "text": "\nReturn a new set or frozenset object whose elements are taken from iterable.\nThe elements of a set must be hashable. To represent sets of sets, the inner\nsets must be `frozenset` objects. If iterable is not specified, a new empty\nset is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.add()", "path": "library/stdtypes#frozenset.add", "type": "Built-in Types", "text": "\nAdd element elem to the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.clear()", "path": "library/stdtypes#frozenset.clear", "type": "Built-in Types", "text": "\nRemove all elements from the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.copy()", "path": "library/stdtypes#frozenset.copy", "type": "Built-in Types", "text": "\nReturn a shallow copy of the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.difference()", "path": "library/stdtypes#frozenset.difference", "type": "Built-in Types", "text": "\nReturn a new set with elements in the set that are not in the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.difference_update()", "path": "library/stdtypes#frozenset.difference_update", "type": "Built-in Types", "text": "\nUpdate the set, removing elements found in others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.discard()", "path": "library/stdtypes#frozenset.discard", "type": "Built-in Types", "text": "\nRemove element elem from the set if it is present.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.intersection()", "path": "library/stdtypes#frozenset.intersection", "type": "Built-in Types", "text": "\nReturn a new set with elements common to the set and all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.intersection_update()", "path": "library/stdtypes#frozenset.intersection_update", "type": "Built-in Types", "text": "\nUpdate the set, keeping only elements found in it and all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.isdisjoint()", "path": "library/stdtypes#frozenset.isdisjoint", "type": "Built-in Types", "text": "\nReturn `True` if the set has no elements in common with other. Sets are\ndisjoint if and only if their intersection is the empty set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.issubset()", "path": "library/stdtypes#frozenset.issubset", "type": "Built-in Types", "text": "\nTest whether every element in the set is in other.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.issuperset()", "path": "library/stdtypes#frozenset.issuperset", "type": "Built-in Types", "text": "\nTest whether every element in other is in the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.pop()", "path": "library/stdtypes#frozenset.pop", "type": "Built-in Types", "text": "\nRemove and return an arbitrary element from the set. Raises `KeyError` if the\nset is empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.remove()", "path": "library/stdtypes#frozenset.remove", "type": "Built-in Types", "text": "\nRemove element elem from the set. Raises `KeyError` if elem is not contained\nin the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.symmetric_difference()", "path": "library/stdtypes#frozenset.symmetric_difference", "type": "Built-in Types", "text": "\nReturn a new set with elements in either the set or other but not both.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.symmetric_difference_update()", "path": "library/stdtypes#frozenset.symmetric_difference_update", "type": "Built-in Types", "text": "\nUpdate the set, keeping only elements found in either set, but not in both.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.union()", "path": "library/stdtypes#frozenset.union", "type": "Built-in Types", "text": "\nReturn a new set with elements from the set and all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.update()", "path": "library/stdtypes#frozenset.update", "type": "Built-in Types", "text": "\nUpdate the set, adding elements from all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib", "path": "library/ftplib", "type": "Internet", "text": "\nSource code: Lib/ftplib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.all_errors", "path": "library/ftplib#ftplib.all_errors", "type": "Internet", "text": "\nThe set of all exceptions (as a tuple) that methods of `FTP` instances may\nraise as a result of problems with the FTP connection (as opposed to\nprogramming errors made by the caller). This set includes the four exceptions\nlisted above as well as `OSError` and `EOFError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_perm", "path": "library/ftplib#ftplib.error_perm", "type": "Internet", "text": "\nException raised when an error code signifying a permanent error (response\ncodes in the range 500\u2013599) is received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_proto", "path": "library/ftplib#ftplib.error_proto", "type": "Internet", "text": "\nException raised when a reply is received from the server that does not fit\nthe response specifications of the File Transfer Protocol, i.e. begin with a\ndigit in the range 1\u20135.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_reply", "path": "library/ftplib#ftplib.error_reply", "type": "Internet", "text": "\nException raised when an unexpected reply is received from the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_temp", "path": "library/ftplib#ftplib.error_temp", "type": "Internet", "text": "\nException raised when an error code signifying a temporary error (response\ncodes in the range 400\u2013499) is received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP", "path": "library/ftplib#ftplib.FTP", "type": "Internet", "text": "\nReturn a new instance of the `FTP` class. When host is given, the method call\n`connect(host)` is made. When user is given, additionally the method call\n`login(user, passwd, acct)` is made (where passwd and acct default to the\nempty string when not given). The optional timeout parameter specifies a\ntimeout in seconds for blocking operations like the connection attempt (if is\nnot specified, the global default timeout setting will be used).\nsource_address is a 2-tuple `(host, port)` for the socket to bind to as its\nsource address before connecting. The encoding parameter specifies the\nencoding for directories and filenames.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.abort()", "path": "library/ftplib#ftplib.FTP.abort", "type": "Internet", "text": "\nAbort a file transfer that is in progress. Using this does not always work,\nbut it\u2019s worth a try.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.close()", "path": "library/ftplib#ftplib.FTP.close", "type": "Internet", "text": "\nClose the connection unilaterally. This should not be applied to an already\nclosed connection such as after a successful call to `quit()`. After this call\nthe `FTP` instance should not be used any more (after a call to `close()` or\n`quit()` you cannot reopen the connection by issuing another `login()`\nmethod).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.connect()", "path": "library/ftplib#ftplib.FTP.connect", "type": "Internet", "text": "\nConnect to the given host and port. The default port number is `21`, as\nspecified by the FTP protocol specification. It is rarely needed to specify a\ndifferent port number. This function should be called only once for each\ninstance; it should not be called at all if a host was given when the instance\nwas created. All other methods can only be used after a connection has been\nmade. The optional timeout parameter specifies a timeout in seconds for the\nconnection attempt. If no timeout is passed, the global default timeout\nsetting will be used. source_address is a 2-tuple `(host, port)` for the\nsocket to bind to as its source address before connecting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.cwd()", "path": "library/ftplib#ftplib.FTP.cwd", "type": "Internet", "text": "\nSet the current directory on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.delete()", "path": "library/ftplib#ftplib.FTP.delete", "type": "Internet", "text": "\nRemove the file named filename from the server. If successful, returns the\ntext of the response, otherwise raises `error_perm` on permission errors or\n`error_reply` on other errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.dir()", "path": "library/ftplib#ftplib.FTP.dir", "type": "Internet", "text": "\nProduce a directory listing as returned by the `LIST` command, printing it to\nstandard output. The optional argument is a directory to list (default is the\ncurrent server directory). Multiple arguments can be used to pass non-standard\noptions to the `LIST` command. If the last argument is a function, it is used\nas a callback function as for `retrlines()`; the default prints to\n`sys.stdout`. This method returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.getwelcome()", "path": "library/ftplib#ftplib.FTP.getwelcome", "type": "Internet", "text": "\nReturn the welcome message sent by the server in reply to the initial\nconnection. (This message sometimes contains disclaimers or help information\nthat may be relevant to the user.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.login()", "path": "library/ftplib#ftplib.FTP.login", "type": "Internet", "text": "\nLog in as the given user. The passwd and acct parameters are optional and\ndefault to the empty string. If no user is specified, it defaults to\n`'anonymous'`. If user is `'anonymous'`, the default passwd is `'anonymous@'`.\nThis function should be called only once for each instance, after a connection\nhas been established; it should not be called at all if a host and user were\ngiven when the instance was created. Most FTP commands are only allowed after\nthe client has logged in. The acct parameter supplies \u201caccounting\ninformation\u201d; few systems implement this.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.mkd()", "path": "library/ftplib#ftplib.FTP.mkd", "type": "Internet", "text": "\nCreate a new directory on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.mlsd()", "path": "library/ftplib#ftplib.FTP.mlsd", "type": "Internet", "text": "\nList a directory in a standardized format by using `MLSD` command (RFC 3659).\nIf path is omitted the current directory is assumed. facts is a list of\nstrings representing the type of information desired (e.g. `[\"type\", \"size\",\n\"perm\"]`). Return a generator object yielding a tuple of two elements for\nevery file found in path. First element is the file name, the second one is a\ndictionary containing facts about the file name. Content of this dictionary\nmight be limited by the facts argument but server is not guaranteed to return\nall requested facts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.nlst()", "path": "library/ftplib#ftplib.FTP.nlst", "type": "Internet", "text": "\nReturn a list of file names as returned by the `NLST` command. The optional\nargument is a directory to list (default is the current server directory).\nMultiple arguments can be used to pass non-standard options to the `NLST`\ncommand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.ntransfercmd()", "path": "library/ftplib#ftplib.FTP.ntransfercmd", "type": "Internet", "text": "\nLike `transfercmd()`, but returns a tuple of the data connection and the\nexpected size of the data. If the expected size could not be computed, `None`\nwill be returned as the expected size. cmd and rest means the same thing as in\n`transfercmd()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.pwd()", "path": "library/ftplib#ftplib.FTP.pwd", "type": "Internet", "text": "\nReturn the pathname of the current directory on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.quit()", "path": "library/ftplib#ftplib.FTP.quit", "type": "Internet", "text": "\nSend a `QUIT` command to the server and close the connection. This is the\n\u201cpolite\u201d way to close a connection, but it may raise an exception if the\nserver responds with an error to the `QUIT` command. This implies a call to\nthe `close()` method which renders the `FTP` instance useless for subsequent\ncalls (see below).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.rename()", "path": "library/ftplib#ftplib.FTP.rename", "type": "Internet", "text": "\nRename file fromname on the server to toname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.retrbinary()", "path": "library/ftplib#ftplib.FTP.retrbinary", "type": "Internet", "text": "\nRetrieve a file in binary transfer mode. cmd should be an appropriate `RETR`\ncommand: `'RETR filename'`. The callback function is called for each block of\ndata received, with a single bytes argument giving the data block. The\noptional blocksize argument specifies the maximum chunk size to read on the\nlow-level socket object created to do the actual transfer (which will also be\nthe largest size of the data blocks passed to callback). A reasonable default\nis chosen. rest means the same thing as in the `transfercmd()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.retrlines()", "path": "library/ftplib#ftplib.FTP.retrlines", "type": "Internet", "text": "\nRetrieve a file or directory listing in the encoding specified by the encoding\nparameter at initialization. cmd should be an appropriate `RETR` command (see\n`retrbinary()`) or a command such as `LIST` or `NLST` (usually just the string\n`'LIST'`). `LIST` retrieves a list of files and information about those files.\n`NLST` retrieves a list of file names. The callback function is called for\neach line with a string argument containing the line with the trailing CRLF\nstripped. The default callback prints the line to `sys.stdout`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.rmd()", "path": "library/ftplib#ftplib.FTP.rmd", "type": "Internet", "text": "\nRemove the directory named dirname on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.sendcmd()", "path": "library/ftplib#ftplib.FTP.sendcmd", "type": "Internet", "text": "\nSend a simple command string to the server and return the response string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.set_debuglevel()", "path": "library/ftplib#ftplib.FTP.set_debuglevel", "type": "Internet", "text": "\nSet the instance\u2019s debugging level. This controls the amount of debugging\noutput printed. The default, `0`, produces no debugging output. A value of `1`\nproduces a moderate amount of debugging output, generally a single line per\nrequest. A value of `2` or higher produces the maximum amount of debugging\noutput, logging each line sent and received on the control connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.set_pasv()", "path": "library/ftplib#ftplib.FTP.set_pasv", "type": "Internet", "text": "\nEnable \u201cpassive\u201d mode if val is true, otherwise disable passive mode. Passive\nmode is on by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.size()", "path": "library/ftplib#ftplib.FTP.size", "type": "Internet", "text": "\nRequest the size of the file named filename on the server. On success, the\nsize of the file is returned as an integer, otherwise `None` is returned. Note\nthat the `SIZE` command is not standardized, but is supported by many common\nserver implementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.storbinary()", "path": "library/ftplib#ftplib.FTP.storbinary", "type": "Internet", "text": "\nStore a file in binary transfer mode. cmd should be an appropriate `STOR`\ncommand: `\"STOR filename\"`. fp is a file object (opened in binary mode) which\nis read until EOF using its `read()` method in blocks of size blocksize to\nprovide the data to be stored. The blocksize argument defaults to 8192.\ncallback is an optional single parameter callable that is called on each block\nof data after it is sent. rest means the same thing as in the `transfercmd()`\nmethod.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.storlines()", "path": "library/ftplib#ftplib.FTP.storlines", "type": "Internet", "text": "\nStore a file in line mode. cmd should be an appropriate `STOR` command (see\n`storbinary()`). Lines are read until EOF from the file object fp (opened in\nbinary mode) using its `readline()` method to provide the data to be stored.\ncallback is an optional single parameter callable that is called on each line\nafter it is sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.transfercmd()", "path": "library/ftplib#ftplib.FTP.transfercmd", "type": "Internet", "text": "\nInitiate a transfer over the data connection. If the transfer is active, send\nan `EPRT` or `PORT` command and the transfer command specified by cmd, and\naccept the connection. If the server is passive, send an `EPSV` or `PASV`\ncommand, connect to it, and start the transfer command. Either way, return the\nsocket for the connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.voidcmd()", "path": "library/ftplib#ftplib.FTP.voidcmd", "type": "Internet", "text": "\nSend a simple command string to the server and handle the response. Return\nnothing if a response code corresponding to success (codes in the range\n200\u2013299) is received. Raise `error_reply` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS", "path": "library/ftplib#ftplib.FTP_TLS", "type": "Internet", "text": "\nA `FTP` subclass which adds TLS support to FTP as described in RFC 4217.\nConnect as usual to port 21 implicitly securing the FTP control connection\nbefore authenticating. Securing the data connection requires the user to\nexplicitly ask for it by calling the `prot_p()` method. context is a\n`ssl.SSLContext` object which allows bundling SSL configuration options,\ncertificates and private keys into a single (potentially long-lived)\nstructure. Please read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.auth()", "path": "library/ftplib#ftplib.FTP_TLS.auth", "type": "Internet", "text": "\nSet up a secure control connection by using TLS or SSL, depending on what is\nspecified in the `ssl_version` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.ccc()", "path": "library/ftplib#ftplib.FTP_TLS.ccc", "type": "Internet", "text": "\nRevert control channel back to plaintext. This can be useful to take advantage\nof firewalls that know how to handle NAT with non-secure FTP without opening\nfixed ports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.prot_c()", "path": "library/ftplib#ftplib.FTP_TLS.prot_c", "type": "Internet", "text": "\nSet up clear text data connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.prot_p()", "path": "library/ftplib#ftplib.FTP_TLS.prot_p", "type": "Internet", "text": "\nSet up secure data connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.ssl_version", "path": "library/ftplib#ftplib.FTP_TLS.ssl_version", "type": "Internet", "text": "\nThe SSL version to use (defaults to `ssl.PROTOCOL_SSLv23`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Functions", "path": "library/functions", "type": "Built-in Functions", "text": "\nThe Python interpreter has a number of functions and types built into it that\nare always available. They are listed here in alphabetical order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools", "path": "library/functools", "type": "Functional Programming", "text": "\nSource code: Lib/functools.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.cache()", "path": "library/functools#functools.cache", "type": "Functional Programming", "text": "\nSimple lightweight unbounded function cache. Sometimes called \u201cmemoize\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.cached_property()", "path": "library/functools#functools.cached_property", "type": "Functional Programming", "text": "\nTransform a method of a class into a property whose value is computed once and\nthen cached as a normal attribute for the life of the instance. Similar to\n`property()`, with the addition of caching. Useful for expensive computed\nproperties of instances that are otherwise effectively immutable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.cmp_to_key()", "path": "library/functools#functools.cmp_to_key", "type": "Functional Programming", "text": "\nTransform an old-style comparison function to a key function. Used with tools\nthat accept key functions (such as `sorted()`, `min()`, `max()`,\n`heapq.nlargest()`, `heapq.nsmallest()`, `itertools.groupby()`). This function\nis primarily used as a transition tool for programs being converted from\nPython 2 which supported the use of comparison functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.lru_cache()", "path": "library/functools#functools.lru_cache", "type": "Functional Programming", "text": "\nDecorator to wrap a function with a memoizing callable that saves up to the\nmaxsize most recent calls. It can save time when an expensive or I/O bound\nfunction is periodically called with the same arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial()", "path": "library/functools#functools.partial", "type": "Functional Programming", "text": "\nReturn a new partial object which when called will behave like func called\nwith the positional arguments args and keyword arguments keywords. If more\narguments are supplied to the call, they are appended to args. If additional\nkeyword arguments are supplied, they extend and override keywords. Roughly\nequivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial.args", "path": "library/functools#functools.partial.args", "type": "Functional Programming", "text": "\nThe leftmost positional arguments that will be prepended to the positional\narguments provided to a `partial` object call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial.func", "path": "library/functools#functools.partial.func", "type": "Functional Programming", "text": "\nA callable object or function. Calls to the `partial` object will be forwarded\nto `func` with new arguments and keywords.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial.keywords", "path": "library/functools#functools.partial.keywords", "type": "Functional Programming", "text": "\nThe keyword arguments that will be supplied when the `partial` object is\ncalled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partialmethod", "path": "library/functools#functools.partialmethod", "type": "Functional Programming", "text": "\nReturn a new `partialmethod` descriptor which behaves like `partial` except\nthat it is designed to be used as a method definition rather than being\ndirectly callable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.reduce()", "path": "library/functools#functools.reduce", "type": "Functional Programming", "text": "\nApply function of two arguments cumulatively to the items of iterable, from\nleft to right, so as to reduce the iterable to a single value. For example,\n`reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])` calculates `((((1+2)+3)+4)+5)`.\nThe left argument, x, is the accumulated value and the right argument, y, is\nthe update value from the iterable. If the optional initializer is present, it\nis placed before the items of the iterable in the calculation, and serves as a\ndefault when the iterable is empty. If initializer is not given and iterable\ncontains only one item, the first item is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.singledispatch()", "path": "library/functools#functools.singledispatch", "type": "Functional Programming", "text": "\nTransform a function into a single-dispatch generic function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.singledispatchmethod", "path": "library/functools#functools.singledispatchmethod", "type": "Functional Programming", "text": "\nTransform a method into a single-dispatch generic function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.total_ordering()", "path": "library/functools#functools.total_ordering", "type": "Functional Programming", "text": "\nGiven a class defining one or more rich comparison ordering methods, this\nclass decorator supplies the rest. This simplifies the effort involved in\nspecifying all of the possible rich comparison operations:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.update_wrapper()", "path": "library/functools#functools.update_wrapper", "type": "Functional Programming", "text": "\nUpdate a wrapper function to look like the wrapped function. The optional\narguments are tuples to specify which attributes of the original function are\nassigned directly to the matching attributes on the wrapper function and which\nattributes of the wrapper function are updated with the corresponding\nattributes from the original function. The default values for these arguments\nare the module level constants `WRAPPER_ASSIGNMENTS` (which assigns to the\nwrapper function\u2019s `__module__`, `__name__`, `__qualname__`, `__annotations__`\nand `__doc__`, the documentation string) and `WRAPPER_UPDATES` (which updates\nthe wrapper function\u2019s `__dict__`, i.e. the instance dictionary).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.wraps()", "path": "library/functools#functools.wraps", "type": "Functional Programming", "text": "\nThis is a convenience function for invoking `update_wrapper()` as a function\ndecorator when defining a wrapper function. It is equivalent to\n`partial(update_wrapper, wrapped=wrapped, assigned=assigned,\nupdated=updated)`. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Futures", "path": "library/asyncio-future", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/futures.py, Lib/asyncio/base_futures.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FutureWarning", "path": "library/exceptions#FutureWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about deprecated features when those warnings are\nintended for end users of applications that are written in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc", "path": "library/gc", "type": "Runtime", "text": "\nThis module provides an interface to the optional garbage collector. It\nprovides the ability to disable the collector, tune the collection frequency,\nand set debugging options. It also provides access to unreachable objects that\nthe collector found but cannot free. Since the collector supplements the\nreference counting already used in Python, you can disable the collector if\nyou are sure your program does not create reference cycles. Automatic\ncollection can be disabled by calling `gc.disable()`. To debug a leaking\nprogram call `gc.set_debug(gc.DEBUG_LEAK)`. Notice that this includes\n`gc.DEBUG_SAVEALL`, causing garbage-collected objects to be saved in\ngc.garbage for inspection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.callbacks", "path": "library/gc#gc.callbacks", "type": "Runtime", "text": "\nA list of callbacks that will be invoked by the garbage collector before and\nafter collection. The callbacks will be called with two arguments, phase and\ninfo.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.collect()", "path": "library/gc#gc.collect", "type": "Runtime", "text": "\nWith no arguments, run a full collection. The optional argument generation may\nbe an integer specifying which generation to collect (from 0 to 2). A\n`ValueError` is raised if the generation number is invalid. The number of\nunreachable objects found is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_COLLECTABLE", "path": "library/gc#gc.DEBUG_COLLECTABLE", "type": "Runtime", "text": "\nPrint information on collectable objects found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_LEAK", "path": "library/gc#gc.DEBUG_LEAK", "type": "Runtime", "text": "\nThe debugging flags necessary for the collector to print information about a\nleaking program (equal to `DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE |\nDEBUG_SAVEALL`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_SAVEALL", "path": "library/gc#gc.DEBUG_SAVEALL", "type": "Runtime", "text": "\nWhen set, all unreachable objects found will be appended to garbage rather\nthan being freed. This can be useful for debugging a leaking program.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_STATS", "path": "library/gc#gc.DEBUG_STATS", "type": "Runtime", "text": "\nPrint statistics during collection. This information can be useful when tuning\nthe collection frequency.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_UNCOLLECTABLE", "path": "library/gc#gc.DEBUG_UNCOLLECTABLE", "type": "Runtime", "text": "\nPrint information of uncollectable objects found (objects which are not\nreachable but cannot be freed by the collector). These objects will be added\nto the `garbage` list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.disable()", "path": "library/gc#gc.disable", "type": "Runtime", "text": "\nDisable automatic garbage collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.enable()", "path": "library/gc#gc.enable", "type": "Runtime", "text": "\nEnable automatic garbage collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.freeze()", "path": "library/gc#gc.freeze", "type": "Runtime", "text": "\nFreeze all the objects tracked by gc - move them to a permanent generation and\nignore all the future collections. This can be used before a POSIX fork() call\nto make the gc copy-on-write friendly or to speed up collection. Also\ncollection before a POSIX fork() call may free pages for future allocation\nwhich can cause copy-on-write too so it\u2019s advised to disable gc in parent\nprocess and freeze before fork and enable gc in child process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.garbage", "path": "library/gc#gc.garbage", "type": "Runtime", "text": "\nA list of objects which the collector found to be unreachable but could not be\nfreed (uncollectable objects). Starting with Python 3.4, this list should be\nempty most of the time, except when using instances of C extension types with\na non-`NULL` `tp_del` slot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_count()", "path": "library/gc#gc.get_count", "type": "Runtime", "text": "\nReturn the current collection counts as a tuple of `(count0, count1, count2)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_debug()", "path": "library/gc#gc.get_debug", "type": "Runtime", "text": "\nReturn the debugging flags currently set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_freeze_count()", "path": "library/gc#gc.get_freeze_count", "type": "Runtime", "text": "\nReturn the number of objects in the permanent generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_objects()", "path": "library/gc#gc.get_objects", "type": "Runtime", "text": "\nReturns a list of all objects tracked by the collector, excluding the list\nreturned. If generation is not None, return only the objects tracked by the\ncollector that are in that generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_referents()", "path": "library/gc#gc.get_referents", "type": "Runtime", "text": "\nReturn a list of objects directly referred to by any of the arguments. The\nreferents returned are those objects visited by the arguments\u2019 C-level\n`tp_traverse` methods (if any), and may not be all objects actually directly\nreachable. `tp_traverse` methods are supported only by objects that support\ngarbage collection, and are only required to visit objects that may be\ninvolved in a cycle. So, for example, if an integer is directly reachable from\nan argument, that integer object may or may not appear in the result list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_referrers()", "path": "library/gc#gc.get_referrers", "type": "Runtime", "text": "\nReturn the list of objects that directly refer to any of objs. This function\nwill only locate those containers which support garbage collection; extension\ntypes which do refer to other objects but do not support garbage collection\nwill not be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_stats()", "path": "library/gc#gc.get_stats", "type": "Runtime", "text": "\nReturn a list of three per-generation dictionaries containing collection\nstatistics since interpreter start. The number of keys may change in the\nfuture, but currently each dictionary will contain the following items:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_threshold()", "path": "library/gc#gc.get_threshold", "type": "Runtime", "text": "\nReturn the current collection thresholds as a tuple of `(threshold0,\nthreshold1, threshold2)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.isenabled()", "path": "library/gc#gc.isenabled", "type": "Runtime", "text": "\nReturn `True` if automatic collection is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.is_finalized()", "path": "library/gc#gc.is_finalized", "type": "Runtime", "text": "\nReturns `True` if the given object has been finalized by the garbage\ncollector, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.is_tracked()", "path": "library/gc#gc.is_tracked", "type": "Runtime", "text": "\nReturns `True` if the object is currently tracked by the garbage collector,\n`False` otherwise. As a general rule, instances of atomic types aren\u2019t tracked\nand instances of non-atomic types (containers, user-defined objects\u2026) are.\nHowever, some type-specific optimizations can be present in order to suppress\nthe garbage collector footprint of simple instances (e.g. dicts containing\nonly atomic keys and values):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.set_debug()", "path": "library/gc#gc.set_debug", "type": "Runtime", "text": "\nSet the garbage collection debugging flags. Debugging information will be\nwritten to `sys.stderr`. See below for a list of debugging flags which can be\ncombined using bit operations to control debugging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.set_threshold()", "path": "library/gc#gc.set_threshold", "type": "Runtime", "text": "\nSet the garbage collection thresholds (the collection frequency). Setting\nthreshold0 to zero disables collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.unfreeze()", "path": "library/gc#gc.unfreeze", "type": "Runtime", "text": "\nUnfreeze the objects in the permanent generation, put them back into the\noldest generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "GeneratorExit", "path": "library/exceptions#GeneratorExit", "type": "Built-in Exceptions", "text": "\nRaised when a generator or coroutine is closed; see `generator.close()` and\n`coroutine.close()`. It directly inherits from `BaseException` instead of\n`Exception` since it is technically not an error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "genericalias.__args__", "path": "library/stdtypes#genericalias.__args__", "type": "Built-in Types", "text": "\nThis attribute is a `tuple` (possibly of length 1) of generic types passed to\nthe original `__class_getitem__()` of the generic container:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "genericalias.__origin__", "path": "library/stdtypes#genericalias.__origin__", "type": "Built-in Types", "text": "\nThis attribute points at the non-parameterized generic class:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "genericalias.__parameters__", "path": "library/stdtypes#genericalias.__parameters__", "type": "Built-in Types", "text": "\nThis attribute is a lazily computed tuple (possibly empty) of unique type\nvariables found in `__args__`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getattr()", "path": "library/functions#getattr", "type": "Built-in Functions", "text": "\nReturn the value of the named attribute of object. name must be a string. If\nthe string is the name of one of the object\u2019s attributes, the result is the\nvalue of that attribute. For example, `getattr(x, 'foobar')` is equivalent to\n`x.foobar`. If the named attribute does not exist, default is returned if\nprovided, otherwise `AttributeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt", "path": "library/getopt", "type": "Operating System", "text": "\nSource code: Lib/getopt.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.error", "path": "library/getopt#getopt.error", "type": "Operating System", "text": "\nAlias for `GetoptError`; for backward compatibility.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.getopt()", "path": "library/getopt#getopt.getopt", "type": "Operating System", "text": "\nParses command line options and parameter list. args is the argument list to\nbe parsed, without the leading reference to the running program. Typically,\nthis means `sys.argv[1:]`. shortopts is the string of option letters that the\nscript wants to recognize, with options that require an argument followed by a\ncolon (`':'`; i.e., the same format that Unix `getopt()` uses).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.GetoptError", "path": "library/getopt#getopt.GetoptError", "type": "Operating System", "text": "\nThis is raised when an unrecognized option is found in the argument list or\nwhen an option requiring an argument is given none. The argument to the\nexception is a string indicating the cause of the error. For long options, an\nargument given to an option which does not require one will also cause this\nexception to be raised. The attributes `msg` and `opt` give the error message\nand related option; if there is no specific option to which the exception\nrelates, `opt` is an empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.gnu_getopt()", "path": "library/getopt#getopt.gnu_getopt", "type": "Operating System", "text": "\nThis function works like `getopt()`, except that GNU style scanning mode is\nused by default. This means that option and non-option arguments may be\nintermixed. The `getopt()` function stops processing options as soon as a non-\noption argument is encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass", "path": "library/getpass", "type": "Operating System", "text": "\nSource code: Lib/getpass.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass.getpass()", "path": "library/getpass#getpass.getpass", "type": "Operating System", "text": "\nPrompt the user for a password without echoing. The user is prompted using the\nstring prompt, which defaults to `'Password: '`. On Unix, the prompt is\nwritten to the file-like object stream using the replace error handler if\nneeded. stream defaults to the controlling terminal (`/dev/tty`) or if that is\nunavailable to `sys.stderr` (this argument is ignored on Windows).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass.GetPassWarning", "path": "library/getpass#getpass.GetPassWarning", "type": "Operating System", "text": "\nA `UserWarning` subclass issued when password input may be echoed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass.getuser()", "path": "library/getpass#getpass.getuser", "type": "Operating System", "text": "\nReturn the \u201clogin name\u201d of the user.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext", "path": "library/gettext", "type": "Internationalization", "text": "\nSource code: Lib/gettext.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.bindtextdomain()", "path": "library/gettext#gettext.bindtextdomain", "type": "Internationalization", "text": "\nBind the domain to the locale directory localedir. More concretely, `gettext`\nwill look for binary `.mo` files for the given domain using the path (on\nUnix): `localedir/language/LC_MESSAGES/domain.mo`, where language is searched\nfor in the environment variables `LANGUAGE`, `LC_ALL`, `LC_MESSAGES`, and\n`LANG` respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.bind_textdomain_codeset()", "path": "library/gettext#gettext.bind_textdomain_codeset", "type": "Internationalization", "text": "\nBind the domain to codeset, changing the encoding of byte strings returned by\nthe `lgettext()`, `ldgettext()`, `lngettext()` and `ldngettext()` functions.\nIf codeset is omitted, then the current binding is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dgettext()", "path": "library/gettext#gettext.dgettext", "type": "Internationalization", "text": "\nLike `gettext()`, but look the message up in the specified domain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dngettext()", "path": "library/gettext#gettext.dngettext", "type": "Internationalization", "text": "\nLike `ngettext()`, but look the message up in the specified domain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dnpgettext()", "path": "library/gettext#gettext.dnpgettext", "type": "Internationalization", "text": "\nSimilar to the corresponding functions without the `p` in the prefix (that is,\n`gettext()`, `dgettext()`, `ngettext()`, `dngettext()`), but the translation\nis restricted to the given message context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dpgettext()", "path": "library/gettext#gettext.dpgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.find()", "path": "library/gettext#gettext.find", "type": "Internationalization", "text": "\nThis function implements the standard `.mo` file search algorithm. It takes a\ndomain, identical to what `textdomain()` takes. Optional localedir is as in\n`bindtextdomain()`. Optional languages is a list of strings, where each string\nis a language code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.gettext()", "path": "library/gettext#gettext.gettext", "type": "Internationalization", "text": "\nReturn the localized translation of message, based on the current global\ndomain, language, and locale directory. This function is usually aliased as\n`_()` in the local namespace (see examples below).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations", "path": "library/gettext#gettext.GNUTranslations", "type": "Internationalization", "text": "\nThe following methods are overridden from the base class implementation:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.gettext()", "path": "library/gettext#gettext.GNUTranslations.gettext", "type": "Internationalization", "text": "\nLook up the message id in the catalog and return the corresponding message\nstring, as a Unicode string. If there is no entry in the catalog for the\nmessage id, and a fallback has been set, the look up is forwarded to the\nfallback\u2019s `gettext()` method. Otherwise, the message id is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.lgettext()", "path": "library/gettext#gettext.GNUTranslations.lgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.lngettext()", "path": "library/gettext#gettext.GNUTranslations.lngettext", "type": "Internationalization", "text": "\nEquivalent to `gettext()` and `ngettext()`, but the translation is returned as\na byte string encoded in the preferred system encoding if no encoding was\nexplicitly set with `set_output_charset()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.ngettext()", "path": "library/gettext#gettext.GNUTranslations.ngettext", "type": "Internationalization", "text": "\nDo a plural-forms lookup of a message id. singular is used as the message id\nfor purposes of lookup in the catalog, while n is used to determine which\nplural form to use. The returned message string is a Unicode string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.npgettext()", "path": "library/gettext#gettext.GNUTranslations.npgettext", "type": "Internationalization", "text": "\nDo a plural-forms lookup of a message id. singular is used as the message id\nfor purposes of lookup in the catalog, while n is used to determine which\nplural form to use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.pgettext()", "path": "library/gettext#gettext.GNUTranslations.pgettext", "type": "Internationalization", "text": "\nLook up the context and message id in the catalog and return the corresponding\nmessage string, as a Unicode string. If there is no entry in the catalog for\nthe message id and context, and a fallback has been set, the look up is\nforwarded to the fallback\u2019s `pgettext()` method. Otherwise, the message id is\nreturned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.install()", "path": "library/gettext#gettext.install", "type": "Internationalization", "text": "\nThis installs the function `_()` in Python\u2019s builtins namespace, based on\ndomain, localedir, and codeset which are passed to the function\n`translation()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.ldgettext()", "path": "library/gettext#gettext.ldgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.ldngettext()", "path": "library/gettext#gettext.ldngettext", "type": "Internationalization", "text": "\nEquivalent to the corresponding functions without the `l` prefix (`gettext()`,\n`dgettext()`, `ngettext()` and `dngettext()`), but the translation is returned\nas a byte string encoded in the preferred system encoding if no other encoding\nwas explicitly set with `bind_textdomain_codeset()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.lgettext()", "path": "library/gettext#gettext.lgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.lngettext()", "path": "library/gettext#gettext.lngettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.ngettext()", "path": "library/gettext#gettext.ngettext", "type": "Internationalization", "text": "\nLike `gettext()`, but consider plural forms. If a translation is found, apply\nthe plural formula to n, and return the resulting message (some languages have\nmore than two plural forms). If no translation is found, return singular if n\nis 1; return plural otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.npgettext()", "path": "library/gettext#gettext.npgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations", "path": "library/gettext#gettext.NullTranslations", "type": "Internationalization", "text": "\nTakes an optional file object fp, which is ignored by the base class.\nInitializes \u201cprotected\u201d instance variables _info and _charset which are set by\nderived classes, as well as _fallback, which is set through `add_fallback()`.\nIt then calls `self._parse(fp)` if fp is not `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.add_fallback()", "path": "library/gettext#gettext.NullTranslations.add_fallback", "type": "Internationalization", "text": "\nAdd fallback as the fallback object for the current translation object. A\ntranslation object should consult the fallback if it cannot provide a\ntranslation for a given message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.charset()", "path": "library/gettext#gettext.NullTranslations.charset", "type": "Internationalization", "text": "\nReturn the encoding of the message catalog file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.gettext()", "path": "library/gettext#gettext.NullTranslations.gettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `gettext()` to the fallback. Otherwise,\nreturn message. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.info()", "path": "library/gettext#gettext.NullTranslations.info", "type": "Internationalization", "text": "\nReturn the \u201cprotected\u201d `_info` variable, a dictionary containing the metadata\nfound in the message catalog file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.install()", "path": "library/gettext#gettext.NullTranslations.install", "type": "Internationalization", "text": "\nThis method installs `gettext()` into the built-in namespace, binding it to\n`_`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.lgettext()", "path": "library/gettext#gettext.NullTranslations.lgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.lngettext()", "path": "library/gettext#gettext.NullTranslations.lngettext", "type": "Internationalization", "text": "\nEquivalent to `gettext()` and `ngettext()`, but the translation is returned as\na byte string encoded in the preferred system encoding if no encoding was\nexplicitly set with `set_output_charset()`. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.ngettext()", "path": "library/gettext#gettext.NullTranslations.ngettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `ngettext()` to the fallback. Otherwise,\nreturn singular if n is 1; return plural otherwise. Overridden in derived\nclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.npgettext()", "path": "library/gettext#gettext.NullTranslations.npgettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `npgettext()` to the fallback. Otherwise,\nreturn the translated message. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.output_charset()", "path": "library/gettext#gettext.NullTranslations.output_charset", "type": "Internationalization", "text": "\nReturn the encoding used to return translated messages in `lgettext()` and\n`lngettext()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.pgettext()", "path": "library/gettext#gettext.NullTranslations.pgettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `pgettext()` to the fallback. Otherwise,\nreturn the translated message. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.set_output_charset()", "path": "library/gettext#gettext.NullTranslations.set_output_charset", "type": "Internationalization", "text": "\nChange the encoding used to return translated messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations._parse()", "path": "library/gettext#gettext.NullTranslations._parse", "type": "Internationalization", "text": "\nNo-op in the base class, this method takes file object fp, and reads the data\nfrom the file, initializing its message catalog. If you have an unsupported\nmessage catalog file format, you should override this method to parse your\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.pgettext()", "path": "library/gettext#gettext.pgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.textdomain()", "path": "library/gettext#gettext.textdomain", "type": "Internationalization", "text": "\nChange or query the current global domain. If domain is `None`, then the\ncurrent global domain is returned, otherwise the global domain is set to\ndomain, which is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.translation()", "path": "library/gettext#gettext.translation", "type": "Internationalization", "text": "\nReturn a `*Translations` instance based on the domain, localedir, and\nlanguages, which are first passed to `find()` to get a list of the associated\n`.mo` file paths. Instances with identical `.mo` file names are cached. The\nactual class instantiated is class_ if provided, otherwise `GNUTranslations`.\nThe class\u2019s constructor must take a single file object argument. If provided,\ncodeset will change the charset used to encode translated strings in the\n`lgettext()` and `lngettext()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob", "path": "library/glob", "type": "File & Directory Access", "text": "\nSource code: Lib/glob.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob.escape()", "path": "library/glob#glob.escape", "type": "File & Directory Access", "text": "\nEscape all special characters (`'?'`, `'*'` and `'['`). This is useful if you\nwant to match an arbitrary literal string that may have special characters in\nit. Special characters in drive/UNC sharepoints are not escaped, e.g. on\nWindows `escape('//?/c:/Quo vadis?.txt')` returns `'//?/c:/Quo vadis[?].txt'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob.glob()", "path": "library/glob#glob.glob", "type": "File & Directory Access", "text": "\nReturn a possibly-empty list of path names that match pathname, which must be\na string containing a path specification. pathname can be either absolute\n(like `/usr/src/Python-1.5/Makefile`) or relative (like\n`../../Tools/*/*.gif`), and can contain shell-style wildcards. Broken symlinks\nare included in the results (as in the shell). Whether or not the results are\nsorted depends on the file system. If a file that satisfies conditions is\nremoved or added during the call of this function, whether a path name for\nthat file be included is unspecified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob.iglob()", "path": "library/glob#glob.iglob", "type": "File & Directory Access", "text": "\nReturn an iterator which yields the same values as `glob()` without actually\nstoring them all simultaneously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "globals()", "path": "library/functions#globals", "type": "Built-in Functions", "text": "\nReturn a dictionary representing the current global symbol table. This is\nalways the dictionary of the current module (inside a function or method, this\nis the module where it is defined, not the module from which it is called).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib", "path": "library/graphlib", "type": "Data Types", "text": "\nSource code: Lib/graphlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.CycleError", "path": "library/graphlib#graphlib.CycleError", "type": "Data Types", "text": "\nSubclass of `ValueError` raised by `TopologicalSorter.prepare()` if cycles\nexist in the working graph. If multiple cycles exist, only one undefined\nchoice among them will be reported and included in the exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter", "path": "library/graphlib#graphlib.TopologicalSorter", "type": "Data Types", "text": "\nProvides functionality to topologically sort a graph of hashable nodes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.add()", "path": "library/graphlib#graphlib.TopologicalSorter.add", "type": "Data Types", "text": "\nAdd a new node and its predecessors to the graph. Both the node and all\nelements in predecessors must be hashable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.done()", "path": "library/graphlib#graphlib.TopologicalSorter.done", "type": "Data Types", "text": "\nMarks a set of nodes returned by `TopologicalSorter.get_ready()` as processed,\nunblocking any successor of each node in nodes for being returned in the\nfuture by a call to `TopologicalSorter.get_ready()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.get_ready()", "path": "library/graphlib#graphlib.TopologicalSorter.get_ready", "type": "Data Types", "text": "\nReturns a `tuple` with all the nodes that are ready. Initially it returns all\nnodes with no predecessors, and once those are marked as processed by calling\n`TopologicalSorter.done()`, further calls will return all new nodes that have\nall their predecessors already processed. Once no more progress can be made,\nempty tuples are returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.is_active()", "path": "library/graphlib#graphlib.TopologicalSorter.is_active", "type": "Data Types", "text": "\nReturns `True` if more progress can be made and `False` otherwise. Progress\ncan be made if cycles do not block the resolution and either there are still\nnodes ready that haven\u2019t yet been returned by `TopologicalSorter.get_ready()`\nor the number of nodes marked `TopologicalSorter.done()` is less than the\nnumber that have been returned by `TopologicalSorter.get_ready()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.prepare()", "path": "library/graphlib#graphlib.TopologicalSorter.prepare", "type": "Data Types", "text": "\nMark the graph as finished and check for cycles in the graph. If any cycle is\ndetected, `CycleError` will be raised, but `get_ready()` can still be used to\nobtain as many nodes as possible until cycles block more progress. After a\ncall to this function, the graph cannot be modified, and therefore no more\nnodes can be added using `add()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.static_order()", "path": "library/graphlib#graphlib.TopologicalSorter.static_order", "type": "Data Types", "text": "\nReturns an iterable of nodes in a topological order. Using this method does\nnot require to call `TopologicalSorter.prepare()` or\n`TopologicalSorter.done()`. This method is equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp", "path": "library/grp", "type": "Unix", "text": "\nThis module provides access to the Unix group database. It is available on all\nUnix versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp.getgrall()", "path": "library/grp#grp.getgrall", "type": "Unix", "text": "\nReturn a list of all available group entries, in arbitrary order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp.getgrgid()", "path": "library/grp#grp.getgrgid", "type": "Unix", "text": "\nReturn the group database entry for the given numeric group ID. `KeyError` is\nraised if the entry asked for cannot be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp.getgrnam()", "path": "library/grp#grp.getgrnam", "type": "Unix", "text": "\nReturn the group database entry for the given group name. `KeyError` is raised\nif the entry asked for cannot be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip", "path": "library/gzip", "type": "Data Compression", "text": "\nSource code: Lib/gzip.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.BadGzipFile", "path": "library/gzip#gzip.BadGzipFile", "type": "Data Compression", "text": "\nAn exception raised for invalid gzip files. It inherits `OSError`. `EOFError`\nand `zlib.error` can also be raised for invalid gzip files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.compress()", "path": "library/gzip#gzip.compress", "type": "Data Compression", "text": "\nCompress the data, returning a `bytes` object containing the compressed data.\ncompresslevel and mtime have the same meaning as in the `GzipFile` constructor\nabove.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.decompress()", "path": "library/gzip#gzip.decompress", "type": "Data Compression", "text": "\nDecompress the data, returning a `bytes` object containing the uncompressed\ndata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.GzipFile", "path": "library/gzip#gzip.GzipFile", "type": "Data Compression", "text": "\nConstructor for the `GzipFile` class, which simulates most of the methods of a\nfile object, with the exception of the `truncate()` method. At least one of\nfileobj and filename must be given a non-trivial value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.GzipFile.mtime", "path": "library/gzip#gzip.GzipFile.mtime", "type": "Data Compression", "text": "\nWhen decompressing, the value of the last modification time field in the most\nrecently read header may be read from this attribute, as an integer. The\ninitial value before reading any headers is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.GzipFile.peek()", "path": "library/gzip#gzip.GzipFile.peek", "type": "Data Compression", "text": "\nRead n uncompressed bytes without advancing the file position. At most one\nsingle read on the compressed stream is done to satisfy the call. The number\nof bytes returned may be more or less than requested.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.open()", "path": "library/gzip#gzip.open", "type": "Data Compression", "text": "\nOpen a gzip-compressed file in binary or text mode, returning a file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hasattr()", "path": "library/functions#hasattr", "type": "Built-in Functions", "text": "\nThe arguments are an object and a string. The result is `True` if the string\nis the name of one of the object\u2019s attributes, `False` if not. (This is\nimplemented by calling `getattr(object, name)` and seeing whether it raises an\n`AttributeError` or not.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hash()", "path": "library/functions#hash", "type": "Built-in Functions", "text": "\nReturn the hash value of the object (if it has one). Hash values are integers.\nThey are used to quickly compare dictionary keys during a dictionary lookup.\nNumeric values that compare equal have the same hash value (even if they are\nof different types, as is the case for 1 and 1.0).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib", "path": "library/hashlib", "type": "Cryptography", "text": "\nSource code: Lib/hashlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.algorithms_available", "path": "library/hashlib#hashlib.algorithms_available", "type": "Cryptography", "text": "\nA set containing the names of the hash algorithms that are available in the\nrunning Python interpreter. These names will be recognized when passed to\n`new()`. `algorithms_guaranteed` will always be a subset. The same algorithm\nmay appear multiple times in this set under different names (thanks to\nOpenSSL).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.algorithms_guaranteed", "path": "library/hashlib#hashlib.algorithms_guaranteed", "type": "Cryptography", "text": "\nA set containing the names of the hash algorithms guaranteed to be supported\nby this module on all platforms. Note that \u2018md5\u2019 is in this list despite some\nupstream vendors offering an odd \u201cFIPS compliant\u201d Python build that excludes\nit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b()", "path": "library/hashlib#hashlib.blake2b", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.MAX_DIGEST_SIZE", "path": "library/hashlib#hashlib.blake2b.MAX_DIGEST_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.MAX_KEY_SIZE", "path": "library/hashlib#hashlib.blake2b.MAX_KEY_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.PERSON_SIZE", "path": "library/hashlib#hashlib.blake2b.PERSON_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.SALT_SIZE", "path": "library/hashlib#hashlib.blake2b.SALT_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s()", "path": "library/hashlib#hashlib.blake2s", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.MAX_DIGEST_SIZE", "path": "library/hashlib#hashlib.blake2s.MAX_DIGEST_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.MAX_KEY_SIZE", "path": "library/hashlib#hashlib.blake2s.MAX_KEY_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.PERSON_SIZE", "path": "library/hashlib#hashlib.blake2s.PERSON_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.SALT_SIZE", "path": "library/hashlib#hashlib.blake2s.SALT_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.block_size", "path": "library/hashlib#hashlib.hash.block_size", "type": "Cryptography", "text": "\nThe internal block size of the hash algorithm in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.copy()", "path": "library/hashlib#hashlib.hash.copy", "type": "Cryptography", "text": "\nReturn a copy (\u201cclone\u201d) of the hash object. This can be used to efficiently\ncompute the digests of data sharing a common initial substring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.digest()", "path": "library/hashlib#hashlib.hash.digest", "type": "Cryptography", "text": "\nReturn the digest of the data passed to the `update()` method so far. This is\na bytes object of size `digest_size` which may contain bytes in the whole\nrange from 0 to 255.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.digest_size", "path": "library/hashlib#hashlib.hash.digest_size", "type": "Cryptography", "text": "\nThe size of the resulting hash in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.hexdigest()", "path": "library/hashlib#hashlib.hash.hexdigest", "type": "Cryptography", "text": "\nLike `digest()` except the digest is returned as a string object of double\nlength, containing only hexadecimal digits. This may be used to exchange the\nvalue safely in email or other non-binary environments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.name", "path": "library/hashlib#hashlib.hash.name", "type": "Cryptography", "text": "\nThe canonical name of this hash, always lowercase and always suitable as a\nparameter to `new()` to create another hash of this type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.update()", "path": "library/hashlib#hashlib.hash.update", "type": "Cryptography", "text": "\nUpdate the hash object with the bytes-like object. Repeated calls are\nequivalent to a single call with the concatenation of all the arguments:\n`m.update(a); m.update(b)` is equivalent to `m.update(a+b)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.new()", "path": "library/hashlib#hashlib.new", "type": "Cryptography", "text": "\nIs a generic constructor that takes the string name of the desired algorithm\nas its first parameter. It also exists to allow access to the above listed\nhashes as well as any other algorithms that your OpenSSL library may offer.\nThe named constructors are much faster than `new()` and should be preferred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.pbkdf2_hmac()", "path": "library/hashlib#hashlib.pbkdf2_hmac", "type": "Cryptography", "text": "\nThe function provides PKCS#5 password-based key derivation function 2. It uses\nHMAC as pseudorandom function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.scrypt()", "path": "library/hashlib#hashlib.scrypt", "type": "Cryptography", "text": "\nThe function provides scrypt password-based key derivation function as defined\nin RFC 7914.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.shake.digest()", "path": "library/hashlib#hashlib.shake.digest", "type": "Cryptography", "text": "\nReturn the digest of the data passed to the `update()` method so far. This is\na bytes object of size length which may contain bytes in the whole range from\n0 to 255.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.shake.hexdigest()", "path": "library/hashlib#hashlib.shake.hexdigest", "type": "Cryptography", "text": "\nLike `digest()` except the digest is returned as a string object of double\nlength, containing only hexadecimal digits. This may be used to exchange the\nvalue safely in email or other non-binary environments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq", "path": "library/heapq", "type": "Data Types", "text": "\nSource code: Lib/heapq.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heapify()", "path": "library/heapq#heapq.heapify", "type": "Data Types", "text": "\nTransform list x into a heap, in-place, in linear time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heappop()", "path": "library/heapq#heapq.heappop", "type": "Data Types", "text": "\nPop and return the smallest item from the heap, maintaining the heap\ninvariant. If the heap is empty, `IndexError` is raised. To access the\nsmallest item without popping it, use `heap[0]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heappush()", "path": "library/heapq#heapq.heappush", "type": "Data Types", "text": "\nPush the value item onto the heap, maintaining the heap invariant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heappushpop()", "path": "library/heapq#heapq.heappushpop", "type": "Data Types", "text": "\nPush item on the heap, then pop and return the smallest item from the heap.\nThe combined action runs more efficiently than `heappush()` followed by a\nseparate call to `heappop()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heapreplace()", "path": "library/heapq#heapq.heapreplace", "type": "Data Types", "text": "\nPop and return the smallest item from the heap, and also push the new item.\nThe heap size doesn\u2019t change. If the heap is empty, `IndexError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.merge()", "path": "library/heapq#heapq.merge", "type": "Data Types", "text": "\nMerge multiple sorted inputs into a single sorted output (for example, merge\ntimestamped entries from multiple log files). Returns an iterator over the\nsorted values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.nlargest()", "path": "library/heapq#heapq.nlargest", "type": "Data Types", "text": "\nReturn a list with the n largest elements from the dataset defined by\niterable. key, if provided, specifies a function of one argument that is used\nto extract a comparison key from each element in iterable (for example,\n`key=str.lower`). Equivalent to: `sorted(iterable, key=key,\nreverse=True)[:n]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.nsmallest()", "path": "library/heapq#heapq.nsmallest", "type": "Data Types", "text": "\nReturn a list with the n smallest elements from the dataset defined by\niterable. key, if provided, specifies a function of one argument that is used\nto extract a comparison key from each element in iterable (for example,\n`key=str.lower`). Equivalent to: `sorted(iterable, key=key)[:n]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "help()", "path": "library/functions#help", "type": "Built-in Functions", "text": "\nInvoke the built-in help system. (This function is intended for interactive\nuse.) If no argument is given, the interactive help system starts on the\ninterpreter console. If the argument is a string, then the string is looked up\nas the name of a module, function, class, method, keyword, or documentation\ntopic, and a help page is printed on the console. If the argument is any other\nkind of object, a help page on the object is generated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hex()", "path": "library/functions#hex", "type": "Built-in Functions", "text": "\nConvert an integer number to a lowercase hexadecimal string prefixed with\n\u201c0x\u201d. If x is not a Python `int` object, it has to define an `__index__()`\nmethod that returns an integer. Some examples:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "High-level API Index", "path": "library/asyncio-api-index", "type": "Asynchronous I/O", "text": "\nThis page lists all high-level async/await enabled asyncio APIs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac", "path": "library/hmac", "type": "Cryptography", "text": "\nSource code: Lib/hmac.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.compare_digest()", "path": "library/hmac#hmac.compare_digest", "type": "Cryptography", "text": "\nReturn `a == b`. This function uses an approach designed to prevent timing\nanalysis by avoiding content-based short circuiting behaviour, making it\nappropriate for cryptography. a and b must both be of the same type: either\n`str` (ASCII only, as e.g. returned by `HMAC.hexdigest()`), or a bytes-like\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.digest()", "path": "library/hmac#hmac.digest", "type": "Cryptography", "text": "\nReturn digest of msg for given secret key and digest. The function is\nequivalent to `HMAC(key, msg, digest).digest()`, but uses an optimized C or\ninline implementation, which is faster for messages that fit into memory. The\nparameters key, msg, and digest have the same meaning as in `new()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.block_size", "path": "library/hmac#hmac.HMAC.block_size", "type": "Cryptography", "text": "\nThe internal block size of the hash algorithm in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.copy()", "path": "library/hmac#hmac.HMAC.copy", "type": "Cryptography", "text": "\nReturn a copy (\u201cclone\u201d) of the hmac object. This can be used to efficiently\ncompute the digests of strings that share a common initial substring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.digest()", "path": "library/hmac#hmac.HMAC.digest", "type": "Cryptography", "text": "\nReturn the digest of the bytes passed to the `update()` method so far. This\nbytes object will be the same length as the digest_size of the digest given to\nthe constructor. It may contain non-ASCII bytes, including NUL bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.digest_size", "path": "library/hmac#hmac.HMAC.digest_size", "type": "Cryptography", "text": "\nThe size of the resulting HMAC digest in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.hexdigest()", "path": "library/hmac#hmac.HMAC.hexdigest", "type": "Cryptography", "text": "\nLike `digest()` except the digest is returned as a string twice the length\ncontaining only hexadecimal digits. This may be used to exchange the value\nsafely in email or other non-binary environments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.name", "path": "library/hmac#hmac.HMAC.name", "type": "Cryptography", "text": "\nThe canonical name of this HMAC, always lowercase, e.g. `hmac-md5`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.update()", "path": "library/hmac#hmac.HMAC.update", "type": "Cryptography", "text": "\nUpdate the hmac object with msg. Repeated calls are equivalent to a single\ncall with the concatenation of all the arguments: `m.update(a); m.update(b)`\nis equivalent to `m.update(a + b)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.new()", "path": "library/hmac#hmac.new", "type": "Cryptography", "text": "\nReturn a new hmac object. key is a bytes or bytearray object giving the secret\nkey. If msg is present, the method call `update(msg)` is made. digestmod is\nthe digest name, digest constructor or module for the HMAC object to use. It\nmay be any name suitable to `hashlib.new()`. Despite its argument position, it\nis required.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html", "path": "library/html", "type": "Structured Markup", "text": "\nSource code: Lib/html/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities", "path": "library/html.entities", "type": "Structured Markup", "text": "\nSource code: Lib/html/entities.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.codepoint2name", "path": "library/html.entities#html.entities.codepoint2name", "type": "Structured Markup", "text": "\nA dictionary that maps Unicode code points to HTML entity names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.entitydefs", "path": "library/html.entities#html.entities.entitydefs", "type": "Structured Markup", "text": "\nA dictionary mapping XHTML 1.0 entity definitions to their replacement text in\nISO Latin-1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.html5", "path": "library/html.entities#html.entities.html5", "type": "Structured Markup", "text": "\nA dictionary that maps HTML5 named character references 1 to the equivalent\nUnicode character(s), e.g. `html5['gt;'] == '>'`. Note that the trailing\nsemicolon is included in the name (e.g. `'gt;'`), however some of the names\nare accepted by the standard even without the semicolon: in this case the name\nis present with and without the `';'`. See also `html.unescape()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.name2codepoint", "path": "library/html.entities#html.entities.name2codepoint", "type": "Structured Markup", "text": "\nA dictionary that maps HTML entity names to the Unicode code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.escape()", "path": "library/html#html.escape", "type": "Structured Markup", "text": "\nConvert the characters `&`, `<` and `>` in string s to HTML-safe sequences.\nUse this if you need to display text that might contain such characters in\nHTML. If the optional flag quote is true, the characters (`\"`) and (`'`) are\nalso translated; this helps for inclusion in an HTML attribute value delimited\nby quotes, as in `<a href=\"...\">`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser", "path": "library/html.parser", "type": "Structured Markup", "text": "\nSource code: Lib/html/parser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser", "path": "library/html.parser#html.parser.HTMLParser", "type": "Structured Markup", "text": "\nCreate a parser instance able to parse invalid markup.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.close()", "path": "library/html.parser#html.parser.HTMLParser.close", "type": "Structured Markup", "text": "\nForce processing of all buffered data as if it were followed by an end-of-file\nmark. This method may be redefined by a derived class to define additional\nprocessing at the end of the input, but the redefined version should always\ncall the `HTMLParser` base class method `close()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.feed()", "path": "library/html.parser#html.parser.HTMLParser.feed", "type": "Structured Markup", "text": "\nFeed some text to the parser. It is processed insofar as it consists of\ncomplete elements; incomplete data is buffered until more data is fed or\n`close()` is called. data must be `str`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.getpos()", "path": "library/html.parser#html.parser.HTMLParser.getpos", "type": "Structured Markup", "text": "\nReturn current line number and offset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.get_starttag_text()", "path": "library/html.parser#html.parser.HTMLParser.get_starttag_text", "type": "Structured Markup", "text": "\nReturn the text of the most recently opened start tag. This should not\nnormally be needed for structured processing, but may be useful in dealing\nwith HTML \u201cas deployed\u201d or for re-generating input with minimal changes\n(whitespace between attributes can be preserved, etc.).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_charref()", "path": "library/html.parser#html.parser.HTMLParser.handle_charref", "type": "Structured Markup", "text": "\nThis method is called to process decimal and hexadecimal numeric character\nreferences of the form `&#NNN;` and `&#xNNN;`. For example, the decimal\nequivalent for `&gt;` is `&#62;`, whereas the hexadecimal is `&#x3E;`; in this\ncase the method will receive `'62'` or `'x3E'`. This method is never called if\nconvert_charrefs is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_comment()", "path": "library/html.parser#html.parser.HTMLParser.handle_comment", "type": "Structured Markup", "text": "\nThis method is called when a comment is encountered (e.g. `<!--comment-->`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_data()", "path": "library/html.parser#html.parser.HTMLParser.handle_data", "type": "Structured Markup", "text": "\nThis method is called to process arbitrary data (e.g. text nodes and the\ncontent of `<script>...</script>` and `<style>...</style>`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_decl()", "path": "library/html.parser#html.parser.HTMLParser.handle_decl", "type": "Structured Markup", "text": "\nThis method is called to handle an HTML doctype declaration (e.g. `<!DOCTYPE\nhtml>`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_endtag()", "path": "library/html.parser#html.parser.HTMLParser.handle_endtag", "type": "Structured Markup", "text": "\nThis method is called to handle the end tag of an element (e.g. `</div>`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_entityref()", "path": "library/html.parser#html.parser.HTMLParser.handle_entityref", "type": "Structured Markup", "text": "\nThis method is called to process a named character reference of the form\n`&name;` (e.g. `&gt;`), where name is a general entity reference (e.g.\n`'gt'`). This method is never called if convert_charrefs is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_pi()", "path": "library/html.parser#html.parser.HTMLParser.handle_pi", "type": "Structured Markup", "text": "\nMethod called when a processing instruction is encountered. The data parameter\nwill contain the entire processing instruction. For example, for the\nprocessing instruction `<?proc color='red'>`, this method would be called as\n`handle_pi(\"proc color='red'\")`. It is intended to be overridden by a derived\nclass; the base class implementation does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_startendtag()", "path": "library/html.parser#html.parser.HTMLParser.handle_startendtag", "type": "Structured Markup", "text": "\nSimilar to `handle_starttag()`, but called when the parser encounters an\nXHTML-style empty tag (`<img ... />`). This method may be overridden by\nsubclasses which require this particular lexical information; the default\nimplementation simply calls `handle_starttag()` and `handle_endtag()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_starttag()", "path": "library/html.parser#html.parser.HTMLParser.handle_starttag", "type": "Structured Markup", "text": "\nThis method is called to handle the start of a tag (e.g. `<div id=\"main\">`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.reset()", "path": "library/html.parser#html.parser.HTMLParser.reset", "type": "Structured Markup", "text": "\nReset the instance. Loses all unprocessed data. This is called implicitly at\ninstantiation time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.unknown_decl()", "path": "library/html.parser#html.parser.HTMLParser.unknown_decl", "type": "Structured Markup", "text": "\nThis method is called when an unrecognized declaration is read by the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.unescape()", "path": "library/html#html.unescape", "type": "Structured Markup", "text": "\nConvert all named and numeric character references (e.g. `&gt;`, `&#62;`,\n`&#x3e;`) in the string s to the corresponding Unicode characters. This\nfunction uses the rules defined by the HTML 5 standard for both valid and\ninvalid character references, and the `list of HTML 5 named character\nreferences`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http", "path": "library/http", "type": "Internet", "text": "\nSource code: Lib/http/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client", "path": "library/http.client", "type": "Internet", "text": "\nSource code: Lib/http/client.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.BadStatusLine", "path": "library/http.client#http.client.BadStatusLine", "type": "Internet", "text": "\nA subclass of `HTTPException`. Raised if a server responds with a HTTP status\ncode that we don\u2019t understand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.CannotSendHeader", "path": "library/http.client#http.client.CannotSendHeader", "type": "Internet", "text": "\nA subclass of `ImproperConnectionState`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.CannotSendRequest", "path": "library/http.client#http.client.CannotSendRequest", "type": "Internet", "text": "\nA subclass of `ImproperConnectionState`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection", "path": "library/http.client#http.client.HTTPConnection", "type": "Internet", "text": "\nAn `HTTPConnection` instance represents one transaction with an HTTP server.\nIt should be instantiated passing it a host and optional port number. If no\nport number is passed, the port is extracted from the host string if it has\nthe form `host:port`, else the default HTTP port (80) is used. If the optional\ntimeout parameter is given, blocking operations (like connection attempts)\nwill timeout after that many seconds (if it is not given, the global default\ntimeout setting is used). The optional source_address parameter may be a tuple\nof a (host, port) to use as the source address the HTTP connection is made\nfrom. The optional blocksize parameter sets the buffer size in bytes for\nsending a file-like message body.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.blocksize", "path": "library/http.client#http.client.HTTPConnection.blocksize", "type": "Internet", "text": "\nBuffer size in bytes for sending a file-like message body.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.close()", "path": "library/http.client#http.client.HTTPConnection.close", "type": "Internet", "text": "\nClose the connection to the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.connect()", "path": "library/http.client#http.client.HTTPConnection.connect", "type": "Internet", "text": "\nConnect to the server specified when the object was created. By default, this\nis called automatically when making a request if the client does not already\nhave a connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.endheaders()", "path": "library/http.client#http.client.HTTPConnection.endheaders", "type": "Internet", "text": "\nSend a blank line to the server, signalling the end of the headers. The\noptional message_body argument can be used to pass a message body associated\nwith the request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.getresponse()", "path": "library/http.client#http.client.HTTPConnection.getresponse", "type": "Internet", "text": "\nShould be called after a request is sent to get the response from the server.\nReturns an `HTTPResponse` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.putheader()", "path": "library/http.client#http.client.HTTPConnection.putheader", "type": "Internet", "text": "\nSend an RFC 822-style header to the server. It sends a line to the server\nconsisting of the header, a colon and a space, and the first argument. If more\narguments are given, continuation lines are sent, each consisting of a tab and\nan argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.putrequest()", "path": "library/http.client#http.client.HTTPConnection.putrequest", "type": "Internet", "text": "\nThis should be the first call after the connection to the server has been\nmade. It sends a line to the server consisting of the method string, the url\nstring, and the HTTP version (`HTTP/1.1`). To disable automatic sending of\n`Host:` or `Accept-Encoding:` headers (for example to accept additional\ncontent encodings), specify skip_host or skip_accept_encoding with non-False\nvalues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.request()", "path": "library/http.client#http.client.HTTPConnection.request", "type": "Internet", "text": "\nThis will send a request to the server using the HTTP request method method\nand the selector url.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.send()", "path": "library/http.client#http.client.HTTPConnection.send", "type": "Internet", "text": "\nSend data to the server. This should be used directly only after the\n`endheaders()` method has been called and before `getresponse()` is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.set_debuglevel()", "path": "library/http.client#http.client.HTTPConnection.set_debuglevel", "type": "Internet", "text": "\nSet the debugging level. The default debug level is `0`, meaning no debugging\noutput is printed. Any value greater than `0` will cause all currently defined\ndebug output to be printed to stdout. The `debuglevel` is passed to any new\n`HTTPResponse` objects that are created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.set_tunnel()", "path": "library/http.client#http.client.HTTPConnection.set_tunnel", "type": "Internet", "text": "\nSet the host and the port for HTTP Connect Tunnelling. This allows running the\nconnection through a proxy server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPException", "path": "library/http.client#http.client.HTTPException", "type": "Internet", "text": "\nThe base class of the other exceptions in this module. It is a subclass of\n`Exception`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse", "path": "library/http.client#http.client.HTTPResponse", "type": "Internet", "text": "\nClass whose instances are returned upon successful connection. Not\ninstantiated directly by user.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.closed", "path": "library/http.client#http.client.HTTPResponse.closed", "type": "Internet", "text": "\nIs `True` if the stream is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.debuglevel", "path": "library/http.client#http.client.HTTPResponse.debuglevel", "type": "Internet", "text": "\nA debugging hook. If `debuglevel` is greater than zero, messages will be\nprinted to stdout as the response is read and parsed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.fileno()", "path": "library/http.client#http.client.HTTPResponse.fileno", "type": "Internet", "text": "\nReturn the `fileno` of the underlying socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.getheader()", "path": "library/http.client#http.client.HTTPResponse.getheader", "type": "Internet", "text": "\nReturn the value of the header name, or default if there is no header matching\nname. If there is more than one header with the name name, return all of the\nvalues joined by \u2018, \u2018. If \u2018default\u2019 is any iterable other than a single\nstring, its elements are similarly returned joined by commas.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.getheaders()", "path": "library/http.client#http.client.HTTPResponse.getheaders", "type": "Internet", "text": "\nReturn a list of (header, value) tuples.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.getstatus()", "path": "library/http.client#http.client.HTTPResponse.getstatus", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `status`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.geturl()", "path": "library/http.client#http.client.HTTPResponse.geturl", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `url`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.headers", "path": "library/http.client#http.client.HTTPResponse.headers", "type": "Internet", "text": "\nHeaders of the response in the form of an `email.message.EmailMessage`\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.info()", "path": "library/http.client#http.client.HTTPResponse.info", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `headers`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.msg", "path": "library/http.client#http.client.HTTPResponse.msg", "type": "Internet", "text": "\nA `http.client.HTTPMessage` instance containing the response headers.\n`http.client.HTTPMessage` is a subclass of `email.message.Message`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.read()", "path": "library/http.client#http.client.HTTPResponse.read", "type": "Internet", "text": "\nReads and returns the response body, or up to the next amt bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.readinto()", "path": "library/http.client#http.client.HTTPResponse.readinto", "type": "Internet", "text": "\nReads up to the next len(b) bytes of the response body into the buffer b.\nReturns the number of bytes read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.reason", "path": "library/http.client#http.client.HTTPResponse.reason", "type": "Internet", "text": "\nReason phrase returned by server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.status", "path": "library/http.client#http.client.HTTPResponse.status", "type": "Internet", "text": "\nStatus code returned by server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.url", "path": "library/http.client#http.client.HTTPResponse.url", "type": "Internet", "text": "\nURL of the resource retrieved, commonly used to determine if a redirect was\nfollowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.version", "path": "library/http.client#http.client.HTTPResponse.version", "type": "Internet", "text": "\nHTTP protocol version used by server. 10 for HTTP/1.0, 11 for HTTP/1.1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPSConnection", "path": "library/http.client#http.client.HTTPSConnection", "type": "Internet", "text": "\nA subclass of `HTTPConnection` that uses SSL for communication with secure\nservers. Default port is `443`. If context is specified, it must be a\n`ssl.SSLContext` instance describing the various SSL options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPS_PORT", "path": "library/http.client#http.client.HTTPS_PORT", "type": "Internet", "text": "\nThe default port for the HTTPS protocol (always `443`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTP_PORT", "path": "library/http.client#http.client.HTTP_PORT", "type": "Internet", "text": "\nThe default port for the HTTP protocol (always `80`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.ImproperConnectionState", "path": "library/http.client#http.client.ImproperConnectionState", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.IncompleteRead", "path": "library/http.client#http.client.IncompleteRead", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.InvalidURL", "path": "library/http.client#http.client.InvalidURL", "type": "Internet", "text": "\nA subclass of `HTTPException`, raised if a port is given and is either non-\nnumeric or empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.LineTooLong", "path": "library/http.client#http.client.LineTooLong", "type": "Internet", "text": "\nA subclass of `HTTPException`. Raised if an excessively long line is received\nin the HTTP protocol from the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.NotConnected", "path": "library/http.client#http.client.NotConnected", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.parse_headers()", "path": "library/http.client#http.client.parse_headers", "type": "Internet", "text": "\nParse the headers from a file pointer fp representing a HTTP request/response.\nThe file has to be a `BufferedIOBase` reader (i.e. not text) and must provide\na valid RFC 2822 style header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.RemoteDisconnected", "path": "library/http.client#http.client.RemoteDisconnected", "type": "Internet", "text": "\nA subclass of `ConnectionResetError` and `BadStatusLine`. Raised by\n`HTTPConnection.getresponse()` when the attempt to read the response results\nin no data read from the connection, indicating that the remote end has closed\nthe connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.ResponseNotReady", "path": "library/http.client#http.client.ResponseNotReady", "type": "Internet", "text": "\nA subclass of `ImproperConnectionState`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.responses", "path": "library/http.client#http.client.responses", "type": "Internet", "text": "\nThis dictionary maps the HTTP 1.1 status codes to the W3C names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.UnimplementedFileMode", "path": "library/http.client#http.client.UnimplementedFileMode", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.UnknownProtocol", "path": "library/http.client#http.client.UnknownProtocol", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.UnknownTransferEncoding", "path": "library/http.client#http.client.UnknownTransferEncoding", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar", "path": "library/http.cookiejar", "type": "Internet", "text": "\nSource code: Lib/http/cookiejar.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie", "path": "library/http.cookiejar#http.cookiejar.Cookie", "type": "Internet", "text": "\nThis class represents Netscape, RFC 2109 and RFC 2965 cookies. It is not\nexpected that users of `http.cookiejar` construct their own `Cookie`\ninstances. Instead, if necessary, call `make_cookies()` on a `CookieJar`\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.comment", "path": "library/http.cookiejar#http.cookiejar.Cookie.comment", "type": "Internet", "text": "\nString comment from the server explaining the function of this cookie, or\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.comment_url", "path": "library/http.cookiejar#http.cookiejar.Cookie.comment_url", "type": "Internet", "text": "\nURL linking to a comment from the server explaining the function of this\ncookie, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.discard", "path": "library/http.cookiejar#http.cookiejar.Cookie.discard", "type": "Internet", "text": "\n`True` if this is a session cookie.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.domain_initial_dot", "path": "library/http.cookiejar#http.cookiejar.Cookie.domain_initial_dot", "type": "Internet", "text": "\n`True` if the domain explicitly specified by the server began with a dot\n(`'.'`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.domain_specified", "path": "library/http.cookiejar#http.cookiejar.Cookie.domain_specified", "type": "Internet", "text": "\n`True` if a domain was explicitly specified by the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.expires", "path": "library/http.cookiejar#http.cookiejar.Cookie.expires", "type": "Internet", "text": "\nInteger expiry date in seconds since epoch, or `None`. See also the\n`is_expired()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.get_nonstandard_attr()", "path": "library/http.cookiejar#http.cookiejar.Cookie.get_nonstandard_attr", "type": "Internet", "text": "\nIf cookie has the named cookie-attribute, return its value. Otherwise, return\ndefault.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.has_nonstandard_attr()", "path": "library/http.cookiejar#http.cookiejar.Cookie.has_nonstandard_attr", "type": "Internet", "text": "\nReturn `True` if cookie has the named cookie-attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.is_expired()", "path": "library/http.cookiejar#http.cookiejar.Cookie.is_expired", "type": "Internet", "text": "\n`True` if cookie has passed the time at which the server requested it should\nexpire. If now is given (in seconds since the epoch), return whether the\ncookie has expired at the specified time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.name", "path": "library/http.cookiejar#http.cookiejar.Cookie.name", "type": "Internet", "text": "\nCookie name (a string).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.path", "path": "library/http.cookiejar#http.cookiejar.Cookie.path", "type": "Internet", "text": "\nCookie path (a string, eg. `'/acme/rocket_launchers'`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.port", "path": "library/http.cookiejar#http.cookiejar.Cookie.port", "type": "Internet", "text": "\nString representing a port or a set of ports (eg. \u201880\u2019, or \u201880,8080\u2019), or\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.port_specified", "path": "library/http.cookiejar#http.cookiejar.Cookie.port_specified", "type": "Internet", "text": "\n`True` if a port or set of ports was explicitly specified by the server (in\nthe Set-Cookie / Set-Cookie2 header).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.rfc2109", "path": "library/http.cookiejar#http.cookiejar.Cookie.rfc2109", "type": "Internet", "text": "\n`True` if this cookie was received as an RFC 2109 cookie (ie. the cookie\narrived in a Set-Cookie header, and the value of the Version cookie-attribute\nin that header was 1). This attribute is provided because `http.cookiejar` may\n\u2018downgrade\u2019 RFC 2109 cookies to Netscape cookies, in which case `version` is\n0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.secure", "path": "library/http.cookiejar#http.cookiejar.Cookie.secure", "type": "Internet", "text": "\n`True` if cookie should only be returned over a secure connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.set_nonstandard_attr()", "path": "library/http.cookiejar#http.cookiejar.Cookie.set_nonstandard_attr", "type": "Internet", "text": "\nSet the value of the named cookie-attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.value", "path": "library/http.cookiejar#http.cookiejar.Cookie.value", "type": "Internet", "text": "\nCookie value (a string), or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.version", "path": "library/http.cookiejar#http.cookiejar.Cookie.version", "type": "Internet", "text": "\nInteger or `None`. Netscape cookies have `version` 0\\. RFC 2965 and RFC 2109\ncookies have a `version` cookie-attribute of 1. However, note that\n`http.cookiejar` may \u2018downgrade\u2019 RFC 2109 cookies to Netscape cookies, in\nwhich case `version` is 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar", "path": "library/http.cookiejar#http.cookiejar.CookieJar", "type": "Internet", "text": "\npolicy is an object implementing the `CookiePolicy` interface.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.add_cookie_header()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.add_cookie_header", "type": "Internet", "text": "\nAdd correct Cookie header to request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.clear()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.clear", "type": "Internet", "text": "\nClear some cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.clear_session_cookies()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.clear_session_cookies", "type": "Internet", "text": "\nDiscard all session cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.extract_cookies()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.extract_cookies", "type": "Internet", "text": "\nExtract cookies from HTTP response and store them in the `CookieJar`, where\nallowed by policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.make_cookies()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.make_cookies", "type": "Internet", "text": "\nReturn sequence of `Cookie` objects extracted from response object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.set_cookie()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.set_cookie", "type": "Internet", "text": "\nSet a `Cookie`, without checking with policy to see whether or not it should\nbe set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.set_cookie_if_ok()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.set_cookie_if_ok", "type": "Internet", "text": "\nSet a `Cookie` if policy says it\u2019s OK to do so.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.set_policy()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.set_policy", "type": "Internet", "text": "\nSet the `CookiePolicy` instance to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy", "type": "Internet", "text": "\nThis class is responsible for deciding whether each cookie should be accepted\nfrom / returned to the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.domain_return_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.domain_return_ok", "type": "Internet", "text": "\nReturn `False` if cookies should not be returned, given cookie domain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.hide_cookie2", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.hide_cookie2", "type": "Internet", "text": "\nDon\u2019t add Cookie2 header to requests (the presence of this header indicates to\nthe server that we understand RFC 2965 cookies).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.netscape", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.netscape", "type": "Internet", "text": "\nImplement Netscape protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.path_return_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.path_return_ok", "type": "Internet", "text": "\nReturn `False` if cookies should not be returned, given cookie path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.return_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.return_ok", "type": "Internet", "text": "\nReturn boolean value indicating whether cookie should be returned to server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.rfc2965", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.rfc2965", "type": "Internet", "text": "\nImplement RFC 2965 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.set_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.set_ok", "type": "Internet", "text": "\nReturn boolean value indicating whether cookie should be accepted from server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy", "type": "Internet", "text": "\nConstructor arguments should be passed as keyword arguments only.\nblocked_domains is a sequence of domain names that we never accept cookies\nfrom, nor return cookies to. allowed_domains if not `None`, this is a sequence\nof the only domains for which we accept and return cookies. secure_protocols\nis a sequence of protocols for which secure cookies can be added to. By\ndefault https and wss (secure websocket) are considered secure protocols. For\nall other arguments, see the documentation for `CookiePolicy` and\n`DefaultCookiePolicy` objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.allowed_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.allowed_domains", "type": "Internet", "text": "\nReturn `None`, or the sequence of allowed domains (as a tuple).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.blocked_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.blocked_domains", "type": "Internet", "text": "\nReturn the sequence of blocked domains (as a tuple).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainLiberal", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainLiberal", "type": "Internet", "text": "\nEquivalent to 0 (ie. all of the above Netscape domain strictness flags\nswitched off).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainRFC2965Match", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainRFC2965Match", "type": "Internet", "text": "\nWhen setting cookies, require a full RFC 2965 domain-match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainStrict", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrict", "type": "Internet", "text": "\nEquivalent to `DomainStrictNoDots|DomainStrictNonDomain`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainStrictNoDots", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrictNoDots", "type": "Internet", "text": "\nWhen setting cookies, the \u2018host prefix\u2019 must not contain a dot (eg.\n`www.foo.bar.com` can\u2019t set a cookie for `.bar.com`, because `www.foo`\ncontains a dot).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainStrictNonDomain", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrictNonDomain", "type": "Internet", "text": "\nCookies that did not explicitly specify a `domain` cookie-attribute can only\nbe returned to a domain equal to the domain that set the cookie (eg.\n`spam.example.com` won\u2019t be returned cookies from `example.com` that had no\n`domain` cookie-attribute).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.is_blocked()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.is_blocked", "type": "Internet", "text": "\nReturn whether domain is on the blacklist for setting or receiving cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.is_not_allowed()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.is_not_allowed", "type": "Internet", "text": "\nReturn whether domain is not on the whitelist for setting or receiving\ncookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.rfc2109_as_netscape", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.rfc2109_as_netscape", "type": "Internet", "text": "\nIf true, request that the `CookieJar` instance downgrade RFC 2109 cookies (ie.\ncookies received in a Set-Cookie header with a version cookie-attribute of 1)\nto Netscape cookies by setting the version attribute of the `Cookie` instance\nto 0. The default value is `None`, in which case RFC 2109 cookies are\ndowngraded if and only if RFC 2965 handling is turned off. Therefore, RFC 2109\ncookies are downgraded by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.set_allowed_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.set_allowed_domains", "type": "Internet", "text": "\nSet the sequence of allowed domains, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.set_blocked_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.set_blocked_domains", "type": "Internet", "text": "\nSet the sequence of blocked domains.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_domain", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_domain", "type": "Internet", "text": "\nDon\u2019t allow sites to set two-component domains with country-code top-level\ndomains like `.co.uk`, `.gov.uk`, `.co.nz`.etc. This is far from perfect and\nisn\u2019t guaranteed to work!\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_domain", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_domain", "type": "Internet", "text": "\nFlags indicating how strict to be with domain-matching rules for Netscape\ncookies. See below for acceptable values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_set_initial_dollar", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_set_initial_dollar", "type": "Internet", "text": "\nIgnore cookies in Set-Cookie: headers that have names starting with `'$'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_set_path", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_set_path", "type": "Internet", "text": "\nDon\u2019t allow setting cookies whose path doesn\u2019t path-match request URI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_unverifiable", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_unverifiable", "type": "Internet", "text": "\nApply RFC 2965 rules on unverifiable transactions even to Netscape cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_rfc2965_unverifiable", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_rfc2965_unverifiable", "type": "Internet", "text": "\nFollow RFC 2965 rules on unverifiable transactions (usually, an unverifiable\ntransaction is one resulting from a redirect or a request for an image hosted\non another site). If this is false, cookies are never blocked on the basis of\nverifiability\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar", "type": "Internet", "text": "\npolicy is an object implementing the `CookiePolicy` interface. For the other\narguments, see the documentation for the corresponding attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.delayload", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.delayload", "type": "Internet", "text": "\nIf true, load cookies lazily from disk. This attribute should not be assigned\nto. This is only a hint, since this only affects performance, not behaviour\n(unless the cookies on disk are changing). A `CookieJar` object may ignore it.\nNone of the `FileCookieJar` classes included in the standard library lazily\nloads cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.filename", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.filename", "type": "Internet", "text": "\nFilename of default file in which to keep cookies. This attribute may be\nassigned to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.load()", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.load", "type": "Internet", "text": "\nLoad cookies from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.revert()", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.revert", "type": "Internet", "text": "\nClear all cookies and reload cookies from a saved file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.save()", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.save", "type": "Internet", "text": "\nSave cookies to a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.LoadError", "path": "library/http.cookiejar#http.cookiejar.LoadError", "type": "Internet", "text": "\nInstances of `FileCookieJar` raise this exception on failure to load cookies\nfrom a file. `LoadError` is a subclass of `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.LWPCookieJar", "path": "library/http.cookiejar#http.cookiejar.LWPCookieJar", "type": "Internet", "text": "\nA `FileCookieJar` that can load from and save cookies to disk in format\ncompatible with the libwww-perl library\u2019s `Set-Cookie3` file format. This is\nconvenient if you want to store cookies in a human-readable file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.MozillaCookieJar", "path": "library/http.cookiejar#http.cookiejar.MozillaCookieJar", "type": "Internet", "text": "\nA `FileCookieJar` that can load from and save cookies to disk in the Mozilla\n`cookies.txt` file format (which is also used by the Lynx and Netscape\nbrowsers).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies", "path": "library/http.cookies", "type": "Internet", "text": "\nSource code: Lib/http/cookies.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie", "path": "library/http.cookies#http.cookies.BaseCookie", "type": "Internet", "text": "\nThis class is a dictionary-like object whose keys are strings and whose values\nare `Morsel` instances. Note that upon setting a key to a value, the value is\nfirst converted to a `Morsel` containing the key and the value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.js_output()", "path": "library/http.cookies#http.cookies.BaseCookie.js_output", "type": "Internet", "text": "\nReturn an embeddable JavaScript snippet, which, if run on a browser which\nsupports JavaScript, will act the same as if the HTTP headers was sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.load()", "path": "library/http.cookies#http.cookies.BaseCookie.load", "type": "Internet", "text": "\nIf rawdata is a string, parse it as an `HTTP_COOKIE` and add the values found\nthere as `Morsel`s. If it is a dictionary, it is equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.output()", "path": "library/http.cookies#http.cookies.BaseCookie.output", "type": "Internet", "text": "\nReturn a string representation suitable to be sent as HTTP headers. attrs and\nheader are sent to each `Morsel`\u2019s `output()` method. sep is used to join the\nheaders together, and is by default the combination `'\\r\\n'` (CRLF).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.value_decode()", "path": "library/http.cookies#http.cookies.BaseCookie.value_decode", "type": "Internet", "text": "\nReturn a tuple `(real_value, coded_value)` from a string representation.\n`real_value` can be any type. This method does no decoding in `BaseCookie` \u2014\nit exists so it can be overridden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.value_encode()", "path": "library/http.cookies#http.cookies.BaseCookie.value_encode", "type": "Internet", "text": "\nReturn a tuple `(real_value, coded_value)`. val can be any type, but\n`coded_value` will always be converted to a string. This method does no\nencoding in `BaseCookie` \u2014 it exists so it can be overridden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.CookieError", "path": "library/http.cookies#http.cookies.CookieError", "type": "Internet", "text": "\nException failing because of RFC 2109 invalidity: incorrect attributes,\nincorrect Set-Cookie header, etc.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel", "path": "library/http.cookies#http.cookies.Morsel", "type": "Internet", "text": "\nAbstract a key/value pair, which has some RFC 2109 attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.coded_value", "path": "library/http.cookies#http.cookies.Morsel.coded_value", "type": "Internet", "text": "\nThe encoded value of the cookie \u2014 this is what should be sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.copy()", "path": "library/http.cookies#http.cookies.Morsel.copy", "type": "Internet", "text": "\nReturn a shallow copy of the Morsel object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.isReservedKey()", "path": "library/http.cookies#http.cookies.Morsel.isReservedKey", "type": "Internet", "text": "\nWhether K is a member of the set of keys of a `Morsel`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.js_output()", "path": "library/http.cookies#http.cookies.Morsel.js_output", "type": "Internet", "text": "\nReturn an embeddable JavaScript snippet, which, if run on a browser which\nsupports JavaScript, will act the same as if the HTTP header was sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.key", "path": "library/http.cookies#http.cookies.Morsel.key", "type": "Internet", "text": "\nThe name of the cookie.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.output()", "path": "library/http.cookies#http.cookies.Morsel.output", "type": "Internet", "text": "\nReturn a string representation of the Morsel, suitable to be sent as an HTTP\nheader. By default, all the attributes are included, unless attrs is given, in\nwhich case it should be a list of attributes to use. header is by default\n`\"Set-Cookie:\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.OutputString()", "path": "library/http.cookies#http.cookies.Morsel.OutputString", "type": "Internet", "text": "\nReturn a string representing the Morsel, without any surrounding HTTP or\nJavaScript.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.set()", "path": "library/http.cookies#http.cookies.Morsel.set", "type": "Internet", "text": "\nSet the key, value and coded_value attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.setdefault()", "path": "library/http.cookies#http.cookies.Morsel.setdefault", "type": "Internet", "text": "\nRaise an error if key is not a valid RFC 2109 attribute, otherwise behave the\nsame as `dict.setdefault()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.update()", "path": "library/http.cookies#http.cookies.Morsel.update", "type": "Internet", "text": "\nUpdate the values in the Morsel dictionary with the values in the dictionary\nvalues. Raise an error if any of the keys in the values dict is not a valid\nRFC 2109 attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.value", "path": "library/http.cookies#http.cookies.Morsel.value", "type": "Internet", "text": "\nThe value of the cookie.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.SimpleCookie", "path": "library/http.cookies#http.cookies.SimpleCookie", "type": "Internet", "text": "\nThis class derives from `BaseCookie` and overrides `value_decode()` and\n`value_encode()`. SimpleCookie supports strings as cookie values. When setting\nthe value, SimpleCookie calls the builtin `str()` to convert the value to a\nstring. Values received from HTTP are kept as strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.HTTPStatus", "path": "library/http#http.HTTPStatus", "type": "Internet", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server", "path": "library/http.server", "type": "Internet", "text": "\nSource code: Lib/http/server.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler", "path": "library/http.server#http.server.BaseHTTPRequestHandler", "type": "Internet", "text": "\nThis class is used to handle the HTTP requests that arrive at the server. By\nitself, it cannot respond to any actual HTTP requests; it must be subclassed\nto handle each request method (e.g. GET or POST). `BaseHTTPRequestHandler`\nprovides a number of class and instance variables, and methods for use by\nsubclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.address_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.address_string", "type": "Internet", "text": "\nReturns the client address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.client_address", "path": "library/http.server#http.server.BaseHTTPRequestHandler.client_address", "type": "Internet", "text": "\nContains a tuple of the form `(host, port)` referring to the client\u2019s address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.close_connection", "path": "library/http.server#http.server.BaseHTTPRequestHandler.close_connection", "type": "Internet", "text": "\nBoolean that should be set before `handle_one_request()` returns, indicating\nif another request may be expected, or if the connection should be shut down.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.command", "path": "library/http.server#http.server.BaseHTTPRequestHandler.command", "type": "Internet", "text": "\nContains the command (request type). For example, `'GET'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.date_time_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.date_time_string", "type": "Internet", "text": "\nReturns the date and time given by timestamp (which must be `None` or in the\nformat returned by `time.time()`), formatted for a message header. If\ntimestamp is omitted, it uses the current date and time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.end_headers()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.end_headers", "type": "Internet", "text": "\nAdds a blank line (indicating the end of the HTTP headers in the response) to\nthe headers buffer and calls `flush_headers()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.error_content_type", "path": "library/http.server#http.server.BaseHTTPRequestHandler.error_content_type", "type": "Internet", "text": "\nSpecifies the Content-Type HTTP header of error responses sent to the client.\nThe default value is `'text/html'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.error_message_format", "path": "library/http.server#http.server.BaseHTTPRequestHandler.error_message_format", "type": "Internet", "text": "\nSpecifies a format string that should be used by `send_error()` method for\nbuilding an error response to the client. The string is filled by default with\nvariables from `responses` based on the status code that passed to\n`send_error()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.flush_headers()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.flush_headers", "type": "Internet", "text": "\nFinally send the headers to the output stream and flush the internal headers\nbuffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.handle()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.handle", "type": "Internet", "text": "\nCalls `handle_one_request()` once (or, if persistent connections are enabled,\nmultiple times) to handle incoming HTTP requests. You should never need to\noverride it; instead, implement appropriate `do_*()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.handle_expect_100()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.handle_expect_100", "type": "Internet", "text": "\nWhen a HTTP/1.1 compliant server receives an `Expect: 100-continue` request\nheader it responds back with a `100 Continue` followed by `200 OK` headers.\nThis method can be overridden to raise an error if the server does not want\nthe client to continue. For e.g. server can chose to send `417 Expectation\nFailed` as a response header and `return False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.handle_one_request()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.handle_one_request", "type": "Internet", "text": "\nThis method will parse and dispatch the request to the appropriate `do_*()`\nmethod. You should never need to override it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.headers", "path": "library/http.server#http.server.BaseHTTPRequestHandler.headers", "type": "Internet", "text": "\nHolds an instance of the class specified by the `MessageClass` class variable.\nThis instance parses and manages the headers in the HTTP request. The\n`parse_headers()` function from `http.client` is used to parse the headers and\nit requires that the HTTP request provide a valid RFC 2822 style header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_date_time_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_date_time_string", "type": "Internet", "text": "\nReturns the current date and time, formatted for logging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_error()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_error", "type": "Internet", "text": "\nLogs an error when a request cannot be fulfilled. By default, it passes the\nmessage to `log_message()`, so it takes the same arguments (format and\nadditional values).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_message()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_message", "type": "Internet", "text": "\nLogs an arbitrary message to `sys.stderr`. This is typically overridden to\ncreate custom error logging mechanisms. The format argument is a standard\nprintf-style format string, where the additional arguments to `log_message()`\nare applied as inputs to the formatting. The client ip address and current\ndate and time are prefixed to every message logged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_request()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_request", "type": "Internet", "text": "\nLogs an accepted (successful) request. code should specify the numeric HTTP\ncode associated with the response. If a size of the response is available,\nthen it should be passed as the size parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.MessageClass", "path": "library/http.server#http.server.BaseHTTPRequestHandler.MessageClass", "type": "Internet", "text": "\nSpecifies an `email.message.Message`-like class to parse HTTP headers.\nTypically, this is not overridden, and it defaults to\n`http.client.HTTPMessage`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.path", "path": "library/http.server#http.server.BaseHTTPRequestHandler.path", "type": "Internet", "text": "\nContains the request path. If query component of the URL is present, then\n`path` includes the query. Using the terminology of RFC 3986, `path` here\nincludes `hier-part` and the `query`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.protocol_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.protocol_version", "type": "Internet", "text": "\nThis specifies the HTTP protocol version used in responses. If set to\n`'HTTP/1.1'`, the server will permit HTTP persistent connections; however,\nyour server must then include an accurate `Content-Length` header (using\n`send_header()`) in all of its responses to clients. For backwards\ncompatibility, the setting defaults to `'HTTP/1.0'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.requestline", "path": "library/http.server#http.server.BaseHTTPRequestHandler.requestline", "type": "Internet", "text": "\nContains the string representation of the HTTP request line. The terminating\nCRLF is stripped. This attribute should be set by `handle_one_request()`. If\nno valid request line was processed, it should be set to the empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.request_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.request_version", "type": "Internet", "text": "\nContains the version string from the request. For example, `'HTTP/1.0'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.responses", "path": "library/http.server#http.server.BaseHTTPRequestHandler.responses", "type": "Internet", "text": "\nThis attribute contains a mapping of error code integers to two-element tuples\ncontaining a short and long message. For example, `{code: (shortmessage,\nlongmessage)}`. The shortmessage is usually used as the message key in an\nerror response, and longmessage as the explain key. It is used by\n`send_response_only()` and `send_error()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.rfile", "path": "library/http.server#http.server.BaseHTTPRequestHandler.rfile", "type": "Internet", "text": "\nAn `io.BufferedIOBase` input stream, ready to read from the start of the\noptional input data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_error()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_error", "type": "Internet", "text": "\nSends and logs a complete error reply to the client. The numeric code\nspecifies the HTTP error code, with message as an optional, short, human\nreadable description of the error. The explain argument can be used to provide\nmore detailed information about the error; it will be formatted using the\n`error_message_format` attribute and emitted, after a complete set of headers,\nas the response body. The `responses` attribute holds the default values for\nmessage and explain that will be used if no value is provided; for unknown\ncodes the default value for both is the string `???`. The body will be empty\nif the method is HEAD or the response code is one of the following: `1xx`,\n`204 No Content`, `205 Reset Content`, `304 Not Modified`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_header()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_header", "type": "Internet", "text": "\nAdds the HTTP header to an internal buffer which will be written to the output\nstream when either `end_headers()` or `flush_headers()` is invoked. keyword\nshould specify the header keyword, with value specifying its value. Note that,\nafter the send_header calls are done, `end_headers()` MUST BE called in order\nto complete the operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_response()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_response", "type": "Internet", "text": "\nAdds a response header to the headers buffer and logs the accepted request.\nThe HTTP response line is written to the internal buffer, followed by Server\nand Date headers. The values for these two headers are picked up from the\n`version_string()` and `date_time_string()` methods, respectively. If the\nserver does not intend to send any other headers using the `send_header()`\nmethod, then `send_response()` should be followed by an `end_headers()` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_response_only()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_response_only", "type": "Internet", "text": "\nSends the response header only, used for the purposes when `100 Continue`\nresponse is sent by the server to the client. The headers not buffered and\nsent directly the output stream.If the message is not specified, the HTTP\nmessage corresponding the response code is sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.server", "path": "library/http.server#http.server.BaseHTTPRequestHandler.server", "type": "Internet", "text": "\nContains the server instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.server_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.server_version", "type": "Internet", "text": "\nSpecifies the server software version. You may want to override this. The\nformat is multiple whitespace-separated strings, where each string is of the\nform name[/version]. For example, `'BaseHTTP/0.2'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.sys_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.sys_version", "type": "Internet", "text": "\nContains the Python system version, in a form usable by the `version_string`\nmethod and the `server_version` class variable. For example, `'Python/1.4'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.version_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.version_string", "type": "Internet", "text": "\nReturns the server software\u2019s version string. This is a combination of the\n`server_version` and `sys_version` attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.wfile", "path": "library/http.server#http.server.BaseHTTPRequestHandler.wfile", "type": "Internet", "text": "\nContains the output stream for writing a response back to the client. Proper\nadherence to the HTTP protocol must be used when writing to this stream in\norder to achieve successful interoperation with HTTP clients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.CGIHTTPRequestHandler", "path": "library/http.server#http.server.CGIHTTPRequestHandler", "type": "Internet", "text": "\nThis class is used to serve either files or output of CGI scripts from the\ncurrent directory and below. Note that mapping HTTP hierarchic structure to\nlocal directory structure is exactly as in `SimpleHTTPRequestHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.CGIHTTPRequestHandler.cgi_directories", "path": "library/http.server#http.server.CGIHTTPRequestHandler.cgi_directories", "type": "Internet", "text": "\nThis defaults to `['/cgi-bin', '/htbin']` and describes directories to treat\nas containing CGI scripts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.CGIHTTPRequestHandler.do_POST()", "path": "library/http.server#http.server.CGIHTTPRequestHandler.do_POST", "type": "Internet", "text": "\nThis method serves the `'POST'` request type, only allowed for CGI scripts.\nError 501, \u201cCan only POST to CGI scripts\u201d, is output when trying to POST to a\nnon-CGI url.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.HTTPServer", "path": "library/http.server#http.server.HTTPServer", "type": "Internet", "text": "\nThis class builds on the `TCPServer` class by storing the server address as\ninstance variables named `server_name` and `server_port`. The server is\naccessible by the handler, typically through the handler\u2019s `server` instance\nvariable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler", "path": "library/http.server#http.server.SimpleHTTPRequestHandler", "type": "Internet", "text": "\nThis class serves files from the current directory and below, directly mapping\nthe directory structure to HTTP requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.directory", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.directory", "type": "Internet", "text": "\nIf not specified, the directory to serve is the current working directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.do_GET()", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.do_GET", "type": "Internet", "text": "\nThe request is mapped to a local file by interpreting the request as a path\nrelative to the current working directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.do_HEAD()", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.do_HEAD", "type": "Internet", "text": "\nThis method serves the `'HEAD'` request type: it sends the headers it would\nsend for the equivalent `GET` request. See the `do_GET()` method for a more\ncomplete explanation of the possible headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.extensions_map", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.extensions_map", "type": "Internet", "text": "\nA dictionary mapping suffixes into MIME types, contains custom overrides for\nthe default system mappings. The mapping is used case-insensitively, and so\nshould contain only lower-cased keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.server_version", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.server_version", "type": "Internet", "text": "\nThis will be `\"SimpleHTTP/\" + __version__`, where `__version__` is defined at\nthe module level.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.ThreadingHTTPServer", "path": "library/http.server#http.server.ThreadingHTTPServer", "type": "Internet", "text": "\nThis class is identical to HTTPServer but uses threads to handle requests by\nusing the `ThreadingMixIn`. This is useful to handle web browsers pre-opening\nsockets, on which `HTTPServer` would wait indefinitely.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "id()", "path": "library/functions#id", "type": "Built-in Functions", "text": "\nReturn the \u201cidentity\u201d of an object. This is an integer which is guaranteed to\nbe unique and constant for this object during its lifetime. Two objects with\nnon-overlapping lifetimes may have the same `id()` value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IDLE", "path": "library/idle", "type": "Tk", "text": "\nSource code: Lib/idlelib/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib", "path": "library/imaplib", "type": "Internet", "text": "\nSource code: Lib/imaplib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4", "path": "library/imaplib#imaplib.IMAP4", "type": "Internet", "text": "\nThis class implements the actual IMAP4 protocol. The connection is created and\nprotocol version (IMAP4 or IMAP4rev1) is determined when the instance is\ninitialized. If host is not specified, `''` (the local host) is used. If port\nis omitted, the standard IMAP4 port (143) is used. The optional timeout\nparameter specifies a timeout in seconds for the connection attempt. If\ntimeout is not given or is None, the global default socket timeout is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.abort", "path": "library/imaplib#imaplib.IMAP4.abort", "type": "Internet", "text": "\nIMAP4 server errors cause this exception to be raised. This is a sub-class of\n`IMAP4.error`. Note that closing the instance and instantiating a new one will\nusually allow recovery from this exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.append()", "path": "library/imaplib#imaplib.IMAP4.append", "type": "Internet", "text": "\nAppend message to named mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.authenticate()", "path": "library/imaplib#imaplib.IMAP4.authenticate", "type": "Internet", "text": "\nAuthenticate command \u2014 requires response processing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.check()", "path": "library/imaplib#imaplib.IMAP4.check", "type": "Internet", "text": "\nCheckpoint mailbox on server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.close()", "path": "library/imaplib#imaplib.IMAP4.close", "type": "Internet", "text": "\nClose currently selected mailbox. Deleted messages are removed from writable\nmailbox. This is the recommended command before `LOGOUT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.copy()", "path": "library/imaplib#imaplib.IMAP4.copy", "type": "Internet", "text": "\nCopy message_set messages onto end of new_mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.create()", "path": "library/imaplib#imaplib.IMAP4.create", "type": "Internet", "text": "\nCreate new mailbox named mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.debug", "path": "library/imaplib#imaplib.IMAP4.debug", "type": "Internet", "text": "\nInteger value to control debugging output. The initialize value is taken from\nthe module variable `Debug`. Values greater than three trace each command.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.delete()", "path": "library/imaplib#imaplib.IMAP4.delete", "type": "Internet", "text": "\nDelete old mailbox named mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.deleteacl()", "path": "library/imaplib#imaplib.IMAP4.deleteacl", "type": "Internet", "text": "\nDelete the ACLs (remove any rights) set for who on mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.enable()", "path": "library/imaplib#imaplib.IMAP4.enable", "type": "Internet", "text": "\nEnable capability (see RFC 5161). Most capabilities do not need to be enabled.\nCurrently only the `UTF8=ACCEPT` capability is supported (see RFC 6855).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.error", "path": "library/imaplib#imaplib.IMAP4.error", "type": "Internet", "text": "\nException raised on any errors. The reason for the exception is passed to the\nconstructor as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.expunge()", "path": "library/imaplib#imaplib.IMAP4.expunge", "type": "Internet", "text": "\nPermanently remove deleted items from selected mailbox. Generates an `EXPUNGE`\nresponse for each deleted message. Returned data contains a list of `EXPUNGE`\nmessage numbers in order received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.fetch()", "path": "library/imaplib#imaplib.IMAP4.fetch", "type": "Internet", "text": "\nFetch (parts of) messages. message_parts should be a string of message part\nnames enclosed within parentheses, eg: `\"(UID BODY[TEXT])\"`. Returned data are\ntuples of message part envelope and data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getacl()", "path": "library/imaplib#imaplib.IMAP4.getacl", "type": "Internet", "text": "\nGet the `ACL`s for mailbox. The method is non-standard, but is supported by\nthe `Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getannotation()", "path": "library/imaplib#imaplib.IMAP4.getannotation", "type": "Internet", "text": "\nRetrieve the specified `ANNOTATION`s for mailbox. The method is non-standard,\nbut is supported by the `Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getquota()", "path": "library/imaplib#imaplib.IMAP4.getquota", "type": "Internet", "text": "\nGet the `quota` root\u2019s resource usage and limits. This method is part of the\nIMAP4 QUOTA extension defined in rfc2087.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getquotaroot()", "path": "library/imaplib#imaplib.IMAP4.getquotaroot", "type": "Internet", "text": "\nGet the list of `quota` `roots` for the named mailbox. This method is part of\nthe IMAP4 QUOTA extension defined in rfc2087.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.list()", "path": "library/imaplib#imaplib.IMAP4.list", "type": "Internet", "text": "\nList mailbox names in directory matching pattern. directory defaults to the\ntop-level mail folder, and pattern defaults to match anything. Returned data\ncontains a list of `LIST` responses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.login()", "path": "library/imaplib#imaplib.IMAP4.login", "type": "Internet", "text": "\nIdentify the client using a plaintext password. The password will be quoted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.login_cram_md5()", "path": "library/imaplib#imaplib.IMAP4.login_cram_md5", "type": "Internet", "text": "\nForce use of `CRAM-MD5` authentication when identifying the client to protect\nthe password. Will only work if the server `CAPABILITY` response includes the\nphrase `AUTH=CRAM-MD5`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.logout()", "path": "library/imaplib#imaplib.IMAP4.logout", "type": "Internet", "text": "\nShutdown connection to server. Returns server `BYE` response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.lsub()", "path": "library/imaplib#imaplib.IMAP4.lsub", "type": "Internet", "text": "\nList subscribed mailbox names in directory matching pattern. directory\ndefaults to the top level directory and pattern defaults to match any mailbox.\nReturned data are tuples of message part envelope and data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.myrights()", "path": "library/imaplib#imaplib.IMAP4.myrights", "type": "Internet", "text": "\nShow my ACLs for a mailbox (i.e. the rights that I have on mailbox).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.namespace()", "path": "library/imaplib#imaplib.IMAP4.namespace", "type": "Internet", "text": "\nReturns IMAP namespaces as defined in RFC 2342.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.noop()", "path": "library/imaplib#imaplib.IMAP4.noop", "type": "Internet", "text": "\nSend `NOOP` to server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.open()", "path": "library/imaplib#imaplib.IMAP4.open", "type": "Internet", "text": "\nOpens socket to port at host. The optional timeout parameter specifies a\ntimeout in seconds for the connection attempt. If timeout is not given or is\nNone, the global default socket timeout is used. Also note that if the timeout\nparameter is set to be zero, it will raise a `ValueError` to reject creating a\nnon-blocking socket. This method is implicitly called by the `IMAP4`\nconstructor. The connection objects established by this method will be used in\nthe `IMAP4.read()`, `IMAP4.readline()`, `IMAP4.send()`, and `IMAP4.shutdown()`\nmethods. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.partial()", "path": "library/imaplib#imaplib.IMAP4.partial", "type": "Internet", "text": "\nFetch truncated part of a message. Returned data is a tuple of message part\nenvelope and data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.PROTOCOL_VERSION", "path": "library/imaplib#imaplib.IMAP4.PROTOCOL_VERSION", "type": "Internet", "text": "\nThe most recent supported protocol in the `CAPABILITY` response from the\nserver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.proxyauth()", "path": "library/imaplib#imaplib.IMAP4.proxyauth", "type": "Internet", "text": "\nAssume authentication as user. Allows an authorised administrator to proxy\ninto any user\u2019s mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.read()", "path": "library/imaplib#imaplib.IMAP4.read", "type": "Internet", "text": "\nReads size bytes from the remote server. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.readline()", "path": "library/imaplib#imaplib.IMAP4.readline", "type": "Internet", "text": "\nReads one line from the remote server. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.readonly", "path": "library/imaplib#imaplib.IMAP4.readonly", "type": "Internet", "text": "\nThis exception is raised when a writable mailbox has its status changed by the\nserver. This is a sub-class of `IMAP4.error`. Some other client now has write\npermission, and the mailbox will need to be re-opened to re-obtain write\npermission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.recent()", "path": "library/imaplib#imaplib.IMAP4.recent", "type": "Internet", "text": "\nPrompt server for an update. Returned data is `None` if no new messages, else\nvalue of `RECENT` response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.rename()", "path": "library/imaplib#imaplib.IMAP4.rename", "type": "Internet", "text": "\nRename mailbox named oldmailbox to newmailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.response()", "path": "library/imaplib#imaplib.IMAP4.response", "type": "Internet", "text": "\nReturn data for response code if received, or `None`. Returns the given code,\ninstead of the usual type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.search()", "path": "library/imaplib#imaplib.IMAP4.search", "type": "Internet", "text": "\nSearch mailbox for matching messages. charset may be `None`, in which case no\n`CHARSET` will be specified in the request to the server. The IMAP protocol\nrequires that at least one criterion be specified; an exception will be raised\nwhen the server returns an error. charset must be `None` if the `UTF8=ACCEPT`\ncapability was enabled using the `enable()` command.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.select()", "path": "library/imaplib#imaplib.IMAP4.select", "type": "Internet", "text": "\nSelect a mailbox. Returned data is the count of messages in mailbox (`EXISTS`\nresponse). The default mailbox is `'INBOX'`. If the readonly flag is set,\nmodifications to the mailbox are not allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.send()", "path": "library/imaplib#imaplib.IMAP4.send", "type": "Internet", "text": "\nSends `data` to the remote server. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.setacl()", "path": "library/imaplib#imaplib.IMAP4.setacl", "type": "Internet", "text": "\nSet an `ACL` for mailbox. The method is non-standard, but is supported by the\n`Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.setannotation()", "path": "library/imaplib#imaplib.IMAP4.setannotation", "type": "Internet", "text": "\nSet `ANNOTATION`s for mailbox. The method is non-standard, but is supported by\nthe `Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.setquota()", "path": "library/imaplib#imaplib.IMAP4.setquota", "type": "Internet", "text": "\nSet the `quota` root\u2019s resource limits. This method is part of the IMAP4 QUOTA\nextension defined in rfc2087.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.shutdown()", "path": "library/imaplib#imaplib.IMAP4.shutdown", "type": "Internet", "text": "\nClose connection established in `open`. This method is implicitly called by\n`IMAP4.logout()`. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.socket()", "path": "library/imaplib#imaplib.IMAP4.socket", "type": "Internet", "text": "\nReturns socket instance used to connect to server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.sort()", "path": "library/imaplib#imaplib.IMAP4.sort", "type": "Internet", "text": "\nThe `sort` command is a variant of `search` with sorting semantics for the\nresults. Returned data contains a space separated list of matching message\nnumbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.starttls()", "path": "library/imaplib#imaplib.IMAP4.starttls", "type": "Internet", "text": "\nSend a `STARTTLS` command. The ssl_context argument is optional and should be\na `ssl.SSLContext` object. This will enable encryption on the IMAP connection.\nPlease read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.status()", "path": "library/imaplib#imaplib.IMAP4.status", "type": "Internet", "text": "\nRequest named status conditions for mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.store()", "path": "library/imaplib#imaplib.IMAP4.store", "type": "Internet", "text": "\nAlters flag dispositions for messages in mailbox. command is specified by\nsection 6.4.6 of RFC 2060 as being one of \u201cFLAGS\u201d, \u201c+FLAGS\u201d, or \u201c-FLAGS\u201d,\noptionally with a suffix of \u201c.SILENT\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.subscribe()", "path": "library/imaplib#imaplib.IMAP4.subscribe", "type": "Internet", "text": "\nSubscribe to new mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.thread()", "path": "library/imaplib#imaplib.IMAP4.thread", "type": "Internet", "text": "\nThe `thread` command is a variant of `search` with threading semantics for the\nresults. Returned data contains a space separated list of thread members.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.uid()", "path": "library/imaplib#imaplib.IMAP4.uid", "type": "Internet", "text": "\nExecute command args with messages identified by UID, rather than message\nnumber. Returns response appropriate to command. At least one argument must be\nsupplied; if none are provided, the server will return an error and an\nexception will be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.unselect()", "path": "library/imaplib#imaplib.IMAP4.unselect", "type": "Internet", "text": "\n`imaplib.IMAP4.unselect()` frees server\u2019s resources associated with the\nselected mailbox and returns the server to the authenticated state. This\ncommand performs the same actions as `imaplib.IMAP4.close()`, except that no\nmessages are permanently removed from the currently selected mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.unsubscribe()", "path": "library/imaplib#imaplib.IMAP4.unsubscribe", "type": "Internet", "text": "\nUnsubscribe from old mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.utf8_enabled", "path": "library/imaplib#imaplib.IMAP4.utf8_enabled", "type": "Internet", "text": "\nBoolean value that is normally `False`, but is set to `True` if an `enable()`\ncommand is successfully issued for the `UTF8=ACCEPT` capability.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.xatom()", "path": "library/imaplib#imaplib.IMAP4.xatom", "type": "Internet", "text": "\nAllow simple extension commands notified by server in `CAPABILITY` response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4_SSL", "path": "library/imaplib#imaplib.IMAP4_SSL", "type": "Internet", "text": "\nThis is a subclass derived from `IMAP4` that connects over an SSL encrypted\nsocket (to use this class you need a socket module that was compiled with SSL\nsupport). If host is not specified, `''` (the local host) is used. If port is\nomitted, the standard IMAP4-over-SSL port (993) is used. ssl_context is a\n`ssl.SSLContext` object which allows bundling SSL configuration options,\ncertificates and private keys into a single (potentially long-lived)\nstructure. Please read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4_stream", "path": "library/imaplib#imaplib.IMAP4_stream", "type": "Internet", "text": "\nThis is a subclass derived from `IMAP4` that connects to the `stdin/stdout`\nfile descriptors created by passing command to `subprocess.Popen()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.Int2AP()", "path": "library/imaplib#imaplib.Int2AP", "type": "Internet", "text": "\nConverts an integer into a bytes representation using characters from the set\n[`A` .. `P`].\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.Internaldate2tuple()", "path": "library/imaplib#imaplib.Internaldate2tuple", "type": "Internet", "text": "\nParse an IMAP4 `INTERNALDATE` string and return corresponding local time. The\nreturn value is a `time.struct_time` tuple or `None` if the string has wrong\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.ParseFlags()", "path": "library/imaplib#imaplib.ParseFlags", "type": "Internet", "text": "\nConverts an IMAP4 `FLAGS` response to a tuple of individual flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.Time2Internaldate()", "path": "library/imaplib#imaplib.Time2Internaldate", "type": "Internet", "text": "\nConvert date_time to an IMAP4 `INTERNALDATE` representation. The return value\nis a string in the form: `\"DD-Mmm-YYYY HH:MM:SS +HHMM\"` (including double-\nquotes). The date_time argument can be a number (int or float) representing\nseconds since epoch (as returned by `time.time()`), a 9-tuple representing\nlocal time an instance of `time.struct_time` (as returned by\n`time.localtime()`), an aware instance of `datetime.datetime`, or a double-\nquoted string. In the last case, it is assumed to already be in the correct\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imghdr", "path": "library/imghdr", "type": "Multimedia", "text": "\nSource code: Lib/imghdr.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imghdr.tests", "path": "library/imghdr#imghdr.tests", "type": "Multimedia", "text": "\nA list of functions performing the individual tests. Each function takes two\narguments: the byte-stream and an open file-like object. When `what()` is\ncalled with a byte-stream, the file-like object will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imghdr.what()", "path": "library/imghdr#imghdr.what", "type": "Multimedia", "text": "\nTests the image data contained in the file named by filename, and returns a\nstring describing the image type. If optional h is provided, the filename is\nignored and h is assumed to contain the byte stream to test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImportError", "path": "library/exceptions#ImportError", "type": "Built-in Exceptions", "text": "\nRaised when the `import` statement has troubles trying to load a module. Also\nraised when the \u201cfrom list\u201d in `from ... import` has a name that cannot be\nfound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib", "path": "library/importlib", "type": "Importing", "text": "\nNew in version 3.1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ExecutionLoader", "path": "library/importlib#importlib.abc.ExecutionLoader", "type": "Importing", "text": "\nAn abstract base class which inherits from `InspectLoader` that, when\nimplemented, helps a module to be executed as a script. The ABC represents an\noptional PEP 302 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ExecutionLoader.get_filename()", "path": "library/importlib#importlib.abc.ExecutionLoader.get_filename", "type": "Importing", "text": "\nAn abstract method that is to return the value of `__file__` for the specified\nmodule. If no path is available, `ImportError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader", "path": "library/importlib#importlib.abc.FileLoader", "type": "Importing", "text": "\nAn abstract base class which inherits from `ResourceLoader` and\n`ExecutionLoader`, providing concrete implementations of\n`ResourceLoader.get_data()` and `ExecutionLoader.get_filename()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.get_data()", "path": "library/importlib#importlib.abc.FileLoader.get_data", "type": "Importing", "text": "\nReads path as a binary file and returns the bytes from it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.get_filename()", "path": "library/importlib#importlib.abc.FileLoader.get_filename", "type": "Importing", "text": "\nReturns `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.load_module()", "path": "library/importlib#importlib.abc.FileLoader.load_module", "type": "Importing", "text": "\nCalls super\u2019s `load_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.name", "path": "library/importlib#importlib.abc.FileLoader.name", "type": "Importing", "text": "\nThe name of the module the loader can handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.path", "path": "library/importlib#importlib.abc.FileLoader.path", "type": "Importing", "text": "\nPath to the file of the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Finder", "path": "library/importlib#importlib.abc.Finder", "type": "Importing", "text": "\nAn abstract base class representing a finder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Finder.find_module()", "path": "library/importlib#importlib.abc.Finder.find_module", "type": "Importing", "text": "\nAn abstract method for finding a loader for the specified module. Originally\nspecified in PEP 302, this method was meant for use in `sys.meta_path` and in\nthe path-based import subsystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader", "path": "library/importlib#importlib.abc.InspectLoader", "type": "Importing", "text": "\nAn abstract base class for a loader which implements the optional PEP 302\nprotocol for loaders that inspect modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.exec_module()", "path": "library/importlib#importlib.abc.InspectLoader.exec_module", "type": "Importing", "text": "\nImplementation of `Loader.exec_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.get_code()", "path": "library/importlib#importlib.abc.InspectLoader.get_code", "type": "Importing", "text": "\nReturn the code object for a module, or `None` if the module does not have a\ncode object (as would be the case, for example, for a built-in module). Raise\nan `ImportError` if loader cannot find the requested module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.get_source()", "path": "library/importlib#importlib.abc.InspectLoader.get_source", "type": "Importing", "text": "\nAn abstract method to return the source of a module. It is returned as a text\nstring using universal newlines, translating all recognized line separators\ninto `'\\n'` characters. Returns `None` if no source is available (e.g. a\nbuilt-in module). Raises `ImportError` if the loader cannot find the module\nspecified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.is_package()", "path": "library/importlib#importlib.abc.InspectLoader.is_package", "type": "Importing", "text": "\nAn abstract method to return a true value if the module is a package, a false\nvalue otherwise. `ImportError` is raised if the loader cannot find the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.load_module()", "path": "library/importlib#importlib.abc.InspectLoader.load_module", "type": "Importing", "text": "\nImplementation of `Loader.load_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.source_to_code()", "path": "library/importlib#importlib.abc.InspectLoader.source_to_code", "type": "Importing", "text": "\nCreate a code object from Python source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader", "path": "library/importlib#importlib.abc.Loader", "type": "Importing", "text": "\nAn abstract base class for a loader. See PEP 302 for the exact definition for\na loader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.create_module()", "path": "library/importlib#importlib.abc.Loader.create_module", "type": "Importing", "text": "\nA method that returns the module object to use when importing a module. This\nmethod may return `None`, indicating that default module creation semantics\nshould take place.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.exec_module()", "path": "library/importlib#importlib.abc.Loader.exec_module", "type": "Importing", "text": "\nAn abstract method that executes the module in its own namespace when a module\nis imported or reloaded. The module should already be initialized when\n`exec_module()` is called. When this method exists, `create_module()` must be\ndefined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.load_module()", "path": "library/importlib#importlib.abc.Loader.load_module", "type": "Importing", "text": "\nA legacy method for loading a module. If the module cannot be loaded,\n`ImportError` is raised, otherwise the loaded module is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.module_repr()", "path": "library/importlib#importlib.abc.Loader.module_repr", "type": "Importing", "text": "\nA legacy method which when implemented calculates and returns the given\nmodule\u2019s repr, as a string. The module type\u2019s default repr() will use the\nresult of this method as appropriate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder", "path": "library/importlib#importlib.abc.MetaPathFinder", "type": "Importing", "text": "\nAn abstract base class representing a meta path finder. For compatibility,\nthis is a subclass of `Finder`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder.find_module()", "path": "library/importlib#importlib.abc.MetaPathFinder.find_module", "type": "Importing", "text": "\nA legacy method for finding a loader for the specified module. If this is a\ntop-level import, path will be `None`. Otherwise, this is a search for a\nsubpackage or module and path will be the value of `__path__` from the parent\npackage. If a loader cannot be found, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder.find_spec()", "path": "library/importlib#importlib.abc.MetaPathFinder.find_spec", "type": "Importing", "text": "\nAn abstract method for finding a spec for the specified module. If this is a\ntop-level import, path will be `None`. Otherwise, this is a search for a\nsubpackage or module and path will be the value of `__path__` from the parent\npackage. If a spec cannot be found, `None` is returned. When passed in,\n`target` is a module object that the finder may use to make a more educated\nguess about what spec to return. `importlib.util.spec_from_loader()` may be\nuseful for implementing concrete `MetaPathFinders`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder.invalidate_caches()", "path": "library/importlib#importlib.abc.MetaPathFinder.invalidate_caches", "type": "Importing", "text": "\nAn optional method which, when called, should invalidate any internal cache\nused by the finder. Used by `importlib.invalidate_caches()` when invalidating\nthe caches of all finders on `sys.meta_path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder", "path": "library/importlib#importlib.abc.PathEntryFinder", "type": "Importing", "text": "\nAn abstract base class representing a path entry finder. Though it bears some\nsimilarities to `MetaPathFinder`, `PathEntryFinder` is meant for use only\nwithin the path-based import subsystem provided by `PathFinder`. This ABC is a\nsubclass of `Finder` for compatibility reasons only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.find_loader()", "path": "library/importlib#importlib.abc.PathEntryFinder.find_loader", "type": "Importing", "text": "\nA legacy method for finding a loader for the specified module. Returns a\n2-tuple of `(loader, portion)` where `portion` is a sequence of file system\nlocations contributing to part of a namespace package. The loader may be\n`None` while specifying `portion` to signify the contribution of the file\nsystem locations to a namespace package. An empty list can be used for\n`portion` to signify the loader is not part of a namespace package. If\n`loader` is `None` and `portion` is the empty list then no loader or location\nfor a namespace package were found (i.e. failure to find anything for the\nmodule).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.find_module()", "path": "library/importlib#importlib.abc.PathEntryFinder.find_module", "type": "Importing", "text": "\nA concrete implementation of `Finder.find_module()` which is equivalent to\n`self.find_loader(fullname)[0]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.find_spec()", "path": "library/importlib#importlib.abc.PathEntryFinder.find_spec", "type": "Importing", "text": "\nAn abstract method for finding a spec for the specified module. The finder\nwill search for the module only within the path entry to which it is assigned.\nIf a spec cannot be found, `None` is returned. When passed in, `target` is a\nmodule object that the finder may use to make a more educated guess about what\nspec to return. `importlib.util.spec_from_loader()` may be useful for\nimplementing concrete `PathEntryFinders`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.invalidate_caches()", "path": "library/importlib#importlib.abc.PathEntryFinder.invalidate_caches", "type": "Importing", "text": "\nAn optional method which, when called, should invalidate any internal cache\nused by the finder. Used by `PathFinder.invalidate_caches()` when invalidating\nthe caches of all cached finders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceLoader", "path": "library/importlib#importlib.abc.ResourceLoader", "type": "Importing", "text": "\nAn abstract base class for a loader which implements the optional PEP 302\nprotocol for loading arbitrary resources from the storage back-end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceLoader.get_data()", "path": "library/importlib#importlib.abc.ResourceLoader.get_data", "type": "Importing", "text": "\nAn abstract method to return the bytes for the data located at path. Loaders\nthat have a file-like storage back-end that allows storing arbitrary data can\nimplement this abstract method to give direct access to the data stored.\n`OSError` is to be raised if the path cannot be found. The path is expected to\nbe constructed using a module\u2019s `__file__` attribute or an item from a\npackage\u2019s `__path__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader", "path": "library/importlib#importlib.abc.ResourceReader", "type": "Importing", "text": "\nSuperseded by TraversableReader\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.contents()", "path": "library/importlib#importlib.abc.ResourceReader.contents", "type": "Importing", "text": "\nReturns an iterable of strings over the contents of the package. Do note that\nit is not required that all names returned by the iterator be actual\nresources, e.g. it is acceptable to return names for which `is_resource()`\nwould be false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.is_resource()", "path": "library/importlib#importlib.abc.ResourceReader.is_resource", "type": "Importing", "text": "\nReturns `True` if the named name is considered a resource. `FileNotFoundError`\nis raised if name does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.open_resource()", "path": "library/importlib#importlib.abc.ResourceReader.open_resource", "type": "Importing", "text": "\nReturns an opened, file-like object for binary reading of the resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.resource_path()", "path": "library/importlib#importlib.abc.ResourceReader.resource_path", "type": "Importing", "text": "\nReturns the file system path to the resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader", "path": "library/importlib#importlib.abc.SourceLoader", "type": "Importing", "text": "\nAn abstract base class for implementing source (and optionally bytecode) file\nloading. The class inherits from both `ResourceLoader` and `ExecutionLoader`,\nrequiring the implementation of:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.exec_module()", "path": "library/importlib#importlib.abc.SourceLoader.exec_module", "type": "Importing", "text": "\nConcrete implementation of `Loader.exec_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.get_code()", "path": "library/importlib#importlib.abc.SourceLoader.get_code", "type": "Importing", "text": "\nConcrete implementation of `InspectLoader.get_code()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.get_source()", "path": "library/importlib#importlib.abc.SourceLoader.get_source", "type": "Importing", "text": "\nConcrete implementation of `InspectLoader.get_source()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.is_package()", "path": "library/importlib#importlib.abc.SourceLoader.is_package", "type": "Importing", "text": "\nConcrete implementation of `InspectLoader.is_package()`. A module is\ndetermined to be a package if its file path (as provided by\n`ExecutionLoader.get_filename()`) is a file named `__init__` when the file\nextension is removed and the module name itself does not end in `__init__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.load_module()", "path": "library/importlib#importlib.abc.SourceLoader.load_module", "type": "Importing", "text": "\nConcrete implementation of `Loader.load_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.path_mtime()", "path": "library/importlib#importlib.abc.SourceLoader.path_mtime", "type": "Importing", "text": "\nOptional abstract method which returns the modification time for the specified\npath.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.path_stats()", "path": "library/importlib#importlib.abc.SourceLoader.path_stats", "type": "Importing", "text": "\nOptional abstract method which returns a `dict` containing metadata about the\nspecified path. Supported dictionary keys are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.set_data()", "path": "library/importlib#importlib.abc.SourceLoader.set_data", "type": "Importing", "text": "\nOptional abstract method which writes the specified bytes to a file path. Any\nintermediate directories which do not exist are to be created automatically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Traversable", "path": "library/importlib#importlib.abc.Traversable", "type": "Importing", "text": "\nAn object with a subset of pathlib.Path methods suitable for traversing\ndirectories and opening files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.TraversableReader", "path": "library/importlib#importlib.abc.TraversableReader", "type": "Importing", "text": "\nAn abstract base class for resource readers capable of serving the `files`\ninterface. Subclasses ResourceReader and provides concrete implementations of\nthe ResourceReader\u2019s abstract methods. Therefore, any loader supplying\nTraversableReader also supplies ResourceReader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.find_loader()", "path": "library/importlib#importlib.find_loader", "type": "Importing", "text": "\nFind the loader for a module, optionally within the specified path. If the\nmodule is in `sys.modules`, then `sys.modules[name].__loader__` is returned\n(unless the loader would be `None` or is not set, in which case `ValueError`\nis raised). Otherwise a search using `sys.meta_path` is done. `None` is\nreturned if no loader is found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.import_module()", "path": "library/importlib#importlib.import_module", "type": "Importing", "text": "\nImport a module. The name argument specifies what module to import in absolute\nor relative terms (e.g. either `pkg.mod` or `..mod`). If the name is specified\nin relative terms, then the package argument must be set to the name of the\npackage which is to act as the anchor for resolving the package name (e.g.\n`import_module('..mod', 'pkg.subpkg')` will import `pkg.mod`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.invalidate_caches()", "path": "library/importlib#importlib.invalidate_caches", "type": "Importing", "text": "\nInvalidate the internal caches of finders stored at `sys.meta_path`. If a\nfinder implements `invalidate_caches()` then it will be called to perform the\ninvalidation. This function should be called if any modules are\ncreated/installed while your program is running to guarantee all finders will\nnotice the new module\u2019s existence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.all_suffixes()", "path": "library/importlib#importlib.machinery.all_suffixes", "type": "Importing", "text": "\nReturns a combined list of strings representing all file suffixes for modules\nrecognized by the standard import machinery. This is a helper for code which\nsimply needs to know if a filesystem path potentially refers to a module\nwithout needing any details on the kind of module (for example,\n`inspect.getmodulename()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.BuiltinImporter", "path": "library/importlib#importlib.machinery.BuiltinImporter", "type": "Importing", "text": "\nAn importer for built-in modules. All known built-in modules are listed in\n`sys.builtin_module_names`. This class implements the\n`importlib.abc.MetaPathFinder` and `importlib.abc.InspectLoader` ABCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.BYTECODE_SUFFIXES", "path": "library/importlib#importlib.machinery.BYTECODE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the recognized file suffixes for bytecode\nmodules (including the leading dot).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.DEBUG_BYTECODE_SUFFIXES", "path": "library/importlib#importlib.machinery.DEBUG_BYTECODE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the file suffixes for non-optimized bytecode\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader", "path": "library/importlib#importlib.machinery.ExtensionFileLoader", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.ExecutionLoader` for extension\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.create_module()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.create_module", "type": "Importing", "text": "\nCreates the module object from the given specification in accordance with PEP\n489.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.exec_module()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.exec_module", "type": "Importing", "text": "\nInitializes the given module object in accordance with PEP 489.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.get_code()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.get_code", "type": "Importing", "text": "\nReturns `None` as extension modules lack a code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.get_filename()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.get_filename", "type": "Importing", "text": "\nReturns `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.get_source()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.get_source", "type": "Importing", "text": "\nReturns `None` as extension modules do not have source code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.is_package()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.is_package", "type": "Importing", "text": "\nReturns `True` if the file path points to a package\u2019s `__init__` module based\non `EXTENSION_SUFFIXES`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.name", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.name", "type": "Importing", "text": "\nName of the module the loader supports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.path", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.path", "type": "Importing", "text": "\nPath to the extension module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.EXTENSION_SUFFIXES", "path": "library/importlib#importlib.machinery.EXTENSION_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the recognized file suffixes for extension\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder", "path": "library/importlib#importlib.machinery.FileFinder", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.PathEntryFinder` which caches\nresults from the file system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.find_loader()", "path": "library/importlib#importlib.machinery.FileFinder.find_loader", "type": "Importing", "text": "\nAttempt to find the loader to handle fullname within `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.find_spec()", "path": "library/importlib#importlib.machinery.FileFinder.find_spec", "type": "Importing", "text": "\nAttempt to find the spec to handle fullname within `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.invalidate_caches()", "path": "library/importlib#importlib.machinery.FileFinder.invalidate_caches", "type": "Importing", "text": "\nClear out the internal cache.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.path", "path": "library/importlib#importlib.machinery.FileFinder.path", "type": "Importing", "text": "\nThe path the finder will search in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.path_hook()", "path": "library/importlib#importlib.machinery.FileFinder.path_hook", "type": "Importing", "text": "\nA class method which returns a closure for use on `sys.path_hooks`. An\ninstance of `FileFinder` is returned by the closure using the path argument\ngiven to the closure directly and loader_details indirectly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FrozenImporter", "path": "library/importlib#importlib.machinery.FrozenImporter", "type": "Importing", "text": "\nAn importer for frozen modules. This class implements the\n`importlib.abc.MetaPathFinder` and `importlib.abc.InspectLoader` ABCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec", "path": "library/importlib#importlib.machinery.ModuleSpec", "type": "Importing", "text": "\nA specification for a module\u2019s import-system-related state. This is typically\nexposed as the module\u2019s `__spec__` attribute. In the descriptions below, the\nnames in parentheses give the corresponding attribute available directly on\nthe module object. E.g. `module.__spec__.origin == module.__file__`. Note\nhowever that while the values are usually equivalent, they can differ since\nthere is no synchronization between the two objects. Thus it is possible to\nupdate the module\u2019s `__path__` at runtime, and this will not be automatically\nreflected in `__spec__.submodule_search_locations`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.cached", "path": "library/importlib#importlib.machinery.ModuleSpec.cached", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.has_location", "path": "library/importlib#importlib.machinery.ModuleSpec.has_location", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.loader", "path": "library/importlib#importlib.machinery.ModuleSpec.loader", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.loader_state", "path": "library/importlib#importlib.machinery.ModuleSpec.loader_state", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.name", "path": "library/importlib#importlib.machinery.ModuleSpec.name", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.origin", "path": "library/importlib#importlib.machinery.ModuleSpec.origin", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.parent", "path": "library/importlib#importlib.machinery.ModuleSpec.parent", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.submodule_search_locations", "path": "library/importlib#importlib.machinery.ModuleSpec.submodule_search_locations", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", "path": "library/importlib#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the file suffixes for optimized bytecode\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder", "path": "library/importlib#importlib.machinery.PathFinder", "type": "Importing", "text": "\nA Finder for `sys.path` and package `__path__` attributes. This class\nimplements the `importlib.abc.MetaPathFinder` ABC.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder.find_module()", "path": "library/importlib#importlib.machinery.PathFinder.find_module", "type": "Importing", "text": "\nA legacy wrapper around `find_spec()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder.find_spec()", "path": "library/importlib#importlib.machinery.PathFinder.find_spec", "type": "Importing", "text": "\nClass method that attempts to find a spec for the module specified by fullname\non `sys.path` or, if defined, on path. For each path entry that is searched,\n`sys.path_importer_cache` is checked. If a non-false object is found then it\nis used as the path entry finder to look for the module being searched for. If\nno entry is found in `sys.path_importer_cache`, then `sys.path_hooks` is\nsearched for a finder for the path entry and, if found, is stored in\n`sys.path_importer_cache` along with being queried about the module. If no\nfinder is ever found then `None` is both stored in the cache and returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder.invalidate_caches()", "path": "library/importlib#importlib.machinery.PathFinder.invalidate_caches", "type": "Importing", "text": "\nCalls `importlib.abc.PathEntryFinder.invalidate_caches()` on all finders\nstored in `sys.path_importer_cache` that define the method. Otherwise entries\nin `sys.path_importer_cache` set to `None` are deleted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader", "path": "library/importlib#importlib.machinery.SourceFileLoader", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.SourceLoader` by subclassing\n`importlib.abc.FileLoader` and providing some concrete implementations of\nother methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.is_package()", "path": "library/importlib#importlib.machinery.SourceFileLoader.is_package", "type": "Importing", "text": "\nReturn `True` if `path` appears to be for a package.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.load_module()", "path": "library/importlib#importlib.machinery.SourceFileLoader.load_module", "type": "Importing", "text": "\nConcrete implementation of `importlib.abc.Loader.load_module()` where\nspecifying the name of the module to load is optional.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.name", "path": "library/importlib#importlib.machinery.SourceFileLoader.name", "type": "Importing", "text": "\nThe name of the module that this loader will handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.path", "path": "library/importlib#importlib.machinery.SourceFileLoader.path", "type": "Importing", "text": "\nThe path to the source file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.path_stats()", "path": "library/importlib#importlib.machinery.SourceFileLoader.path_stats", "type": "Importing", "text": "\nConcrete implementation of `importlib.abc.SourceLoader.path_stats()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.set_data()", "path": "library/importlib#importlib.machinery.SourceFileLoader.set_data", "type": "Importing", "text": "\nConcrete implementation of `importlib.abc.SourceLoader.set_data()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader", "path": "library/importlib#importlib.machinery.SourcelessFileLoader", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.FileLoader` which can import\nbytecode files (i.e. no source code files exist).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.get_code()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.get_code", "type": "Importing", "text": "\nReturns the code object for `name` created from `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.get_source()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.get_source", "type": "Importing", "text": "\nReturns `None` as bytecode files have no source when this loader is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.is_package()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.is_package", "type": "Importing", "text": "\nDetermines if the module is a package based on `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.load_module()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.load_module", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.name", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.name", "type": "Importing", "text": "\nThe name of the module the loader will handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.path", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.path", "type": "Importing", "text": "\nThe path to the bytecode file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SOURCE_SUFFIXES", "path": "library/importlib#importlib.machinery.SOURCE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the recognized file suffixes for source\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.WindowsRegistryFinder", "path": "library/importlib#importlib.machinery.WindowsRegistryFinder", "type": "Importing", "text": "\nFinder for modules declared in the Windows registry. This class implements the\n`importlib.abc.MetaPathFinder` ABC.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.reload()", "path": "library/importlib#importlib.reload", "type": "Importing", "text": "\nReload a previously imported module. The argument must be a module object, so\nit must have been successfully imported before. This is useful if you have\nedited the module source file using an external editor and want to try out the\nnew version without leaving the Python interpreter. The return value is the\nmodule object (which can be different if re-importing causes a different\nobject to be placed in `sys.modules`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.as_file()", "path": "library/importlib#importlib.resources.as_file", "type": "Importing", "text": "\nGiven a `importlib.resources.abc.Traversable` object representing a file,\ntypically from `importlib.resources.files()`, return a context manager for use\nin a `with` statement. The context manager provides a `pathlib.Path` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.contents()", "path": "library/importlib#importlib.resources.contents", "type": "Importing", "text": "\nReturn an iterable over the named items within the package. The iterable\nreturns `str` resources (e.g. files) and non-resources (e.g. directories). The\niterable does not recurse into subdirectories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.files()", "path": "library/importlib#importlib.resources.files", "type": "Importing", "text": "\nReturns an `importlib.resources.abc.Traversable` object representing the\nresource container for the package (think directory) and its resources (think\nfiles). A Traversable may contain other containers (think subdirectories).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.is_resource()", "path": "library/importlib#importlib.resources.is_resource", "type": "Importing", "text": "\nReturn `True` if there is a resource named name in the package, otherwise\n`False`. Remember that directories are not resources! package is either a name\nor a module object which conforms to the `Package` requirements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.open_binary()", "path": "library/importlib#importlib.resources.open_binary", "type": "Importing", "text": "\nOpen for binary reading the resource within package.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.open_text()", "path": "library/importlib#importlib.resources.open_text", "type": "Importing", "text": "\nOpen for text reading the resource within package. By default, the resource is\nopened for reading as UTF-8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.Package", "path": "library/importlib#importlib.resources.Package", "type": "Importing", "text": "\nThe `Package` type is defined as `Union[str, ModuleType]`. This means that\nwhere the function describes accepting a `Package`, you can pass in either a\nstring or a module. Module objects must have a resolvable\n`__spec__.submodule_search_locations` that is not `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.path()", "path": "library/importlib#importlib.resources.path", "type": "Importing", "text": "\nReturn the path to the resource as an actual file system path. This function\nreturns a context manager for use in a `with` statement. The context manager\nprovides a `pathlib.Path` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.read_binary()", "path": "library/importlib#importlib.resources.read_binary", "type": "Importing", "text": "\nRead and return the contents of the resource within package as `bytes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.read_text()", "path": "library/importlib#importlib.resources.read_text", "type": "Importing", "text": "\nRead and return the contents of resource within package as a `str`. By\ndefault, the contents are read as strict UTF-8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.Resource", "path": "library/importlib#importlib.resources.Resource", "type": "Importing", "text": "\nThis type describes the resource names passed into the various functions in\nthis package. This is defined as `Union[str, os.PathLike]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.cache_from_source()", "path": "library/importlib#importlib.util.cache_from_source", "type": "Importing", "text": "\nReturn the PEP 3147/PEP 488 path to the byte-compiled file associated with the\nsource path. For example, if path is `/foo/bar/baz.py` the return value would\nbe `/foo/bar/__pycache__/baz.cpython-32.pyc` for Python 3.2. The `cpython-32`\nstring comes from the current magic tag (see `get_tag()`; if\n`sys.implementation.cache_tag` is not defined then `NotImplementedError` will\nbe raised).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.decode_source()", "path": "library/importlib#importlib.util.decode_source", "type": "Importing", "text": "\nDecode the given bytes representing source code and return it as a string with\nuniversal newlines (as required by\n`importlib.abc.InspectLoader.get_source()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.find_spec()", "path": "library/importlib#importlib.util.find_spec", "type": "Importing", "text": "\nFind the spec for a module, optionally relative to the specified package name.\nIf the module is in `sys.modules`, then `sys.modules[name].__spec__` is\nreturned (unless the spec would be `None` or is not set, in which case\n`ValueError` is raised). Otherwise a search using `sys.meta_path` is done.\n`None` is returned if no spec is found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.LazyLoader", "path": "library/importlib#importlib.util.LazyLoader", "type": "Importing", "text": "\nA class which postpones the execution of the loader of a module until the\nmodule has an attribute accessed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.LazyLoader.factory()", "path": "library/importlib#importlib.util.LazyLoader.factory", "type": "Importing", "text": "\nA static method which returns a callable that creates a lazy loader. This is\nmeant to be used in situations where the loader is passed by class instead of\nby instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.MAGIC_NUMBER", "path": "library/importlib#importlib.util.MAGIC_NUMBER", "type": "Importing", "text": "\nThe bytes which represent the bytecode version number. If you need help with\nloading/writing bytecode then consider `importlib.abc.SourceLoader`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.module_for_loader()", "path": "library/importlib#importlib.util.module_for_loader", "type": "Importing", "text": "\nA decorator for `importlib.abc.Loader.load_module()` to handle selecting the\nproper module object to load with. The decorated method is expected to have a\ncall signature taking two positional arguments (e.g. `load_module(self,\nmodule)`) for which the second argument will be the module object to be used\nby the loader. Note that the decorator will not work on static methods because\nof the assumption of two arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.module_from_spec()", "path": "library/importlib#importlib.util.module_from_spec", "type": "Importing", "text": "\nCreate a new module based on spec and `spec.loader.create_module`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.resolve_name()", "path": "library/importlib#importlib.util.resolve_name", "type": "Importing", "text": "\nResolve a relative module name to an absolute one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.set_loader()", "path": "library/importlib#importlib.util.set_loader", "type": "Importing", "text": "\nA decorator for `importlib.abc.Loader.load_module()` to set the `__loader__`\nattribute on the returned module. If the attribute is already set the\ndecorator does nothing. It is assumed that the first positional argument to\nthe wrapped method (i.e. `self`) is what `__loader__` should be set to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.set_package()", "path": "library/importlib#importlib.util.set_package", "type": "Importing", "text": "\nA decorator for `importlib.abc.Loader.load_module()` to set the `__package__`\nattribute on the returned module. If `__package__` is set and has a value\nother than `None` it will not be changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.source_from_cache()", "path": "library/importlib#importlib.util.source_from_cache", "type": "Importing", "text": "\nGiven the path to a PEP 3147 file name, return the associated source code file\npath. For example, if path is `/foo/bar/__pycache__/baz.cpython-32.pyc` the\nreturned path would be `/foo/bar/baz.py`. path need not exist, however if it\ndoes not conform to PEP 3147 or PEP 488 format, a `ValueError` is raised. If\n`sys.implementation.cache_tag` is not defined, `NotImplementedError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.source_hash()", "path": "library/importlib#importlib.util.source_hash", "type": "Importing", "text": "\nReturn the hash of source_bytes as bytes. A hash-based `.pyc` file embeds the\n`source_hash()` of the corresponding source file\u2019s contents in its header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.spec_from_file_location()", "path": "library/importlib#importlib.util.spec_from_file_location", "type": "Importing", "text": "\nA factory function for creating a `ModuleSpec` instance based on the path to a\nfile. Missing information will be filled in on the spec by making use of\nloader APIs and by the implication that the module will be file-based.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.spec_from_loader()", "path": "library/importlib#importlib.util.spec_from_loader", "type": "Importing", "text": "\nA factory function for creating a `ModuleSpec` instance based on a loader. The\nparameters have the same meaning as they do for ModuleSpec. The function uses\navailable loader APIs, such as `InspectLoader.is_package()`, to fill in any\nmissing information on the spec.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.__import__()", "path": "library/importlib#importlib.__import__", "type": "Importing", "text": "\nAn implementation of the built-in `__import__()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImportWarning", "path": "library/exceptions#ImportWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about probable mistakes in module imports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IndentationError", "path": "library/exceptions#IndentationError", "type": "Built-in Exceptions", "text": "\nBase class for syntax errors related to incorrect indentation. This is a\nsubclass of `SyntaxError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IndexError", "path": "library/exceptions#IndexError", "type": "Built-in Exceptions", "text": "\nRaised when a sequence subscript is out of range. (Slice indices are silently\ntruncated to fall in the allowed range; if an index is not an integer,\n`TypeError` is raised.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "input()", "path": "library/functions#input", "type": "Built-in Functions", "text": "\nIf the prompt argument is present, it is written to standard output without a\ntrailing newline. The function then reads a line from input, converts it to a\nstring (stripping a trailing newline), and returns that. When EOF is read,\n`EOFError` is raised. Example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect", "path": "library/inspect", "type": "Runtime", "text": "\nSource code: Lib/inspect.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments", "path": "library/inspect#inspect.BoundArguments", "type": "Runtime", "text": "\nResult of a `Signature.bind()` or `Signature.bind_partial()` call. Holds the\nmapping of arguments to the function\u2019s parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.apply_defaults()", "path": "library/inspect#inspect.BoundArguments.apply_defaults", "type": "Runtime", "text": "\nSet default values for missing arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.args", "path": "library/inspect#inspect.BoundArguments.args", "type": "Runtime", "text": "\nA tuple of positional arguments values. Dynamically computed from the\n`arguments` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.arguments", "path": "library/inspect#inspect.BoundArguments.arguments", "type": "Runtime", "text": "\nA mutable mapping of parameters\u2019 names to arguments\u2019 values. Contains only\nexplicitly bound arguments. Changes in `arguments` will reflect in `args` and\n`kwargs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.kwargs", "path": "library/inspect#inspect.BoundArguments.kwargs", "type": "Runtime", "text": "\nA dict of keyword arguments values. Dynamically computed from the `arguments`\nattribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.signature", "path": "library/inspect#inspect.BoundArguments.signature", "type": "Runtime", "text": "\nA reference to the parent `Signature` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.cleandoc()", "path": "library/inspect#inspect.cleandoc", "type": "Runtime", "text": "\nClean up indentation from docstrings that are indented to line up with blocks\nof code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_ASYNC_GENERATOR", "path": "library/inspect#inspect.CO_ASYNC_GENERATOR", "type": "Runtime", "text": "\nThe flag is set when the code object is an asynchronous generator function.\nWhen the code object is executed it returns an asynchronous generator object.\nSee PEP 525 for more details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_COROUTINE", "path": "library/inspect#inspect.CO_COROUTINE", "type": "Runtime", "text": "\nThe flag is set when the code object is a coroutine function. When the code\nobject is executed it returns a coroutine object. See PEP 492 for more\ndetails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_GENERATOR", "path": "library/inspect#inspect.CO_GENERATOR", "type": "Runtime", "text": "\nThe flag is set when the code object is a generator function, i.e. a generator\nobject is returned when the code object is executed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_ITERABLE_COROUTINE", "path": "library/inspect#inspect.CO_ITERABLE_COROUTINE", "type": "Runtime", "text": "\nThe flag is used to transform generators into generator-based coroutines.\nGenerator objects with this flag can be used in `await` expression, and can\n`yield from` coroutine objects. See PEP 492 for more details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_NESTED", "path": "library/inspect#inspect.CO_NESTED", "type": "Runtime", "text": "\nThe flag is set when the code object is a nested function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_NEWLOCALS", "path": "library/inspect#inspect.CO_NEWLOCALS", "type": "Runtime", "text": "\nIf set, a new dict will be created for the frame\u2019s `f_locals` when the code\nobject is executed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_NOFREE", "path": "library/inspect#inspect.CO_NOFREE", "type": "Runtime", "text": "\nThe flag is set if there are no free or cell variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_OPTIMIZED", "path": "library/inspect#inspect.CO_OPTIMIZED", "type": "Runtime", "text": "\nThe code object is optimized, using fast locals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_VARARGS", "path": "library/inspect#inspect.CO_VARARGS", "type": "Runtime", "text": "\nThe code object has a variable positional parameter (`*args`-like).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_VARKEYWORDS", "path": "library/inspect#inspect.CO_VARKEYWORDS", "type": "Runtime", "text": "\nThe code object has a variable keyword parameter (`**kwargs`-like).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.currentframe()", "path": "library/inspect#inspect.currentframe", "type": "Runtime", "text": "\nReturn the frame object for the caller\u2019s stack frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.formatargspec()", "path": "library/inspect#inspect.formatargspec", "type": "Runtime", "text": "\nFormat a pretty argument spec from the values returned by `getfullargspec()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.formatargvalues()", "path": "library/inspect#inspect.formatargvalues", "type": "Runtime", "text": "\nFormat a pretty argument spec from the four values returned by\n`getargvalues()`. The format* arguments are the corresponding optional\nformatting functions that are called to turn names and values into strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getargspec()", "path": "library/inspect#inspect.getargspec", "type": "Runtime", "text": "\nGet the names and default values of a Python function\u2019s parameters. A named\ntuple `ArgSpec(args, varargs, keywords, defaults)` is returned. args is a list\nof the parameter names. varargs and keywords are the names of the `*` and `**`\nparameters or `None`. defaults is a tuple of default argument values or `None`\nif there are no default arguments; if this tuple has n elements, they\ncorrespond to the last n elements listed in args.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getargvalues()", "path": "library/inspect#inspect.getargvalues", "type": "Runtime", "text": "\nGet information about arguments passed into a particular frame. A named tuple\n`ArgInfo(args, varargs, keywords, locals)` is returned. args is a list of the\nargument names. varargs and keywords are the names of the `*` and `**`\narguments or `None`. locals is the locals dictionary of the given frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getattr_static()", "path": "library/inspect#inspect.getattr_static", "type": "Runtime", "text": "\nRetrieve attributes without triggering dynamic lookup via the descriptor\nprotocol, `__getattr__()` or `__getattribute__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcallargs()", "path": "library/inspect#inspect.getcallargs", "type": "Runtime", "text": "\nBind the args and kwds to the argument names of the Python function or method\nfunc, as if it was called with them. For bound methods, bind also the first\nargument (typically named `self`) to the associated instance. A dict is\nreturned, mapping the argument names (including the names of the `*` and `**`\narguments, if any) to their values from args and kwds. In case of invoking\nfunc incorrectly, i.e. whenever `func(*args, **kwds)` would raise an exception\nbecause of incompatible signature, an exception of the same type and the same\nor similar message is raised. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getclasstree()", "path": "library/inspect#inspect.getclasstree", "type": "Runtime", "text": "\nArrange the given list of classes into a hierarchy of nested lists. Where a\nnested list appears, it contains classes derived from the class whose entry\nimmediately precedes the list. Each entry is a 2-tuple containing a class and\na tuple of its base classes. If the unique argument is true, exactly one entry\nappears in the returned structure for each class in the given list. Otherwise,\nclasses using multiple inheritance and their descendants will appear multiple\ntimes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getclosurevars()", "path": "library/inspect#inspect.getclosurevars", "type": "Runtime", "text": "\nGet the mapping of external name references in a Python function or method\nfunc to their current values. A named tuple `ClosureVars(nonlocals, globals,\nbuiltins, unbound)` is returned. nonlocals maps referenced names to lexical\nclosure variables, globals to the function\u2019s module globals and builtins to\nthe builtins visible from the function body. unbound is the set of names\nreferenced in the function that could not be resolved at all given the current\nmodule globals and builtins.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcomments()", "path": "library/inspect#inspect.getcomments", "type": "Runtime", "text": "\nReturn in a single string any lines of comments immediately preceding the\nobject\u2019s source code (for a class, function, or method), or at the top of the\nPython source file (if the object is a module). If the object\u2019s source code is\nunavailable, return `None`. This could happen if the object has been defined\nin C or the interactive shell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcoroutinelocals()", "path": "library/inspect#inspect.getcoroutinelocals", "type": "Runtime", "text": "\nThis function is analogous to `getgeneratorlocals()`, but works for coroutine\nobjects created by `async def` functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcoroutinestate()", "path": "library/inspect#inspect.getcoroutinestate", "type": "Runtime", "text": "\nGet current state of a coroutine object. The function is intended to be used\nwith coroutine objects created by `async def` functions, but will accept any\ncoroutine-like object that has `cr_running` and `cr_frame` attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getdoc()", "path": "library/inspect#inspect.getdoc", "type": "Runtime", "text": "\nGet the documentation string for an object, cleaned up with `cleandoc()`. If\nthe documentation string for an object is not provided and the object is a\nclass, a method, a property or a descriptor, retrieve the documentation string\nfrom the inheritance hierarchy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getfile()", "path": "library/inspect#inspect.getfile", "type": "Runtime", "text": "\nReturn the name of the (text or binary) file in which an object was defined.\nThis will fail with a `TypeError` if the object is a built-in module, class,\nor function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getframeinfo()", "path": "library/inspect#inspect.getframeinfo", "type": "Runtime", "text": "\nGet information about a frame or traceback object. A named tuple\n`Traceback(filename, lineno, function, code_context, index)` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getfullargspec()", "path": "library/inspect#inspect.getfullargspec", "type": "Runtime", "text": "\nGet the names and default values of a Python function\u2019s parameters. A named\ntuple is returned:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getgeneratorlocals()", "path": "library/inspect#inspect.getgeneratorlocals", "type": "Runtime", "text": "\nGet the mapping of live local variables in generator to their current values.\nA dictionary is returned that maps from variable names to values. This is the\nequivalent of calling `locals()` in the body of the generator, and all the\nsame caveats apply.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getgeneratorstate()", "path": "library/inspect#inspect.getgeneratorstate", "type": "Runtime", "text": "\nGet current state of a generator-iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getinnerframes()", "path": "library/inspect#inspect.getinnerframes", "type": "Runtime", "text": "\nGet a list of frame records for a traceback\u2019s frame and all inner frames.\nThese frames represent calls made as a consequence of frame. The first entry\nin the list represents traceback; the last entry represents where the\nexception was raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmembers()", "path": "library/inspect#inspect.getmembers", "type": "Runtime", "text": "\nReturn all the members of an object in a list of `(name, value)` pairs sorted\nby name. If the optional predicate argument\u2014which will be called with the\n`value` object of each member\u2014is supplied, only members for which the\npredicate returns a true value are included.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmodule()", "path": "library/inspect#inspect.getmodule", "type": "Runtime", "text": "\nTry to guess which module an object was defined in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmodulename()", "path": "library/inspect#inspect.getmodulename", "type": "Runtime", "text": "\nReturn the name of the module named by the file path, without including the\nnames of enclosing packages. The file extension is checked against all of the\nentries in `importlib.machinery.all_suffixes()`. If it matches, the final path\ncomponent is returned with the extension removed. Otherwise, `None` is\nreturned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmro()", "path": "library/inspect#inspect.getmro", "type": "Runtime", "text": "\nReturn a tuple of class cls\u2019s base classes, including cls, in method\nresolution order. No class appears more than once in this tuple. Note that the\nmethod resolution order depends on cls\u2019s type. Unless a very peculiar user-\ndefined metatype is in use, cls will be the first element of the tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getouterframes()", "path": "library/inspect#inspect.getouterframes", "type": "Runtime", "text": "\nGet a list of frame records for a frame and all outer frames. These frames\nrepresent the calls that lead to the creation of frame. The first entry in the\nreturned list represents frame; the last entry represents the outermost call\non frame\u2019s stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getsource()", "path": "library/inspect#inspect.getsource", "type": "Runtime", "text": "\nReturn the text of the source code for an object. The argument may be a\nmodule, class, method, function, traceback, frame, or code object. The source\ncode is returned as a single string. An `OSError` is raised if the source code\ncannot be retrieved.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getsourcefile()", "path": "library/inspect#inspect.getsourcefile", "type": "Runtime", "text": "\nReturn the name of the Python source file in which an object was defined. This\nwill fail with a `TypeError` if the object is a built-in module, class, or\nfunction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getsourcelines()", "path": "library/inspect#inspect.getsourcelines", "type": "Runtime", "text": "\nReturn a list of source lines and starting line number for an object. The\nargument may be a module, class, method, function, traceback, frame, or code\nobject. The source code is returned as a list of the lines corresponding to\nthe object and the line number indicates where in the original source file the\nfirst line of code was found. An `OSError` is raised if the source code cannot\nbe retrieved.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isabstract()", "path": "library/inspect#inspect.isabstract", "type": "Runtime", "text": "\nReturn `True` if the object is an abstract base class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isasyncgen()", "path": "library/inspect#inspect.isasyncgen", "type": "Runtime", "text": "\nReturn `True` if the object is an asynchronous generator iterator created by\nan asynchronous generator function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isasyncgenfunction()", "path": "library/inspect#inspect.isasyncgenfunction", "type": "Runtime", "text": "\nReturn `True` if the object is an asynchronous generator function, for\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isawaitable()", "path": "library/inspect#inspect.isawaitable", "type": "Runtime", "text": "\nReturn `True` if the object can be used in `await` expression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isbuiltin()", "path": "library/inspect#inspect.isbuiltin", "type": "Runtime", "text": "\nReturn `True` if the object is a built-in function or a bound built-in method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isclass()", "path": "library/inspect#inspect.isclass", "type": "Runtime", "text": "\nReturn `True` if the object is a class, whether built-in or created in Python\ncode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.iscode()", "path": "library/inspect#inspect.iscode", "type": "Runtime", "text": "\nReturn `True` if the object is a code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.iscoroutine()", "path": "library/inspect#inspect.iscoroutine", "type": "Runtime", "text": "\nReturn `True` if the object is a coroutine created by an `async def` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.iscoroutinefunction()", "path": "library/inspect#inspect.iscoroutinefunction", "type": "Runtime", "text": "\nReturn `True` if the object is a coroutine function (a function defined with\nan `async def` syntax).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isdatadescriptor()", "path": "library/inspect#inspect.isdatadescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a data descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isframe()", "path": "library/inspect#inspect.isframe", "type": "Runtime", "text": "\nReturn `True` if the object is a frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isfunction()", "path": "library/inspect#inspect.isfunction", "type": "Runtime", "text": "\nReturn `True` if the object is a Python function, which includes functions\ncreated by a lambda expression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isgenerator()", "path": "library/inspect#inspect.isgenerator", "type": "Runtime", "text": "\nReturn `True` if the object is a generator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isgeneratorfunction()", "path": "library/inspect#inspect.isgeneratorfunction", "type": "Runtime", "text": "\nReturn `True` if the object is a Python generator function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isgetsetdescriptor()", "path": "library/inspect#inspect.isgetsetdescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a getset descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismemberdescriptor()", "path": "library/inspect#inspect.ismemberdescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a member descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismethod()", "path": "library/inspect#inspect.ismethod", "type": "Runtime", "text": "\nReturn `True` if the object is a bound method written in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismethoddescriptor()", "path": "library/inspect#inspect.ismethoddescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a method descriptor, but not if `ismethod()`,\n`isclass()`, `isfunction()` or `isbuiltin()` are true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismodule()", "path": "library/inspect#inspect.ismodule", "type": "Runtime", "text": "\nReturn `True` if the object is a module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isroutine()", "path": "library/inspect#inspect.isroutine", "type": "Runtime", "text": "\nReturn `True` if the object is a user-defined or built-in function or method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.istraceback()", "path": "library/inspect#inspect.istraceback", "type": "Runtime", "text": "\nReturn `True` if the object is a traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter", "path": "library/inspect#inspect.Parameter", "type": "Runtime", "text": "\nParameter objects are immutable. Instead of modifying a Parameter object, you\ncan use `Parameter.replace()` to create a modified copy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.annotation", "path": "library/inspect#inspect.Parameter.annotation", "type": "Runtime", "text": "\nThe annotation for the parameter. If the parameter has no annotation, this\nattribute is set to `Parameter.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.default", "path": "library/inspect#inspect.Parameter.default", "type": "Runtime", "text": "\nThe default value for the parameter. If the parameter has no default value,\nthis attribute is set to `Parameter.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.empty", "path": "library/inspect#inspect.Parameter.empty", "type": "Runtime", "text": "\nA special class-level marker to specify absence of default values and\nannotations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.kind", "path": "library/inspect#inspect.Parameter.kind", "type": "Runtime", "text": "\nDescribes how argument values are bound to the parameter. Possible values\n(accessible via `Parameter`, like `Parameter.KEYWORD_ONLY`):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.kind.description", "path": "library/inspect#inspect.Parameter.kind.description", "type": "Runtime", "text": "\nDescribes a enum value of Parameter.kind.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.name", "path": "library/inspect#inspect.Parameter.name", "type": "Runtime", "text": "\nThe name of the parameter as a string. The name must be a valid Python\nidentifier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.replace()", "path": "library/inspect#inspect.Parameter.replace", "type": "Runtime", "text": "\nCreate a new Parameter instance based on the instance replaced was invoked on.\nTo override a `Parameter` attribute, pass the corresponding argument. To\nremove a default value or/and an annotation from a Parameter, pass\n`Parameter.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature", "path": "library/inspect#inspect.Signature", "type": "Runtime", "text": "\nA Signature object represents the call signature of a function and its return\nannotation. For each parameter accepted by the function it stores a\n`Parameter` object in its `parameters` collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.signature()", "path": "library/inspect#inspect.signature", "type": "Runtime", "text": "\nReturn a `Signature` object for the given `callable`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.bind()", "path": "library/inspect#inspect.Signature.bind", "type": "Runtime", "text": "\nCreate a mapping from positional and keyword arguments to parameters. Returns\n`BoundArguments` if `*args` and `**kwargs` match the signature, or raises a\n`TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.bind_partial()", "path": "library/inspect#inspect.Signature.bind_partial", "type": "Runtime", "text": "\nWorks the same way as `Signature.bind()`, but allows the omission of some\nrequired arguments (mimics `functools.partial()` behavior.) Returns\n`BoundArguments`, or raises a `TypeError` if the passed arguments do not match\nthe signature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.empty", "path": "library/inspect#inspect.Signature.empty", "type": "Runtime", "text": "\nA special class-level marker to specify absence of a return annotation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.from_callable()", "path": "library/inspect#inspect.Signature.from_callable", "type": "Runtime", "text": "\nReturn a `Signature` (or its subclass) object for a given callable `obj`. Pass\n`follow_wrapped=False` to get a signature of `obj` without unwrapping its\n`__wrapped__` chain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.parameters", "path": "library/inspect#inspect.Signature.parameters", "type": "Runtime", "text": "\nAn ordered mapping of parameters\u2019 names to the corresponding `Parameter`\nobjects. Parameters appear in strict definition order, including keyword-only\nparameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.replace()", "path": "library/inspect#inspect.Signature.replace", "type": "Runtime", "text": "\nCreate a new Signature instance based on the instance replace was invoked on.\nIt is possible to pass different `parameters` and/or `return_annotation` to\noverride the corresponding properties of the base signature. To remove\nreturn_annotation from the copied Signature, pass in `Signature.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.return_annotation", "path": "library/inspect#inspect.Signature.return_annotation", "type": "Runtime", "text": "\nThe \u201creturn\u201d annotation for the callable. If the callable has no \u201creturn\u201d\nannotation, this attribute is set to `Signature.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.stack()", "path": "library/inspect#inspect.stack", "type": "Runtime", "text": "\nReturn a list of frame records for the caller\u2019s stack. The first entry in the\nreturned list represents the caller; the last entry represents the outermost\ncall on the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.trace()", "path": "library/inspect#inspect.trace", "type": "Runtime", "text": "\nReturn a list of frame records for the stack between the current frame and the\nframe in which an exception currently being handled was raised in. The first\nentry in the list represents the caller; the last entry represents where the\nexception was raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.unwrap()", "path": "library/inspect#inspect.unwrap", "type": "Runtime", "text": "\nGet the object wrapped by func. It follows the chain of `__wrapped__`\nattributes returning the last object in the chain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "instance.__class__", "path": "library/stdtypes#instance.__class__", "type": "Built-in Types", "text": "\nThe class to which a class instance belongs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int", "path": "library/functions#int", "type": "Built-in Functions", "text": "\nReturn an integer object constructed from a number or string x, or return `0`\nif no arguments are given. If x defines `__int__()`, `int(x)` returns\n`x.__int__()`. If x defines `__index__()`, it returns `x.__index__()`. If x\ndefines `__trunc__()`, it returns `x.__trunc__()`. For floating point numbers,\nthis truncates towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.as_integer_ratio()", "path": "library/stdtypes#int.as_integer_ratio", "type": "Built-in Types", "text": "\nReturn a pair of integers whose ratio is exactly equal to the original integer\nand with a positive denominator. The integer ratio of integers (whole numbers)\nis always the integer as the numerator and `1` as the denominator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.bit_length()", "path": "library/stdtypes#int.bit_length", "type": "Built-in Types", "text": "\nReturn the number of bits necessary to represent an integer in binary,\nexcluding the sign and leading zeros:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.from_bytes()", "path": "library/stdtypes#int.from_bytes", "type": "Built-in Types", "text": "\nReturn the integer represented by the given array of bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.to_bytes()", "path": "library/stdtypes#int.to_bytes", "type": "Built-in Types", "text": "\nReturn an array of bytes representing an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "InterruptedError", "path": "library/exceptions#InterruptedError", "type": "Built-in Exceptions", "text": "\nRaised when a system call is interrupted by an incoming signal. Corresponds to\n`errno` `EINTR`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io", "path": "library/io", "type": "Operating System", "text": "\nSource code: Lib/io.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BlockingIOError", "path": "library/io#io.BlockingIOError", "type": "Operating System", "text": "\nThis is a compatibility alias for the builtin `BlockingIOError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase", "path": "library/io#io.BufferedIOBase", "type": "Operating System", "text": "\nBase class for binary streams that support some kind of buffering. It inherits\n`IOBase`. There is no public constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.detach()", "path": "library/io#io.BufferedIOBase.detach", "type": "Operating System", "text": "\nSeparate the underlying raw stream from the buffer and return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.raw", "path": "library/io#io.BufferedIOBase.raw", "type": "Operating System", "text": "\nThe underlying raw stream (a `RawIOBase` instance) that `BufferedIOBase` deals\nwith. This is not part of the `BufferedIOBase` API and may not exist on some\nimplementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.read()", "path": "library/io#io.BufferedIOBase.read", "type": "Operating System", "text": "\nRead and return up to size bytes. If the argument is omitted, `None`, or\nnegative, data is read and returned until EOF is reached. An empty `bytes`\nobject is returned if the stream is already at EOF.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.read1()", "path": "library/io#io.BufferedIOBase.read1", "type": "Operating System", "text": "\nRead and return up to size bytes, with at most one call to the underlying raw\nstream\u2019s `read()` (or `readinto()`) method. This can be useful if you are\nimplementing your own buffering on top of a `BufferedIOBase` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.readinto()", "path": "library/io#io.BufferedIOBase.readinto", "type": "Operating System", "text": "\nRead bytes into a pre-allocated, writable bytes-like object b and return the\nnumber of bytes read. For example, b might be a `bytearray`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.readinto1()", "path": "library/io#io.BufferedIOBase.readinto1", "type": "Operating System", "text": "\nRead bytes into a pre-allocated, writable bytes-like object b, using at most\none call to the underlying raw stream\u2019s `read()` (or `readinto()`) method.\nReturn the number of bytes read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.write()", "path": "library/io#io.BufferedIOBase.write", "type": "Operating System", "text": "\nWrite the given bytes-like object, b, and return the number of bytes written\n(always equal to the length of b in bytes, since if the write fails an\n`OSError` will be raised). Depending on the actual implementation, these bytes\nmay be readily written to the underlying stream, or held in a buffer for\nperformance and latency reasons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedRandom", "path": "library/io#io.BufferedRandom", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to a seekable\n`RawIOBase` raw binary stream. It inherits `BufferedReader` and\n`BufferedWriter`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader", "path": "library/io#io.BufferedReader", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to a readable, non\nseekable `RawIOBase` raw binary stream. It inherits `BufferedIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader.peek()", "path": "library/io#io.BufferedReader.peek", "type": "Operating System", "text": "\nReturn bytes from the stream without advancing the position. At most one\nsingle read on the raw stream is done to satisfy the call. The number of bytes\nreturned may be less or more than requested.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader.read()", "path": "library/io#io.BufferedReader.read", "type": "Operating System", "text": "\nRead and return size bytes, or if size is not given or negative, until EOF or\nif the read call would block in non-blocking mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader.read1()", "path": "library/io#io.BufferedReader.read1", "type": "Operating System", "text": "\nRead and return up to size bytes with only one call on the raw stream. If at\nleast one byte is buffered, only buffered bytes are returned. Otherwise, one\nraw stream read call is made.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedRWPair", "path": "library/io#io.BufferedRWPair", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to two non seekable\n`RawIOBase` raw binary streams\u2014one readable, the other writeable. It inherits\n`BufferedIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedWriter", "path": "library/io#io.BufferedWriter", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to a writeable, non\nseekable `RawIOBase` raw binary stream. It inherits `BufferedIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedWriter.flush()", "path": "library/io#io.BufferedWriter.flush", "type": "Operating System", "text": "\nForce bytes held in the buffer into the raw stream. A `BlockingIOError` should\nbe raised if the raw stream blocks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedWriter.write()", "path": "library/io#io.BufferedWriter.write", "type": "Operating System", "text": "\nWrite the bytes-like object, b, and return the number of bytes written. When\nin non-blocking mode, a `BlockingIOError` is raised if the buffer needs to be\nwritten out but the raw stream blocks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO", "path": "library/io#io.BytesIO", "type": "Operating System", "text": "\nA binary stream using an in-memory bytes buffer. It inherits `BufferedIOBase`.\nThe buffer is discarded when the `close()` method is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.getbuffer()", "path": "library/io#io.BytesIO.getbuffer", "type": "Operating System", "text": "\nReturn a readable and writable view over the contents of the buffer without\ncopying them. Also, mutating the view will transparently update the contents\nof the buffer:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.getvalue()", "path": "library/io#io.BytesIO.getvalue", "type": "Operating System", "text": "\nReturn `bytes` containing the entire contents of the buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.read1()", "path": "library/io#io.BytesIO.read1", "type": "Operating System", "text": "\nIn `BytesIO`, this is the same as `read()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.readinto1()", "path": "library/io#io.BytesIO.readinto1", "type": "Operating System", "text": "\nIn `BytesIO`, this is the same as `readinto()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.DEFAULT_BUFFER_SIZE", "path": "library/io#io.DEFAULT_BUFFER_SIZE", "type": "Operating System", "text": "\nAn int containing the default buffer size used by the module\u2019s buffered I/O\nclasses. `open()` uses the file\u2019s blksize (as obtained by `os.stat()`) if\npossible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.FileIO", "path": "library/io#io.FileIO", "type": "Operating System", "text": "\nA raw binary stream representing an OS-level file containing bytes data. It\ninherits `RawIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.FileIO.mode", "path": "library/io#io.FileIO.mode", "type": "Operating System", "text": "\nThe mode as given in the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.FileIO.name", "path": "library/io#io.FileIO.name", "type": "Operating System", "text": "\nThe file name. This is the file descriptor of the file when no name is given\nin the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IncrementalNewlineDecoder", "path": "library/io#io.IncrementalNewlineDecoder", "type": "Operating System", "text": "\nA helper codec that decodes newlines for universal newlines mode. It inherits\n`codecs.IncrementalDecoder`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase", "path": "library/io#io.IOBase", "type": "Operating System", "text": "\nThe abstract base class for all I/O classes, acting on streams of bytes. There\nis no public constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.close()", "path": "library/io#io.IOBase.close", "type": "Operating System", "text": "\nFlush and close this stream. This method has no effect if the file is already\nclosed. Once the file is closed, any operation on the file (e.g. reading or\nwriting) will raise a `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.closed", "path": "library/io#io.IOBase.closed", "type": "Operating System", "text": "\n`True` if the stream is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.fileno()", "path": "library/io#io.IOBase.fileno", "type": "Operating System", "text": "\nReturn the underlying file descriptor (an integer) of the stream if it exists.\nAn `OSError` is raised if the IO object does not use a file descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.flush()", "path": "library/io#io.IOBase.flush", "type": "Operating System", "text": "\nFlush the write buffers of the stream if applicable. This does nothing for\nread-only and non-blocking streams.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.isatty()", "path": "library/io#io.IOBase.isatty", "type": "Operating System", "text": "\nReturn `True` if the stream is interactive (i.e., connected to a terminal/tty\ndevice).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.readable()", "path": "library/io#io.IOBase.readable", "type": "Operating System", "text": "\nReturn `True` if the stream can be read from. If `False`, `read()` will raise\n`OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.readline()", "path": "library/io#io.IOBase.readline", "type": "Operating System", "text": "\nRead and return one line from the stream. If size is specified, at most size\nbytes will be read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.readlines()", "path": "library/io#io.IOBase.readlines", "type": "Operating System", "text": "\nRead and return a list of lines from the stream. hint can be specified to\ncontrol the number of lines read: no more lines will be read if the total size\n(in bytes/characters) of all lines so far exceeds hint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.seek()", "path": "library/io#io.IOBase.seek", "type": "Operating System", "text": "\nChange the stream position to the given byte offset. offset is interpreted\nrelative to the position indicated by whence. The default value for whence is\n`SEEK_SET`. Values for whence are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.seekable()", "path": "library/io#io.IOBase.seekable", "type": "Operating System", "text": "\nReturn `True` if the stream supports random access. If `False`, `seek()`,\n`tell()` and `truncate()` will raise `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.tell()", "path": "library/io#io.IOBase.tell", "type": "Operating System", "text": "\nReturn the current stream position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.truncate()", "path": "library/io#io.IOBase.truncate", "type": "Operating System", "text": "\nResize the stream to the given size in bytes (or the current position if size\nis not specified). The current stream position isn\u2019t changed. This resizing\ncan extend or reduce the current file size. In case of extension, the contents\nof the new file area depend on the platform (on most systems, additional bytes\nare zero-filled). The new file size is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.writable()", "path": "library/io#io.IOBase.writable", "type": "Operating System", "text": "\nReturn `True` if the stream supports writing. If `False`, `write()` and\n`truncate()` will raise `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.writelines()", "path": "library/io#io.IOBase.writelines", "type": "Operating System", "text": "\nWrite a list of lines to the stream. Line separators are not added, so it is\nusual for each of the lines provided to have a line separator at the end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.__del__()", "path": "library/io#io.IOBase.__del__", "type": "Operating System", "text": "\nPrepare for object destruction. `IOBase` provides a default implementation of\nthis method that calls the instance\u2019s `close()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.open()", "path": "library/io#io.open", "type": "Operating System", "text": "\nThis is an alias for the builtin `open()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.open_code()", "path": "library/io#io.open_code", "type": "Operating System", "text": "\nOpens the provided file with mode `'rb'`. This function should be used when\nthe intent is to treat the contents as executable code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase", "path": "library/io#io.RawIOBase", "type": "Operating System", "text": "\nBase class for raw binary streams. It inherits `IOBase`. There is no public\nconstructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.read()", "path": "library/io#io.RawIOBase.read", "type": "Operating System", "text": "\nRead up to size bytes from the object and return them. As a convenience, if\nsize is unspecified or -1, all bytes until EOF are returned. Otherwise, only\none system call is ever made. Fewer than size bytes may be returned if the\noperating system call returns fewer than size bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.readall()", "path": "library/io#io.RawIOBase.readall", "type": "Operating System", "text": "\nRead and return all the bytes from the stream until EOF, using multiple calls\nto the stream if necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.readinto()", "path": "library/io#io.RawIOBase.readinto", "type": "Operating System", "text": "\nRead bytes into a pre-allocated, writable bytes-like object b, and return the\nnumber of bytes read. For example, b might be a `bytearray`. If the object is\nin non-blocking mode and no bytes are available, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.write()", "path": "library/io#io.RawIOBase.write", "type": "Operating System", "text": "\nWrite the given bytes-like object, b, to the underlying raw stream, and return\nthe number of bytes written. This can be less than the length of b in bytes,\ndepending on specifics of the underlying raw stream, and especially if it is\nin non-blocking mode. `None` is returned if the raw stream is set not to block\nand no single byte could be readily written to it. The caller may release or\nmutate b after this method returns, so the implementation should only access b\nduring the method call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.StringIO", "path": "library/io#io.StringIO", "type": "Operating System", "text": "\nA text stream using an in-memory text buffer. It inherits `TextIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.StringIO.getvalue()", "path": "library/io#io.StringIO.getvalue", "type": "Operating System", "text": "\nReturn a `str` containing the entire contents of the buffer. Newlines are\ndecoded as if by `read()`, although the stream position is not changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase", "path": "library/io#io.TextIOBase", "type": "Operating System", "text": "\nBase class for text streams. This class provides a character and line based\ninterface to stream I/O. It inherits `IOBase`. There is no public constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.buffer", "path": "library/io#io.TextIOBase.buffer", "type": "Operating System", "text": "\nThe underlying binary buffer (a `BufferedIOBase` instance) that `TextIOBase`\ndeals with. This is not part of the `TextIOBase` API and may not exist in some\nimplementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.detach()", "path": "library/io#io.TextIOBase.detach", "type": "Operating System", "text": "\nSeparate the underlying binary buffer from the `TextIOBase` and return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.encoding", "path": "library/io#io.TextIOBase.encoding", "type": "Operating System", "text": "\nThe name of the encoding used to decode the stream\u2019s bytes into strings, and\nto encode strings into bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.errors", "path": "library/io#io.TextIOBase.errors", "type": "Operating System", "text": "\nThe error setting of the decoder or encoder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.newlines", "path": "library/io#io.TextIOBase.newlines", "type": "Operating System", "text": "\nA string, a tuple of strings, or `None`, indicating the newlines translated so\nfar. Depending on the implementation and the initial constructor flags, this\nmay not be available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.read()", "path": "library/io#io.TextIOBase.read", "type": "Operating System", "text": "\nRead and return at most size characters from the stream as a single `str`. If\nsize is negative or `None`, reads until EOF.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.readline()", "path": "library/io#io.TextIOBase.readline", "type": "Operating System", "text": "\nRead until newline or EOF and return a single `str`. If the stream is already\nat EOF, an empty string is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.seek()", "path": "library/io#io.TextIOBase.seek", "type": "Operating System", "text": "\nChange the stream position to the given offset. Behaviour depends on the\nwhence parameter. The default value for whence is `SEEK_SET`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.tell()", "path": "library/io#io.TextIOBase.tell", "type": "Operating System", "text": "\nReturn the current stream position as an opaque number. The number does not\nusually represent a number of bytes in the underlying binary storage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.write()", "path": "library/io#io.TextIOBase.write", "type": "Operating System", "text": "\nWrite the string s to the stream and return the number of characters written.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper", "path": "library/io#io.TextIOWrapper", "type": "Operating System", "text": "\nA buffered text stream providing higher-level access to a `BufferedIOBase`\nbuffered binary stream. It inherits `TextIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper.line_buffering", "path": "library/io#io.TextIOWrapper.line_buffering", "type": "Operating System", "text": "\nWhether line buffering is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper.reconfigure()", "path": "library/io#io.TextIOWrapper.reconfigure", "type": "Operating System", "text": "\nReconfigure this text stream using new settings for encoding, errors, newline,\nline_buffering and write_through.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper.write_through", "path": "library/io#io.TextIOWrapper.write_through", "type": "Operating System", "text": "\nWhether writes are passed immediately to the underlying binary buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.UnsupportedOperation", "path": "library/io#io.UnsupportedOperation", "type": "Operating System", "text": "\nAn exception inheriting `OSError` and `ValueError` that is raised when an\nunsupported operation is called on a stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IOError", "path": "library/exceptions#IOError", "type": "Built-in Exceptions", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress", "path": "library/ipaddress", "type": "Internet", "text": "\nSource code: Lib/ipaddress.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.AddressValueError", "path": "library/ipaddress#ipaddress.AddressValueError", "type": "Internet", "text": "\nAny value error related to the address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.collapse_addresses()", "path": "library/ipaddress#ipaddress.collapse_addresses", "type": "Internet", "text": "\nReturn an iterator of the collapsed `IPv4Network` or `IPv6Network` objects.\naddresses is an iterator of `IPv4Network` or `IPv6Network` objects. A\n`TypeError` is raised if addresses contains mixed version objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.get_mixed_type_key()", "path": "library/ipaddress#ipaddress.get_mixed_type_key", "type": "Internet", "text": "\nReturn a key suitable for sorting between networks and addresses. Address and\nNetwork objects are not sortable by default; they\u2019re fundamentally different,\nso the expression:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address", "path": "library/ipaddress#ipaddress.IPv4Address", "type": "Internet", "text": "\nConstruct an IPv4 address. An `AddressValueError` is raised if address is not\na valid IPv4 address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.compressed", "path": "library/ipaddress#ipaddress.IPv4Address.compressed", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.exploded", "path": "library/ipaddress#ipaddress.IPv4Address.exploded", "type": "Internet", "text": "\nThe string representation in dotted decimal notation. Leading zeroes are never\nincluded in the representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_global", "path": "library/ipaddress#ipaddress.IPv4Address.is_global", "type": "Internet", "text": "\n`True` if the address is allocated for public networks. See iana-ipv4-special-\nregistry (for IPv4) or iana-ipv6-special-registry (for IPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_link_local", "path": "library/ipaddress#ipaddress.IPv4Address.is_link_local", "type": "Internet", "text": "\n`True` if the address is reserved for link-local usage. See RFC 3927.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_loopback", "path": "library/ipaddress#ipaddress.IPv4Address.is_loopback", "type": "Internet", "text": "\n`True` if this is a loopback address. See RFC 3330 (for IPv4) or RFC 2373 (for\nIPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_multicast", "path": "library/ipaddress#ipaddress.IPv4Address.is_multicast", "type": "Internet", "text": "\n`True` if the address is reserved for multicast use. See RFC 3171 (for IPv4)\nor RFC 2373 (for IPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_pr