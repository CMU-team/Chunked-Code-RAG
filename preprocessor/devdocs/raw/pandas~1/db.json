{"index":"<h1>pandas documentation</h1> <p><strong>Date</strong>: Jan 22, 2022 <strong>Version</strong>: 1.4.0</p> <p><strong>Download documentation</strong>: <a class=\"reference external\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/pandas.pdf\">PDF Version</a> | <a class=\"reference external\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/pandas.zip\">Zipped HTML</a></p> <p><strong>Previous versions</strong>: Documentation of previous pandas versions is available at <a class=\"reference external\" href=\"https://pandas.pydata.org/\">pandas.pydata.org</a>.</p> <p><strong>Useful links</strong>: <a class=\"reference external\" href=\"https://pypi.org/project/pandas\">Binary Installers</a> | <a class=\"reference external\" href=\"https://github.com/pandas-dev/pandas\">Source Repository</a> | <a class=\"reference external\" href=\"https://github.com/pandas-dev/pandas/issues\">Issues &amp; Ideas</a> | <a class=\"reference external\" href=\"https://stackoverflow.com/questions/tagged/pandas\">Q&amp;A Support</a> | <a class=\"reference external\" href=\"https://groups.google.com/g/pydata\">Mailing List</a></p> <p><a class=\"reference internal\" href=\"#module-pandas\" title=\"pandas\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">pandas</span></code></a> is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the <a class=\"reference external\" href=\"https://www.python.org/\">Python</a> programming language.</p> <div class=\"sphinx-bs container pb-4 docutils\"> <div class=\"row docutils\"> <div class=\"d-flex col-lg-6 col-md-6 col-sm-6 col-xs-12 docutils\"> <div class=\"card w-100 shadow intro-card text-center docutils\"> <div class=\"card-header docutils\"> <p class=\"card-text\">Getting started</p> </div> <div class=\"card-body docutils\"> <p class=\"card-text\">New to <em>pandas</em>? Check out the getting started guides. They contain an introduction to <em>pandas’</em> main concepts and links to additional tutorials.</p> </div> <div class=\"card-footer docutils\"> <p class=\"card-text\"><a class=\"sphinx-bs btn text-wrap btn-block btn-secondary stretched-link reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/getting_started/index.html#getting-started\"><span class=\"std std-ref\">To the getting started guides</span></a></p> </div> </div> </div> <div class=\"d-flex col-lg-6 col-md-6 col-sm-6 col-xs-12 docutils\"> <div class=\"card w-100 shadow intro-card text-center docutils\"> <div class=\"card-header docutils\"> <p class=\"card-text\">User guide</p> </div> <div class=\"card-body docutils\"> <p class=\"card-text\">The user guide provides in-depth information on the key concepts of pandas with useful background information and explanation.</p> </div> <div class=\"card-footer docutils\"> <p class=\"card-text\"><a class=\"sphinx-bs btn text-wrap btn-block btn-secondary stretched-link reference internal\" href=\"user_guide/index#user-guide\"><span class=\"std std-ref\">To the user guide</span></a></p> </div> </div> </div> <div class=\"d-flex col-lg-6 col-md-6 col-sm-6 col-xs-12 docutils\"> <div class=\"card w-100 shadow intro-card text-center docutils\"> <div class=\"card-header docutils\"> <p class=\"card-text\">API reference</p> </div> <div class=\"card-body docutils\"> <p class=\"card-text\">The reference guide contains a detailed description of the pandas API. The reference describes how the methods work and which parameters can be used. It assumes that you have an understanding of the key concepts.</p> </div> <div class=\"card-footer docutils\"> <p class=\"card-text\"><a class=\"sphinx-bs btn text-wrap btn-block btn-secondary stretched-link reference internal\" href=\"reference/index#api\"><span class=\"std std-ref\">To the reference guide</span></a></p> </div> </div> </div> <div class=\"d-flex col-lg-6 col-md-6 col-sm-6 col-xs-12 docutils\"> <div class=\"card w-100 shadow intro-card text-center docutils\"> <div class=\"card-header docutils\"> <p class=\"card-text\">Developer guide</p> </div> <div class=\"card-body docutils\"> <p class=\"card-text\">Saw a typo in the documentation? Want to improve existing functionalities? The contributing guidelines will guide you through the process of improving pandas.</p> </div> <div class=\"card-footer docutils\"> <p class=\"card-text\"><a class=\"sphinx-bs btn text-wrap btn-block btn-secondary stretched-link reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/development/index.html#development\"><span class=\"std std-ref\">To the development guide</span></a></p> </div> </div> </div> </div> </div> <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>\n    <a href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/index.html\" class=\"_attribution-link\">https://pandas.pydata.org/pandas-docs/version/1.4.0/index.html</a>\n  </p>\n</div>\n","user_guide/index":"<h1>User Guide</h1> <p>The User Guide covers all of pandas by topic area. Each of the subsections introduces a topic (such as “working with missing data”), and discusses how pandas approaches the problem, with many examples throughout.</p> <p>Users brand-new to pandas should start with <a class=\"reference internal\" href=\"10min#min\"><span class=\"std std-ref\">10 minutes to pandas</span></a>.</p> <p>For a high level summary of the pandas fundamentals, see <a class=\"reference internal\" href=\"dsintro#dsintro\"><span class=\"std std-ref\">Intro to data structures</span></a> and <a class=\"reference internal\" href=\"basics#basics\"><span class=\"std std-ref\">Essential basic functionality</span></a>.</p> <p>Further information on any specific method can be obtained in the <a class=\"reference internal\" href=\"../reference/index#api\"><span class=\"std std-ref\">API reference</span></a>.</p> <div class=\"toctree-wrapper compound\"> <ul> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"10min\">10 minutes to pandas</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#object-creation\">Object creation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#viewing-data\">Viewing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#selection\">Selection</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#missing-data\">Missing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#operations\">Operations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#merge\">Merge</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#grouping\">Grouping</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#reshaping\">Reshaping</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#time-series\">Time series</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#categoricals\">Categoricals</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#plotting\">Plotting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#getting-data-in-out\">Getting data in/out</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"10min#gotchas\">Gotchas</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"dsintro\">Intro to data structures</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dsintro#series\">Series</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dsintro#dataframe\">DataFrame</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"basics\">Essential basic functionality</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#head-and-tail\">Head and tail</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#attributes-and-underlying-data\">Attributes and underlying data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#accelerated-operations\">Accelerated operations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#flexible-binary-operations\">Flexible binary operations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#descriptive-statistics\">Descriptive statistics</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#function-application\">Function application</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#reindexing-and-altering-labels\">Reindexing and altering labels</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#iteration\">Iteration</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#dt-accessor\">.dt accessor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#vectorized-string-methods\">Vectorized string methods</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#sorting\">Sorting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#copying\">Copying</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#dtypes\">dtypes</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"basics#selecting-columns-based-on-dtype\">Selecting columns based on <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code></a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"io\">IO tools (text, CSV, HDF5, …)</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#csv-text-files\">CSV &amp; text files</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#json\">JSON</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#html\">HTML</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#latex\">LaTeX</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#xml\">XML</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#excel-files\">Excel files</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#opendocument-spreadsheets\">OpenDocument Spreadsheets</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#binary-excel-xlsb-files\">Binary Excel (.xlsb) files</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#clipboard\">Clipboard</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#pickling\">Pickling</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#msgpack\">msgpack</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#hdf5-pytables\">HDF5 (PyTables)</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#feather\">Feather</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#parquet\">Parquet</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#orc\">ORC</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#sql-queries\">SQL queries</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#google-bigquery\">Google BigQuery</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#stata-format\">Stata format</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#sas-formats\">SAS formats</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#spss-formats\">SPSS formats</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#other-file-formats\">Other file formats</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#performance-considerations\">Performance considerations</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"indexing\">Indexing and selecting data</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#different-choices-for-indexing\">Different choices for indexing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#basics\">Basics</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#attribute-access\">Attribute access</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#slicing-ranges\">Slicing ranges</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#selection-by-label\">Selection by label</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#selection-by-position\">Selection by position</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#selection-by-callable\">Selection by callable</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#combining-positional-and-label-based-indexing\">Combining positional and label-based indexing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#indexing-with-list-with-missing-labels-is-deprecated\">Indexing with list with missing labels is deprecated</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#selecting-random-samples\">Selecting random samples</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#setting-with-enlargement\">Setting with enlargement</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#fast-scalar-value-getting-and-setting\">Fast scalar value getting and setting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#boolean-indexing\">Boolean indexing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#indexing-with-isin\">Indexing with isin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#the-where-method-and-masking\">The <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">where()</span></code> Method and Masking</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#setting-with-enlargement-conditionally-using-numpy\">Setting with enlargement conditionally using <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">numpy()</span></code></a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#the-query-method\">The <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code> Method</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#duplicate-data\">Duplicate data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#dictionary-like-get-method\">Dictionary-like <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">get()</span></code> method</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#looking-up-values-by-index-column-labels\">Looking up values by index/column labels</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#index-objects\">Index objects</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#set-reset-index\">Set / reset index</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#returning-a-view-versus-a-copy\">Returning a view versus a copy</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"advanced\">MultiIndex / advanced indexing</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"advanced#hierarchical-indexing-multiindex\">Hierarchical indexing (MultiIndex)</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"advanced#advanced-indexing-with-hierarchical-index\">Advanced indexing with hierarchical index</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"advanced#sorting-a-multiindex\">Sorting a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code></a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"advanced#take-methods\">Take methods</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"advanced#index-types\">Index types</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"advanced#miscellaneous-indexing-faq\">Miscellaneous indexing FAQ</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"merging\">Merge, join, concatenate and compare</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"merging#concatenating-objects\">Concatenating objects</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"merging#database-style-dataframe-or-named-series-joining-merging\">Database-style DataFrame or named Series joining/merging</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"merging#timeseries-friendly-merging\">Timeseries friendly merging</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"merging#comparing-objects\">Comparing objects</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"reshaping\">Reshaping and pivot tables</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#reshaping-by-pivoting-dataframe-objects\">Reshaping by pivoting DataFrame objects</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#reshaping-by-stacking-and-unstacking\">Reshaping by stacking and unstacking</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#reshaping-by-melt\">Reshaping by melt</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#combining-with-stats-and-groupby\">Combining with stats and GroupBy</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#pivot-tables\">Pivot tables</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#cross-tabulations\">Cross tabulations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#tiling\">Tiling</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#computing-indicator-dummy-variables\">Computing indicator / dummy variables</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#factorizing-values\">Factorizing values</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#examples\">Examples</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"reshaping#exploding-a-list-like-column\">Exploding a list-like column</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"text\">Working with text data</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#text-data-types\">Text data types</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#string-methods\">String methods</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#splitting-and-replacing-strings\">Splitting and replacing strings</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#concatenation\">Concatenation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#indexing-with-str\">Indexing with <code class=\"docutils literal notranslate\"><span class=\"pre\">.str</span></code></a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#extracting-substrings\">Extracting substrings</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#testing-for-strings-that-match-or-contain-a-pattern\">Testing for strings that match or contain a pattern</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#creating-indicator-variables\">Creating indicator variables</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"text#method-summary\">Method summary</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"missing_data\">Working with missing data</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#values-considered-missing\">Values considered “missing”</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#inserting-missing-data\">Inserting missing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#calculations-with-missing-data\">Calculations with missing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#sum-prod-of-empties-nans\">Sum/prod of empties/nans</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#na-values-in-groupby\">NA values in GroupBy</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#filling-missing-values-fillna\">Filling missing values: fillna</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#filling-with-a-pandasobject\">Filling with a PandasObject</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#dropping-axis-labels-with-missing-data-dropna\">Dropping axis labels with missing data: dropna</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#interpolation\">Interpolation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#replacing-generic-values\">Replacing generic values</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#string-regular-expression-replacement\">String/regular expression replacement</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#numeric-replacement\">Numeric replacement</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"missing_data#experimental-na-scalar-to-denote-missing-values\">Experimental <code class=\"docutils literal notranslate\"><span class=\"pre\">NA</span></code> scalar to denote missing values</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"duplicates\">Duplicate Labels</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"duplicates#consequences-of-duplicate-labels\">Consequences of Duplicate Labels</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"duplicates#duplicate-label-detection\">Duplicate Label Detection</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"duplicates#disallowing-duplicate-labels\">Disallowing Duplicate Labels</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"categorical\">Categorical data</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#object-creation\">Object creation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#categoricaldtype\">CategoricalDtype</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#description\">Description</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#working-with-categories\">Working with categories</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#sorting-and-order\">Sorting and order</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#comparisons\">Comparisons</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#operations\">Operations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#data-munging\">Data munging</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#getting-data-in-out\">Getting data in/out</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#missing-data\">Missing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#differences-to-r-s-factor\">Differences to R’s <code class=\"docutils literal notranslate\"><span class=\"pre\">factor</span></code></a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"categorical#gotchas\">Gotchas</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"integer_na\">Nullable integer data type</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integer_na#construction\">Construction</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integer_na#operations\">Operations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integer_na#scalar-na-value\">Scalar NA Value</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"boolean\">Nullable Boolean data type</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"boolean#indexing-with-na-values\">Indexing with NA values</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"boolean#kleene-logical-operations\">Kleene logical operations</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"visualization\">Chart Visualization</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"visualization#basic-plotting-plot\">Basic plotting: <code class=\"docutils literal notranslate\"><span class=\"pre\">plot</span></code></a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"visualization#other-plots\">Other plots</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"visualization#plotting-with-missing-data\">Plotting with missing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"visualization#plotting-tools\">Plotting tools</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"visualization#plot-formatting\">Plot formatting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"visualization#plotting-directly-with-matplotlib\">Plotting directly with matplotlib</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"visualization#plotting-backends\">Plotting backends</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"style\">Table Visualization</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Styler-Object-and-HTML\">Styler Object and HTML</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Formatting-the-Display\">Formatting the Display</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Methods-to-Add-Styles\">Methods to Add Styles</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Table-Styles\">Table Styles</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Setting-Classes-and-Linking-to-External-CSS\">Setting Classes and Linking to External CSS</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Styler-Functions\">Styler Functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Tooltips-and-Captions\">Tooltips and Captions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Finer-Control-with-Slicing\">Finer Control with Slicing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Optimization\">Optimization</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Builtin-Styles\">Builtin Styles</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Sharing-styles\">Sharing styles</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Limitations\">Limitations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Other-Fun-and-Useful-Stuff\">Other Fun and Useful Stuff</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Export-to-Excel\">Export to Excel</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Export-to-LaTeX\">Export to LaTeX</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#More-About-CSS-and-HTML\">More About CSS and HTML</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#Extensibility\">Extensibility</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"computation\">Computational tools</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"computation#statistical-functions\">Statistical functions</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"groupby\">Group by: split-apply-combine</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#splitting-an-object-into-groups\">Splitting an object into groups</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#iterating-through-groups\">Iterating through groups</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#selecting-a-group\">Selecting a group</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#aggregation\">Aggregation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#transformation\">Transformation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#filtration\">Filtration</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#dispatching-to-instance-methods\">Dispatching to instance methods</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#flexible-apply\">Flexible <code class=\"docutils literal notranslate\"><span class=\"pre\">apply</span></code></a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#numba-accelerated-routines\">Numba Accelerated Routines</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#other-useful-features\">Other useful features</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#examples\">Examples</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"window\">Windowing Operations</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#overview\">Overview</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#rolling-window\">Rolling window</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#weighted-window\">Weighted window</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#expanding-window\">Expanding window</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#exponentially-weighted-window\">Exponentially Weighted window</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"timeseries\">Time series / date functionality</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#overview\">Overview</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#timestamps-vs-time-spans\">Timestamps vs. time spans</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#converting-to-timestamps\">Converting to timestamps</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#generating-ranges-of-timestamps\">Generating ranges of timestamps</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#timestamp-limitations\">Timestamp limitations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#indexing\">Indexing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#time-date-components\">Time/date components</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#dateoffset-objects\">DateOffset objects</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#time-series-related-instance-methods\">Time series-related instance methods</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#resampling\">Resampling</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#time-span-representation\">Time span representation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#converting-between-representations\">Converting between representations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#representing-out-of-bounds-spans\">Representing out-of-bounds spans</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timeseries#time-zone-handling\">Time zone handling</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"timedeltas\">Time deltas</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timedeltas#parsing\">Parsing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timedeltas#operations\">Operations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timedeltas#reductions\">Reductions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timedeltas#frequency-conversion\">Frequency conversion</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timedeltas#attributes\">Attributes</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timedeltas#timedeltaindex\">TimedeltaIndex</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"timedeltas#resampling\">Resampling</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"options\">Options and settings</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#overview\">Overview</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#getting-and-setting-options\">Getting and setting options</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#setting-startup-options-in-python-ipython-environment\">Setting startup options in Python/IPython environment</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#frequently-used-options\">Frequently used options</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#available-options\">Available options</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#number-formatting\">Number formatting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#unicode-formatting\">Unicode formatting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"options#table-schema-display\">Table schema display</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"enhancingperf\">Enhancing performance</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"enhancingperf#cython-writing-c-extensions-for-pandas\">Cython (writing C extensions for pandas)</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"enhancingperf#numba-jit-compilation\">Numba (JIT compilation)</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"enhancingperf#expression-evaluation-via-eval\">Expression evaluation via <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">eval()</span></code></a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"scale\">Scaling to large datasets</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"scale#load-less-data\">Load less data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"scale#use-efficient-datatypes\">Use efficient datatypes</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"scale#use-chunking\">Use chunking</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"scale#use-other-libraries\">Use other libraries</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"sparse\">Sparse data structures</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sparse#sparsearray\">SparseArray</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sparse#sparsedtype\">SparseDtype</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sparse#sparse-accessor\">Sparse accessor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sparse#sparse-calculation\">Sparse calculation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sparse#migrating\">Migrating</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sparse#interaction-with-scipy-sparse\">Interaction with scipy.sparse</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"gotchas\">Frequently Asked Questions (FAQ)</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"gotchas#dataframe-memory-usage\">DataFrame memory usage</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"gotchas#using-if-truth-statements-with-pandas\">Using if/truth statements with pandas</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"gotchas#mutating-with-user-defined-function-udf-methods\">Mutating with User Defined Function (UDF) methods</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"gotchas#nan-integer-na-values-and-na-type-promotions\"><code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>, Integer <code class=\"docutils literal notranslate\"><span class=\"pre\">NA</span></code> values and <code class=\"docutils literal notranslate\"><span class=\"pre\">NA</span></code> type promotions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"gotchas#differences-with-numpy\">Differences with NumPy</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"gotchas#thread-safety\">Thread-safety</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"gotchas#byte-ordering-issues\">Byte-ordering issues</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"cookbook\">Cookbook</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#idioms\">Idioms</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#selection\">Selection</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#multiindexing\">Multiindexing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#missing-data\">Missing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#grouping\">Grouping</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#timeseries\">Timeseries</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#merge\">Merge</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#plotting\">Plotting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#data-in-out\">Data in/out</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#computation\">Computation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#timedeltas\">Timedeltas</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"cookbook#creating-example-data\">Creating example data</a></li> </ul> </li> </ul> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>\n    <a href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/index.html\" class=\"_attribution-link\">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/index.html</a>\n  </p>\n</div>\n","reference/index":"<h1>API reference</h1> <p>This page gives an overview of all public pandas objects, functions and methods. All classes and functions exposed in <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.*</span></code> namespace are public.</p> <p>Some subpackages are public which include <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.errors</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.plotting</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.testing</span></code>. Public functions in <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.io</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.tseries</span></code> submodules are mentioned in the documentation. <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.api.types</span></code> subpackage holds some public functions related to data types in pandas.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.core</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.compat</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas.util</span></code> top-level modules are PRIVATE. Stable functionality in such modules is not guaranteed.</p> </div> <div class=\"toctree-wrapper compound\"> <ul> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"io\">Input/output</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#pickling\">Pickling</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#flat-file\">Flat file</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#clipboard\">Clipboard</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#excel\">Excel</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#json\">JSON</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#html\">HTML</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#xml\">XML</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#latex\">Latex</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#hdfstore-pytables-hdf5\">HDFStore: PyTables (HDF5)</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#feather\">Feather</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#parquet\">Parquet</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#orc\">ORC</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#sas\">SAS</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#spss\">SPSS</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#sql\">SQL</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#google-bigquery\">Google BigQuery</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io#stata\">STATA</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"general_functions\">General functions</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#data-manipulations\">Data manipulations</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#top-level-missing-data\">Top-level missing data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#top-level-dealing-with-numeric-data\">Top-level dealing with numeric data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#top-level-dealing-with-datetimelike-data\">Top-level dealing with datetimelike data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#top-level-dealing-with-interval-data\">Top-level dealing with Interval data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#top-level-evaluation\">Top-level evaluation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#hashing\">Hashing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_functions#testing\">Testing</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"series\">Series</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#constructor\">Constructor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#attributes\">Attributes</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#conversion\">Conversion</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#indexing-iteration\">Indexing, iteration</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#binary-operator-functions\">Binary operator functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#function-application-groupby-window\">Function application, GroupBy &amp; window</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#computations-descriptive-stats\">Computations / descriptive stats</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#reindexing-selection-label-manipulation\">Reindexing / selection / label manipulation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#missing-data-handling\">Missing data handling</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#reshaping-sorting\">Reshaping, sorting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#combining-comparing-joining-merging\">Combining / comparing / joining / merging</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#time-series-related\">Time Series-related</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#accessors\">Accessors</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#plotting\">Plotting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"series#serialization-io-conversion\">Serialization / IO / conversion</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"frame\">DataFrame</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#constructor\">Constructor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#attributes-and-underlying-data\">Attributes and underlying data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#conversion\">Conversion</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#indexing-iteration\">Indexing, iteration</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#binary-operator-functions\">Binary operator functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#function-application-groupby-window\">Function application, GroupBy &amp; window</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#computations-descriptive-stats\">Computations / descriptive stats</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#reindexing-selection-label-manipulation\">Reindexing / selection / label manipulation</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#missing-data-handling\">Missing data handling</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#reshaping-sorting-transposing\">Reshaping, sorting, transposing</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#combining-comparing-joining-merging\">Combining / comparing / joining / merging</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#time-series-related\">Time Series-related</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#flags\">Flags</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#metadata\">Metadata</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#plotting\">Plotting</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#sparse-accessor\">Sparse accessor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"frame#serialization-io-conversion\">Serialization / IO / conversion</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"arrays\">pandas arrays, scalars, and data types</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.array\">pandas.array</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#datetime-data\">Datetime data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#timedelta-data\">Timedelta data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#timespan-data\">Timespan data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#period\">Period</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#interval-data\">Interval data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#nullable-integer\">Nullable integer</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#categorical-data\">Categorical data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#sparse-data\">Sparse data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#text-data\">Text data</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays#boolean-data-with-missing-values\">Boolean data with missing values</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"indexing\">Index objects</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#index\">Index</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#numeric-index\">Numeric Index</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#categoricalindex\">CategoricalIndex</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#intervalindex\">IntervalIndex</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#multiindex\">MultiIndex</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#datetimeindex\">DatetimeIndex</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#timedeltaindex\">TimedeltaIndex</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"indexing#periodindex\">PeriodIndex</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"offset_frequency\">Date offsets</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#dateoffset\">DateOffset</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#businessday\">BusinessDay</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#businesshour\">BusinessHour</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#custombusinessday\">CustomBusinessDay</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#custombusinesshour\">CustomBusinessHour</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#monthend\">MonthEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#monthbegin\">MonthBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#businessmonthend\">BusinessMonthEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#businessmonthbegin\">BusinessMonthBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#custombusinessmonthend\">CustomBusinessMonthEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#custombusinessmonthbegin\">CustomBusinessMonthBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#semimonthend\">SemiMonthEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#semimonthbegin\">SemiMonthBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#week\">Week</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#weekofmonth\">WeekOfMonth</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#lastweekofmonth\">LastWeekOfMonth</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#bquarterend\">BQuarterEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#bquarterbegin\">BQuarterBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#quarterend\">QuarterEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#quarterbegin\">QuarterBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#byearend\">BYearEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#byearbegin\">BYearBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#yearend\">YearEnd</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#yearbegin\">YearBegin</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#fy5253\">FY5253</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#fy5253quarter\">FY5253Quarter</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#easter\">Easter</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#tick\">Tick</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#day\">Day</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#hour\">Hour</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#minute\">Minute</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#second\">Second</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#milli\">Milli</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#micro\">Micro</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"offset_frequency#nano\">Nano</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"offset_frequency#frequencies\">Frequencies</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.tseries.frequencies.to_offset\">pandas.tseries.frequencies.to_offset</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"window\">Window</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#rolling-window-functions\">Rolling window functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#weighted-window-functions\">Weighted window functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#expanding-window-functions\">Expanding window functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#exponentially-weighted-window-functions\">Exponentially-weighted window functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"window#window-indexer\">Window indexer</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"groupby\">GroupBy</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#indexing-iteration\">Indexing, iteration</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#function-application\">Function application</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"groupby#computations-descriptive-stats\">Computations / descriptive stats</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"resampling\">Resampling</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"resampling#indexing-iteration\">Indexing, iteration</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"resampling#function-application\">Function application</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"resampling#upsampling\">Upsampling</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"resampling#computations-descriptive-stats\">Computations / descriptive stats</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"style\">Style</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#styler-constructor\">Styler constructor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#styler-properties\">Styler properties</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#style-application\">Style application</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#builtin-styles\">Builtin styles</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style#style-export-and-import\">Style export and import</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"plotting\">Plotting</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.andrews_curves\">pandas.plotting.andrews_curves</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.autocorrelation_plot\">pandas.plotting.autocorrelation_plot</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.bootstrap_plot\">pandas.plotting.bootstrap_plot</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.boxplot\">pandas.plotting.boxplot</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.deregister_matplotlib_converters\">pandas.plotting.deregister_matplotlib_converters</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.lag_plot\">pandas.plotting.lag_plot</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.parallel_coordinates\">pandas.plotting.parallel_coordinates</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.plot_params\">pandas.plotting.plot_params</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.radviz\">pandas.plotting.radviz</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.register_matplotlib_converters\">pandas.plotting.register_matplotlib_converters</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.scatter_matrix\">pandas.plotting.scatter_matrix</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.plotting.table\">pandas.plotting.table</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"general_utility_functions\">General utility functions</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_utility_functions#working-with-options\">Working with options</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_utility_functions#testing-functions\">Testing functions</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_utility_functions#exceptions-and-warnings\">Exceptions and warnings</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_utility_functions#data-types-related-functionality\">Data types related functionality</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"general_utility_functions#bug-report-function\">Bug report function</a></li> </ul> </li> <li class=\"toctree-l1\">\n<a class=\"reference internal\" href=\"extensions\">Extensions</a><ul> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.api.extensions.register_extension_dtype\">pandas.api.extensions.register_extension_dtype</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.api.extensions.register_dataframe_accessor\">pandas.api.extensions.register_dataframe_accessor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.api.extensions.register_series_accessor\">pandas.api.extensions.register_series_accessor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.api.extensions.register_index_accessor\">pandas.api.extensions.register_index_accessor</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.api.extensions.extensiondtype\">pandas.api.extensions.ExtensionDtype</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.api.extensions.extensionarray\">pandas.api.extensions.ExtensionArray</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.arrays.pandasarray\">pandas.arrays.PandasArray</a></li> <li class=\"toctree-l2\"><a class=\"reference internal\" href=\"api/pandas.api.indexers.check_array_indexer\">pandas.api.indexers.check_array_indexer</a></li> </ul> </li> </ul> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>\n    <a href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/reference/index.html\" class=\"_attribution-link\">https://pandas.pydata.org/pandas-docs/version/1.4.0/reference/index.html</a>\n  </p>\n</div>\n","user_guide/10min":"<h1>10 minutes to pandas</h1> <p>This is a short introduction to pandas, geared mainly for new users. You can see more complex recipes in the <a class=\"reference internal\" href=\"cookbook#cookbook\"><span class=\"std std-ref\">Cookbook</span></a>.</p> <p>Customarily, we import as follows:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [1]: import numpy as np\n\nIn [2]: import pandas as pd\n</pre></div> </div> <section id=\"object-creation\"> <h2>Object creation</h2> <p>See the <a class=\"reference internal\" href=\"dsintro#dsintro\"><span class=\"std std-ref\">Intro to data structures section</span></a>.</p> <p>Creating a <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> by passing a list of values, letting pandas create a default integer index:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [3]: s = pd.Series([1, 3, 5, np.nan, 6, 8])\n\nIn [4]: s\nOut[4]: \n0    1.0\n1    3.0\n2    5.0\n3    NaN\n4    6.0\n5    8.0\ndtype: float64\n</pre></div> </div> <p>Creating a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> by passing a NumPy array, with a datetime index and labeled columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [5]: dates = pd.date_range(\"20130101\", periods=6)\n\nIn [6]: dates\nOut[6]: \nDatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\n               '2013-01-05', '2013-01-06'],\n              dtype='datetime64[ns]', freq='D')\n\nIn [7]: df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list(\"ABCD\"))\n\nIn [8]: df\nOut[8]: \n                   A         B         C         D\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\n2013-01-06 -0.673690  0.113648 -1.478427  0.524988\n</pre></div> </div> <p>Creating a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> by passing a dictionary of objects that can be converted into a series-like structure:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [9]: df2 = pd.DataFrame(\n   ...:     {\n   ...:         \"A\": 1.0,\n   ...:         \"B\": pd.Timestamp(\"20130102\"),\n   ...:         \"C\": pd.Series(1, index=list(range(4)), dtype=\"float32\"),\n   ...:         \"D\": np.array([3] * 4, dtype=\"int32\"),\n   ...:         \"E\": pd.Categorical([\"test\", \"train\", \"test\", \"train\"]),\n   ...:         \"F\": \"foo\",\n   ...:     }\n   ...: )\n   ...: \n\nIn [10]: df2\nOut[10]: \n     A          B    C  D      E    F\n0  1.0 2013-01-02  1.0  3   test  foo\n1  1.0 2013-01-02  1.0  3  train  foo\n2  1.0 2013-01-02  1.0  3   test  foo\n3  1.0 2013-01-02  1.0  3  train  foo\n</pre></div> </div> <p>The columns of the resulting <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> have different <a class=\"reference internal\" href=\"basics#basics-dtypes\"><span class=\"std std-ref\">dtypes</span></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [11]: df2.dtypes\nOut[11]: \nA           float64\nB    datetime64[ns]\nC           float32\nD             int32\nE          category\nF            object\ndtype: object\n</pre></div> </div> <p>If you’re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here’s a subset of the attributes that will be completed:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [12]: df2.&lt;TAB&gt;  # noqa: E225, E999\ndf2.A                  df2.bool\ndf2.abs                df2.boxplot\ndf2.add                df2.C\ndf2.add_prefix         df2.clip\ndf2.add_suffix         df2.columns\ndf2.align              df2.copy\ndf2.all                df2.count\ndf2.any                df2.combine\ndf2.append             df2.D\ndf2.apply              df2.describe\ndf2.applymap           df2.diff\ndf2.B                  df2.duplicated\n</pre></div> </div> <p>As you can see, the columns <code class=\"docutils literal notranslate\"><span class=\"pre\">A</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">B</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">C</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">D</span></code> are automatically tab completed. <code class=\"docutils literal notranslate\"><span class=\"pre\">E</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">F</span></code> are there as well; the rest of the attributes have been truncated for brevity.</p> </section> <section id=\"viewing-data\"> <h2>Viewing data</h2> <p>See the <a class=\"reference internal\" href=\"basics#basics\"><span class=\"std std-ref\">Basics section</span></a>.</p> <p>Here is how to view the top and bottom rows of the frame:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [13]: df.head()\nOut[13]: \n                   A         B         C         D\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\n\nIn [14]: df.tail(3)\nOut[14]: \n                   A         B         C         D\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\n2013-01-06 -0.673690  0.113648 -1.478427  0.524988\n</pre></div> </div> <p>Display the index, columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [15]: df.index\nOut[15]: \nDatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\n               '2013-01-05', '2013-01-06'],\n              dtype='datetime64[ns]', freq='D')\n\nIn [16]: df.columns\nOut[16]: Index(['A', 'B', 'C', 'D'], dtype='object')\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a> gives a NumPy representation of the underlying data. Note that this can be an expensive operation when your <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> has columns with different data types, which comes down to a fundamental difference between pandas and NumPy: <strong>NumPy arrays have one dtype for the entire array, while pandas DataFrames have one dtype per column</strong>. When you call <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a>, pandas will find the NumPy dtype that can hold <em>all</em> of the dtypes in the DataFrame. This may end up being <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code>, which requires casting every value to a Python object.</p> <p>For <code class=\"docutils literal notranslate\"><span class=\"pre\">df</span></code>, our <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> of all floating-point values, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a> is fast and doesn’t require copying data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [17]: df.to_numpy()\nOut[17]: \narray([[ 0.4691, -0.2829, -1.5091, -1.1356],\n       [ 1.2121, -0.1732,  0.1192, -1.0442],\n       [-0.8618, -2.1046, -0.4949,  1.0718],\n       [ 0.7216, -0.7068, -1.0396,  0.2719],\n       [-0.425 ,  0.567 ,  0.2762, -1.0874],\n       [-0.6737,  0.1136, -1.4784,  0.525 ]])\n</pre></div> </div> <p>For <code class=\"docutils literal notranslate\"><span class=\"pre\">df2</span></code>, the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> with multiple dtypes, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a> is relatively expensive:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [18]: df2.to_numpy()\nOut[18]: \narray([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],\n       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],\n       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],\n       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']],\n      dtype=object)\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a> does <em>not</em> include the index or column labels in the output.</p> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.describe#pandas.DataFrame.describe\" title=\"pandas.DataFrame.describe\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">describe()</span></code></a> shows a quick statistic summary of your data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [19]: df.describe()\nOut[19]: \n              A         B         C         D\ncount  6.000000  6.000000  6.000000  6.000000\nmean   0.073711 -0.431125 -0.687758 -0.233103\nstd    0.843157  0.922818  0.779887  0.973118\nmin   -0.861849 -2.104569 -1.509059 -1.135632\n25%   -0.611510 -0.600794 -1.368714 -1.076610\n50%    0.022070 -0.228039 -0.767252 -0.386188\n75%    0.658444  0.041933 -0.034326  0.461706\nmax    1.212112  0.567020  0.276232  1.071804\n</pre></div> </div> <p>Transposing your data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [20]: df.T\nOut[20]: \n   2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06\nA    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690\nB   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648\nC   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427\nD   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988\n</pre></div> </div> <p>Sorting by an axis:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [21]: df.sort_index(axis=1, ascending=False)\nOut[21]: \n                   D         C         B         A\n2013-01-01 -1.135632 -1.509059 -0.282863  0.469112\n2013-01-02 -1.044236  0.119209 -0.173215  1.212112\n2013-01-03  1.071804 -0.494929 -2.104569 -0.861849\n2013-01-04  0.271860 -1.039575 -0.706771  0.721555\n2013-01-05 -1.087401  0.276232  0.567020 -0.424972\n2013-01-06  0.524988 -1.478427  0.113648 -0.673690\n</pre></div> </div> <p>Sorting by values:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [22]: df.sort_values(by=\"B\")\nOut[22]: \n                   A         B         C         D\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-06 -0.673690  0.113648 -1.478427  0.524988\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\n</pre></div> </div> </section> <section id=\"selection\"> <h2>Selection</h2> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>While standard Python / NumPy expressions for selecting and setting are intuitive and come in handy for interactive work, for production code, we recommend the optimized pandas data access methods, <code class=\"docutils literal notranslate\"><span class=\"pre\">.at</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">.iat</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code>.</p> </div> <p>See the indexing documentation <a class=\"reference internal\" href=\"indexing#indexing\"><span class=\"std std-ref\">Indexing and Selecting Data</span></a> and <a class=\"reference internal\" href=\"advanced#advanced\"><span class=\"std std-ref\">MultiIndex / Advanced Indexing</span></a>.</p> <section id=\"getting\"> <h3>Getting</h3> <p>Selecting a single column, which yields a <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a>, equivalent to <code class=\"docutils literal notranslate\"><span class=\"pre\">df.A</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [23]: df[\"A\"]\nOut[23]: \n2013-01-01    0.469112\n2013-01-02    1.212112\n2013-01-03   -0.861849\n2013-01-04    0.721555\n2013-01-05   -0.424972\n2013-01-06   -0.673690\nFreq: D, Name: A, dtype: float64\n</pre></div> </div> <p>Selecting via <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code>, which slices the rows:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [24]: df[0:3]\nOut[24]: \n                   A         B         C         D\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n\nIn [25]: df[\"20130102\":\"20130104\"]\nOut[25]: \n                   A         B         C         D\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n</pre></div> </div> </section> <section id=\"selection-by-label\"> <h3>Selection by label</h3> <p>See more in <a class=\"reference internal\" href=\"indexing#indexing-label\"><span class=\"std std-ref\">Selection by Label</span></a>.</p> <p>For getting a cross section using a label:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [26]: df.loc[dates[0]]\nOut[26]: \nA    0.469112\nB   -0.282863\nC   -1.509059\nD   -1.135632\nName: 2013-01-01 00:00:00, dtype: float64\n</pre></div> </div> <p>Selecting on a multi-axis by label:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [27]: df.loc[:, [\"A\", \"B\"]]\nOut[27]: \n                   A         B\n2013-01-01  0.469112 -0.282863\n2013-01-02  1.212112 -0.173215\n2013-01-03 -0.861849 -2.104569\n2013-01-04  0.721555 -0.706771\n2013-01-05 -0.424972  0.567020\n2013-01-06 -0.673690  0.113648\n</pre></div> </div> <p>Showing label slicing, both endpoints are <em>included</em>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [28]: df.loc[\"20130102\":\"20130104\", [\"A\", \"B\"]]\nOut[28]: \n                   A         B\n2013-01-02  1.212112 -0.173215\n2013-01-03 -0.861849 -2.104569\n2013-01-04  0.721555 -0.706771\n</pre></div> </div> <p>Reduction in the dimensions of the returned object:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [29]: df.loc[\"20130102\", [\"A\", \"B\"]]\nOut[29]: \nA    1.212112\nB   -0.173215\nName: 2013-01-02 00:00:00, dtype: float64\n</pre></div> </div> <p>For getting a scalar value:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [30]: df.loc[dates[0], \"A\"]\nOut[30]: 0.4691122999071863\n</pre></div> </div> <p>For getting fast access to a scalar (equivalent to the prior method):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [31]: df.at[dates[0], \"A\"]\nOut[31]: 0.4691122999071863\n</pre></div> </div> </section> <section id=\"selection-by-position\"> <h3>Selection by position</h3> <p>See more in <a class=\"reference internal\" href=\"indexing#indexing-integer\"><span class=\"std std-ref\">Selection by Position</span></a>.</p> <p>Select via the position of the passed integers:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [32]: df.iloc[3]\nOut[32]: \nA    0.721555\nB   -0.706771\nC   -1.039575\nD    0.271860\nName: 2013-01-04 00:00:00, dtype: float64\n</pre></div> </div> <p>By integer slices, acting similar to NumPy/Python:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [33]: df.iloc[3:5, 0:2]\nOut[33]: \n                   A         B\n2013-01-04  0.721555 -0.706771\n2013-01-05 -0.424972  0.567020\n</pre></div> </div> <p>By lists of integer position locations, similar to the NumPy/Python style:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [34]: df.iloc[[1, 2, 4], [0, 2]]\nOut[34]: \n                   A         C\n2013-01-02  1.212112  0.119209\n2013-01-03 -0.861849 -0.494929\n2013-01-05 -0.424972  0.276232\n</pre></div> </div> <p>For slicing rows explicitly:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [35]: df.iloc[1:3, :]\nOut[35]: \n                   A         B         C         D\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n</pre></div> </div> <p>For slicing columns explicitly:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [36]: df.iloc[:, 1:3]\nOut[36]: \n                   B         C\n2013-01-01 -0.282863 -1.509059\n2013-01-02 -0.173215  0.119209\n2013-01-03 -2.104569 -0.494929\n2013-01-04 -0.706771 -1.039575\n2013-01-05  0.567020  0.276232\n2013-01-06  0.113648 -1.478427\n</pre></div> </div> <p>For getting a value explicitly:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [37]: df.iloc[1, 1]\nOut[37]: -0.17321464905330858\n</pre></div> </div> <p>For getting fast access to a scalar (equivalent to the prior method):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [38]: df.iat[1, 1]\nOut[38]: -0.17321464905330858\n</pre></div> </div> </section> <section id=\"boolean-indexing\"> <h3>Boolean indexing</h3> <p>Using a single column’s values to select data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [39]: df[df[\"A\"] &gt; 0]\nOut[39]: \n                   A         B         C         D\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n</pre></div> </div> <p>Selecting values from a DataFrame where a boolean condition is met:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [40]: df[df &gt; 0]\nOut[40]: \n                   A         B         C         D\n2013-01-01  0.469112       NaN       NaN       NaN\n2013-01-02  1.212112       NaN  0.119209       NaN\n2013-01-03       NaN       NaN       NaN  1.071804\n2013-01-04  0.721555       NaN       NaN  0.271860\n2013-01-05       NaN  0.567020  0.276232       NaN\n2013-01-06       NaN  0.113648       NaN  0.524988\n</pre></div> </div> <p>Using the <a class=\"reference internal\" href=\"../reference/api/pandas.series.isin#pandas.Series.isin\" title=\"pandas.Series.isin\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isin()</span></code></a> method for filtering:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [41]: df2 = df.copy()\n\nIn [42]: df2[\"E\"] = [\"one\", \"one\", \"two\", \"three\", \"four\", \"three\"]\n\nIn [43]: df2\nOut[43]: \n                   A         B         C         D      E\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four\n2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three\n\nIn [44]: df2[df2[\"E\"].isin([\"two\", \"four\"])]\nOut[44]: \n                   A         B         C         D     E\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four\n</pre></div> </div> </section> <section id=\"setting\"> <h3>Setting</h3> <p>Setting a new column automatically aligns the data by the indexes:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [45]: s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range(\"20130102\", periods=6))\n\nIn [46]: s1\nOut[46]: \n2013-01-02    1\n2013-01-03    2\n2013-01-04    3\n2013-01-05    4\n2013-01-06    5\n2013-01-07    6\nFreq: D, dtype: int64\n\nIn [47]: df[\"F\"] = s1\n</pre></div> </div> <p>Setting values by label:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [48]: df.at[dates[0], \"A\"] = 0\n</pre></div> </div> <p>Setting values by position:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [49]: df.iat[0, 1] = 0\n</pre></div> </div> <p>Setting by assigning with a NumPy array:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [50]: df.loc[:, \"D\"] = np.array([5] * len(df))\n</pre></div> </div> <p>The result of the prior setting operations:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [51]: df\nOut[51]: \n                   A         B         C  D    F\n2013-01-01  0.000000  0.000000 -1.509059  5  NaN\n2013-01-02  1.212112 -0.173215  0.119209  5  1.0\n2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0\n2013-01-04  0.721555 -0.706771 -1.039575  5  3.0\n2013-01-05 -0.424972  0.567020  0.276232  5  4.0\n2013-01-06 -0.673690  0.113648 -1.478427  5  5.0\n</pre></div> </div> <p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> operation with setting:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [52]: df2 = df.copy()\n\nIn [53]: df2[df2 &gt; 0] = -df2\n\nIn [54]: df2\nOut[54]: \n                   A         B         C  D    F\n2013-01-01  0.000000  0.000000 -1.509059 -5  NaN\n2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0\n2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0\n2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0\n2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0\n2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0\n</pre></div> </div> </section> </section> <section id=\"missing-data\"> <h2>Missing data</h2> <p>pandas primarily uses the value <code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code> to represent missing data. It is by default not included in computations. See the <a class=\"reference internal\" href=\"missing_data#missing-data\"><span class=\"std std-ref\">Missing Data section</span></a>.</p> <p>Reindexing allows you to change/add/delete the index on a specified axis. This returns a copy of the data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [55]: df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + [\"E\"])\n\nIn [56]: df1.loc[dates[0] : dates[1], \"E\"] = 1\n\nIn [57]: df1\nOut[57]: \n                   A         B         C  D    F    E\n2013-01-01  0.000000  0.000000 -1.509059  5  NaN  1.0\n2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0\n2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  NaN\n2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  NaN\n</pre></div> </div> <p>To drop any rows that have missing data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [58]: df1.dropna(how=\"any\")\nOut[58]: \n                   A         B         C  D    F    E\n2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0\n</pre></div> </div> <p>Filling missing data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [59]: df1.fillna(value=5)\nOut[59]: \n                   A         B         C  D    F    E\n2013-01-01  0.000000  0.000000 -1.509059  5  5.0  1.0\n2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0\n2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  5.0\n2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  5.0\n</pre></div> </div> <p>To get the boolean mask where values are <code class=\"docutils literal notranslate\"><span class=\"pre\">nan</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [60]: pd.isna(df1)\nOut[60]: \n                A      B      C      D      F      E\n2013-01-01  False  False  False  False   True  False\n2013-01-02  False  False  False  False  False  False\n2013-01-03  False  False  False  False  False   True\n2013-01-04  False  False  False  False  False   True\n</pre></div> </div> </section> <section id=\"operations\"> <h2>Operations</h2> <p>See the <a class=\"reference internal\" href=\"basics#basics-binop\"><span class=\"std std-ref\">Basic section on Binary Ops</span></a>.</p> <section id=\"stats\"> <h3>Stats</h3> <p>Operations in general <em>exclude</em> missing data.</p> <p>Performing a descriptive statistic:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [61]: df.mean()\nOut[61]: \nA   -0.004474\nB   -0.383981\nC   -0.687758\nD    5.000000\nF    3.000000\ndtype: float64\n</pre></div> </div> <p>Same operation on the other axis:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [62]: df.mean(1)\nOut[62]: \n2013-01-01    0.872735\n2013-01-02    1.431621\n2013-01-03    0.707731\n2013-01-04    1.395042\n2013-01-05    1.883656\n2013-01-06    1.592306\nFreq: D, dtype: float64\n</pre></div> </div> <p>Operating with objects that have different dimensionality and need alignment. In addition, pandas automatically broadcasts along the specified dimension:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [63]: s = pd.Series([1, 3, 5, np.nan, 6, 8], index=dates).shift(2)\n\nIn [64]: s\nOut[64]: \n2013-01-01    NaN\n2013-01-02    NaN\n2013-01-03    1.0\n2013-01-04    3.0\n2013-01-05    5.0\n2013-01-06    NaN\nFreq: D, dtype: float64\n\nIn [65]: df.sub(s, axis=\"index\")\nOut[65]: \n                   A         B         C    D    F\n2013-01-01       NaN       NaN       NaN  NaN  NaN\n2013-01-02       NaN       NaN       NaN  NaN  NaN\n2013-01-03 -1.861849 -3.104569 -1.494929  4.0  1.0\n2013-01-04 -2.278445 -3.706771 -4.039575  2.0  0.0\n2013-01-05 -5.424972 -4.432980 -4.723768  0.0 -1.0\n2013-01-06       NaN       NaN       NaN  NaN  NaN\n</pre></div> </div> </section> <section id=\"apply\"> <h3>Apply</h3> <p>Applying functions to the data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [66]: df.apply(np.cumsum)\nOut[66]: \n                   A         B         C   D     F\n2013-01-01  0.000000  0.000000 -1.509059   5   NaN\n2013-01-02  1.212112 -0.173215 -1.389850  10   1.0\n2013-01-03  0.350263 -2.277784 -1.884779  15   3.0\n2013-01-04  1.071818 -2.984555 -2.924354  20   6.0\n2013-01-05  0.646846 -2.417535 -2.648122  25  10.0\n2013-01-06 -0.026844 -2.303886 -4.126549  30  15.0\n\nIn [67]: df.apply(lambda x: x.max() - x.min())\nOut[67]: \nA    2.073961\nB    2.671590\nC    1.785291\nD    0.000000\nF    4.000000\ndtype: float64\n</pre></div> </div> </section> <section id=\"histogramming\"> <h3>Histogramming</h3> <p>See more at <a class=\"reference internal\" href=\"basics#basics-discretization\"><span class=\"std std-ref\">Histogramming and Discretization</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [68]: s = pd.Series(np.random.randint(0, 7, size=10))\n\nIn [69]: s\nOut[69]: \n0    4\n1    2\n2    1\n3    2\n4    6\n5    4\n6    4\n7    6\n8    4\n9    4\ndtype: int64\n\nIn [70]: s.value_counts()\nOut[70]: \n4    5\n2    2\n6    2\n1    1\ndtype: int64\n</pre></div> </div> </section> <section id=\"string-methods\"> <h3>String Methods</h3> <p>Series is equipped with a set of string processing methods in the <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> attribute that make it easy to operate on each element of the array, as in the code snippet below. Note that pattern-matching in <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> generally uses <a class=\"reference external\" href=\"https://docs.python.org/3/library/re.html\">regular expressions</a> by default (and in some cases always uses them). See more at <a class=\"reference internal\" href=\"text#text-string-methods\"><span class=\"std std-ref\">Vectorized String Methods</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [71]: s = pd.Series([\"A\", \"B\", \"C\", \"Aaba\", \"Baca\", np.nan, \"CABA\", \"dog\", \"cat\"])\n\nIn [72]: s.str.lower()\nOut[72]: \n0       a\n1       b\n2       c\n3    aaba\n4    baca\n5     NaN\n6    caba\n7     dog\n8     cat\ndtype: object\n</pre></div> </div> </section> </section> <section id=\"merge\"> <h2>Merge</h2> <section id=\"concat\"> <h3>Concat</h3> <p>pandas provides various facilities for easily combining together Series and DataFrame objects with various kinds of set logic for the indexes and relational algebra functionality in the case of join / merge-type operations.</p> <p>See the <a class=\"reference internal\" href=\"merging#merging\"><span class=\"std std-ref\">Merging section</span></a>.</p> <p>Concatenating pandas objects together with <a class=\"reference internal\" href=\"../reference/api/pandas.concat#pandas.concat\" title=\"pandas.concat\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">concat()</span></code></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [73]: df = pd.DataFrame(np.random.randn(10, 4))\n\nIn [74]: df\nOut[74]: \n          0         1         2         3\n0 -0.548702  1.467327 -1.015962 -0.483075\n1  1.637550 -1.217659 -0.291519 -1.745505\n2 -0.263952  0.991460 -0.919069  0.266046\n3 -0.709661  1.669052  1.037882 -1.705775\n4 -0.919854 -0.042379  1.247642 -0.009920\n5  0.290213  0.495767  0.362949  1.548106\n6 -1.131345 -0.089329  0.337863 -0.945867\n7 -0.932132  1.956030  0.017587 -0.016692\n8 -0.575247  0.254161 -1.143704  0.215897\n9  1.193555 -0.077118 -0.408530 -0.862495\n\n# break it into pieces\nIn [75]: pieces = [df[:3], df[3:7], df[7:]]\n\nIn [76]: pd.concat(pieces)\nOut[76]: \n          0         1         2         3\n0 -0.548702  1.467327 -1.015962 -0.483075\n1  1.637550 -1.217659 -0.291519 -1.745505\n2 -0.263952  0.991460 -0.919069  0.266046\n3 -0.709661  1.669052  1.037882 -1.705775\n4 -0.919854 -0.042379  1.247642 -0.009920\n5  0.290213  0.495767  0.362949  1.548106\n6 -1.131345 -0.089329  0.337863 -0.945867\n7 -0.932132  1.956030  0.017587 -0.016692\n8 -0.575247  0.254161 -1.143704  0.215897\n9  1.193555 -0.077118 -0.408530 -0.862495\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Adding a column to a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> is relatively fast. However, adding a row requires a copy, and may be expensive. We recommend passing a pre-built list of records to the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> constructor instead of building a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> by iteratively appending records to it.</p> </div> </section> <section id=\"join\"> <h3>Join</h3> <p>SQL style merges. See the <a class=\"reference internal\" href=\"merging#merging-join\"><span class=\"std std-ref\">Database style joining</span></a> section.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [77]: left = pd.DataFrame({\"key\": [\"foo\", \"foo\"], \"lval\": [1, 2]})\n\nIn [78]: right = pd.DataFrame({\"key\": [\"foo\", \"foo\"], \"rval\": [4, 5]})\n\nIn [79]: left\nOut[79]: \n   key  lval\n0  foo     1\n1  foo     2\n\nIn [80]: right\nOut[80]: \n   key  rval\n0  foo     4\n1  foo     5\n\nIn [81]: pd.merge(left, right, on=\"key\")\nOut[81]: \n   key  lval  rval\n0  foo     1     4\n1  foo     1     5\n2  foo     2     4\n3  foo     2     5\n</pre></div> </div> <p>Another example that can be given is:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [82]: left = pd.DataFrame({\"key\": [\"foo\", \"bar\"], \"lval\": [1, 2]})\n\nIn [83]: right = pd.DataFrame({\"key\": [\"foo\", \"bar\"], \"rval\": [4, 5]})\n\nIn [84]: left\nOut[84]: \n   key  lval\n0  foo     1\n1  bar     2\n\nIn [85]: right\nOut[85]: \n   key  rval\n0  foo     4\n1  bar     5\n\nIn [86]: pd.merge(left, right, on=\"key\")\nOut[86]: \n   key  lval  rval\n0  foo     1     4\n1  bar     2     5\n</pre></div> </div> </section> </section> <section id=\"grouping\"> <h2>Grouping</h2> <p>By “group by” we are referring to a process involving one or more of the following steps:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p><strong>Splitting</strong> the data into groups based on some criteria</p></li> <li><p><strong>Applying</strong> a function to each group independently</p></li> <li><p><strong>Combining</strong> the results into a data structure</p></li> </ul> </div>\n</blockquote> <p>See the <a class=\"reference internal\" href=\"groupby#groupby\"><span class=\"std std-ref\">Grouping section</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [87]: df = pd.DataFrame(\n   ....:     {\n   ....:         \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n   ....:         \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n   ....:         \"C\": np.random.randn(8),\n   ....:         \"D\": np.random.randn(8),\n   ....:     }\n   ....: )\n   ....: \n\nIn [88]: df\nOut[88]: \n     A      B         C         D\n0  foo    one  1.346061 -1.577585\n1  bar    one  1.511763  0.396823\n2  foo    two  1.627081 -0.105381\n3  bar  three -0.990582 -0.532532\n4  foo    two -0.441652  1.453749\n5  bar    two  1.211526  1.208843\n6  foo    one  0.268520 -0.080952\n7  foo  three  0.024580 -0.264610\n</pre></div> </div> <p>Grouping and then applying the <a class=\"reference internal\" href=\"../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum\" title=\"pandas.core.groupby.GroupBy.sum\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">sum()</span></code></a> function to the resulting groups:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [89]: df.groupby(\"A\").sum()\nOut[89]: \n            C         D\nA                      \nbar  1.732707  1.073134\nfoo  2.824590 -0.574779\n</pre></div> </div> <p>Grouping by multiple columns forms a hierarchical index, and again we can apply the <a class=\"reference internal\" href=\"../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum\" title=\"pandas.core.groupby.GroupBy.sum\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">sum()</span></code></a> function:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [90]: df.groupby([\"A\", \"B\"]).sum()\nOut[90]: \n                  C         D\nA   B                        \nbar one    1.511763  0.396823\n    three -0.990582 -0.532532\n    two    1.211526  1.208843\nfoo one    1.614581 -1.658537\n    three  0.024580 -0.264610\n    two    1.185429  1.348368\n</pre></div> </div> </section> <section id=\"reshaping\"> <h2>Reshaping</h2> <p>See the sections on <a class=\"reference internal\" href=\"advanced#advanced-hierarchical\"><span class=\"std std-ref\">Hierarchical Indexing</span></a> and <a class=\"reference internal\" href=\"reshaping#reshaping-stacking\"><span class=\"std std-ref\">Reshaping</span></a>.</p> <section id=\"stack\"> <h3>Stack</h3> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [91]: tuples = list(\n   ....:     zip(\n   ....:         *[\n   ....:             [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n   ....:             [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n   ....:         ]\n   ....:     )\n   ....: )\n   ....: \n\nIn [92]: index = pd.MultiIndex.from_tuples(tuples, names=[\"first\", \"second\"])\n\nIn [93]: df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=[\"A\", \"B\"])\n\nIn [94]: df2 = df[:4]\n\nIn [95]: df2\nOut[95]: \n                     A         B\nfirst second                    \nbar   one    -0.727965 -0.589346\n      two     0.339969 -0.693205\nbaz   one    -0.339355  0.593616\n      two     0.884345  1.591431\n</pre></div> </div> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.stack#pandas.DataFrame.stack\" title=\"pandas.DataFrame.stack\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">stack()</span></code></a> method “compresses” a level in the DataFrame’s columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [96]: stacked = df2.stack()\n\nIn [97]: stacked\nOut[97]: \nfirst  second   \nbar    one     A   -0.727965\n               B   -0.589346\n       two     A    0.339969\n               B   -0.693205\nbaz    one     A   -0.339355\n               B    0.593616\n       two     A    0.884345\n               B    1.591431\ndtype: float64\n</pre></div> </div> <p>With a “stacked” DataFrame or Series (having a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> as the <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>), the inverse operation of <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.stack#pandas.DataFrame.stack\" title=\"pandas.DataFrame.stack\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">stack()</span></code></a> is <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.unstack#pandas.DataFrame.unstack\" title=\"pandas.DataFrame.unstack\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">unstack()</span></code></a>, which by default unstacks the <strong>last level</strong>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [98]: stacked.unstack()\nOut[98]: \n                     A         B\nfirst second                    \nbar   one    -0.727965 -0.589346\n      two     0.339969 -0.693205\nbaz   one    -0.339355  0.593616\n      two     0.884345  1.591431\n\nIn [99]: stacked.unstack(1)\nOut[99]: \nsecond        one       two\nfirst                      \nbar   A -0.727965  0.339969\n      B -0.589346 -0.693205\nbaz   A -0.339355  0.884345\n      B  0.593616  1.591431\n\nIn [100]: stacked.unstack(0)\nOut[100]: \nfirst          bar       baz\nsecond                      \none    A -0.727965 -0.339355\n       B -0.589346  0.593616\ntwo    A  0.339969  0.884345\n       B -0.693205  1.591431\n</pre></div> </div> </section> <section id=\"pivot-tables\"> <h3>Pivot tables</h3> <p>See the section on <a class=\"reference internal\" href=\"reshaping#reshaping-pivot\"><span class=\"std std-ref\">Pivot Tables</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [101]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": [\"one\", \"one\", \"two\", \"three\"] * 3,\n   .....:         \"B\": [\"A\", \"B\", \"C\"] * 4,\n   .....:         \"C\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\"] * 2,\n   .....:         \"D\": np.random.randn(12),\n   .....:         \"E\": np.random.randn(12),\n   .....:     }\n   .....: )\n   .....: \n\nIn [102]: df\nOut[102]: \n        A  B    C         D         E\n0     one  A  foo -1.202872  0.047609\n1     one  B  foo -1.814470 -0.136473\n2     two  C  foo  1.018601 -0.561757\n3   three  A  bar -0.595447 -1.623033\n4     one  B  bar  1.395433  0.029399\n5     one  C  bar -0.392670 -0.542108\n6     two  A  foo  0.007207  0.282696\n7   three  B  foo  1.928123 -0.087302\n8     one  C  foo -0.055224 -1.575170\n9     one  A  bar  2.395985  1.771208\n10    two  B  bar  1.552825  0.816482\n11  three  C  bar  0.166599  1.100230\n</pre></div> </div> <p>We can produce pivot tables from this data very easily:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [103]: pd.pivot_table(df, values=\"D\", index=[\"A\", \"B\"], columns=[\"C\"])\nOut[103]: \nC             bar       foo\nA     B                    \none   A  2.395985 -1.202872\n      B  1.395433 -1.814470\n      C -0.392670 -0.055224\nthree A -0.595447       NaN\n      B       NaN  1.928123\n      C  0.166599       NaN\ntwo   A       NaN  0.007207\n      B  1.552825       NaN\n      C       NaN  1.018601\n</pre></div> </div> </section> </section> <section id=\"time-series\"> <h2>Time series</h2> <p>pandas has simple, powerful, and efficient functionality for performing resampling operations during frequency conversion (e.g., converting secondly data into 5-minutely data). This is extremely common in, but not limited to, financial applications. See the <a class=\"reference internal\" href=\"timeseries#timeseries\"><span class=\"std std-ref\">Time Series section</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [104]: rng = pd.date_range(\"1/1/2012\", periods=100, freq=\"S\")\n\nIn [105]: ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)\n\nIn [106]: ts.resample(\"5Min\").sum()\nOut[106]: \n2012-01-01    24182\nFreq: 5T, dtype: int64\n</pre></div> </div> <p>Time zone representation:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [107]: rng = pd.date_range(\"3/6/2012 00:00\", periods=5, freq=\"D\")\n\nIn [108]: ts = pd.Series(np.random.randn(len(rng)), rng)\n\nIn [109]: ts\nOut[109]: \n2012-03-06    1.857704\n2012-03-07   -1.193545\n2012-03-08    0.677510\n2012-03-09   -0.153931\n2012-03-10    0.520091\nFreq: D, dtype: float64\n\nIn [110]: ts_utc = ts.tz_localize(\"UTC\")\n\nIn [111]: ts_utc\nOut[111]: \n2012-03-06 00:00:00+00:00    1.857704\n2012-03-07 00:00:00+00:00   -1.193545\n2012-03-08 00:00:00+00:00    0.677510\n2012-03-09 00:00:00+00:00   -0.153931\n2012-03-10 00:00:00+00:00    0.520091\nFreq: D, dtype: float64\n</pre></div> </div> <p>Converting to another time zone:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [112]: ts_utc.tz_convert(\"US/Eastern\")\nOut[112]: \n2012-03-05 19:00:00-05:00    1.857704\n2012-03-06 19:00:00-05:00   -1.193545\n2012-03-07 19:00:00-05:00    0.677510\n2012-03-08 19:00:00-05:00   -0.153931\n2012-03-09 19:00:00-05:00    0.520091\nFreq: D, dtype: float64\n</pre></div> </div> <p>Converting between time span representations:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [113]: rng = pd.date_range(\"1/1/2012\", periods=5, freq=\"M\")\n\nIn [114]: ts = pd.Series(np.random.randn(len(rng)), index=rng)\n\nIn [115]: ts\nOut[115]: \n2012-01-31   -1.475051\n2012-02-29    0.722570\n2012-03-31   -0.322646\n2012-04-30   -1.601631\n2012-05-31    0.778033\nFreq: M, dtype: float64\n\nIn [116]: ps = ts.to_period()\n\nIn [117]: ps\nOut[117]: \n2012-01   -1.475051\n2012-02    0.722570\n2012-03   -0.322646\n2012-04   -1.601631\n2012-05    0.778033\nFreq: M, dtype: float64\n\nIn [118]: ps.to_timestamp()\nOut[118]: \n2012-01-01   -1.475051\n2012-02-01    0.722570\n2012-03-01   -0.322646\n2012-04-01   -1.601631\n2012-05-01    0.778033\nFreq: MS, dtype: float64\n</pre></div> </div> <p>Converting between period and timestamp enables some convenient arithmetic functions to be used. In the following example, we convert a quarterly frequency with year ending in November to 9am of the end of the month following the quarter end:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [119]: prng = pd.period_range(\"1990Q1\", \"2000Q4\", freq=\"Q-NOV\")\n\nIn [120]: ts = pd.Series(np.random.randn(len(prng)), prng)\n\nIn [121]: ts.index = (prng.asfreq(\"M\", \"e\") + 1).asfreq(\"H\", \"s\") + 9\n\nIn [122]: ts.head()\nOut[122]: \n1990-03-01 09:00   -0.289342\n1990-06-01 09:00    0.233141\n1990-09-01 09:00   -0.223540\n1990-12-01 09:00    0.542054\n1991-03-01 09:00   -0.688585\nFreq: H, dtype: float64\n</pre></div> </div> </section> <section id=\"categoricals\"> <h2>Categoricals</h2> <p>pandas can include categorical data in a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a>. For full docs, see the <a class=\"reference internal\" href=\"categorical#categorical\"><span class=\"std std-ref\">categorical introduction</span></a> and the <a class=\"reference internal\" href=\"../reference/arrays#api-arrays-categorical\"><span class=\"std std-ref\">API documentation</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [123]: df = pd.DataFrame(\n   .....:     {\"id\": [1, 2, 3, 4, 5, 6], \"raw_grade\": [\"a\", \"b\", \"b\", \"a\", \"a\", \"e\"]}\n   .....: )\n   .....: \n</pre></div> </div> <p>Converting the raw grades to a categorical data type:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [124]: df[\"grade\"] = df[\"raw_grade\"].astype(\"category\")\n\nIn [125]: df[\"grade\"]\nOut[125]: \n0    a\n1    b\n2    b\n3    a\n4    a\n5    e\nName: grade, dtype: category\nCategories (3, object): ['a', 'b', 'e']\n</pre></div> </div> <p>Rename the categories to more meaningful names (assigning to <a class=\"reference internal\" href=\"../reference/api/pandas.series.cat.categories#pandas.Series.cat.categories\" title=\"pandas.Series.cat.categories\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.cat.categories()</span></code></a> is in place!):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [126]: df[\"grade\"].cat.categories = [\"very good\", \"good\", \"very bad\"]\n</pre></div> </div> <p>Reorder the categories and simultaneously add the missing categories (methods under <a class=\"reference internal\" href=\"../reference/api/pandas.series.cat#pandas.Series.cat\" title=\"pandas.Series.cat\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.cat()</span></code></a> return a new <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> by default):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [127]: df[\"grade\"] = df[\"grade\"].cat.set_categories(\n   .....:     [\"very bad\", \"bad\", \"medium\", \"good\", \"very good\"]\n   .....: )\n   .....: \n\nIn [128]: df[\"grade\"]\nOut[128]: \n0    very good\n1         good\n2         good\n3    very good\n4    very good\n5     very bad\nName: grade, dtype: category\nCategories (5, object): ['very bad', 'bad', 'medium', 'good', 'very good']\n</pre></div> </div> <p>Sorting is per order in the categories, not lexical order:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [129]: df.sort_values(by=\"grade\")\nOut[129]: \n   id raw_grade      grade\n5   6         e   very bad\n1   2         b       good\n2   3         b       good\n0   1         a  very good\n3   4         a  very good\n4   5         a  very good\n</pre></div> </div> <p>Grouping by a categorical column also shows empty categories:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [130]: df.groupby(\"grade\").size()\nOut[130]: \ngrade\nvery bad     1\nbad          0\nmedium       0\ngood         2\nvery good    3\ndtype: int64\n</pre></div> </div> </section> <section id=\"plotting\"> <h2>Plotting</h2> <p>See the <a class=\"reference internal\" href=\"visualization#visualization\"><span class=\"std std-ref\">Plotting</span></a> docs.</p> <p>We use the standard convention for referencing the matplotlib API:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [131]: import matplotlib.pyplot as plt\n\nIn [132]: plt.close(\"all\")\n</pre></div> </div> <p>The <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">close()</span></code> method is used to <a class=\"reference external\" href=\"https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.close.html\">close</a> a figure window:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [133]: ts = pd.Series(np.random.randn(1000), index=pd.date_range(\"1/1/2000\", periods=1000))\n\nIn [134]: ts = ts.cumsum()\n\nIn [135]: ts.plot();\n</pre></div> </div> <img alt=\"../_images/series_plot_basic.png\" src=\"data:image/png;base64,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\"> <p>If running under Jupyter Notebook, the plot will appear on <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">plot()</span></code>. Otherwise use <a class=\"reference external\" href=\"https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.show.html\">matplotlib.pyplot.show</a> to show it or <a class=\"reference external\" href=\"https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.savefig.html\">matplotlib.pyplot.savefig</a> to write it to a file.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [136]: plt.show();\n</pre></div> </div> <p>On a DataFrame, the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.plot#pandas.DataFrame.plot\" title=\"pandas.DataFrame.plot\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">plot()</span></code></a> method is a convenience to plot all of the columns with labels:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [137]: df = pd.DataFrame(\n   .....:     np.random.randn(1000, 4), index=ts.index, columns=[\"A\", \"B\", \"C\", \"D\"]\n   .....: )\n   .....: \n\nIn [138]: df = df.cumsum()\n\nIn [139]: plt.figure();\n\nIn [140]: df.plot();\n\nIn [141]: plt.legend(loc='best');\n</pre></div> </div> <img alt=\"../_images/frame_plot_basic.png\" src=\"data:image/png;base64,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\"> </section> <section id=\"getting-data-in-out\"> <h2>Getting data in/out</h2> <section id=\"csv\"> <h3>CSV</h3> <p><a class=\"reference internal\" href=\"io#io-store-in-csv\"><span class=\"std std-ref\">Writing to a csv file:</span></a></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [142]: df.to_csv(\"foo.csv\")\n</pre></div> </div> <p><a class=\"reference internal\" href=\"io#io-read-csv-table\"><span class=\"std std-ref\">Reading from a csv file:</span></a></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [143]: pd.read_csv(\"foo.csv\")\nOut[143]: \n     Unnamed: 0          A          B          C          D\n0    2000-01-01   0.350262   0.843315   1.798556   0.782234\n1    2000-01-02  -0.586873   0.034907   1.923792  -0.562651\n2    2000-01-03  -1.245477  -0.963406   2.269575  -1.612566\n3    2000-01-04  -0.252830  -0.498066   3.176886  -1.275581\n4    2000-01-05  -1.044057   0.118042   2.768571   0.386039\n..          ...        ...        ...        ...        ...\n995  2002-09-22 -48.017654  31.474551  69.146374 -47.541670\n996  2002-09-23 -47.207912  32.627390  68.505254 -48.828331\n997  2002-09-24 -48.907133  31.990402  67.310924 -49.391051\n998  2002-09-25 -50.146062  33.716770  67.717434 -49.037577\n999  2002-09-26 -49.724318  33.479952  68.108014 -48.822030\n\n[1000 rows x 5 columns]\n</pre></div> </div> </section> <section id=\"hdf5\"> <h3>HDF5</h3> <p>Reading and writing to <a class=\"reference internal\" href=\"io#io-hdf5\"><span class=\"std std-ref\">HDFStores</span></a>.</p> <p>Writing to a HDF5 Store:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [144]: df.to_hdf(\"foo.h5\", \"df\")\n</pre></div> </div> <p>Reading from a HDF5 Store:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [145]: pd.read_hdf(\"foo.h5\", \"df\")\nOut[145]: \n                    A          B          C          D\n2000-01-01   0.350262   0.843315   1.798556   0.782234\n2000-01-02  -0.586873   0.034907   1.923792  -0.562651\n2000-01-03  -1.245477  -0.963406   2.269575  -1.612566\n2000-01-04  -0.252830  -0.498066   3.176886  -1.275581\n2000-01-05  -1.044057   0.118042   2.768571   0.386039\n...               ...        ...        ...        ...\n2002-09-22 -48.017654  31.474551  69.146374 -47.541670\n2002-09-23 -47.207912  32.627390  68.505254 -48.828331\n2002-09-24 -48.907133  31.990402  67.310924 -49.391051\n2002-09-25 -50.146062  33.716770  67.717434 -49.037577\n2002-09-26 -49.724318  33.479952  68.108014 -48.822030\n\n[1000 rows x 4 columns]\n</pre></div> </div> </section> <section id=\"excel\"> <h3>Excel</h3> <p>Reading and writing to <a class=\"reference internal\" href=\"io#io-excel\"><span class=\"std std-ref\">MS Excel</span></a>.</p> <p>Writing to an excel file:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [146]: df.to_excel(\"foo.xlsx\", sheet_name=\"Sheet1\")\n</pre></div> </div> <p>Reading from an excel file:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [147]: pd.read_excel(\"foo.xlsx\", \"Sheet1\", index_col=None, na_values=[\"NA\"])\nOut[147]: \n    Unnamed: 0          A          B          C          D\n0   2000-01-01   0.350262   0.843315   1.798556   0.782234\n1   2000-01-02  -0.586873   0.034907   1.923792  -0.562651\n2   2000-01-03  -1.245477  -0.963406   2.269575  -1.612566\n3   2000-01-04  -0.252830  -0.498066   3.176886  -1.275581\n4   2000-01-05  -1.044057   0.118042   2.768571   0.386039\n..         ...        ...        ...        ...        ...\n995 2002-09-22 -48.017654  31.474551  69.146374 -47.541670\n996 2002-09-23 -47.207912  32.627390  68.505254 -48.828331\n997 2002-09-24 -48.907133  31.990402  67.310924 -49.391051\n998 2002-09-25 -50.146062  33.716770  67.717434 -49.037577\n999 2002-09-26 -49.724318  33.479952  68.108014 -48.822030\n\n[1000 rows x 5 columns]\n</pre></div> </div> </section> </section> <section id=\"gotchas\"> <h2>Gotchas</h2> <p>If you are attempting to perform an operation you might see an exception like:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; if pd.Series([False, True, False]):\n...     print(\"I was true\")\nTraceback\n    ...\nValueError: The truth value of an array is ambiguous. Use a.empty, a.any() or a.all().\n</pre></div> </div> <p>See <a class=\"reference internal\" href=\"basics#basics-compare\"><span class=\"std std-ref\">Comparisons</span></a> for an explanation and what to do.</p> <p>See <a class=\"reference internal\" href=\"gotchas#gotchas\"><span class=\"std std-ref\">Gotchas</span></a> as well.</p> </section><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>\n    <a href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/10min.html\" class=\"_attribution-link\">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/10min.html</a>\n  </p>\n</div>\n","user_guide/dsintro":"<h1>Intro to data structures</h1> <p>We’ll start with a quick, non-comprehensive overview of the fundamental data structures in pandas to get you started. The fundamental behavior about data types, indexing, and axis labeling / alignment apply across all of the objects. To get started, import NumPy and load pandas into your namespace:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [1]: import numpy as np\n\nIn [2]: import pandas as pd\n</pre></div> </div> <p>Here is a basic tenet to keep in mind: <strong>data alignment is intrinsic</strong>. The link between labels and data will not be broken unless done so explicitly by you.</p> <p>We’ll give a brief intro to the data structures, then consider all of the broad categories of functionality and methods in separate sections.</p> <section id=\"series\"> <h2>Series</h2> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> is a one-dimensional labeled array capable of holding any data type (integers, strings, floating point numbers, Python objects, etc.). The axis labels are collectively referred to as the <strong>index</strong>. The basic method to create a Series is to call:</p> <div class=\"highlight-default notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; s = pd.Series(data, index=index)\n</pre></div> </div> <p>Here, <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code> can be many different things:</p> <ul class=\"simple\"> <li><p>a Python dict</p></li> <li><p>an ndarray</p></li> <li><p>a scalar value (like 5)</p></li> </ul> <p>The passed <strong>index</strong> is a list of axis labels. Thus, this separates into a few cases depending on what <strong>data is</strong>:</p> <p><strong>From ndarray</strong></p> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code> is an ndarray, <strong>index</strong> must be the same length as <strong>data</strong>. If no index is passed, one will be created having values <code class=\"docutils literal notranslate\"><span class=\"pre\">[0,</span> <span class=\"pre\">...,</span> <span class=\"pre\">len(data)</span> <span class=\"pre\">-</span> <span class=\"pre\">1]</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [3]: s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\nIn [4]: s\nOut[4]: \na    0.469112\nb   -0.282863\nc   -1.509059\nd   -1.135632\ne    1.212112\ndtype: float64\n\nIn [5]: s.index\nOut[5]: Index(['a', 'b', 'c', 'd', 'e'], dtype='object')\n\nIn [6]: pd.Series(np.random.randn(5))\nOut[6]: \n0   -0.173215\n1    0.119209\n2   -1.044236\n3   -0.861849\n4   -2.104569\ndtype: float64\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>pandas supports non-unique index values. If an operation that does not support duplicate index values is attempted, an exception will be raised at that time. The reason for being lazy is nearly all performance-based (there are many instances in computations, like parts of GroupBy, where the index is not used).</p> </div> <p><strong>From dict</strong></p> <p>Series can be instantiated from dicts:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [7]: d = {\"b\": 1, \"a\": 0, \"c\": 2}\n\nIn [8]: pd.Series(d)\nOut[8]: \nb    1\na    0\nc    2\ndtype: int64\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>When the data is a dict, and an index is not passed, the <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> index will be ordered by the dict’s insertion order, if you’re using Python version &gt;= 3.6 and pandas version &gt;= 0.23.</p> <p>If you’re using Python &lt; 3.6 or pandas &lt; 0.23, and an index is not passed, the <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> index will be the lexically ordered list of dict keys.</p> </div> <p>In the example above, if you were on a Python version lower than 3.6 or a pandas version lower than 0.23, the <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> would be ordered by the lexical order of the dict keys (i.e. <code class=\"docutils literal notranslate\"><span class=\"pre\">['a',</span> <span class=\"pre\">'b',</span> <span class=\"pre\">'c']</span></code> rather than <code class=\"docutils literal notranslate\"><span class=\"pre\">['b',</span> <span class=\"pre\">'a',</span> <span class=\"pre\">'c']</span></code>).</p> <p>If an index is passed, the values in data corresponding to the labels in the index will be pulled out.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [9]: d = {\"a\": 0.0, \"b\": 1.0, \"c\": 2.0}\n\nIn [10]: pd.Series(d)\nOut[10]: \na    0.0\nb    1.0\nc    2.0\ndtype: float64\n\nIn [11]: pd.Series(d, index=[\"b\", \"c\", \"d\", \"a\"])\nOut[11]: \nb    1.0\nc    2.0\nd    NaN\na    0.0\ndtype: float64\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>NaN (not a number) is the standard missing data marker used in pandas.</p> </div> <p><strong>From scalar value</strong></p> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code> is a scalar value, an index must be provided. The value will be repeated to match the length of <strong>index</strong>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [12]: pd.Series(5.0, index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\nOut[12]: \na    5.0\nb    5.0\nc    5.0\nd    5.0\ne    5.0\ndtype: float64\n</pre></div> </div> <section id=\"series-is-ndarray-like\"> <h3>Series is ndarray-like</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> acts very similarly to a <code class=\"docutils literal notranslate\"><span class=\"pre\">ndarray</span></code>, and is a valid argument to most NumPy functions. However, operations such as slicing will also slice the index.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [13]: s[0]\nOut[13]: 0.4691122999071863\n\nIn [14]: s[:3]\nOut[14]: \na    0.469112\nb   -0.282863\nc   -1.509059\ndtype: float64\n\nIn [15]: s[s &gt; s.median()]\nOut[15]: \na    0.469112\ne    1.212112\ndtype: float64\n\nIn [16]: s[[4, 3, 1]]\nOut[16]: \ne    1.212112\nd   -1.135632\nb   -0.282863\ndtype: float64\n\nIn [17]: np.exp(s)\nOut[17]: \na    1.598575\nb    0.753623\nc    0.221118\nd    0.321219\ne    3.360575\ndtype: float64\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>We will address array-based indexing like <code class=\"docutils literal notranslate\"><span class=\"pre\">s[[4,</span> <span class=\"pre\">3,</span> <span class=\"pre\">1]]</span></code> in <a class=\"reference internal\" href=\"indexing#indexing\"><span class=\"std std-ref\">section on indexing</span></a>.</p> </div> <p>Like a NumPy array, a pandas Series has a <a class=\"reference internal\" href=\"../reference/api/pandas.series.dtype#pandas.Series.dtype\" title=\"pandas.Series.dtype\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">dtype</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [18]: s.dtype\nOut[18]: dtype('float64')\n</pre></div> </div> <p>This is often a NumPy dtype. However, pandas and 3rd-party libraries extend NumPy’s type system in a few places, in which case the dtype would be an <a class=\"reference internal\" href=\"../reference/api/pandas.api.extensions.extensiondtype#pandas.api.extensions.ExtensionDtype\" title=\"pandas.api.extensions.ExtensionDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExtensionDtype</span></code></a>. Some examples within pandas are <a class=\"reference internal\" href=\"categorical#categorical\"><span class=\"std std-ref\">Categorical data</span></a> and <a class=\"reference internal\" href=\"integer_na#integer-na\"><span class=\"std std-ref\">Nullable integer data type</span></a>. See <a class=\"reference internal\" href=\"basics#basics-dtypes\"><span class=\"std std-ref\">dtypes</span></a> for more.</p> <p>If you need the actual array backing a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>, use <a class=\"reference internal\" href=\"../reference/api/pandas.series.array#pandas.Series.array\" title=\"pandas.Series.array\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">Series.array</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [19]: s.array\nOut[19]: \n&lt;PandasArray&gt;\n[ 0.4691122999071863, -0.2828633443286633, -1.5090585031735124,\n -1.1356323710171934,  1.2121120250208506]\nLength: 5, dtype: float64\n</pre></div> </div> <p>Accessing the array can be useful when you need to do some operation without the index (to disable <a class=\"reference internal\" href=\"#dsintro-alignment\"><span class=\"std std-ref\">automatic alignment</span></a>, for example).</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.array#pandas.Series.array\" title=\"pandas.Series.array\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">Series.array</span></code></a> will always be an <a class=\"reference internal\" href=\"../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray\" title=\"pandas.api.extensions.ExtensionArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code></a>. Briefly, an ExtensionArray is a thin wrapper around one or more <em>concrete</em> arrays like a <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">numpy.ndarray</span></code></a>. pandas knows how to take an <code class=\"docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code> and store it in a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> or a column of a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>. See <a class=\"reference internal\" href=\"basics#basics-dtypes\"><span class=\"std std-ref\">dtypes</span></a> for more.</p> <p>While Series is ndarray-like, if you need an <em>actual</em> ndarray, then use <a class=\"reference internal\" href=\"../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy\" title=\"pandas.Series.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.to_numpy()</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [20]: s.to_numpy()\nOut[20]: array([ 0.4691, -0.2829, -1.5091, -1.1356,  1.2121])\n</pre></div> </div> <p>Even if the Series is backed by a <a class=\"reference internal\" href=\"../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray\" title=\"pandas.api.extensions.ExtensionArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy\" title=\"pandas.Series.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.to_numpy()</span></code></a> will return a NumPy ndarray.</p> </section> <section id=\"series-is-dict-like\"> <h3>Series is dict-like</h3> <p>A Series is like a fixed-size dict in that you can get and set values by index label:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [21]: s[\"a\"]\nOut[21]: 0.4691122999071863\n\nIn [22]: s[\"e\"] = 12.0\n\nIn [23]: s\nOut[23]: \na     0.469112\nb    -0.282863\nc    -1.509059\nd    -1.135632\ne    12.000000\ndtype: float64\n\nIn [24]: \"e\" in s\nOut[24]: True\n\nIn [25]: \"f\" in s\nOut[25]: False\n</pre></div> </div> <p>If a label is not contained, an exception is raised:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; s[\"f\"]\nKeyError: 'f'\n</pre></div> </div> <p>Using the <code class=\"docutils literal notranslate\"><span class=\"pre\">get</span></code> method, a missing label will return None or specified default:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [26]: s.get(\"f\")\n\nIn [27]: s.get(\"f\", np.nan)\nOut[27]: nan\n</pre></div> </div> <p>See also the <a class=\"reference internal\" href=\"indexing#indexing-attribute-access\"><span class=\"std std-ref\">section on attribute access</span></a>.</p> </section> <section id=\"vectorized-operations-and-label-alignment-with-series\"> <h3>Vectorized operations and label alignment with Series</h3> <p>When working with raw NumPy arrays, looping through value-by-value is usually not necessary. The same is true when working with Series in pandas. Series can also be passed into most NumPy methods expecting an ndarray.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [28]: s + s\nOut[28]: \na     0.938225\nb    -0.565727\nc    -3.018117\nd    -2.271265\ne    24.000000\ndtype: float64\n\nIn [29]: s * 2\nOut[29]: \na     0.938225\nb    -0.565727\nc    -3.018117\nd    -2.271265\ne    24.000000\ndtype: float64\n\nIn [30]: np.exp(s)\nOut[30]: \na         1.598575\nb         0.753623\nc         0.221118\nd         0.321219\ne    162754.791419\ndtype: float64\n</pre></div> </div> <p>A key difference between Series and ndarray is that operations between Series automatically align the data based on label. Thus, you can write computations without giving consideration to whether the Series involved have the same labels.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [31]: s[1:] + s[:-1]\nOut[31]: \na         NaN\nb   -0.565727\nc   -3.018117\nd   -2.271265\ne         NaN\ndtype: float64\n</pre></div> </div> <p>The result of an operation between unaligned Series will have the <strong>union</strong> of the indexes involved. If a label is not found in one Series or the other, the result will be marked as missing <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>. Being able to write code without doing any explicit data alignment grants immense freedom and flexibility in interactive data analysis and research. The integrated data alignment features of the pandas data structures set pandas apart from the majority of related tools for working with labeled data.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>In general, we chose to make the default result of operations between differently indexed objects yield the <strong>union</strong> of the indexes in order to avoid loss of information. Having an index label, though the data is missing, is typically important information as part of a computation. You of course have the option of dropping labels with missing data via the <strong>dropna</strong> function.</p> </div> </section> <section id=\"name-attribute\"> <h3>Name attribute</h3> <p id=\"dsintro-name-attribute\">Series can also have a <code class=\"docutils literal notranslate\"><span class=\"pre\">name</span></code> attribute:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [32]: s = pd.Series(np.random.randn(5), name=\"something\")\n\nIn [33]: s\nOut[33]: \n0   -0.494929\n1    1.071804\n2    0.721555\n3   -0.706771\n4   -1.039575\nName: something, dtype: float64\n\nIn [34]: s.name\nOut[34]: 'something'\n</pre></div> </div> <p>The Series <code class=\"docutils literal notranslate\"><span class=\"pre\">name</span></code> will be assigned automatically in many cases, in particular when taking 1D slices of DataFrame as you will see below.</p> <p>You can rename a Series with the <a class=\"reference internal\" href=\"../reference/api/pandas.series.rename#pandas.Series.rename\" title=\"pandas.Series.rename\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">pandas.Series.rename()</span></code></a> method.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [35]: s2 = s.rename(\"different\")\n\nIn [36]: s2.name\nOut[36]: 'different'\n</pre></div> </div> <p>Note that <code class=\"docutils literal notranslate\"><span class=\"pre\">s</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">s2</span></code> refer to different objects.</p> </section> </section> <section id=\"dataframe\"> <h2>DataFrame</h2> <p><strong>DataFrame</strong> is a 2-dimensional labeled data structure with columns of potentially different types. You can think of it like a spreadsheet or SQL table, or a dict of Series objects. It is generally the most commonly used pandas object. Like Series, DataFrame accepts many different kinds of input:</p> <ul class=\"simple\"> <li><p>Dict of 1D ndarrays, lists, dicts, or Series</p></li> <li><p>2-D numpy.ndarray</p></li> <li><p><a class=\"reference external\" href=\"https://numpy.org/doc/stable/user/basics.rec.html\">Structured or record</a> ndarray</p></li> <li><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code></p></li> <li><p>Another <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></p></li> </ul> <p>Along with the data, you can optionally pass <strong>index</strong> (row labels) and <strong>columns</strong> (column labels) arguments. If you pass an index and / or columns, you are guaranteeing the index and / or columns of the resulting DataFrame. Thus, a dict of Series plus a specific index will discard all data not matching up to the passed index.</p> <p>If axis labels are not passed, they will be constructed from the input data based on common sense rules.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>When the data is a dict, and <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> is not specified, the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> columns will be ordered by the dict’s insertion order, if you are using Python version &gt;= 3.6 and pandas &gt;= 0.23.</p> <p>If you are using Python &lt; 3.6 or pandas &lt; 0.23, and <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> is not specified, the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> columns will be the lexically ordered list of dict keys.</p> </div> <section id=\"from-dict-of-series-or-dicts\"> <h3>From dict of Series or dicts</h3> <p>The resulting <strong>index</strong> will be the <strong>union</strong> of the indexes of the various Series. If there are any nested dicts, these will first be converted to Series. If no columns are passed, the columns will be the ordered list of dict keys.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [37]: d = {\n   ....:     \"one\": pd.Series([1.0, 2.0, 3.0], index=[\"a\", \"b\", \"c\"]),\n   ....:     \"two\": pd.Series([1.0, 2.0, 3.0, 4.0], index=[\"a\", \"b\", \"c\", \"d\"]),\n   ....: }\n   ....: \n\nIn [38]: df = pd.DataFrame(d)\n\nIn [39]: df\nOut[39]: \n   one  two\na  1.0  1.0\nb  2.0  2.0\nc  3.0  3.0\nd  NaN  4.0\n\nIn [40]: pd.DataFrame(d, index=[\"d\", \"b\", \"a\"])\nOut[40]: \n   one  two\nd  NaN  4.0\nb  2.0  2.0\na  1.0  1.0\n\nIn [41]: pd.DataFrame(d, index=[\"d\", \"b\", \"a\"], columns=[\"two\", \"three\"])\nOut[41]: \n   two three\nd  4.0   NaN\nb  2.0   NaN\na  1.0   NaN\n</pre></div> </div> <p>The row and column labels can be accessed respectively by accessing the <strong>index</strong> and <strong>columns</strong> attributes:</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>When a particular set of columns is passed along with a dict of data, the passed columns override the keys in the dict.</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [42]: df.index\nOut[42]: Index(['a', 'b', 'c', 'd'], dtype='object')\n\nIn [43]: df.columns\nOut[43]: Index(['one', 'two'], dtype='object')\n</pre></div> </div> </section> <section id=\"from-dict-of-ndarrays-lists\"> <h3>From dict of ndarrays / lists</h3> <p>The ndarrays must all be the same length. If an index is passed, it must clearly also be the same length as the arrays. If no index is passed, the result will be <code class=\"docutils literal notranslate\"><span class=\"pre\">range(n)</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> is the array length.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [44]: d = {\"one\": [1.0, 2.0, 3.0, 4.0], \"two\": [4.0, 3.0, 2.0, 1.0]}\n\nIn [45]: pd.DataFrame(d)\nOut[45]: \n   one  two\n0  1.0  4.0\n1  2.0  3.0\n2  3.0  2.0\n3  4.0  1.0\n\nIn [46]: pd.DataFrame(d, index=[\"a\", \"b\", \"c\", \"d\"])\nOut[46]: \n   one  two\na  1.0  4.0\nb  2.0  3.0\nc  3.0  2.0\nd  4.0  1.0\n</pre></div> </div> </section> <section id=\"from-structured-or-record-array\"> <h3>From structured or record array</h3> <p>This case is handled identically to a dict of arrays.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [47]: data = np.zeros((2,), dtype=[(\"A\", \"i4\"), (\"B\", \"f4\"), (\"C\", \"a10\")])\n\nIn [48]: data[:] = [(1, 2.0, \"Hello\"), (2, 3.0, \"World\")]\n\nIn [49]: pd.DataFrame(data)\nOut[49]: \n   A    B         C\n0  1  2.0  b'Hello'\n1  2  3.0  b'World'\n\nIn [50]: pd.DataFrame(data, index=[\"first\", \"second\"])\nOut[50]: \n        A    B         C\nfirst   1  2.0  b'Hello'\nsecond  2  3.0  b'World'\n\nIn [51]: pd.DataFrame(data, columns=[\"C\", \"A\", \"B\"])\nOut[51]: \n          C  A    B\n0  b'Hello'  1  2.0\n1  b'World'  2  3.0\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>DataFrame is not intended to work exactly like a 2-dimensional NumPy ndarray.</p> </div> </section> <section id=\"from-a-list-of-dicts\"> <h3>From a list of dicts</h3> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [52]: data2 = [{\"a\": 1, \"b\": 2}, {\"a\": 5, \"b\": 10, \"c\": 20}]\n\nIn [53]: pd.DataFrame(data2)\nOut[53]: \n   a   b     c\n0  1   2   NaN\n1  5  10  20.0\n\nIn [54]: pd.DataFrame(data2, index=[\"first\", \"second\"])\nOut[54]: \n        a   b     c\nfirst   1   2   NaN\nsecond  5  10  20.0\n\nIn [55]: pd.DataFrame(data2, columns=[\"a\", \"b\"])\nOut[55]: \n   a   b\n0  1   2\n1  5  10\n</pre></div> </div> </section> <section id=\"from-a-dict-of-tuples\"> <h3>From a dict of tuples</h3> <p>You can automatically create a MultiIndexed frame by passing a tuples dictionary.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [56]: pd.DataFrame(\n   ....:     {\n   ....:         (\"a\", \"b\"): {(\"A\", \"B\"): 1, (\"A\", \"C\"): 2},\n   ....:         (\"a\", \"a\"): {(\"A\", \"C\"): 3, (\"A\", \"B\"): 4},\n   ....:         (\"a\", \"c\"): {(\"A\", \"B\"): 5, (\"A\", \"C\"): 6},\n   ....:         (\"b\", \"a\"): {(\"A\", \"C\"): 7, (\"A\", \"B\"): 8},\n   ....:         (\"b\", \"b\"): {(\"A\", \"D\"): 9, (\"A\", \"B\"): 10},\n   ....:     }\n   ....: )\n   ....: \nOut[56]: \n       a              b      \n       b    a    c    a     b\nA B  1.0  4.0  5.0  8.0  10.0\n  C  2.0  3.0  6.0  7.0   NaN\n  D  NaN  NaN  NaN  NaN   9.0\n</pre></div> </div> </section> <section id=\"from-a-series\"> <h3>From a Series</h3> <p>The result will be a DataFrame with the same index as the input Series, and with one column whose name is the original name of the Series (only if no other column name provided).</p> </section> <section id=\"from-a-list-of-namedtuples\"> <h3>From a list of namedtuples</h3> <p>The field names of the first <code class=\"docutils literal notranslate\"><span class=\"pre\">namedtuple</span></code> in the list determine the columns of the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>. The remaining namedtuples (or tuples) are simply unpacked and their values are fed into the rows of the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>. If any of those tuples is shorter than the first <code class=\"docutils literal notranslate\"><span class=\"pre\">namedtuple</span></code> then the later columns in the corresponding row are marked as missing values. If any are longer than the first <code class=\"docutils literal notranslate\"><span class=\"pre\">namedtuple</span></code>, a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code> is raised.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [57]: from collections import namedtuple\n\nIn [58]: Point = namedtuple(\"Point\", \"x y\")\n\nIn [59]: pd.DataFrame([Point(0, 0), Point(0, 3), (2, 3)])\nOut[59]: \n   x  y\n0  0  0\n1  0  3\n2  2  3\n\nIn [60]: Point3D = namedtuple(\"Point3D\", \"x y z\")\n\nIn [61]: pd.DataFrame([Point3D(0, 0, 0), Point3D(0, 3, 5), Point(2, 3)])\nOut[61]: \n   x  y    z\n0  0  0  0.0\n1  0  3  5.0\n2  2  3  NaN\n</pre></div> </div> </section> <section id=\"from-a-list-of-dataclasses\"> <h3>From a list of dataclasses</h3> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.1.0.</span></p> </div> <p>Data Classes as introduced in <a class=\"reference external\" href=\"https://www.python.org/dev/peps/pep-0557\">PEP557</a>, can be passed into the DataFrame constructor. Passing a list of dataclasses is equivalent to passing a list of dictionaries.</p> <p>Please be aware, that all values in the list should be dataclasses, mixing types in the list would result in a TypeError.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [62]: from dataclasses import make_dataclass\n\nIn [63]: Point = make_dataclass(\"Point\", [(\"x\", int), (\"y\", int)])\n\nIn [64]: pd.DataFrame([Point(0, 0), Point(0, 3), Point(2, 3)])\nOut[64]: \n   x  y\n0  0  0\n1  0  3\n2  2  3\n</pre></div> </div> <p><strong>Missing data</strong></p> <p>Much more will be said on this topic in the <a class=\"reference internal\" href=\"missing_data#missing-data\"><span class=\"std std-ref\">Missing data</span></a> section. To construct a DataFrame with missing data, we use <code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code> to represent missing values. Alternatively, you may pass a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy.MaskedArray</span></code> as the data argument to the DataFrame constructor, and its masked entries will be considered missing.</p> </section> <section id=\"alternate-constructors\"> <h3>Alternate constructors</h3> <p id=\"basics-dataframe-from-dict\"><strong>DataFrame.from_dict</strong></p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.from_dict</span></code> takes a dict of dicts or a dict of array-like sequences and returns a DataFrame. It operates like the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> constructor except for the <code class=\"docutils literal notranslate\"><span class=\"pre\">orient</span></code> parameter which is <code class=\"docutils literal notranslate\"><span class=\"pre\">'columns'</span></code> by default, but which can be set to <code class=\"docutils literal notranslate\"><span class=\"pre\">'index'</span></code> in order to use the dict keys as row labels.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [65]: pd.DataFrame.from_dict(dict([(\"A\", [1, 2, 3]), (\"B\", [4, 5, 6])]))\nOut[65]: \n   A  B\n0  1  4\n1  2  5\n2  3  6\n</pre></div> </div> <p>If you pass <code class=\"docutils literal notranslate\"><span class=\"pre\">orient='index'</span></code>, the keys will be the row labels. In this case, you can also pass the desired column names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [66]: pd.DataFrame.from_dict(\n   ....:     dict([(\"A\", [1, 2, 3]), (\"B\", [4, 5, 6])]),\n   ....:     orient=\"index\",\n   ....:     columns=[\"one\", \"two\", \"three\"],\n   ....: )\n   ....: \nOut[66]: \n   one  two  three\nA    1    2      3\nB    4    5      6\n</pre></div> </div> <p id=\"basics-dataframe-from-records\"><strong>DataFrame.from_records</strong></p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.from_records</span></code> takes a list of tuples or an ndarray with structured dtype. It works analogously to the normal <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> constructor, except that the resulting DataFrame index may be a specific field of the structured dtype. For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [67]: data\nOut[67]: \narray([(1, 2., b'Hello'), (2, 3., b'World')],\n      dtype=[('A', '&lt;i4'), ('B', '&lt;f4'), ('C', 'S10')])\n\nIn [68]: pd.DataFrame.from_records(data, index=\"C\")\nOut[68]: \n          A    B\nC               \nb'Hello'  1  2.0\nb'World'  2  3.0\n</pre></div> </div> </section> <section id=\"column-selection-addition-deletion\"> <h3>Column selection, addition, deletion</h3> <p>You can treat a DataFrame semantically like a dict of like-indexed Series objects. Getting, setting, and deleting columns works with the same syntax as the analogous dict operations:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [69]: df[\"one\"]\nOut[69]: \na    1.0\nb    2.0\nc    3.0\nd    NaN\nName: one, dtype: float64\n\nIn [70]: df[\"three\"] = df[\"one\"] * df[\"two\"]\n\nIn [71]: df[\"flag\"] = df[\"one\"] &gt; 2\n\nIn [72]: df\nOut[72]: \n   one  two  three   flag\na  1.0  1.0    1.0  False\nb  2.0  2.0    4.0  False\nc  3.0  3.0    9.0   True\nd  NaN  4.0    NaN  False\n</pre></div> </div> <p>Columns can be deleted or popped like with a dict:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [73]: del df[\"two\"]\n\nIn [74]: three = df.pop(\"three\")\n\nIn [75]: df\nOut[75]: \n   one   flag\na  1.0  False\nb  2.0  False\nc  3.0   True\nd  NaN  False\n</pre></div> </div> <p>When inserting a scalar value, it will naturally be propagated to fill the column:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [76]: df[\"foo\"] = \"bar\"\n\nIn [77]: df\nOut[77]: \n   one   flag  foo\na  1.0  False  bar\nb  2.0  False  bar\nc  3.0   True  bar\nd  NaN  False  bar\n</pre></div> </div> <p>When inserting a Series that does not have the same index as the DataFrame, it will be conformed to the DataFrame’s index:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [78]: df[\"one_trunc\"] = df[\"one\"][:2]\n\nIn [79]: df\nOut[79]: \n   one   flag  foo  one_trunc\na  1.0  False  bar        1.0\nb  2.0  False  bar        2.0\nc  3.0   True  bar        NaN\nd  NaN  False  bar        NaN\n</pre></div> </div> <p>You can insert raw ndarrays but their length must match the length of the DataFrame’s index.</p> <p>By default, columns get inserted at the end. The <code class=\"docutils literal notranslate\"><span class=\"pre\">insert</span></code> function is available to insert at a particular location in the columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [80]: df.insert(1, \"bar\", df[\"one\"])\n\nIn [81]: df\nOut[81]: \n   one  bar   flag  foo  one_trunc\na  1.0  1.0  False  bar        1.0\nb  2.0  2.0  False  bar        2.0\nc  3.0  3.0   True  bar        NaN\nd  NaN  NaN  False  bar        NaN\n</pre></div> </div> </section> <section id=\"assigning-new-columns-in-method-chains\"> <h3>Assigning new columns in method chains</h3> <p>Inspired by <a class=\"reference external\" href=\"https://dplyr.tidyverse.org/reference/mutate.html\">dplyr’s</a> <code class=\"docutils literal notranslate\"><span class=\"pre\">mutate</span></code> verb, DataFrame has an <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.assign#pandas.DataFrame.assign\" title=\"pandas.DataFrame.assign\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">assign()</span></code></a> method that allows you to easily create new columns that are potentially derived from existing columns.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [82]: iris = pd.read_csv(\"data/iris.data\")\n\nIn [83]: iris.head()\nOut[83]: \n   SepalLength  SepalWidth  PetalLength  PetalWidth         Name\n0          5.1         3.5          1.4         0.2  Iris-setosa\n1          4.9         3.0          1.4         0.2  Iris-setosa\n2          4.7         3.2          1.3         0.2  Iris-setosa\n3          4.6         3.1          1.5         0.2  Iris-setosa\n4          5.0         3.6          1.4         0.2  Iris-setosa\n\nIn [84]: iris.assign(sepal_ratio=iris[\"SepalWidth\"] / iris[\"SepalLength\"]).head()\nOut[84]: \n   SepalLength  SepalWidth  PetalLength  PetalWidth         Name  sepal_ratio\n0          5.1         3.5          1.4         0.2  Iris-setosa     0.686275\n1          4.9         3.0          1.4         0.2  Iris-setosa     0.612245\n2          4.7         3.2          1.3         0.2  Iris-setosa     0.680851\n3          4.6         3.1          1.5         0.2  Iris-setosa     0.673913\n4          5.0         3.6          1.4         0.2  Iris-setosa     0.720000\n</pre></div> </div> <p>In the example above, we inserted a precomputed value. We can also pass in a function of one argument to be evaluated on the DataFrame being assigned to.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [85]: iris.assign(sepal_ratio=lambda x: (x[\"SepalWidth\"] / x[\"SepalLength\"])).head()\nOut[85]: \n   SepalLength  SepalWidth  PetalLength  PetalWidth         Name  sepal_ratio\n0          5.1         3.5          1.4         0.2  Iris-setosa     0.686275\n1          4.9         3.0          1.4         0.2  Iris-setosa     0.612245\n2          4.7         3.2          1.3         0.2  Iris-setosa     0.680851\n3          4.6         3.1          1.5         0.2  Iris-setosa     0.673913\n4          5.0         3.6          1.4         0.2  Iris-setosa     0.720000\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">assign</span></code> <strong>always</strong> returns a copy of the data, leaving the original DataFrame untouched.</p> <p>Passing a callable, as opposed to an actual value to be inserted, is useful when you don’t have a reference to the DataFrame at hand. This is common when using <code class=\"docutils literal notranslate\"><span class=\"pre\">assign</span></code> in a chain of operations. For example, we can limit the DataFrame to just those observations with a Sepal Length greater than 5, calculate the ratio, and plot:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [86]: (\n   ....:     iris.query(\"SepalLength &gt; 5\")\n   ....:     .assign(\n   ....:         SepalRatio=lambda x: x.SepalWidth / x.SepalLength,\n   ....:         PetalRatio=lambda x: x.PetalWidth / x.PetalLength,\n   ....:     )\n   ....:     .plot(kind=\"scatter\", x=\"SepalRatio\", y=\"PetalRatio\")\n   ....: )\n   ....: \nOut[86]: &lt;AxesSubplot:xlabel='SepalRatio', ylabel='PetalRatio'&gt;\n</pre></div> </div> <img alt=\"../_images/basics_assign.png\" src=\"data:image/png;base64,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\"> <p>Since a function is passed in, the function is computed on the DataFrame being assigned to. Importantly, this is the DataFrame that’s been filtered to those rows with sepal length greater than 5. The filtering happens first, and then the ratio calculations. This is an example where we didn’t have a reference to the <em>filtered</em> DataFrame available.</p> <p>The function signature for <code class=\"docutils literal notranslate\"><span class=\"pre\">assign</span></code> is simply <code class=\"docutils literal notranslate\"><span class=\"pre\">**kwargs</span></code>. The keys are the column names for the new fields, and the values are either a value to be inserted (for example, a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> or NumPy array), or a function of one argument to be called on the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>. A <em>copy</em> of the original DataFrame is returned, with the new values inserted.</p> <p>Starting with Python 3.6 the order of <code class=\"docutils literal notranslate\"><span class=\"pre\">**kwargs</span></code> is preserved. This allows for <em>dependent</em> assignment, where an expression later in <code class=\"docutils literal notranslate\"><span class=\"pre\">**kwargs</span></code> can refer to a column created earlier in the same <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.assign#pandas.DataFrame.assign\" title=\"pandas.DataFrame.assign\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">assign()</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [87]: dfa = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n\nIn [88]: dfa.assign(C=lambda x: x[\"A\"] + x[\"B\"], D=lambda x: x[\"A\"] + x[\"C\"])\nOut[88]: \n   A  B  C   D\n0  1  4  5   6\n1  2  5  7   9\n2  3  6  9  12\n</pre></div> </div> <p>In the second expression, <code class=\"docutils literal notranslate\"><span class=\"pre\">x['C']</span></code> will refer to the newly created column, that’s equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">dfa['A']</span> <span class=\"pre\">+</span> <span class=\"pre\">dfa['B']</span></code>.</p> </section> <section id=\"indexing-selection\"> <h3>Indexing / selection</h3> <p>The basics of indexing are as follows:</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 50%\"> <col style=\"width: 33%\"> <col style=\"width: 17%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Operation</p></th> <th class=\"head\"><p>Syntax</p></th> <th class=\"head\"><p>Result</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>Select column</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df[col]</span></code></p></td> <td><p>Series</p></td> </tr> <tr class=\"row-odd\">\n<td><p>Select row by label</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df.loc[label]</span></code></p></td> <td><p>Series</p></td> </tr> <tr class=\"row-even\">\n<td><p>Select row by integer location</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df.iloc[loc]</span></code></p></td> <td><p>Series</p></td> </tr> <tr class=\"row-odd\">\n<td><p>Slice rows</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df[5:10]</span></code></p></td> <td><p>DataFrame</p></td> </tr> <tr class=\"row-even\">\n<td><p>Select rows by boolean vector</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df[bool_vec]</span></code></p></td> <td><p>DataFrame</p></td> </tr> </tbody> </table> <p>Row selection, for example, returns a Series whose index is the columns of the DataFrame:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [89]: df.loc[\"b\"]\nOut[89]: \none            2.0\nbar            2.0\nflag         False\nfoo            bar\none_trunc      2.0\nName: b, dtype: object\n\nIn [90]: df.iloc[2]\nOut[90]: \none           3.0\nbar           3.0\nflag         True\nfoo           bar\none_trunc     NaN\nName: c, dtype: object\n</pre></div> </div> <p>For a more exhaustive treatment of sophisticated label-based indexing and slicing, see the <a class=\"reference internal\" href=\"indexing#indexing\"><span class=\"std std-ref\">section on indexing</span></a>. We will address the fundamentals of reindexing / conforming to new sets of labels in the <a class=\"reference internal\" href=\"basics#basics-reindexing\"><span class=\"std std-ref\">section on reindexing</span></a>.</p> </section> <section id=\"data-alignment-and-arithmetic\"> <h3>Data alignment and arithmetic</h3> <p>Data alignment between DataFrame objects automatically align on <strong>both the columns and the index (row labels)</strong>. Again, the resulting object will have the union of the column and row labels.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [91]: df = pd.DataFrame(np.random.randn(10, 4), columns=[\"A\", \"B\", \"C\", \"D\"])\n\nIn [92]: df2 = pd.DataFrame(np.random.randn(7, 3), columns=[\"A\", \"B\", \"C\"])\n\nIn [93]: df + df2\nOut[93]: \n          A         B         C   D\n0  0.045691 -0.014138  1.380871 NaN\n1 -0.955398 -1.501007  0.037181 NaN\n2 -0.662690  1.534833 -0.859691 NaN\n3 -2.452949  1.237274 -0.133712 NaN\n4  1.414490  1.951676 -2.320422 NaN\n5 -0.494922 -1.649727 -1.084601 NaN\n6 -1.047551 -0.748572 -0.805479 NaN\n7       NaN       NaN       NaN NaN\n8       NaN       NaN       NaN NaN\n9       NaN       NaN       NaN NaN\n</pre></div> </div> <p>When doing an operation between DataFrame and Series, the default behavior is to align the Series <strong>index</strong> on the DataFrame <strong>columns</strong>, thus <a class=\"reference external\" href=\"https://numpy.org/doc/stable/user/basics.broadcasting.html\">broadcasting</a> row-wise. For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [94]: df - df.iloc[0]\nOut[94]: \n          A         B         C         D\n0  0.000000  0.000000  0.000000  0.000000\n1 -1.359261 -0.248717 -0.453372 -1.754659\n2  0.253128  0.829678  0.010026 -1.991234\n3 -1.311128  0.054325 -1.724913 -1.620544\n4  0.573025  1.500742 -0.676070  1.367331\n5 -1.741248  0.781993 -1.241620 -2.053136\n6 -1.240774 -0.869551 -0.153282  0.000430\n7 -0.743894  0.411013 -0.929563 -0.282386\n8 -1.194921  1.320690  0.238224 -1.482644\n9  2.293786  1.856228  0.773289 -1.446531\n</pre></div> </div> <p>For explicit control over the matching and broadcasting behavior, see the section on <a class=\"reference internal\" href=\"basics#basics-binop\"><span class=\"std std-ref\">flexible binary operations</span></a>.</p> <p>Operations with scalars are just as you would expect:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [95]: df * 5 + 2\nOut[95]: \n           A         B         C          D\n0   3.359299 -0.124862  4.835102   3.381160\n1  -3.437003 -1.368449  2.568242  -5.392133\n2   4.624938  4.023526  4.885230  -6.575010\n3  -3.196342  0.146766 -3.789461  -4.721559\n4   6.224426  7.378849  1.454750  10.217815\n5  -5.346940  3.785103 -1.373001  -6.884519\n6  -2.844569 -4.472618  4.068691   3.383309\n7  -0.360173  1.930201  0.187285   1.969232\n8  -2.615303  6.478587  6.026220  -4.032059\n9  14.828230  9.156280  8.701544  -3.851494\n\nIn [96]: 1 / df\nOut[96]: \n          A          B         C           D\n0  3.678365  -2.353094  1.763605    3.620145\n1 -0.919624  -1.484363  8.799067   -0.676395\n2  1.904807   2.470934  1.732964   -0.583090\n3 -0.962215  -2.697986 -0.863638   -0.743875\n4  1.183593   0.929567 -9.170108    0.608434\n5 -0.680555   2.800959 -1.482360   -0.562777\n6 -1.032084  -0.772485  2.416988    3.614523\n7 -2.118489 -71.634509 -2.758294 -162.507295\n8 -1.083352   1.116424  1.241860   -0.828904\n9  0.389765   0.698687  0.746097   -0.854483\n\nIn [97]: df ** 4\nOut[97]: \n           A             B         C             D\n0   0.005462  3.261689e-02  0.103370  5.822320e-03\n1   1.398165  2.059869e-01  0.000167  4.777482e+00\n2   0.075962  2.682596e-02  0.110877  8.650845e+00\n3   1.166571  1.887302e-02  1.797515  3.265879e+00\n4   0.509555  1.339298e+00  0.000141  7.297019e+00\n5   4.661717  1.624699e-02  0.207103  9.969092e+00\n6   0.881334  2.808277e+00  0.029302  5.858632e-03\n7   0.049647  3.797614e-08  0.017276  1.433866e-09\n8   0.725974  6.437005e-01  0.420446  2.118275e+00\n9  43.329821  4.196326e+00  3.227153  1.875802e+00\n</pre></div> </div> <p id=\"dsintro-boolean\">Boolean operators work as well:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [98]: df1 = pd.DataFrame({\"a\": [1, 0, 1], \"b\": [0, 1, 1]}, dtype=bool)\n\nIn [99]: df2 = pd.DataFrame({\"a\": [0, 1, 1], \"b\": [1, 1, 0]}, dtype=bool)\n\nIn [100]: df1 &amp; df2\nOut[100]: \n       a      b\n0  False  False\n1  False   True\n2   True  False\n\nIn [101]: df1 | df2\nOut[101]: \n      a     b\n0  True  True\n1  True  True\n2  True  True\n\nIn [102]: df1 ^ df2\nOut[102]: \n       a      b\n0   True   True\n1   True  False\n2  False   True\n\nIn [103]: -df1\nOut[103]: \n       a      b\n0  False   True\n1   True  False\n2  False  False\n</pre></div> </div> </section> <section id=\"transposing\"> <h3>Transposing</h3> <p>To transpose, access the <code class=\"docutils literal notranslate\"><span class=\"pre\">T</span></code> attribute (also the <code class=\"docutils literal notranslate\"><span class=\"pre\">transpose</span></code> function), similar to an ndarray:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># only show the first 5 rows\nIn [104]: df[:5].T\nOut[104]: \n          0         1         2         3         4\nA  0.271860 -1.087401  0.524988 -1.039268  0.844885\nB -0.424972 -0.673690  0.404705 -0.370647  1.075770\nC  0.567020  0.113648  0.577046 -1.157892 -0.109050\nD  0.276232 -1.478427 -1.715002 -1.344312  1.643563\n</pre></div> </div> </section> <section id=\"dataframe-interoperability-with-numpy-functions\"> <h3>DataFrame interoperability with NumPy functions</h3> <p>Elementwise NumPy ufuncs (log, exp, sqrt, …) and various other NumPy functions can be used with no issues on Series and DataFrame, assuming the data within are numeric:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [105]: np.exp(df)\nOut[105]: \n           A         B         C         D\n0   1.312403  0.653788  1.763006  1.318154\n1   0.337092  0.509824  1.120358  0.227996\n2   1.690438  1.498861  1.780770  0.179963\n3   0.353713  0.690288  0.314148  0.260719\n4   2.327710  2.932249  0.896686  5.173571\n5   0.230066  1.429065  0.509360  0.169161\n6   0.379495  0.274028  1.512461  1.318720\n7   0.623732  0.986137  0.695904  0.993865\n8   0.397301  2.449092  2.237242  0.299269\n9  13.009059  4.183951  3.820223  0.310274\n\nIn [106]: np.asarray(df)\nOut[106]: \narray([[ 0.2719, -0.425 ,  0.567 ,  0.2762],\n       [-1.0874, -0.6737,  0.1136, -1.4784],\n       [ 0.525 ,  0.4047,  0.577 , -1.715 ],\n       [-1.0393, -0.3706, -1.1579, -1.3443],\n       [ 0.8449,  1.0758, -0.109 ,  1.6436],\n       [-1.4694,  0.357 , -0.6746, -1.7769],\n       [-0.9689, -1.2945,  0.4137,  0.2767],\n       [-0.472 , -0.014 , -0.3625, -0.0062],\n       [-0.9231,  0.8957,  0.8052, -1.2064],\n       [ 2.5656,  1.4313,  1.3403, -1.1703]])\n</pre></div> </div> <p>DataFrame is not intended to be a drop-in replacement for ndarray as its indexing semantics and data model are quite different in places from an n-dimensional array.</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> implements <code class=\"docutils literal notranslate\"><span class=\"pre\">__array_ufunc__</span></code>, which allows it to work with NumPy’s <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/ufuncs.html\">universal functions</a>.</p> <p>The ufunc is applied to the underlying array in a Series.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [107]: ser = pd.Series([1, 2, 3, 4])\n\nIn [108]: np.exp(ser)\nOut[108]: \n0     2.718282\n1     7.389056\n2    20.085537\n3    54.598150\ndtype: float64\n</pre></div> </div> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 0.25.0: </span>When multiple <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> are passed to a ufunc, they are aligned before performing the operation.</p> </div> <p>Like other parts of the library, pandas will automatically align labeled inputs as part of a ufunc with multiple inputs. For example, using <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">numpy.remainder()</span></code> on two <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> with differently ordered labels will align before the operation.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [109]: ser1 = pd.Series([1, 2, 3], index=[\"a\", \"b\", \"c\"])\n\nIn [110]: ser2 = pd.Series([1, 3, 5], index=[\"b\", \"a\", \"c\"])\n\nIn [111]: ser1\nOut[111]: \na    1\nb    2\nc    3\ndtype: int64\n\nIn [112]: ser2\nOut[112]: \nb    1\na    3\nc    5\ndtype: int64\n\nIn [113]: np.remainder(ser1, ser2)\nOut[113]: \na    1\nb    0\nc    3\ndtype: int64\n</pre></div> </div> <p>As usual, the union of the two indices is taken, and non-overlapping values are filled with missing values.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [114]: ser3 = pd.Series([2, 4, 6], index=[\"b\", \"c\", \"d\"])\n\nIn [115]: ser3\nOut[115]: \nb    2\nc    4\nd    6\ndtype: int64\n\nIn [116]: np.remainder(ser1, ser3)\nOut[116]: \na    NaN\nb    0.0\nc    3.0\nd    NaN\ndtype: float64\n</pre></div> </div> <p>When a binary ufunc is applied to a <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.index#pandas.Index\" title=\"pandas.Index\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Index</span></code></a>, the Series implementation takes precedence and a Series is returned.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [117]: ser = pd.Series([1, 2, 3])\n\nIn [118]: idx = pd.Index([4, 5, 6])\n\nIn [119]: np.maximum(ser, idx)\nOut[119]: \n0    4\n1    5\n2    6\ndtype: int64\n</pre></div> </div> <p>NumPy ufuncs are safe to apply to <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> backed by non-ndarray arrays, for example <a class=\"reference internal\" href=\"../reference/api/pandas.arrays.sparsearray#pandas.arrays.SparseArray\" title=\"pandas.arrays.SparseArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.SparseArray</span></code></a> (see <a class=\"reference internal\" href=\"sparse#sparse-calculation\"><span class=\"std std-ref\">Sparse calculation</span></a>). If possible, the ufunc is applied without converting the underlying data to an ndarray.</p> </section> <section id=\"console-display\"> <h3>Console display</h3> <p>Very large DataFrames will be truncated to display them in the console. You can also get a summary using <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.info#pandas.DataFrame.info\" title=\"pandas.DataFrame.info\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">info()</span></code></a>. (Here I am reading a CSV version of the <strong>baseball</strong> dataset from the <strong>plyr</strong> R package):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [120]: baseball = pd.read_csv(\"data/baseball.csv\")\n\nIn [121]: print(baseball)\n       id     player  year  stint team  lg   g   ab   r    h  X2b  X3b  hr   rbi   sb   cs  bb    so  ibb  hbp   sh   sf  gidp\n0   88641  womacto01  2006      2  CHN  NL  19   50   6   14    1    0   1   2.0  1.0  1.0   4   4.0  0.0  0.0  3.0  0.0   0.0\n1   88643  schilcu01  2006      1  BOS  AL  31    2   0    1    0    0   0   0.0  0.0  0.0   0   1.0  0.0  0.0  0.0  0.0   0.0\n..    ...        ...   ...    ...  ...  ..  ..  ...  ..  ...  ...  ...  ..   ...  ...  ...  ..   ...  ...  ...  ...  ...   ...\n98  89533   aloumo01  2007      1  NYN  NL  87  328  51  112   19    1  13  49.0  3.0  0.0  27  30.0  5.0  2.0  0.0  3.0  13.0\n99  89534  alomasa02  2007      1  NYN  NL   8   22   1    3    1    0   0   0.0  0.0  0.0   0   3.0  0.0  0.0  0.0  0.0   0.0\n\n[100 rows x 23 columns]\n\nIn [122]: baseball.info()\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 100 entries, 0 to 99\nData columns (total 23 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   id      100 non-null    int64  \n 1   player  100 non-null    object \n 2   year    100 non-null    int64  \n 3   stint   100 non-null    int64  \n 4   team    100 non-null    object \n 5   lg      100 non-null    object \n 6   g       100 non-null    int64  \n 7   ab      100 non-null    int64  \n 8   r       100 non-null    int64  \n 9   h       100 non-null    int64  \n 10  X2b     100 non-null    int64  \n 11  X3b     100 non-null    int64  \n 12  hr      100 non-null    int64  \n 13  rbi     100 non-null    float64\n 14  sb      100 non-null    float64\n 15  cs      100 non-null    float64\n 16  bb      100 non-null    int64  \n 17  so      100 non-null    float64\n 18  ibb     100 non-null    float64\n 19  hbp     100 non-null    float64\n 20  sh      100 non-null    float64\n 21  sf      100 non-null    float64\n 22  gidp    100 non-null    float64\ndtypes: float64(9), int64(11), object(3)\nmemory usage: 18.1+ KB\n</pre></div> </div> <p>However, using <code class=\"docutils literal notranslate\"><span class=\"pre\">to_string</span></code> will return a string representation of the DataFrame in tabular form, though it won’t always fit the console width:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [123]: print(baseball.iloc[-20:, :12].to_string())\n       id     player  year  stint team  lg    g   ab   r    h  X2b  X3b\n80  89474  finlest01  2007      1  COL  NL   43   94   9   17    3    0\n81  89480  embreal01  2007      1  OAK  AL    4    0   0    0    0    0\n82  89481  edmonji01  2007      1  SLN  NL  117  365  39   92   15    2\n83  89482  easleda01  2007      1  NYN  NL   76  193  24   54    6    0\n84  89489  delgaca01  2007      1  NYN  NL  139  538  71  139   30    0\n85  89493  cormirh01  2007      1  CIN  NL    6    0   0    0    0    0\n86  89494  coninje01  2007      2  NYN  NL   21   41   2    8    2    0\n87  89495  coninje01  2007      1  CIN  NL   80  215  23   57   11    1\n88  89497  clemero02  2007      1  NYA  AL    2    2   0    1    0    0\n89  89498  claytro01  2007      2  BOS  AL    8    6   1    0    0    0\n90  89499  claytro01  2007      1  TOR  AL   69  189  23   48   14    0\n91  89501  cirilje01  2007      2  ARI  NL   28   40   6    8    4    0\n92  89502  cirilje01  2007      1  MIN  AL   50  153  18   40    9    2\n93  89521  bondsba01  2007      1  SFN  NL  126  340  75   94   14    0\n94  89523  biggicr01  2007      1  HOU  NL  141  517  68  130   31    3\n95  89525  benitar01  2007      2  FLO  NL   34    0   0    0    0    0\n96  89526  benitar01  2007      1  SFN  NL   19    0   0    0    0    0\n97  89530  ausmubr01  2007      1  HOU  NL  117  349  38   82   16    3\n98  89533   aloumo01  2007      1  NYN  NL   87  328  51  112   19    1\n99  89534  alomasa02  2007      1  NYN  NL    8   22   1    3    1    0\n</pre></div> </div> <p>Wide DataFrames will be printed across multiple rows by default:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [124]: pd.DataFrame(np.random.randn(3, 12))\nOut[124]: \n         0         1         2         3         4         5         6         7         8         9         10        11\n0 -1.226825  0.769804 -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734  0.959726 -1.110336 -0.619976  0.149748\n1 -0.732339  0.687738  0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849 -0.954208  1.462696 -1.743161 -0.826591\n2 -0.345352  1.314232  0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441 -1.236269  0.896171 -0.487602 -0.082240\n</pre></div> </div> <p>You can change how much to print on a single row by setting the <code class=\"docutils literal notranslate\"><span class=\"pre\">display.width</span></code> option:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [125]: pd.set_option(\"display.width\", 40)  # default is 80\n\nIn [126]: pd.DataFrame(np.random.randn(3, 12))\nOut[126]: \n         0         1         2         3         4         5         6         7         8         9         10        11\n0 -2.182937  0.380396  0.084844  0.432390  1.519970 -0.493662  0.600178  0.274230  0.132885 -0.023688  2.410179  1.450520\n1  0.206053 -0.251905 -2.213588  1.063327  1.266143  0.299368 -0.863838  0.408204 -1.048089 -0.025747 -0.988387  0.094055\n2  1.262731  1.289997  0.082423 -0.055758  0.536580 -0.489682  0.369374 -0.034571 -2.484478 -0.281461  0.030711  0.109121\n</pre></div> </div> <p>You can adjust the max width of the individual columns by setting <code class=\"docutils literal notranslate\"><span class=\"pre\">display.max_colwidth</span></code></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [127]: datafile = {\n   .....:     \"filename\": [\"filename_01\", \"filename_02\"],\n   .....:     \"path\": [\n   .....:         \"media/user_name/storage/folder_01/filename_01\",\n   .....:         \"media/user_name/storage/folder_02/filename_02\",\n   .....:     ],\n   .....: }\n   .....: \n\nIn [128]: pd.set_option(\"display.max_colwidth\", 30)\n\nIn [129]: pd.DataFrame(datafile)\nOut[129]: \n      filename                           path\n0  filename_01  media/user_name/storage/fo...\n1  filename_02  media/user_name/storage/fo...\n\nIn [130]: pd.set_option(\"display.max_colwidth\", 100)\n\nIn [131]: pd.DataFrame(datafile)\nOut[131]: \n      filename                                           path\n0  filename_01  media/user_name/storage/folder_01/filename_01\n1  filename_02  media/user_name/storage/folder_02/filename_02\n</pre></div> </div> <p>You can also disable this feature via the <code class=\"docutils literal notranslate\"><span class=\"pre\">expand_frame_repr</span></code> option. This will print the table in one block.</p> </section> <section id=\"dataframe-column-attribute-access-and-ipython-completion\"> <h3>DataFrame column attribute access and IPython completion</h3> <p>If a DataFrame column label is a valid Python variable name, the column can be accessed like an attribute:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [132]: df = pd.DataFrame({\"foo1\": np.random.randn(5), \"foo2\": np.random.randn(5)})\n\nIn [133]: df\nOut[133]: \n       foo1      foo2\n0  1.126203  0.781836\n1 -0.977349 -1.071357\n2  1.474071  0.441153\n3 -0.064034  2.353925\n4 -1.282782  0.583787\n\nIn [134]: df.foo1\nOut[134]: \n0    1.126203\n1   -0.977349\n2    1.474071\n3   -0.064034\n4   -1.282782\nName: foo1, dtype: float64\n</pre></div> </div> <p>The columns are also connected to the <a class=\"reference external\" href=\"https://ipython.org\">IPython</a> completion mechanism so they can be tab-completed:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [5]: df.foo&lt;TAB&gt;  # noqa: E225, E999\ndf.foo1  df.foo2\n</pre></div> </div> </section> </section><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>\n    <a href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/dsintro.html\" class=\"_attribution-link\">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/dsintro.html</a>\n  </p>\n</div>\n","user_guide/basics":"<h1>Essential basic functionality</h1> <p>Here we discuss a lot of the essential functionality common to the pandas data structures. To begin, let’s create some example objects like we did in the <a class=\"reference internal\" href=\"10min#min\"><span class=\"std std-ref\">10 minutes to pandas</span></a> section:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [1]: index = pd.date_range(\"1/1/2000\", periods=8)\n\nIn [2]: s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\nIn [3]: df = pd.DataFrame(np.random.randn(8, 3), index=index, columns=[\"A\", \"B\", \"C\"])\n</pre></div> </div> <section id=\"head-and-tail\"> <h2>Head and tail</h2> <p>To view a small sample of a Series or DataFrame object, use the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.head#pandas.DataFrame.head\" title=\"pandas.DataFrame.head\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">head()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.tail#pandas.DataFrame.tail\" title=\"pandas.DataFrame.tail\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">tail()</span></code></a> methods. The default number of elements to display is five, but you may pass a custom number.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [4]: long_series = pd.Series(np.random.randn(1000))\n\nIn [5]: long_series.head()\nOut[5]: \n0   -1.157892\n1   -1.344312\n2    0.844885\n3    1.075770\n4   -0.109050\ndtype: float64\n\nIn [6]: long_series.tail(3)\nOut[6]: \n997   -0.289388\n998   -1.020544\n999    0.589993\ndtype: float64\n</pre></div> </div> </section> <section id=\"attributes-and-underlying-data\"> <h2>Attributes and underlying data</h2> <p>pandas objects have a number of attributes enabling you to access the metadata</p> <ul class=\"simple\"> <li><p><strong>shape</strong>: gives the axis dimensions of the object, consistent with ndarray</p></li> <li>\n<dl class=\"simple\"> <dt>Axis labels</dt>\n<dd>\n<ul> <li><p><strong>Series</strong>: <em>index</em> (only axis)</p></li> <li><p><strong>DataFrame</strong>: <em>index</em> (rows) and <em>columns</em></p></li> </ul> </dd> </dl> </li> </ul> <p>Note, <strong>these attributes can be safely assigned to</strong>!</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [7]: df[:2]\nOut[7]: \n                   A         B         C\n2000-01-01 -0.173215  0.119209 -1.044236\n2000-01-02 -0.861849 -2.104569 -0.494929\n\nIn [8]: df.columns = [x.lower() for x in df.columns]\n\nIn [9]: df\nOut[9]: \n                   a         b         c\n2000-01-01 -0.173215  0.119209 -1.044236\n2000-01-02 -0.861849 -2.104569 -0.494929\n2000-01-03  1.071804  0.721555 -0.706771\n2000-01-04 -1.039575  0.271860 -0.424972\n2000-01-05  0.567020  0.276232 -1.087401\n2000-01-06 -0.673690  0.113648 -1.478427\n2000-01-07  0.524988  0.404705  0.577046\n2000-01-08 -1.715002 -1.039268 -0.370647\n</pre></div> </div> <p>pandas objects (<a class=\"reference internal\" href=\"../reference/api/pandas.index#pandas.Index\" title=\"pandas.Index\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Index</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a>) can be thought of as containers for arrays, which hold the actual data and do the actual computation. For many types, the underlying array is a <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">numpy.ndarray</span></code></a>. However, pandas and 3rd party libraries may <em>extend</em> NumPy’s type system to add support for custom arrays (see <a class=\"reference internal\" href=\"#basics-dtypes\"><span class=\"std std-ref\">dtypes</span></a>).</p> <p>To get the actual data inside a <a class=\"reference internal\" href=\"../reference/api/pandas.index#pandas.Index\" title=\"pandas.Index\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Index</span></code></a> or <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a>, use the <code class=\"docutils literal notranslate\"><span class=\"pre\">.array</span></code> property</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [10]: s.array\nOut[10]: \n&lt;PandasArray&gt;\n[ 0.4691122999071863, -0.2828633443286633, -1.5090585031735124,\n -1.1356323710171934,  1.2121120250208506]\nLength: 5, dtype: float64\n\nIn [11]: s.index.array\nOut[11]: \n&lt;PandasArray&gt;\n['a', 'b', 'c', 'd', 'e']\nLength: 5, dtype: object\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.array#pandas.Series.array\" title=\"pandas.Series.array\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">array</span></code></a> will always be an <a class=\"reference internal\" href=\"../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray\" title=\"pandas.api.extensions.ExtensionArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code></a>. The exact details of what an <a class=\"reference internal\" href=\"../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray\" title=\"pandas.api.extensions.ExtensionArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code></a> is and why pandas uses them are a bit beyond the scope of this introduction. See <a class=\"reference internal\" href=\"#basics-dtypes\"><span class=\"std std-ref\">dtypes</span></a> for more.</p> <p>If you know you need a NumPy array, use <a class=\"reference internal\" href=\"../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy\" title=\"pandas.Series.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_numpy()</span></code></a> or <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">numpy.asarray()</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [12]: s.to_numpy()\nOut[12]: array([ 0.4691, -0.2829, -1.5091, -1.1356,  1.2121])\n\nIn [13]: np.asarray(s)\nOut[13]: array([ 0.4691, -0.2829, -1.5091, -1.1356,  1.2121])\n</pre></div> </div> <p>When the Series or Index is backed by an <a class=\"reference internal\" href=\"../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray\" title=\"pandas.api.extensions.ExtensionArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy\" title=\"pandas.Series.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_numpy()</span></code></a> may involve copying data and coercing values. See <a class=\"reference internal\" href=\"#basics-dtypes\"><span class=\"std std-ref\">dtypes</span></a> for more.</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy\" title=\"pandas.Series.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_numpy()</span></code></a> gives some control over the <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> of the resulting <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">numpy.ndarray</span></code></a>. For example, consider datetimes with timezones. NumPy doesn’t have a dtype to represent timezone-aware datetimes, so there are two possibly useful representations:</p> <ol class=\"arabic simple\"> <li><p>An object-dtype <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">numpy.ndarray</span></code></a> with <a class=\"reference internal\" href=\"../reference/api/pandas.timestamp#pandas.Timestamp\" title=\"pandas.Timestamp\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Timestamp</span></code></a> objects, each with the correct <code class=\"docutils literal notranslate\"><span class=\"pre\">tz</span></code></p></li> <li><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">datetime64[ns]</span></code> -dtype <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">numpy.ndarray</span></code></a>, where the values have been converted to UTC and the timezone discarded</p></li> </ol> <p>Timezones may be preserved with <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype=object</span></code></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [14]: ser = pd.Series(pd.date_range(\"2000\", periods=2, tz=\"CET\"))\n\nIn [15]: ser.to_numpy(dtype=object)\nOut[15]: \narray([Timestamp('2000-01-01 00:00:00+0100', tz='CET'),\n       Timestamp('2000-01-02 00:00:00+0100', tz='CET')], dtype=object)\n</pre></div> </div> <p>Or thrown away with <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype='datetime64[ns]'</span></code></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [16]: ser.to_numpy(dtype=\"datetime64[ns]\")\nOut[16]: \narray(['1999-12-31T23:00:00.000000000', '2000-01-01T23:00:00.000000000'],\n      dtype='datetime64[ns]')\n</pre></div> </div> <p>Getting the “raw data” inside a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> is possibly a bit more complex. When your <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> only has a single data type for all the columns, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a> will return the underlying data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [17]: df.to_numpy()\nOut[17]: \narray([[-0.1732,  0.1192, -1.0442],\n       [-0.8618, -2.1046, -0.4949],\n       [ 1.0718,  0.7216, -0.7068],\n       [-1.0396,  0.2719, -0.425 ],\n       [ 0.567 ,  0.2762, -1.0874],\n       [-0.6737,  0.1136, -1.4784],\n       [ 0.525 ,  0.4047,  0.577 ],\n       [-1.715 , -1.0393, -0.3706]])\n</pre></div> </div> <p>If a DataFrame contains homogeneously-typed data, the ndarray can actually be modified in-place, and the changes will be reflected in the data structure. For heterogeneous data (e.g. some of the DataFrame’s columns are not all the same dtype), this will not be the case. The values attribute itself, unlike the axis labels, cannot be assigned to.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>When working with heterogeneous data, the dtype of the resulting ndarray will be chosen to accommodate all of the data involved. For example, if strings are involved, the result will be of object dtype. If there are only floats and integers, the resulting array will be of float dtype.</p> </div> <p>In the past, pandas recommended <a class=\"reference internal\" href=\"../reference/api/pandas.series.values#pandas.Series.values\" title=\"pandas.Series.values\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">Series.values</span></code></a> or <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.values#pandas.DataFrame.values\" title=\"pandas.DataFrame.values\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">DataFrame.values</span></code></a> for extracting the data from a Series or DataFrame. You’ll still find references to these in old code bases and online. Going forward, we recommend avoiding <code class=\"docutils literal notranslate\"><span class=\"pre\">.values</span></code> and using <code class=\"docutils literal notranslate\"><span class=\"pre\">.array</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">.to_numpy()</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">.values</span></code> has the following drawbacks:</p> <ol class=\"arabic simple\"> <li><p>When your Series contains an <a class=\"reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/development/extending.html#extending-extension-types\"><span class=\"std std-ref\">extension type</span></a>, it’s unclear whether <a class=\"reference internal\" href=\"../reference/api/pandas.series.values#pandas.Series.values\" title=\"pandas.Series.values\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">Series.values</span></code></a> returns a NumPy array or the extension array. <a class=\"reference internal\" href=\"../reference/api/pandas.series.array#pandas.Series.array\" title=\"pandas.Series.array\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">Series.array</span></code></a> will always return an <a class=\"reference internal\" href=\"../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray\" title=\"pandas.api.extensions.ExtensionArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code></a>, and will never copy data. <a class=\"reference internal\" href=\"../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy\" title=\"pandas.Series.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.to_numpy()</span></code></a> will always return a NumPy array, potentially at the cost of copying / coercing values.</p></li> <li><p>When your DataFrame contains a mixture of data types, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.values#pandas.DataFrame.values\" title=\"pandas.DataFrame.values\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">DataFrame.values</span></code></a> may involve copying data and coercing values to a common dtype, a relatively expensive operation. <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a>, being a method, makes it clearer that the returned NumPy array may not be a view on the same data in the DataFrame.</p></li> </ol> </section> <section id=\"accelerated-operations\"> <h2>Accelerated operations</h2> <p>pandas has support for accelerating certain types of binary numerical and boolean operations using the <code class=\"docutils literal notranslate\"><span class=\"pre\">numexpr</span></code> library and the <code class=\"docutils literal notranslate\"><span class=\"pre\">bottleneck</span></code> libraries.</p> <p>These libraries are especially useful when dealing with large data sets, and provide large speedups. <code class=\"docutils literal notranslate\"><span class=\"pre\">numexpr</span></code> uses smart chunking, caching, and multiple cores. <code class=\"docutils literal notranslate\"><span class=\"pre\">bottleneck</span></code> is a set of specialized cython routines that are especially fast when dealing with arrays that have <code class=\"docutils literal notranslate\"><span class=\"pre\">nans</span></code>.</p> <p>Here is a sample (using 100 column x 100,000 row <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code>):</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 25%\"> <col style=\"width: 25%\"> <col style=\"width: 25%\"> <col style=\"width: 25%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Operation</p></th> <th class=\"head\"><p>0.11.0 (ms)</p></th> <th class=\"head\"><p>Prior Version (ms)</p></th> <th class=\"head\"><p>Ratio to Prior</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df1</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">df2</span></code></p></td> <td><p>13.32</p></td> <td><p>125.35</p></td> <td><p>0.1063</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df1</span> <span class=\"pre\">*</span> <span class=\"pre\">df2</span></code></p></td> <td><p>21.71</p></td> <td><p>36.63</p></td> <td><p>0.5928</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df1</span> <span class=\"pre\">+</span> <span class=\"pre\">df2</span></code></p></td> <td><p>22.04</p></td> <td><p>36.50</p></td> <td><p>0.6039</p></td> </tr> </tbody> </table> <p>You are highly encouraged to install both libraries. See the section <a class=\"reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/getting_started/install.html#install-recommended-dependencies\"><span class=\"std std-ref\">Recommended Dependencies</span></a> for more installation info.</p> <p>These are both enabled to be used by default, you can control this by setting the options:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.set_option(\"compute.use_bottleneck\", False)\npd.set_option(\"compute.use_numexpr\", False)\n</pre></div> </div> </section> <section id=\"flexible-binary-operations\"> <h2>Flexible binary operations</h2> <p>With binary operations between pandas data structures, there are two key points of interest:</p> <ul class=\"simple\"> <li><p>Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional (e.g. Series) objects.</p></li> <li><p>Missing data in computations.</p></li> </ul> <p>We will demonstrate how to manage these issues independently, though they can be handled simultaneously.</p> <section id=\"matching-broadcasting-behavior\"> <h3>Matching / broadcasting behavior</h3> <p>DataFrame has the methods <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.add#pandas.DataFrame.add\" title=\"pandas.DataFrame.add\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">add()</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.sub#pandas.DataFrame.sub\" title=\"pandas.DataFrame.sub\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">sub()</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.mul#pandas.DataFrame.mul\" title=\"pandas.DataFrame.mul\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">mul()</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.div#pandas.DataFrame.div\" title=\"pandas.DataFrame.div\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">div()</span></code></a> and related functions <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.radd#pandas.DataFrame.radd\" title=\"pandas.DataFrame.radd\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">radd()</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.rsub#pandas.DataFrame.rsub\" title=\"pandas.DataFrame.rsub\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">rsub()</span></code></a>, … for carrying out binary operations. For broadcasting behavior, Series input is of primary interest. Using these functions, you can use to either match on the <em>index</em> or <em>columns</em> via the <strong>axis</strong> keyword:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [18]: df = pd.DataFrame(\n   ....:     {\n   ....:         \"one\": pd.Series(np.random.randn(3), index=[\"a\", \"b\", \"c\"]),\n   ....:         \"two\": pd.Series(np.random.randn(4), index=[\"a\", \"b\", \"c\", \"d\"]),\n   ....:         \"three\": pd.Series(np.random.randn(3), index=[\"b\", \"c\", \"d\"]),\n   ....:     }\n   ....: )\n   ....: \n\nIn [19]: df\nOut[19]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [20]: row = df.iloc[1]\n\nIn [21]: column = df[\"two\"]\n\nIn [22]: df.sub(row, axis=\"columns\")\nOut[22]: \n        one       two     three\na  1.051928 -0.139606       NaN\nb  0.000000  0.000000  0.000000\nc  0.352192 -0.433754  1.277825\nd       NaN -1.632779 -0.562782\n\nIn [23]: df.sub(row, axis=1)\nOut[23]: \n        one       two     three\na  1.051928 -0.139606       NaN\nb  0.000000  0.000000  0.000000\nc  0.352192 -0.433754  1.277825\nd       NaN -1.632779 -0.562782\n\nIn [24]: df.sub(column, axis=\"index\")\nOut[24]: \n        one  two     three\na -0.377535  0.0       NaN\nb -1.569069  0.0 -1.962513\nc -0.783123  0.0 -0.250933\nd       NaN  0.0 -0.892516\n\nIn [25]: df.sub(column, axis=0)\nOut[25]: \n        one  two     three\na -0.377535  0.0       NaN\nb -1.569069  0.0 -1.962513\nc -0.783123  0.0 -0.250933\nd       NaN  0.0 -0.892516\n</pre></div> </div> <p>Furthermore you can align a level of a MultiIndexed DataFrame with a Series.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [26]: dfmi = df.copy()\n\nIn [27]: dfmi.index = pd.MultiIndex.from_tuples(\n   ....:     [(1, \"a\"), (1, \"b\"), (1, \"c\"), (2, \"a\")], names=[\"first\", \"second\"]\n   ....: )\n   ....: \n\nIn [28]: dfmi.sub(column, axis=0, level=\"second\")\nOut[28]: \n                   one       two     three\nfirst second                              \n1     a      -0.377535  0.000000       NaN\n      b      -1.569069  0.000000 -1.962513\n      c      -0.783123  0.000000 -0.250933\n2     a            NaN -1.493173 -2.385688\n</pre></div> </div> <p>Series and Index also support the <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#divmod\" title=\"(in Python v3.10)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">divmod()</span></code></a> builtin. This function takes the floor division and modulo operation at the same time returning a two-tuple of the same type as the left hand side. For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [29]: s = pd.Series(np.arange(10))\n\nIn [30]: s\nOut[30]: \n0    0\n1    1\n2    2\n3    3\n4    4\n5    5\n6    6\n7    7\n8    8\n9    9\ndtype: int64\n\nIn [31]: div, rem = divmod(s, 3)\n\nIn [32]: div\nOut[32]: \n0    0\n1    0\n2    0\n3    1\n4    1\n5    1\n6    2\n7    2\n8    2\n9    3\ndtype: int64\n\nIn [33]: rem\nOut[33]: \n0    0\n1    1\n2    2\n3    0\n4    1\n5    2\n6    0\n7    1\n8    2\n9    0\ndtype: int64\n\nIn [34]: idx = pd.Index(np.arange(10))\n\nIn [35]: idx\nOut[35]: Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='int64')\n\nIn [36]: div, rem = divmod(idx, 3)\n\nIn [37]: div\nOut[37]: Int64Index([0, 0, 0, 1, 1, 1, 2, 2, 2, 3], dtype='int64')\n\nIn [38]: rem\nOut[38]: Int64Index([0, 1, 2, 0, 1, 2, 0, 1, 2, 0], dtype='int64')\n</pre></div> </div> <p>We can also do elementwise <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#divmod\" title=\"(in Python v3.10)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">divmod()</span></code></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [39]: div, rem = divmod(s, [2, 2, 3, 3, 4, 4, 5, 5, 6, 6])\n\nIn [40]: div\nOut[40]: \n0    0\n1    0\n2    0\n3    1\n4    1\n5    1\n6    1\n7    1\n8    1\n9    1\ndtype: int64\n\nIn [41]: rem\nOut[41]: \n0    0\n1    1\n2    2\n3    0\n4    0\n5    1\n6    1\n7    2\n8    2\n9    3\ndtype: int64\n</pre></div> </div> </section> <section id=\"missing-data-operations-with-fill-values\"> <h3>Missing data / operations with fill values</h3> <p>In Series and DataFrame, the arithmetic functions have the option of inputting a <em>fill_value</em>, namely a value to substitute when at most one of the values at a location are missing. For example, when adding two DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames are missing that value, in which case the result will be NaN (you can later replace NaN with some other value using <code class=\"docutils literal notranslate\"><span class=\"pre\">fillna</span></code> if you wish).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [42]: df\nOut[42]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [43]: df2\nOut[43]: \n        one       two     three\na  1.394981  1.772517  1.000000\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [44]: df + df2\nOut[44]: \n        one       two     three\na  2.789963  3.545034       NaN\nb  0.686107  3.824246 -0.100780\nc  1.390491  2.956737  2.454870\nd       NaN  0.558688 -1.226343\n\nIn [45]: df.add(df2, fill_value=0)\nOut[45]: \n        one       two     three\na  2.789963  3.545034  1.000000\nb  0.686107  3.824246 -0.100780\nc  1.390491  2.956737  2.454870\nd       NaN  0.558688 -1.226343\n</pre></div> </div> </section> <section id=\"flexible-comparisons\"> <h3>Flexible comparisons</h3> <p>Series and DataFrame have the binary comparison methods <code class=\"docutils literal notranslate\"><span class=\"pre\">eq</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">ne</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">lt</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">gt</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">le</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">ge</span></code> whose behavior is analogous to the binary arithmetic operations described above:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [46]: df.gt(df2)\nOut[46]: \n     one    two  three\na  False  False  False\nb  False  False  False\nc  False  False  False\nd  False  False  False\n\nIn [47]: df2.ne(df)\nOut[47]: \n     one    two  three\na  False  False   True\nb  False  False  False\nc  False  False  False\nd   True  False  False\n</pre></div> </div> <p>These operations produce a pandas object of the same type as the left-hand-side input that is of dtype <code class=\"docutils literal notranslate\"><span class=\"pre\">bool</span></code>. These <code class=\"docutils literal notranslate\"><span class=\"pre\">boolean</span></code> objects can be used in indexing operations, see the section on <a class=\"reference internal\" href=\"indexing#indexing-boolean\"><span class=\"std std-ref\">Boolean indexing</span></a>.</p> </section> <section id=\"boolean-reductions\"> <h3>Boolean reductions</h3> <p>You can apply the reductions: <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.empty#pandas.DataFrame.empty\" title=\"pandas.DataFrame.empty\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">empty</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.any#pandas.DataFrame.any\" title=\"pandas.DataFrame.any\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">any()</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.all#pandas.DataFrame.all\" title=\"pandas.DataFrame.all\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">all()</span></code></a>, and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.bool#pandas.DataFrame.bool\" title=\"pandas.DataFrame.bool\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">bool()</span></code></a> to provide a way to summarize a boolean result.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [48]: (df &gt; 0).all()\nOut[48]: \none      False\ntwo       True\nthree    False\ndtype: bool\n\nIn [49]: (df &gt; 0).any()\nOut[49]: \none      True\ntwo      True\nthree    True\ndtype: bool\n</pre></div> </div> <p>You can reduce to a final boolean value.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [50]: (df &gt; 0).any().any()\nOut[50]: True\n</pre></div> </div> <p>You can test if a pandas object is empty, via the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.empty#pandas.DataFrame.empty\" title=\"pandas.DataFrame.empty\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">empty</span></code></a> property.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [51]: df.empty\nOut[51]: False\n\nIn [52]: pd.DataFrame(columns=list(\"ABC\")).empty\nOut[52]: True\n</pre></div> </div> <p>To evaluate single-element pandas objects in a boolean context, use the method <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.bool#pandas.DataFrame.bool\" title=\"pandas.DataFrame.bool\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">bool()</span></code></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [53]: pd.Series([True]).bool()\nOut[53]: True\n\nIn [54]: pd.Series([False]).bool()\nOut[54]: False\n\nIn [55]: pd.DataFrame([[True]]).bool()\nOut[55]: True\n\nIn [56]: pd.DataFrame([[False]]).bool()\nOut[56]: False\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>You might be tempted to do the following:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; if df:\n...     pass\n</pre></div> </div> <p>Or</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; df and df2\n</pre></div> </div> <p>These will both raise errors, as you are trying to compare multiple values.:</p> <div class=\"highlight-default notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">ValueError: The truth value of an array is ambiguous. Use a.empty, a.any() or a.all().\n</pre></div> </div> </div> <p>See <a class=\"reference internal\" href=\"gotchas#gotchas-truth\"><span class=\"std std-ref\">gotchas</span></a> for a more detailed discussion.</p> </section> <section id=\"comparing-if-objects-are-equivalent\"> <h3>Comparing if objects are equivalent</h3> <p>Often you may find that there is more than one way to compute the same result. As a simple example, consider <code class=\"docutils literal notranslate\"><span class=\"pre\">df</span> <span class=\"pre\">+</span> <span class=\"pre\">df</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">df</span> <span class=\"pre\">*</span> <span class=\"pre\">2</span></code>. To test that these two computations produce the same result, given the tools shown above, you might imagine using <code class=\"docutils literal notranslate\"><span class=\"pre\">(df</span> <span class=\"pre\">+</span> <span class=\"pre\">df</span> <span class=\"pre\">==</span> <span class=\"pre\">df</span> <span class=\"pre\">*</span> <span class=\"pre\">2).all()</span></code>. But in fact, this expression is False:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [57]: df + df == df * 2\nOut[57]: \n     one   two  three\na   True  True  False\nb   True  True   True\nc   True  True   True\nd  False  True   True\n\nIn [58]: (df + df == df * 2).all()\nOut[58]: \none      False\ntwo       True\nthree    False\ndtype: bool\n</pre></div> </div> <p>Notice that the boolean DataFrame <code class=\"docutils literal notranslate\"><span class=\"pre\">df</span> <span class=\"pre\">+</span> <span class=\"pre\">df</span> <span class=\"pre\">==</span> <span class=\"pre\">df</span> <span class=\"pre\">*</span> <span class=\"pre\">2</span></code> contains some False values! This is because NaNs do not compare as equals:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [59]: np.nan == np.nan\nOut[59]: False\n</pre></div> </div> <p>So, NDFrames (such as Series and DataFrames) have an <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.equals#pandas.DataFrame.equals\" title=\"pandas.DataFrame.equals\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">equals()</span></code></a> method for testing equality, with NaNs in corresponding locations treated as equal.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [60]: (df + df).equals(df * 2)\nOut[60]: True\n</pre></div> </div> <p>Note that the Series or DataFrame index needs to be in the same order for equality to be True:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [61]: df1 = pd.DataFrame({\"col\": [\"foo\", 0, np.nan]})\n\nIn [62]: df2 = pd.DataFrame({\"col\": [np.nan, 0, \"foo\"]}, index=[2, 1, 0])\n\nIn [63]: df1.equals(df2)\nOut[63]: False\n\nIn [64]: df1.equals(df2.sort_index())\nOut[64]: True\n</pre></div> </div> </section> <section id=\"comparing-array-like-objects\"> <h3>Comparing array-like objects</h3> <p>You can conveniently perform element-wise comparisons when comparing a pandas data structure with a scalar value:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [65]: pd.Series([\"foo\", \"bar\", \"baz\"]) == \"foo\"\nOut[65]: \n0     True\n1    False\n2    False\ndtype: bool\n\nIn [66]: pd.Index([\"foo\", \"bar\", \"baz\"]) == \"foo\"\nOut[66]: array([ True, False, False])\n</pre></div> </div> <p>pandas also handles element-wise comparisons between different array-like objects of the same length:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [67]: pd.Series([\"foo\", \"bar\", \"baz\"]) == pd.Index([\"foo\", \"bar\", \"qux\"])\nOut[67]: \n0     True\n1     True\n2    False\ndtype: bool\n\nIn [68]: pd.Series([\"foo\", \"bar\", \"baz\"]) == np.array([\"foo\", \"bar\", \"qux\"])\nOut[68]: \n0     True\n1     True\n2    False\ndtype: bool\n</pre></div> </div> <p>Trying to compare <code class=\"docutils literal notranslate\"><span class=\"pre\">Index</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> objects of different lengths will raise a ValueError:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [55]: pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo', 'bar'])\nValueError: Series lengths must match to compare\n\nIn [56]: pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo'])\nValueError: Series lengths must match to compare\n</pre></div> </div> <p>Note that this is different from the NumPy behavior where a comparison can be broadcast:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [69]: np.array([1, 2, 3]) == np.array([2])\nOut[69]: array([False,  True, False])\n</pre></div> </div> <p>or it can return False if broadcasting can not be done:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [70]: np.array([1, 2, 3]) == np.array([1, 2])\nOut[70]: False\n</pre></div> </div> </section> <section id=\"combining-overlapping-data-sets\"> <h3>Combining overlapping data sets</h3> <p>A problem occasionally arising is the combination of two similar data sets where values in one are preferred over the other. An example would be two data series representing a particular economic indicator where one is considered to be of “higher quality”. However, the lower quality series might extend further back in history or have more complete data coverage. As such, we would like to combine two DataFrame objects where missing values in one DataFrame are conditionally filled with like-labeled values from the other DataFrame. The function implementing this operation is <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first\" title=\"pandas.DataFrame.combine_first\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">combine_first()</span></code></a>, which we illustrate:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [71]: df1 = pd.DataFrame(\n   ....:     {\"A\": [1.0, np.nan, 3.0, 5.0, np.nan], \"B\": [np.nan, 2.0, 3.0, np.nan, 6.0]}\n   ....: )\n   ....: \n\nIn [72]: df2 = pd.DataFrame(\n   ....:     {\n   ....:         \"A\": [5.0, 2.0, 4.0, np.nan, 3.0, 7.0],\n   ....:         \"B\": [np.nan, np.nan, 3.0, 4.0, 6.0, 8.0],\n   ....:     }\n   ....: )\n   ....: \n\nIn [73]: df1\nOut[73]: \n     A    B\n0  1.0  NaN\n1  NaN  2.0\n2  3.0  3.0\n3  5.0  NaN\n4  NaN  6.0\n\nIn [74]: df2\nOut[74]: \n     A    B\n0  5.0  NaN\n1  2.0  NaN\n2  4.0  3.0\n3  NaN  4.0\n4  3.0  6.0\n5  7.0  8.0\n\nIn [75]: df1.combine_first(df2)\nOut[75]: \n     A    B\n0  1.0  NaN\n1  2.0  2.0\n2  3.0  3.0\n3  5.0  4.0\n4  3.0  6.0\n5  7.0  8.0\n</pre></div> </div> </section> <section id=\"general-dataframe-combine\"> <h3>General DataFrame combine</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first\" title=\"pandas.DataFrame.combine_first\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">combine_first()</span></code></a> method above calls the more general <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.combine#pandas.DataFrame.combine\" title=\"pandas.DataFrame.combine\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.combine()</span></code></a>. This method takes another DataFrame and a combiner function, aligns the input DataFrame and then passes the combiner function pairs of Series (i.e., columns whose names are the same).</p> <p>So, for instance, to reproduce <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first\" title=\"pandas.DataFrame.combine_first\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">combine_first()</span></code></a> as above:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [76]: def combiner(x, y):\n   ....:     return np.where(pd.isna(x), y, x)\n   ....: \n\nIn [77]: df1.combine(df2, combiner)\nOut[77]: \n     A    B\n0  1.0  NaN\n1  2.0  2.0\n2  3.0  3.0\n3  5.0  4.0\n4  3.0  6.0\n5  7.0  8.0\n</pre></div> </div> </section> </section> <section id=\"descriptive-statistics\"> <h2>Descriptive statistics</h2> <p>There exists a large number of methods for computing descriptive statistics and other related operations on <a class=\"reference internal\" href=\"../reference/series#api-series-stats\"><span class=\"std std-ref\">Series</span></a>, <a class=\"reference internal\" href=\"../reference/frame#api-dataframe-stats\"><span class=\"std std-ref\">DataFrame</span></a>. Most of these are aggregations (hence producing a lower-dimensional result) like <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.sum#pandas.DataFrame.sum\" title=\"pandas.DataFrame.sum\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">sum()</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.mean#pandas.DataFrame.mean\" title=\"pandas.DataFrame.mean\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">mean()</span></code></a>, and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.quantile#pandas.DataFrame.quantile\" title=\"pandas.DataFrame.quantile\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">quantile()</span></code></a>, but some of them, like <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.cumsum#pandas.DataFrame.cumsum\" title=\"pandas.DataFrame.cumsum\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">cumsum()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.cumprod#pandas.DataFrame.cumprod\" title=\"pandas.DataFrame.cumprod\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">cumprod()</span></code></a>, produce an object of the same size. Generally speaking, these methods take an <strong>axis</strong> argument, just like <em>ndarray.{sum, std, …}</em>, but the axis can be specified by name or integer:</p> <ul class=\"simple\"> <li><p><strong>Series</strong>: no axis argument needed</p></li> <li><p><strong>DataFrame</strong>: “index” (axis=0, default), “columns” (axis=1)</p></li> </ul> <p>For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [78]: df\nOut[78]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [79]: df.mean(0)\nOut[79]: \none      0.811094\ntwo      1.360588\nthree    0.187958\ndtype: float64\n\nIn [80]: df.mean(1)\nOut[80]: \na    1.583749\nb    0.734929\nc    1.133683\nd   -0.166914\ndtype: float64\n</pre></div> </div> <p>All such methods have a <code class=\"docutils literal notranslate\"><span class=\"pre\">skipna</span></code> option signaling whether to exclude missing data (<code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> by default):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [81]: df.sum(0, skipna=False)\nOut[81]: \none           NaN\ntwo      5.442353\nthree         NaN\ndtype: float64\n\nIn [82]: df.sum(axis=1, skipna=True)\nOut[82]: \na    3.167498\nb    2.204786\nc    3.401050\nd   -0.333828\ndtype: float64\n</pre></div> </div> <p>Combined with the broadcasting / arithmetic behavior, one can describe various statistical procedures, like standardization (rendering data zero mean and standard deviation of 1), very concisely:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [83]: ts_stand = (df - df.mean()) / df.std()\n\nIn [84]: ts_stand.std()\nOut[84]: \none      1.0\ntwo      1.0\nthree    1.0\ndtype: float64\n\nIn [85]: xs_stand = df.sub(df.mean(1), axis=0).div(df.std(1), axis=0)\n\nIn [86]: xs_stand.std(1)\nOut[86]: \na    1.0\nb    1.0\nc    1.0\nd    1.0\ndtype: float64\n</pre></div> </div> <p>Note that methods like <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.cumsum#pandas.DataFrame.cumsum\" title=\"pandas.DataFrame.cumsum\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">cumsum()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.cumprod#pandas.DataFrame.cumprod\" title=\"pandas.DataFrame.cumprod\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">cumprod()</span></code></a> preserve the location of <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code> values. This is somewhat different from <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.expanding#pandas.DataFrame.expanding\" title=\"pandas.DataFrame.expanding\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">expanding()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.rolling#pandas.DataFrame.rolling\" title=\"pandas.DataFrame.rolling\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">rolling()</span></code></a> since <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code> behavior is furthermore dictated by a <code class=\"docutils literal notranslate\"><span class=\"pre\">min_periods</span></code> parameter.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [87]: df.cumsum()\nOut[87]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  1.738035  3.684640 -0.050390\nc  2.433281  5.163008  1.177045\nd       NaN  5.442353  0.563873\n</pre></div> </div> <p>Here is a quick reference summary table of common functions. Each also takes an optional <code class=\"docutils literal notranslate\"><span class=\"pre\">level</span></code> parameter which applies only if the object has a <a class=\"reference internal\" href=\"advanced#advanced-hierarchical\"><span class=\"std std-ref\">hierarchical index</span></a>.</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 20%\"> <col style=\"width: 80%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Function</p></th> <th class=\"head\"><p>Description</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">count</span></code></p></td> <td><p>Number of non-NA observations</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">sum</span></code></p></td> <td><p>Sum of values</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">mean</span></code></p></td> <td><p>Mean of values</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">mad</span></code></p></td> <td><p>Mean absolute deviation</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">median</span></code></p></td> <td><p>Arithmetic median of values</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">min</span></code></p></td> <td><p>Minimum</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">max</span></code></p></td> <td><p>Maximum</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">mode</span></code></p></td> <td><p>Mode</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">abs</span></code></p></td> <td><p>Absolute Value</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">prod</span></code></p></td> <td><p>Product of values</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">std</span></code></p></td> <td><p>Bessel-corrected sample standard deviation</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">var</span></code></p></td> <td><p>Unbiased variance</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">sem</span></code></p></td> <td><p>Standard error of the mean</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">skew</span></code></p></td> <td><p>Sample skewness (3rd moment)</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">kurt</span></code></p></td> <td><p>Sample kurtosis (4th moment)</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">quantile</span></code></p></td> <td><p>Sample quantile (value at %)</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">cumsum</span></code></p></td> <td><p>Cumulative sum</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">cumprod</span></code></p></td> <td><p>Cumulative product</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">cummax</span></code></p></td> <td><p>Cumulative maximum</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">cummin</span></code></p></td> <td><p>Cumulative minimum</p></td> </tr> </tbody> </table> <p>Note that by chance some NumPy methods, like <code class=\"docutils literal notranslate\"><span class=\"pre\">mean</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">std</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">sum</span></code>, will exclude NAs on Series input by default:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [88]: np.mean(df[\"one\"])\nOut[88]: 0.8110935116651192\n\nIn [89]: np.mean(df[\"one\"].to_numpy())\nOut[89]: nan\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.nunique#pandas.Series.nunique\" title=\"pandas.Series.nunique\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.nunique()</span></code></a> will return the number of unique non-NA values in a Series:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [90]: series = pd.Series(np.random.randn(500))\n\nIn [91]: series[20:500] = np.nan\n\nIn [92]: series[10:20] = 5\n\nIn [93]: series.nunique()\nOut[93]: 11\n</pre></div> </div> <section id=\"summarizing-data-describe\"> <h3>Summarizing data: describe</h3> <p>There is a convenient <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.describe#pandas.DataFrame.describe\" title=\"pandas.DataFrame.describe\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">describe()</span></code></a> function which computes a variety of summary statistics about a Series or the columns of a DataFrame (excluding NAs of course):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [94]: series = pd.Series(np.random.randn(1000))\n\nIn [95]: series[::2] = np.nan\n\nIn [96]: series.describe()\nOut[96]: \ncount    500.000000\nmean      -0.021292\nstd        1.015906\nmin       -2.683763\n25%       -0.699070\n50%       -0.069718\n75%        0.714483\nmax        3.160915\ndtype: float64\n\nIn [97]: frame = pd.DataFrame(np.random.randn(1000, 5), columns=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\nIn [98]: frame.iloc[::2] = np.nan\n\nIn [99]: frame.describe()\nOut[99]: \n                a           b           c           d           e\ncount  500.000000  500.000000  500.000000  500.000000  500.000000\nmean     0.033387    0.030045   -0.043719   -0.051686    0.005979\nstd      1.017152    0.978743    1.025270    1.015988    1.006695\nmin     -3.000951   -2.637901   -3.303099   -3.159200   -3.188821\n25%     -0.647623   -0.576449   -0.712369   -0.691338   -0.691115\n50%      0.047578   -0.021499   -0.023888   -0.032652   -0.025363\n75%      0.729907    0.775880    0.618896    0.670047    0.649748\nmax      2.740139    2.752332    3.004229    2.728702    3.240991\n</pre></div> </div> <p>You can select specific percentiles to include in the output:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [100]: series.describe(percentiles=[0.05, 0.25, 0.75, 0.95])\nOut[100]: \ncount    500.000000\nmean      -0.021292\nstd        1.015906\nmin       -2.683763\n5%        -1.645423\n25%       -0.699070\n50%       -0.069718\n75%        0.714483\n95%        1.711409\nmax        3.160915\ndtype: float64\n</pre></div> </div> <p>By default, the median is always included.</p> <p>For a non-numerical Series object, <a class=\"reference internal\" href=\"../reference/api/pandas.series.describe#pandas.Series.describe\" title=\"pandas.Series.describe\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">describe()</span></code></a> will give a simple summary of the number of unique values and most frequently occurring values:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [101]: s = pd.Series([\"a\", \"a\", \"b\", \"b\", \"a\", \"a\", np.nan, \"c\", \"d\", \"a\"])\n\nIn [102]: s.describe()\nOut[102]: \ncount     9\nunique    4\ntop       a\nfreq      5\ndtype: object\n</pre></div> </div> <p>Note that on a mixed-type DataFrame object, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.describe#pandas.DataFrame.describe\" title=\"pandas.DataFrame.describe\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">describe()</span></code></a> will restrict the summary to include only numerical columns or, if none are, only categorical columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [103]: frame = pd.DataFrame({\"a\": [\"Yes\", \"Yes\", \"No\", \"No\"], \"b\": range(4)})\n\nIn [104]: frame.describe()\nOut[104]: \n              b\ncount  4.000000\nmean   1.500000\nstd    1.290994\nmin    0.000000\n25%    0.750000\n50%    1.500000\n75%    2.250000\nmax    3.000000\n</pre></div> </div> <p>This behavior can be controlled by providing a list of types as <code class=\"docutils literal notranslate\"><span class=\"pre\">include</span></code>/<code class=\"docutils literal notranslate\"><span class=\"pre\">exclude</span></code> arguments. The special value <code class=\"docutils literal notranslate\"><span class=\"pre\">all</span></code> can also be used:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [105]: frame.describe(include=[\"object\"])\nOut[105]: \n          a\ncount     4\nunique    2\ntop     Yes\nfreq      2\n\nIn [106]: frame.describe(include=[\"number\"])\nOut[106]: \n              b\ncount  4.000000\nmean   1.500000\nstd    1.290994\nmin    0.000000\n25%    0.750000\n50%    1.500000\n75%    2.250000\nmax    3.000000\n\nIn [107]: frame.describe(include=\"all\")\nOut[107]: \n          a         b\ncount     4  4.000000\nunique    2       NaN\ntop     Yes       NaN\nfreq      2       NaN\nmean    NaN  1.500000\nstd     NaN  1.290994\nmin     NaN  0.000000\n25%     NaN  0.750000\n50%     NaN  1.500000\n75%     NaN  2.250000\nmax     NaN  3.000000\n</pre></div> </div> <p>That feature relies on <a class=\"reference internal\" href=\"#basics-selectdtypes\"><span class=\"std std-ref\">select_dtypes</span></a>. Refer to there for details about accepted inputs.</p> </section> <section id=\"index-of-min-max-values\"> <h3>Index of min/max values</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.idxmin#pandas.DataFrame.idxmin\" title=\"pandas.DataFrame.idxmin\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">idxmin()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.idxmax#pandas.DataFrame.idxmax\" title=\"pandas.DataFrame.idxmax\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">idxmax()</span></code></a> functions on Series and DataFrame compute the index labels with the minimum and maximum corresponding values:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [108]: s1 = pd.Series(np.random.randn(5))\n\nIn [109]: s1\nOut[109]: \n0    1.118076\n1   -0.352051\n2   -1.242883\n3   -1.277155\n4   -0.641184\ndtype: float64\n\nIn [110]: s1.idxmin(), s1.idxmax()\nOut[110]: (3, 0)\n\nIn [111]: df1 = pd.DataFrame(np.random.randn(5, 3), columns=[\"A\", \"B\", \"C\"])\n\nIn [112]: df1\nOut[112]: \n          A         B         C\n0 -0.327863 -0.946180 -0.137570\n1 -0.186235 -0.257213 -0.486567\n2 -0.507027 -0.871259 -0.111110\n3  2.000339 -2.430505  0.089759\n4 -0.321434 -0.033695  0.096271\n\nIn [113]: df1.idxmin(axis=0)\nOut[113]: \nA    2\nB    3\nC    1\ndtype: int64\n\nIn [114]: df1.idxmax(axis=1)\nOut[114]: \n0    C\n1    A\n2    C\n3    A\n4    C\ndtype: object\n</pre></div> </div> <p>When there are multiple rows (or columns) matching the minimum or maximum value, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.idxmin#pandas.DataFrame.idxmin\" title=\"pandas.DataFrame.idxmin\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">idxmin()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.idxmax#pandas.DataFrame.idxmax\" title=\"pandas.DataFrame.idxmax\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">idxmax()</span></code></a> return the first matching index:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [115]: df3 = pd.DataFrame([2, 1, 1, 3, np.nan], columns=[\"A\"], index=list(\"edcba\"))\n\nIn [116]: df3\nOut[116]: \n     A\ne  2.0\nd  1.0\nc  1.0\nb  3.0\na  NaN\n\nIn [117]: df3[\"A\"].idxmin()\nOut[117]: 'd'\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">idxmin</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">idxmax</span></code> are called <code class=\"docutils literal notranslate\"><span class=\"pre\">argmin</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">argmax</span></code> in NumPy.</p> </div> </section> <section id=\"value-counts-histogramming-mode\"> <h3>Value counts (histogramming) / mode</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.series.value_counts#pandas.Series.value_counts\" title=\"pandas.Series.value_counts\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">value_counts()</span></code></a> Series method and top-level function computes a histogram of a 1D array of values. It can also be used as a function on regular arrays:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [118]: data = np.random.randint(0, 7, size=50)\n\nIn [119]: data\nOut[119]: \narray([6, 6, 2, 3, 5, 3, 2, 5, 4, 5, 4, 3, 4, 5, 0, 2, 0, 4, 2, 0, 3, 2,\n       2, 5, 6, 5, 3, 4, 6, 4, 3, 5, 6, 4, 3, 6, 2, 6, 6, 2, 3, 4, 2, 1,\n       6, 2, 6, 1, 5, 4])\n\nIn [120]: s = pd.Series(data)\n\nIn [121]: s.value_counts()\nOut[121]: \n6    10\n2    10\n4     9\n3     8\n5     8\n0     3\n1     2\ndtype: int64\n\nIn [122]: pd.value_counts(data)\nOut[122]: \n6    10\n2    10\n4     9\n3     8\n5     8\n0     3\n1     2\ndtype: int64\n</pre></div> </div> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.1.0.</span></p> </div> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.value_counts#pandas.DataFrame.value_counts\" title=\"pandas.DataFrame.value_counts\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">value_counts()</span></code></a> method can be used to count combinations across multiple columns. By default all columns are used but a subset can be selected using the <code class=\"docutils literal notranslate\"><span class=\"pre\">subset</span></code> argument.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [123]: data = {\"a\": [1, 2, 3, 4], \"b\": [\"x\", \"x\", \"y\", \"y\"]}\n\nIn [124]: frame = pd.DataFrame(data)\n\nIn [125]: frame.value_counts()\nOut[125]: \na  b\n1  x    1\n2  x    1\n3  y    1\n4  y    1\ndtype: int64\n</pre></div> </div> <p>Similarly, you can get the most frequently occurring value(s), i.e. the mode, of the values in a Series or DataFrame:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [126]: s5 = pd.Series([1, 1, 3, 3, 3, 5, 5, 7, 7, 7])\n\nIn [127]: s5.mode()\nOut[127]: \n0    3\n1    7\ndtype: int64\n\nIn [128]: df5 = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": np.random.randint(0, 7, size=50),\n   .....:         \"B\": np.random.randint(-10, 15, size=50),\n   .....:     }\n   .....: )\n   .....: \n\nIn [129]: df5.mode()\nOut[129]: \n     A   B\n0  1.0  -9\n1  NaN  10\n2  NaN  13\n</pre></div> </div> </section> <section id=\"discretization-and-quantiling\"> <h3>Discretization and quantiling</h3> <p>Continuous values can be discretized using the <a class=\"reference internal\" href=\"../reference/api/pandas.cut#pandas.cut\" title=\"pandas.cut\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">cut()</span></code></a> (bins based on values) and <a class=\"reference internal\" href=\"../reference/api/pandas.qcut#pandas.qcut\" title=\"pandas.qcut\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">qcut()</span></code></a> (bins based on sample quantiles) functions:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [130]: arr = np.random.randn(20)\n\nIn [131]: factor = pd.cut(arr, 4)\n\nIn [132]: factor\nOut[132]: \n[(-0.251, 0.464], (-0.968, -0.251], (0.464, 1.179], (-0.251, 0.464], (-0.968, -0.251], ..., (-0.251, 0.464], (-0.968, -0.251], (-0.968, -0.251], (-0.968, -0.251], (-0.968, -0.251]]\nLength: 20\nCategories (4, interval[float64, right]): [(-0.968, -0.251] &lt; (-0.251, 0.464] &lt; (0.464, 1.179] &lt;\n                                           (1.179, 1.893]]\n\nIn [133]: factor = pd.cut(arr, [-5, -1, 0, 1, 5])\n\nIn [134]: factor\nOut[134]: \n[(0, 1], (-1, 0], (0, 1], (0, 1], (-1, 0], ..., (-1, 0], (-1, 0], (-1, 0], (-1, 0], (-1, 0]]\nLength: 20\nCategories (4, interval[int64, right]): [(-5, -1] &lt; (-1, 0] &lt; (0, 1] &lt; (1, 5]]\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.qcut#pandas.qcut\" title=\"pandas.qcut\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">qcut()</span></code></a> computes sample quantiles. For example, we could slice up some normally distributed data into equal-size quartiles like so:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [135]: arr = np.random.randn(30)\n\nIn [136]: factor = pd.qcut(arr, [0, 0.25, 0.5, 0.75, 1])\n\nIn [137]: factor\nOut[137]: \n[(0.569, 1.184], (-2.278, -0.301], (-2.278, -0.301], (0.569, 1.184], (0.569, 1.184], ..., (-0.301, 0.569], (1.184, 2.346], (1.184, 2.346], (-0.301, 0.569], (-2.278, -0.301]]\nLength: 30\nCategories (4, interval[float64, right]): [(-2.278, -0.301] &lt; (-0.301, 0.569] &lt; (0.569, 1.184] &lt;\n                                           (1.184, 2.346]]\n\nIn [138]: pd.value_counts(factor)\nOut[138]: \n(-2.278, -0.301]    8\n(1.184, 2.346]      8\n(-0.301, 0.569]     7\n(0.569, 1.184]      7\ndtype: int64\n</pre></div> </div> <p>We can also pass infinite values to define the bins:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [139]: arr = np.random.randn(20)\n\nIn [140]: factor = pd.cut(arr, [-np.inf, 0, np.inf])\n\nIn [141]: factor\nOut[141]: \n[(-inf, 0.0], (0.0, inf], (0.0, inf], (-inf, 0.0], (-inf, 0.0], ..., (-inf, 0.0], (-inf, 0.0], (-inf, 0.0], (0.0, inf], (0.0, inf]]\nLength: 20\nCategories (2, interval[float64, right]): [(-inf, 0.0] &lt; (0.0, inf]]\n</pre></div> </div> </section> </section> <section id=\"function-application\"> <h2>Function application</h2> <p>To apply your own or another library’s functions to pandas objects, you should be aware of the three methods below. The appropriate method to use depends on whether your function expects to operate on an entire <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>, row- or column-wise, or elementwise.</p> <ol class=\"arabic simple\"> <li><p><a class=\"reference internal\" href=\"#tablewise-function-application\">Tablewise Function Application</a>: <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.pipe#pandas.DataFrame.pipe\" title=\"pandas.DataFrame.pipe\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">pipe()</span></code></a></p></li> <li><p><a class=\"reference internal\" href=\"#row-or-column-wise-function-application\">Row or Column-wise Function Application</a>: <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a></p></li> <li><p><a class=\"reference internal\" href=\"#aggregation-api\">Aggregation API</a>: <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.agg#pandas.DataFrame.agg\" title=\"pandas.DataFrame.agg\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">agg()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform\" title=\"pandas.DataFrame.transform\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">transform()</span></code></a></p></li> <li><p><a class=\"reference internal\" href=\"#applying-elementwise-functions\">Applying Elementwise Functions</a>: <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.applymap#pandas.DataFrame.applymap\" title=\"pandas.DataFrame.applymap\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">applymap()</span></code></a></p></li> </ol> <section id=\"tablewise-function-application\"> <h3>Tablewise function application</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> can be passed into functions. However, if the function needs to be called in a chain, consider using the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.pipe#pandas.DataFrame.pipe\" title=\"pandas.DataFrame.pipe\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">pipe()</span></code></a> method.</p> <p>First some setup:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [142]: def extract_city_name(df):\n   .....:     \"\"\"\n   .....:     Chicago, IL -&gt; Chicago for city_name column\n   .....:     \"\"\"\n   .....:     df[\"city_name\"] = df[\"city_and_code\"].str.split(\",\").str.get(0)\n   .....:     return df\n   .....: \n\nIn [143]: def add_country_name(df, country_name=None):\n   .....:     \"\"\"\n   .....:     Chicago -&gt; Chicago-US for city_name column\n   .....:     \"\"\"\n   .....:     col = \"city_name\"\n   .....:     df[\"city_and_country\"] = df[col] + country_name\n   .....:     return df\n   .....: \n\nIn [144]: df_p = pd.DataFrame({\"city_and_code\": [\"Chicago, IL\"]})\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">extract_city_name</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">add_country_name</span></code> are functions taking and returning <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code>.</p> <p>Now compare the following:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [145]: add_country_name(extract_city_name(df_p), country_name=\"US\")\nOut[145]: \n  city_and_code city_name city_and_country\n0   Chicago, IL   Chicago        ChicagoUS\n</pre></div> </div> <p>Is equivalent to:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [146]: df_p.pipe(extract_city_name).pipe(add_country_name, country_name=\"US\")\nOut[146]: \n  city_and_code city_name city_and_country\n0   Chicago, IL   Chicago        ChicagoUS\n</pre></div> </div> <p>pandas encourages the second style, which is known as method chaining. <code class=\"docutils literal notranslate\"><span class=\"pre\">pipe</span></code> makes it easy to use your own or another library’s functions in method chains, alongside pandas’ methods.</p> <p>In the example above, the functions <code class=\"docutils literal notranslate\"><span class=\"pre\">extract_city_name</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">add_country_name</span></code> each expected a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> as the first positional argument. What if the function you wish to apply takes its data as, say, the second argument? In this case, provide <code class=\"docutils literal notranslate\"><span class=\"pre\">pipe</span></code> with a tuple of <code class=\"docutils literal notranslate\"><span class=\"pre\">(callable,</span> <span class=\"pre\">data_keyword)</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">.pipe</span></code> will route the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> to the argument specified in the tuple.</p> <p>For example, we can fit a regression using statsmodels. Their API expects a formula first and a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> as the second argument, <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code>. We pass in the function, keyword pair <code class=\"docutils literal notranslate\"><span class=\"pre\">(sm.ols,</span> <span class=\"pre\">'data')</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">pipe</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [147]: import statsmodels.formula.api as sm\n\nIn [148]: bb = pd.read_csv(\"data/baseball.csv\", index_col=\"id\")\n\nIn [149]: (\n   .....:     bb.query(\"h &gt; 0\")\n   .....:     .assign(ln_h=lambda df: np.log(df.h))\n   .....:     .pipe((sm.ols, \"data\"), \"hr ~ ln_h + year + g + C(lg)\")\n   .....:     .fit()\n   .....:     .summary()\n   .....: )\n   .....: \nOut[149]: \n&lt;class 'statsmodels.iolib.summary.Summary'&gt;\n\"\"\"\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                     hr   R-squared:                       0.685\nModel:                            OLS   Adj. R-squared:                  0.665\nMethod:                 Least Squares   F-statistic:                     34.28\nDate:                Sat, 22 Jan 2022   Prob (F-statistic):           3.48e-15\nTime:                        10:50:02   Log-Likelihood:                -205.92\nNo. Observations:                  68   AIC:                             421.8\nDf Residuals:                      63   BIC:                             432.9\nDf Model:                           4                                         \nCovariance Type:            nonrobust                                         \n===============================================================================\n                  coef    std err          t      P&gt;|t|      [0.025      0.975]\n-------------------------------------------------------------------------------\nIntercept   -8484.7720   4664.146     -1.819      0.074   -1.78e+04     835.780\nC(lg)[T.NL]    -2.2736      1.325     -1.716      0.091      -4.922       0.375\nln_h           -1.3542      0.875     -1.547      0.127      -3.103       0.395\nyear            4.2277      2.324      1.819      0.074      -0.417       8.872\ng               0.1841      0.029      6.258      0.000       0.125       0.243\n==============================================================================\nOmnibus:                       10.875   Durbin-Watson:                   1.999\nProb(Omnibus):                  0.004   Jarque-Bera (JB):               17.298\nSkew:                           0.537   Prob(JB):                     0.000175\nKurtosis:                       5.225   Cond. No.                     1.49e+07\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n[2] The condition number is large, 1.49e+07. This might indicate that there are\nstrong multicollinearity or other numerical problems.\n\"\"\"\n</pre></div> </div> <p>The pipe method is inspired by unix pipes and more recently <a class=\"reference external\" href=\"https://github.com/tidyverse/dplyr\">dplyr</a> and <a class=\"reference external\" href=\"https://github.com/tidyverse/magrittr\">magrittr</a>, which have introduced the popular <code class=\"docutils literal notranslate\"><span class=\"pre\">(%&gt;%)</span></code> (read pipe) operator for <a class=\"reference external\" href=\"https://www.r-project.org\">R</a>. The implementation of <code class=\"docutils literal notranslate\"><span class=\"pre\">pipe</span></code> here is quite clean and feels right at home in Python. We encourage you to view the source code of <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.pipe#pandas.DataFrame.pipe\" title=\"pandas.DataFrame.pipe\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">pipe()</span></code></a>.</p> </section> <section id=\"row-or-column-wise-function-application\"> <h3>Row or column-wise function application</h3> <p>Arbitrary functions can be applied along the axes of a DataFrame using the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a> method, which, like the descriptive statistics methods, takes an optional <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> argument:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [150]: df.apply(np.mean)\nOut[150]: \none      0.811094\ntwo      1.360588\nthree    0.187958\ndtype: float64\n\nIn [151]: df.apply(np.mean, axis=1)\nOut[151]: \na    1.583749\nb    0.734929\nc    1.133683\nd   -0.166914\ndtype: float64\n\nIn [152]: df.apply(lambda x: x.max() - x.min())\nOut[152]: \none      1.051928\ntwo      1.632779\nthree    1.840607\ndtype: float64\n\nIn [153]: df.apply(np.cumsum)\nOut[153]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  1.738035  3.684640 -0.050390\nc  2.433281  5.163008  1.177045\nd       NaN  5.442353  0.563873\n\nIn [154]: df.apply(np.exp)\nOut[154]: \n        one       two     three\na  4.034899  5.885648       NaN\nb  1.409244  6.767440  0.950858\nc  2.004201  4.385785  3.412466\nd       NaN  1.322262  0.541630\n</pre></div> </div> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a> method will also dispatch on a string method name.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [155]: df.apply(\"mean\")\nOut[155]: \none      0.811094\ntwo      1.360588\nthree    0.187958\ndtype: float64\n\nIn [156]: df.apply(\"mean\", axis=1)\nOut[156]: \na    1.583749\nb    0.734929\nc    1.133683\nd   -0.166914\ndtype: float64\n</pre></div> </div> <p>The return type of the function passed to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a> affects the type of the final output from <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.apply</span></code> for the default behaviour:</p> <ul class=\"simple\"> <li><p>If the applied function returns a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>, the final output is a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>. The columns match the index of the <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> returned by the applied function.</p></li> <li><p>If the applied function returns any other type, the final output is a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>.</p></li> </ul> <p>This default behaviour can be overridden using the <code class=\"docutils literal notranslate\"><span class=\"pre\">result_type</span></code>, which accepts three options: <code class=\"docutils literal notranslate\"><span class=\"pre\">reduce</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">broadcast</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">expand</span></code>. These will determine how list-likes return values expand (or not) to a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a> combined with some cleverness can be used to answer many questions about a data set. For example, suppose we wanted to extract the date where the maximum value for each column occurred:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [157]: tsdf = pd.DataFrame(\n   .....:     np.random.randn(1000, 3),\n   .....:     columns=[\"A\", \"B\", \"C\"],\n   .....:     index=pd.date_range(\"1/1/2000\", periods=1000),\n   .....: )\n   .....: \n\nIn [158]: tsdf.apply(lambda x: x.idxmax())\nOut[158]: \nA   2000-08-06\nB   2001-01-18\nC   2001-07-18\ndtype: datetime64[ns]\n</pre></div> </div> <p>You may also pass additional arguments and keyword arguments to the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a> method. For instance, consider the following function you would like to apply:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">def subtract_and_divide(x, sub, divide=1):\n    return (x - sub) / divide\n</pre></div> </div> <p>You may then apply this function as follows:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df.apply(subtract_and_divide, args=(5,), divide=3)\n</pre></div> </div> <p>Another useful feature is the ability to pass Series methods to carry out some Series operation on each column or row:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [159]: tsdf\nOut[159]: \n                   A         B         C\n2000-01-01 -0.158131 -0.232466  0.321604\n2000-01-02 -1.810340 -3.105758  0.433834\n2000-01-03 -1.209847 -1.156793 -0.136794\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08 -0.653602  0.178875  1.008298\n2000-01-09  1.007996  0.462824  0.254472\n2000-01-10  0.307473  0.600337  1.643950\n\nIn [160]: tsdf.apply(pd.Series.interpolate)\nOut[160]: \n                   A         B         C\n2000-01-01 -0.158131 -0.232466  0.321604\n2000-01-02 -1.810340 -3.105758  0.433834\n2000-01-03 -1.209847 -1.156793 -0.136794\n2000-01-04 -1.098598 -0.889659  0.092225\n2000-01-05 -0.987349 -0.622526  0.321243\n2000-01-06 -0.876100 -0.355392  0.550262\n2000-01-07 -0.764851 -0.088259  0.779280\n2000-01-08 -0.653602  0.178875  1.008298\n2000-01-09  1.007996  0.462824  0.254472\n2000-01-10  0.307473  0.600337  1.643950\n</pre></div> </div> <p>Finally, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a> takes an argument <code class=\"docutils literal notranslate\"><span class=\"pre\">raw</span></code> which is False by default, which converts each row or column into a Series before applying the function. When set to True, the passed function will instead receive an ndarray object, which has positive performance implications if you do not need the indexing functionality.</p> </section> <section id=\"aggregation-api\"> <h3>Aggregation API</h3> <p>The aggregation API allows one to express possibly multiple aggregation operations in a single concise way. This API is similar across pandas objects, see <a class=\"reference internal\" href=\"groupby#groupby-aggregate\"><span class=\"std std-ref\">groupby API</span></a>, the <a class=\"reference internal\" href=\"window#window-overview\"><span class=\"std std-ref\">window API</span></a>, and the <a class=\"reference internal\" href=\"timeseries#timeseries-aggregate\"><span class=\"std std-ref\">resample API</span></a>. The entry point for aggregation is <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.aggregate#pandas.DataFrame.aggregate\" title=\"pandas.DataFrame.aggregate\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.aggregate()</span></code></a>, or the alias <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.agg#pandas.DataFrame.agg\" title=\"pandas.DataFrame.agg\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.agg()</span></code></a>.</p> <p>We will use a similar starting frame from above:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [161]: tsdf = pd.DataFrame(\n   .....:     np.random.randn(10, 3),\n   .....:     columns=[\"A\", \"B\", \"C\"],\n   .....:     index=pd.date_range(\"1/1/2000\", periods=10),\n   .....: )\n   .....: \n\nIn [162]: tsdf.iloc[3:7] = np.nan\n\nIn [163]: tsdf\nOut[163]: \n                   A         B         C\n2000-01-01  1.257606  1.004194  0.167574\n2000-01-02 -0.749892  0.288112 -0.757304\n2000-01-03 -0.207550 -0.298599  0.116018\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08  0.814347 -0.257623  0.869226\n2000-01-09 -0.250663 -1.206601  0.896839\n2000-01-10  2.169758 -1.333363  0.283157\n</pre></div> </div> <p>Using a single function is equivalent to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a>. You can also pass named methods as strings. These will return a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> of the aggregated output:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [164]: tsdf.agg(np.sum)\nOut[164]: \nA    3.033606\nB   -1.803879\nC    1.575510\ndtype: float64\n\nIn [165]: tsdf.agg(\"sum\")\nOut[165]: \nA    3.033606\nB   -1.803879\nC    1.575510\ndtype: float64\n\n# these are equivalent to a ``.sum()`` because we are aggregating\n# on a single function\nIn [166]: tsdf.sum()\nOut[166]: \nA    3.033606\nB   -1.803879\nC    1.575510\ndtype: float64\n</pre></div> </div> <p>Single aggregations on a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> this will return a scalar value:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [167]: tsdf[\"A\"].agg(\"sum\")\nOut[167]: 3.033606102414146\n</pre></div> </div> <section id=\"aggregating-with-multiple-functions\"> <h4>Aggregating with multiple functions</h4> <p>You can pass multiple aggregation arguments as a list. The results of each of the passed functions will be a row in the resulting <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>. These are naturally named from the aggregation function.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [168]: tsdf.agg([\"sum\"])\nOut[168]: \n            A         B        C\nsum  3.033606 -1.803879  1.57551\n</pre></div> </div> <p>Multiple functions yield multiple rows:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [169]: tsdf.agg([\"sum\", \"mean\"])\nOut[169]: \n             A         B         C\nsum   3.033606 -1.803879  1.575510\nmean  0.505601 -0.300647  0.262585\n</pre></div> </div> <p>On a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>, multiple functions return a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>, indexed by the function names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [170]: tsdf[\"A\"].agg([\"sum\", \"mean\"])\nOut[170]: \nsum     3.033606\nmean    0.505601\nName: A, dtype: float64\n</pre></div> </div> <p>Passing a <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span></code> function will yield a <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;lambda&gt;</span></code> named row:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [171]: tsdf[\"A\"].agg([\"sum\", lambda x: x.mean()])\nOut[171]: \nsum         3.033606\n&lt;lambda&gt;    0.505601\nName: A, dtype: float64\n</pre></div> </div> <p>Passing a named function will yield that name for the row:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [172]: def mymean(x):\n   .....:     return x.mean()\n   .....: \n\nIn [173]: tsdf[\"A\"].agg([\"sum\", mymean])\nOut[173]: \nsum       3.033606\nmymean    0.505601\nName: A, dtype: float64\n</pre></div> </div> </section> <section id=\"aggregating-with-a-dict\"> <h4>Aggregating with a dict</h4> <p>Passing a dictionary of column names to a scalar or a list of scalars, to <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.agg</span></code> allows you to customize which functions are applied to which columns. Note that the results are not in any particular order, you can use an <code class=\"docutils literal notranslate\"><span class=\"pre\">OrderedDict</span></code> instead to guarantee ordering.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [174]: tsdf.agg({\"A\": \"mean\", \"B\": \"sum\"})\nOut[174]: \nA    0.505601\nB   -1.803879\ndtype: float64\n</pre></div> </div> <p>Passing a list-like will generate a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> output. You will get a matrix-like output of all of the aggregators. The output will consist of all unique functions. Those that are not noted for a particular column will be <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [175]: tsdf.agg({\"A\": [\"mean\", \"min\"], \"B\": \"sum\"})\nOut[175]: \n             A         B\nmean  0.505601       NaN\nmin  -0.749892       NaN\nsum        NaN -1.803879\n</pre></div> </div> </section> <section id=\"mixed-dtypes\"> <h4>Mixed dtypes</h4> <div class=\"deprecated\"> <p><span class=\"versionmodified deprecated\">Deprecated since version 1.4.0: </span>Attempting to determine which columns cannot be aggregated and silently dropping them from the results is deprecated and will be removed in a future version. If any porition of the columns or operations provided fail, the call to <code class=\"docutils literal notranslate\"><span class=\"pre\">.agg</span></code> will raise.</p> </div> <p>When presented with mixed dtypes that cannot aggregate, <code class=\"docutils literal notranslate\"><span class=\"pre\">.agg</span></code> will only take the valid aggregations. This is similar to how <code class=\"docutils literal notranslate\"><span class=\"pre\">.groupby.agg</span></code> works.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [176]: mdf = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": [1, 2, 3],\n   .....:         \"B\": [1.0, 2.0, 3.0],\n   .....:         \"C\": [\"foo\", \"bar\", \"baz\"],\n   .....:         \"D\": pd.date_range(\"20130101\", periods=3),\n   .....:     }\n   .....: )\n   .....: \n\nIn [177]: mdf.dtypes\nOut[177]: \nA             int64\nB           float64\nC            object\nD    datetime64[ns]\ndtype: object\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [178]: mdf.agg([\"min\", \"sum\"])\nOut[178]: \n     A    B          C          D\nmin  1  1.0        bar 2013-01-01\nsum  6  6.0  foobarbaz        NaT\n</pre></div> </div> </section> <section id=\"custom-describe\"> <h4>Custom describe</h4> <p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">.agg()</span></code> it is possible to easily create a custom describe function, similar to the built in <a class=\"reference internal\" href=\"#basics-describe\"><span class=\"std std-ref\">describe function</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [179]: from functools import partial\n\nIn [180]: q_25 = partial(pd.Series.quantile, q=0.25)\n\nIn [181]: q_25.__name__ = \"25%\"\n\nIn [182]: q_75 = partial(pd.Series.quantile, q=0.75)\n\nIn [183]: q_75.__name__ = \"75%\"\n\nIn [184]: tsdf.agg([\"count\", \"mean\", \"std\", \"min\", q_25, \"median\", q_75, \"max\"])\nOut[184]: \n               A         B         C\ncount   6.000000  6.000000  6.000000\nmean    0.505601 -0.300647  0.262585\nstd     1.103362  0.887508  0.606860\nmin    -0.749892 -1.333363 -0.757304\n25%    -0.239885 -0.979600  0.128907\nmedian  0.303398 -0.278111  0.225365\n75%     1.146791  0.151678  0.722709\nmax     2.169758  1.004194  0.896839\n</pre></div> </div> </section> </section> <section id=\"transform-api\"> <h3>Transform API</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform\" title=\"pandas.DataFrame.transform\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">transform()</span></code></a> method returns an object that is indexed the same (same size) as the original. This API allows you to provide <em>multiple</em> operations at the same time rather than one-by-one. Its API is quite similar to the <code class=\"docutils literal notranslate\"><span class=\"pre\">.agg</span></code> API.</p> <p>We create a frame similar to the one used in the above sections.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [185]: tsdf = pd.DataFrame(\n   .....:     np.random.randn(10, 3),\n   .....:     columns=[\"A\", \"B\", \"C\"],\n   .....:     index=pd.date_range(\"1/1/2000\", periods=10),\n   .....: )\n   .....: \n\nIn [186]: tsdf.iloc[3:7] = np.nan\n\nIn [187]: tsdf\nOut[187]: \n                   A         B         C\n2000-01-01 -0.428759 -0.864890 -0.675341\n2000-01-02 -0.168731  1.338144 -1.279321\n2000-01-03 -1.621034  0.438107  0.903794\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08  0.254374 -1.240447 -0.201052\n2000-01-09 -0.157795  0.791197 -1.144209\n2000-01-10 -0.030876  0.371900  0.061932\n</pre></div> </div> <p>Transform the entire frame. <code class=\"docutils literal notranslate\"><span class=\"pre\">.transform()</span></code> allows input functions as: a NumPy function, a string function name or a user defined function.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [188]: tsdf.transform(np.abs)\nOut[188]: \n                   A         B         C\n2000-01-01  0.428759  0.864890  0.675341\n2000-01-02  0.168731  1.338144  1.279321\n2000-01-03  1.621034  0.438107  0.903794\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08  0.254374  1.240447  0.201052\n2000-01-09  0.157795  0.791197  1.144209\n2000-01-10  0.030876  0.371900  0.061932\n\nIn [189]: tsdf.transform(\"abs\")\nOut[189]: \n                   A         B         C\n2000-01-01  0.428759  0.864890  0.675341\n2000-01-02  0.168731  1.338144  1.279321\n2000-01-03  1.621034  0.438107  0.903794\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08  0.254374  1.240447  0.201052\n2000-01-09  0.157795  0.791197  1.144209\n2000-01-10  0.030876  0.371900  0.061932\n\nIn [190]: tsdf.transform(lambda x: x.abs())\nOut[190]: \n                   A         B         C\n2000-01-01  0.428759  0.864890  0.675341\n2000-01-02  0.168731  1.338144  1.279321\n2000-01-03  1.621034  0.438107  0.903794\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08  0.254374  1.240447  0.201052\n2000-01-09  0.157795  0.791197  1.144209\n2000-01-10  0.030876  0.371900  0.061932\n</pre></div> </div> <p>Here <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform\" title=\"pandas.DataFrame.transform\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">transform()</span></code></a> received a single function; this is equivalent to a <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/ufuncs.html\">ufunc</a> application.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [191]: np.abs(tsdf)\nOut[191]: \n                   A         B         C\n2000-01-01  0.428759  0.864890  0.675341\n2000-01-02  0.168731  1.338144  1.279321\n2000-01-03  1.621034  0.438107  0.903794\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08  0.254374  1.240447  0.201052\n2000-01-09  0.157795  0.791197  1.144209\n2000-01-10  0.030876  0.371900  0.061932\n</pre></div> </div> <p>Passing a single function to <code class=\"docutils literal notranslate\"><span class=\"pre\">.transform()</span></code> with a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> will yield a single <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> in return.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [192]: tsdf[\"A\"].transform(np.abs)\nOut[192]: \n2000-01-01    0.428759\n2000-01-02    0.168731\n2000-01-03    1.621034\n2000-01-04         NaN\n2000-01-05         NaN\n2000-01-06         NaN\n2000-01-07         NaN\n2000-01-08    0.254374\n2000-01-09    0.157795\n2000-01-10    0.030876\nFreq: D, Name: A, dtype: float64\n</pre></div> </div> <section id=\"transform-with-multiple-functions\"> <h4>Transform with multiple functions</h4> <p>Passing multiple functions will yield a column MultiIndexed DataFrame. The first level will be the original frame column names; the second level will be the names of the transforming functions.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [193]: tsdf.transform([np.abs, lambda x: x + 1])\nOut[193]: \n                   A                   B                   C          \n            absolute  &lt;lambda&gt;  absolute  &lt;lambda&gt;  absolute  &lt;lambda&gt;\n2000-01-01  0.428759  0.571241  0.864890  0.135110  0.675341  0.324659\n2000-01-02  0.168731  0.831269  1.338144  2.338144  1.279321 -0.279321\n2000-01-03  1.621034 -0.621034  0.438107  1.438107  0.903794  1.903794\n2000-01-04       NaN       NaN       NaN       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN       NaN       NaN       NaN\n2000-01-08  0.254374  1.254374  1.240447 -0.240447  0.201052  0.798948\n2000-01-09  0.157795  0.842205  0.791197  1.791197  1.144209 -0.144209\n2000-01-10  0.030876  0.969124  0.371900  1.371900  0.061932  1.061932\n</pre></div> </div> <p>Passing multiple functions to a Series will yield a DataFrame. The resulting column names will be the transforming functions.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [194]: tsdf[\"A\"].transform([np.abs, lambda x: x + 1])\nOut[194]: \n            absolute  &lt;lambda&gt;\n2000-01-01  0.428759  0.571241\n2000-01-02  0.168731  0.831269\n2000-01-03  1.621034 -0.621034\n2000-01-04       NaN       NaN\n2000-01-05       NaN       NaN\n2000-01-06       NaN       NaN\n2000-01-07       NaN       NaN\n2000-01-08  0.254374  1.254374\n2000-01-09  0.157795  0.842205\n2000-01-10  0.030876  0.969124\n</pre></div> </div> </section> <section id=\"transforming-with-a-dict\"> <h4>Transforming with a dict</h4> <p>Passing a dict of functions will allow selective transforming per column.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [195]: tsdf.transform({\"A\": np.abs, \"B\": lambda x: x + 1})\nOut[195]: \n                   A         B\n2000-01-01  0.428759  0.135110\n2000-01-02  0.168731  2.338144\n2000-01-03  1.621034  1.438107\n2000-01-04       NaN       NaN\n2000-01-05       NaN       NaN\n2000-01-06       NaN       NaN\n2000-01-07       NaN       NaN\n2000-01-08  0.254374 -0.240447\n2000-01-09  0.157795  1.791197\n2000-01-10  0.030876  1.371900\n</pre></div> </div> <p>Passing a dict of lists will generate a MultiIndexed DataFrame with these selective transforms.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [196]: tsdf.transform({\"A\": np.abs, \"B\": [lambda x: x + 1, \"sqrt\"]})\nOut[196]: \n                   A         B          \n            absolute  &lt;lambda&gt;      sqrt\n2000-01-01  0.428759  0.135110       NaN\n2000-01-02  0.168731  2.338144  1.156782\n2000-01-03  1.621034  1.438107  0.661897\n2000-01-04       NaN       NaN       NaN\n2000-01-05       NaN       NaN       NaN\n2000-01-06       NaN       NaN       NaN\n2000-01-07       NaN       NaN       NaN\n2000-01-08  0.254374 -0.240447       NaN\n2000-01-09  0.157795  1.791197  0.889493\n2000-01-10  0.030876  1.371900  0.609836\n</pre></div> </div> </section> </section> <section id=\"applying-elementwise-functions\"> <h3>Applying elementwise functions</h3> <p>Since not all functions can be vectorized (accept NumPy arrays and return another array or value), the methods <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.applymap#pandas.DataFrame.applymap\" title=\"pandas.DataFrame.applymap\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">applymap()</span></code></a> on DataFrame and analogously <a class=\"reference internal\" href=\"../reference/api/pandas.series.map#pandas.Series.map\" title=\"pandas.Series.map\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">map()</span></code></a> on Series accept any Python function taking a single value and returning a single value. For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [197]: df4\nOut[197]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [198]: def f(x):\n   .....:     return len(str(x))\n   .....: \n\nIn [199]: df4[\"one\"].map(f)\nOut[199]: \na    18\nb    19\nc    18\nd     3\nName: one, dtype: int64\n\nIn [200]: df4.applymap(f)\nOut[200]: \n   one  two  three\na   18   17      3\nb   19   18     20\nc   18   18     16\nd    3   19     19\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.map#pandas.Series.map\" title=\"pandas.Series.map\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.map()</span></code></a> has an additional feature; it can be used to easily “link” or “map” values defined by a secondary series. This is closely related to <a class=\"reference internal\" href=\"merging#merging\"><span class=\"std std-ref\">merging/joining functionality</span></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [201]: s = pd.Series(\n   .....:     [\"six\", \"seven\", \"six\", \"seven\", \"six\"], index=[\"a\", \"b\", \"c\", \"d\", \"e\"]\n   .....: )\n   .....: \n\nIn [202]: t = pd.Series({\"six\": 6.0, \"seven\": 7.0})\n\nIn [203]: s\nOut[203]: \na      six\nb    seven\nc      six\nd    seven\ne      six\ndtype: object\n\nIn [204]: s.map(t)\nOut[204]: \na    6.0\nb    7.0\nc    6.0\nd    7.0\ne    6.0\ndtype: float64\n</pre></div> </div> </section> </section> <section id=\"reindexing-and-altering-labels\"> <h2>Reindexing and altering labels</h2> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.reindex#pandas.Series.reindex\" title=\"pandas.Series.reindex\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">reindex()</span></code></a> is the fundamental data alignment method in pandas. It is used to implement nearly all other features relying on label-alignment functionality. To <em>reindex</em> means to conform the data to match a given set of labels along a particular axis. This accomplishes several things:</p> <ul class=\"simple\"> <li><p>Reorders the existing data to match a new set of labels</p></li> <li><p>Inserts missing value (NA) markers in label locations where no data for that label existed</p></li> <li><p>If specified, <strong>fill</strong> data for missing labels using logic (highly relevant to working with time series data)</p></li> </ul> <p>Here is a simple example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [205]: s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\nIn [206]: s\nOut[206]: \na    1.695148\nb    1.328614\nc    1.234686\nd   -0.385845\ne   -1.326508\ndtype: float64\n\nIn [207]: s.reindex([\"e\", \"b\", \"f\", \"d\"])\nOut[207]: \ne   -1.326508\nb    1.328614\nf         NaN\nd   -0.385845\ndtype: float64\n</pre></div> </div> <p>Here, the <code class=\"docutils literal notranslate\"><span class=\"pre\">f</span></code> label was not contained in the Series and hence appears as <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code> in the result.</p> <p>With a DataFrame, you can simultaneously reindex the index and columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [208]: df\nOut[208]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [209]: df.reindex(index=[\"c\", \"f\", \"b\"], columns=[\"three\", \"two\", \"one\"])\nOut[209]: \n      three       two       one\nc  1.227435  1.478369  0.695246\nf       NaN       NaN       NaN\nb -0.050390  1.912123  0.343054\n</pre></div> </div> <p>You may also use <code class=\"docutils literal notranslate\"><span class=\"pre\">reindex</span></code> with an <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> keyword:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [210]: df.reindex([\"c\", \"f\", \"b\"], axis=\"index\")\nOut[210]: \n        one       two     three\nc  0.695246  1.478369  1.227435\nf       NaN       NaN       NaN\nb  0.343054  1.912123 -0.050390\n</pre></div> </div> <p>Note that the <code class=\"docutils literal notranslate\"><span class=\"pre\">Index</span></code> objects containing the actual axis labels can be <strong>shared</strong> between objects. So if we have a Series and a DataFrame, the following can be done:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [211]: rs = s.reindex(df.index)\n\nIn [212]: rs\nOut[212]: \na    1.695148\nb    1.328614\nc    1.234686\nd   -0.385845\ndtype: float64\n\nIn [213]: rs.index is df.index\nOut[213]: True\n</pre></div> </div> <p>This means that the reindexed Series’s index is the same Python object as the DataFrame’s index.</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.reindex#pandas.DataFrame.reindex\" title=\"pandas.DataFrame.reindex\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.reindex()</span></code></a> also supports an “axis-style” calling convention, where you specify a single <code class=\"docutils literal notranslate\"><span class=\"pre\">labels</span></code> argument and the <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> it applies to.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [214]: df.reindex([\"c\", \"f\", \"b\"], axis=\"index\")\nOut[214]: \n        one       two     three\nc  0.695246  1.478369  1.227435\nf       NaN       NaN       NaN\nb  0.343054  1.912123 -0.050390\n\nIn [215]: df.reindex([\"three\", \"two\", \"one\"], axis=\"columns\")\nOut[215]: \n      three       two       one\na       NaN  1.772517  1.394981\nb -0.050390  1.912123  0.343054\nc  1.227435  1.478369  0.695246\nd -0.613172  0.279344       NaN\n</pre></div> </div> <div class=\"admonition seealso\"> <p class=\"admonition-title\">See also</p> <p><a class=\"reference internal\" href=\"advanced#advanced\"><span class=\"std std-ref\">MultiIndex / Advanced Indexing</span></a> is an even more concise way of doing reindexing.</p> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>When writing performance-sensitive code, there is a good reason to spend some time becoming a reindexing ninja: <strong>many operations are faster on pre-aligned data</strong>. Adding two unaligned DataFrames internally triggers a reindexing step. For exploratory analysis you will hardly notice the difference (because <code class=\"docutils literal notranslate\"><span class=\"pre\">reindex</span></code> has been heavily optimized), but when CPU cycles matter sprinkling a few explicit <code class=\"docutils literal notranslate\"><span class=\"pre\">reindex</span></code> calls here and there can have an impact.</p> </div> <section id=\"reindexing-to-align-with-another-object\"> <h3>Reindexing to align with another object</h3> <p>You may wish to take an object and reindex its axes to be labeled the same as another object. While the syntax for this is straightforward albeit verbose, it is a common enough operation that the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.reindex_like#pandas.DataFrame.reindex_like\" title=\"pandas.DataFrame.reindex_like\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">reindex_like()</span></code></a> method is available to make this simpler:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [216]: df2\nOut[216]: \n        one       two\na  1.394981  1.772517\nb  0.343054  1.912123\nc  0.695246  1.478369\n\nIn [217]: df3\nOut[217]: \n        one       two\na  0.583888  0.051514\nb -0.468040  0.191120\nc -0.115848 -0.242634\n\nIn [218]: df.reindex_like(df2)\nOut[218]: \n        one       two\na  1.394981  1.772517\nb  0.343054  1.912123\nc  0.695246  1.478369\n</pre></div> </div> </section> <section id=\"aligning-objects-with-each-other-with-align\"> <h3>Aligning objects with each other with <code class=\"docutils literal notranslate\"><span class=\"pre\">align</span></code>\n</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.series.align#pandas.Series.align\" title=\"pandas.Series.align\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">align()</span></code></a> method is the fastest way to simultaneously align two objects. It supports a <code class=\"docutils literal notranslate\"><span class=\"pre\">join</span></code> argument (related to <a class=\"reference internal\" href=\"merging#merging\"><span class=\"std std-ref\">joining and merging</span></a>):</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">join='outer'</span></code>: take the union of the indexes (default)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">join='left'</span></code>: use the calling object’s index</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">join='right'</span></code>: use the passed object’s index</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">join='inner'</span></code>: intersect the indexes</p></li> </ul> </div>\n</blockquote> <p>It returns a tuple with both of the reindexed Series:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [219]: s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\nIn [220]: s1 = s[:4]\n\nIn [221]: s2 = s[1:]\n\nIn [222]: s1.align(s2)\nOut[222]: \n(a   -0.186646\n b   -1.692424\n c   -0.303893\n d   -1.425662\n e         NaN\n dtype: float64,\n a         NaN\n b   -1.692424\n c   -0.303893\n d   -1.425662\n e    1.114285\n dtype: float64)\n\nIn [223]: s1.align(s2, join=\"inner\")\nOut[223]: \n(b   -1.692424\n c   -0.303893\n d   -1.425662\n dtype: float64,\n b   -1.692424\n c   -0.303893\n d   -1.425662\n dtype: float64)\n\nIn [224]: s1.align(s2, join=\"left\")\nOut[224]: \n(a   -0.186646\n b   -1.692424\n c   -0.303893\n d   -1.425662\n dtype: float64,\n a         NaN\n b   -1.692424\n c   -0.303893\n d   -1.425662\n dtype: float64)\n</pre></div> </div> <p id=\"basics-df-join\">For DataFrames, the join method will be applied to both the index and the columns by default:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [225]: df.align(df2, join=\"inner\")\nOut[225]: \n(        one       two\n a  1.394981  1.772517\n b  0.343054  1.912123\n c  0.695246  1.478369,\n         one       two\n a  1.394981  1.772517\n b  0.343054  1.912123\n c  0.695246  1.478369)\n</pre></div> </div> <p>You can also pass an <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> option to only align on the specified axis:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [226]: df.align(df2, join=\"inner\", axis=0)\nOut[226]: \n(        one       two     three\n a  1.394981  1.772517       NaN\n b  0.343054  1.912123 -0.050390\n c  0.695246  1.478369  1.227435,\n         one       two\n a  1.394981  1.772517\n b  0.343054  1.912123\n c  0.695246  1.478369)\n</pre></div> </div> <p id=\"basics-align-frame-series\">If you pass a Series to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.align#pandas.DataFrame.align\" title=\"pandas.DataFrame.align\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.align()</span></code></a>, you can choose to align both objects either on the DataFrame’s index or columns using the <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> argument:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [227]: df.align(df2.iloc[0], axis=1)\nOut[227]: \n(        one     three       two\n a  1.394981       NaN  1.772517\n b  0.343054 -0.050390  1.912123\n c  0.695246  1.227435  1.478369\n d       NaN -0.613172  0.279344,\n one      1.394981\n three         NaN\n two      1.772517\n Name: a, dtype: float64)\n</pre></div> </div> </section> <section id=\"filling-while-reindexing\"> <h3>Filling while reindexing</h3> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.reindex#pandas.Series.reindex\" title=\"pandas.Series.reindex\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">reindex()</span></code></a> takes an optional parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">method</span></code> which is a filling method chosen from the following table:</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 38%\"> <col style=\"width: 63%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Method</p></th> <th class=\"head\"><p>Action</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>pad / ffill</p></td> <td><p>Fill values forward</p></td> </tr> <tr class=\"row-odd\">\n<td><p>bfill / backfill</p></td> <td><p>Fill values backward</p></td> </tr> <tr class=\"row-even\">\n<td><p>nearest</p></td> <td><p>Fill from the nearest index value</p></td> </tr> </tbody> </table> <p>We illustrate these fill methods on a simple Series:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [228]: rng = pd.date_range(\"1/3/2000\", periods=8)\n\nIn [229]: ts = pd.Series(np.random.randn(8), index=rng)\n\nIn [230]: ts2 = ts[[0, 3, 6]]\n\nIn [231]: ts\nOut[231]: \n2000-01-03    0.183051\n2000-01-04    0.400528\n2000-01-05   -0.015083\n2000-01-06    2.395489\n2000-01-07    1.414806\n2000-01-08    0.118428\n2000-01-09    0.733639\n2000-01-10   -0.936077\nFreq: D, dtype: float64\n\nIn [232]: ts2\nOut[232]: \n2000-01-03    0.183051\n2000-01-06    2.395489\n2000-01-09    0.733639\nFreq: 3D, dtype: float64\n\nIn [233]: ts2.reindex(ts.index)\nOut[233]: \n2000-01-03    0.183051\n2000-01-04         NaN\n2000-01-05         NaN\n2000-01-06    2.395489\n2000-01-07         NaN\n2000-01-08         NaN\n2000-01-09    0.733639\n2000-01-10         NaN\nFreq: D, dtype: float64\n\nIn [234]: ts2.reindex(ts.index, method=\"ffill\")\nOut[234]: \n2000-01-03    0.183051\n2000-01-04    0.183051\n2000-01-05    0.183051\n2000-01-06    2.395489\n2000-01-07    2.395489\n2000-01-08    2.395489\n2000-01-09    0.733639\n2000-01-10    0.733639\nFreq: D, dtype: float64\n\nIn [235]: ts2.reindex(ts.index, method=\"bfill\")\nOut[235]: \n2000-01-03    0.183051\n2000-01-04    2.395489\n2000-01-05    2.395489\n2000-01-06    2.395489\n2000-01-07    0.733639\n2000-01-08    0.733639\n2000-01-09    0.733639\n2000-01-10         NaN\nFreq: D, dtype: float64\n\nIn [236]: ts2.reindex(ts.index, method=\"nearest\")\nOut[236]: \n2000-01-03    0.183051\n2000-01-04    0.183051\n2000-01-05    2.395489\n2000-01-06    2.395489\n2000-01-07    2.395489\n2000-01-08    0.733639\n2000-01-09    0.733639\n2000-01-10    0.733639\nFreq: D, dtype: float64\n</pre></div> </div> <p>These methods require that the indexes are <strong>ordered</strong> increasing or decreasing.</p> <p>Note that the same result could have been achieved using <a class=\"reference internal\" href=\"missing_data#missing-data-fillna\"><span class=\"std std-ref\">fillna</span></a> (except for <code class=\"docutils literal notranslate\"><span class=\"pre\">method='nearest'</span></code>) or <a class=\"reference internal\" href=\"missing_data#missing-data-interpolate\"><span class=\"std std-ref\">interpolate</span></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [237]: ts2.reindex(ts.index).fillna(method=\"ffill\")\nOut[237]: \n2000-01-03    0.183051\n2000-01-04    0.183051\n2000-01-05    0.183051\n2000-01-06    2.395489\n2000-01-07    2.395489\n2000-01-08    2.395489\n2000-01-09    0.733639\n2000-01-10    0.733639\nFreq: D, dtype: float64\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.series.reindex#pandas.Series.reindex\" title=\"pandas.Series.reindex\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">reindex()</span></code></a> will raise a ValueError if the index is not monotonically increasing or decreasing. <a class=\"reference internal\" href=\"../reference/api/pandas.series.fillna#pandas.Series.fillna\" title=\"pandas.Series.fillna\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">fillna()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.series.interpolate#pandas.Series.interpolate\" title=\"pandas.Series.interpolate\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">interpolate()</span></code></a> will not perform any checks on the order of the index.</p> </section> <section id=\"limits-on-filling-while-reindexing\"> <h3>Limits on filling while reindexing</h3> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">limit</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">tolerance</span></code> arguments provide additional control over filling while reindexing. Limit specifies the maximum count of consecutive matches:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [238]: ts2.reindex(ts.index, method=\"ffill\", limit=1)\nOut[238]: \n2000-01-03    0.183051\n2000-01-04    0.183051\n2000-01-05         NaN\n2000-01-06    2.395489\n2000-01-07    2.395489\n2000-01-08         NaN\n2000-01-09    0.733639\n2000-01-10    0.733639\nFreq: D, dtype: float64\n</pre></div> </div> <p>In contrast, tolerance specifies the maximum distance between the index and indexer values:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [239]: ts2.reindex(ts.index, method=\"ffill\", tolerance=\"1 day\")\nOut[239]: \n2000-01-03    0.183051\n2000-01-04    0.183051\n2000-01-05         NaN\n2000-01-06    2.395489\n2000-01-07    2.395489\n2000-01-08         NaN\n2000-01-09    0.733639\n2000-01-10    0.733639\nFreq: D, dtype: float64\n</pre></div> </div> <p>Notice that when used on a <code class=\"docutils literal notranslate\"><span class=\"pre\">DatetimeIndex</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">TimedeltaIndex</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">PeriodIndex</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">tolerance</span></code> will coerced into a <code class=\"docutils literal notranslate\"><span class=\"pre\">Timedelta</span></code> if possible. This allows you to specify tolerance with appropriate strings.</p> </section> <section id=\"dropping-labels-from-an-axis\"> <h3>Dropping labels from an axis</h3> <p>A method closely related to <code class=\"docutils literal notranslate\"><span class=\"pre\">reindex</span></code> is the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.drop#pandas.DataFrame.drop\" title=\"pandas.DataFrame.drop\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">drop()</span></code></a> function. It removes a set of labels from an axis:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [240]: df\nOut[240]: \n        one       two     three\na  1.394981  1.772517       NaN\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [241]: df.drop([\"a\", \"d\"], axis=0)\nOut[241]: \n        one       two     three\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\n\nIn [242]: df.drop([\"one\"], axis=1)\nOut[242]: \n        two     three\na  1.772517       NaN\nb  1.912123 -0.050390\nc  1.478369  1.227435\nd  0.279344 -0.613172\n</pre></div> </div> <p>Note that the following also works, but is a bit less obvious / clean:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [243]: df.reindex(df.index.difference([\"a\", \"d\"]))\nOut[243]: \n        one       two     three\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\n</pre></div> </div> </section> <section id=\"renaming-mapping-labels\"> <h3>Renaming / mapping labels</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.rename#pandas.DataFrame.rename\" title=\"pandas.DataFrame.rename\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">rename()</span></code></a> method allows you to relabel an axis based on some mapping (a dict or Series) or an arbitrary function.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [244]: s\nOut[244]: \na   -0.186646\nb   -1.692424\nc   -0.303893\nd   -1.425662\ne    1.114285\ndtype: float64\n\nIn [245]: s.rename(str.upper)\nOut[245]: \nA   -0.186646\nB   -1.692424\nC   -0.303893\nD   -1.425662\nE    1.114285\ndtype: float64\n</pre></div> </div> <p>If you pass a function, it must return a value when called with any of the labels (and must produce a set of unique values). A dict or Series can also be used:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [246]: df.rename(\n   .....:     columns={\"one\": \"foo\", \"two\": \"bar\"},\n   .....:     index={\"a\": \"apple\", \"b\": \"banana\", \"d\": \"durian\"},\n   .....: )\n   .....: \nOut[246]: \n             foo       bar     three\napple   1.394981  1.772517       NaN\nbanana  0.343054  1.912123 -0.050390\nc       0.695246  1.478369  1.227435\ndurian       NaN  0.279344 -0.613172\n</pre></div> </div> <p>If the mapping doesn’t include a column/index label, it isn’t renamed. Note that extra labels in the mapping don’t throw an error.</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.rename#pandas.DataFrame.rename\" title=\"pandas.DataFrame.rename\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.rename()</span></code></a> also supports an “axis-style” calling convention, where you specify a single <code class=\"docutils literal notranslate\"><span class=\"pre\">mapper</span></code> and the <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> to apply that mapping to.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [247]: df.rename({\"one\": \"foo\", \"two\": \"bar\"}, axis=\"columns\")\nOut[247]: \n        foo       bar     three\na  1.394981  1.772517       NaN\nb  0.343054  1.912123 -0.050390\nc  0.695246  1.478369  1.227435\nd       NaN  0.279344 -0.613172\n\nIn [248]: df.rename({\"a\": \"apple\", \"b\": \"banana\", \"d\": \"durian\"}, axis=\"index\")\nOut[248]: \n             one       two     three\napple   1.394981  1.772517       NaN\nbanana  0.343054  1.912123 -0.050390\nc       0.695246  1.478369  1.227435\ndurian       NaN  0.279344 -0.613172\n</pre></div> </div> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.rename#pandas.DataFrame.rename\" title=\"pandas.DataFrame.rename\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">rename()</span></code></a> method also provides an <code class=\"docutils literal notranslate\"><span class=\"pre\">inplace</span></code> named parameter that is by default <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code> and copies the underlying data. Pass <code class=\"docutils literal notranslate\"><span class=\"pre\">inplace=True</span></code> to rename the data in place.</p> <p>Finally, <a class=\"reference internal\" href=\"../reference/api/pandas.series.rename#pandas.Series.rename\" title=\"pandas.Series.rename\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">rename()</span></code></a> also accepts a scalar or list-like for altering the <code class=\"docutils literal notranslate\"><span class=\"pre\">Series.name</span></code> attribute.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [249]: s.rename(\"scalar-name\")\nOut[249]: \na   -0.186646\nb   -1.692424\nc   -0.303893\nd   -1.425662\ne    1.114285\nName: scalar-name, dtype: float64\n</pre></div> </div> <p id=\"basics-rename-axis\">The methods <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.rename_axis#pandas.DataFrame.rename_axis\" title=\"pandas.DataFrame.rename_axis\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.rename_axis()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.series.rename_axis#pandas.Series.rename_axis\" title=\"pandas.Series.rename_axis\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.rename_axis()</span></code></a> allow specific names of a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> to be changed (as opposed to the labels).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [250]: df = pd.DataFrame(\n   .....:     {\"x\": [1, 2, 3, 4, 5, 6], \"y\": [10, 20, 30, 40, 50, 60]},\n   .....:     index=pd.MultiIndex.from_product(\n   .....:         [[\"a\", \"b\", \"c\"], [1, 2]], names=[\"let\", \"num\"]\n   .....:     ),\n   .....: )\n   .....: \n\nIn [251]: df\nOut[251]: \n         x   y\nlet num       \na   1    1  10\n    2    2  20\nb   1    3  30\n    2    4  40\nc   1    5  50\n    2    6  60\n\nIn [252]: df.rename_axis(index={\"let\": \"abc\"})\nOut[252]: \n         x   y\nabc num       \na   1    1  10\n    2    2  20\nb   1    3  30\n    2    4  40\nc   1    5  50\n    2    6  60\n\nIn [253]: df.rename_axis(index=str.upper)\nOut[253]: \n         x   y\nLET NUM       \na   1    1  10\n    2    2  20\nb   1    3  30\n    2    4  40\nc   1    5  50\n    2    6  60\n</pre></div> </div> </section> </section> <section id=\"iteration\"> <h2>Iteration</h2> <p>The behavior of basic iteration over pandas objects depends on the type. When iterating over a Series, it is regarded as array-like, and basic iteration produces the values. DataFrames follow the dict-like convention of iterating over the “keys” of the objects.</p> <p>In short, basic iteration (<code class=\"docutils literal notranslate\"><span class=\"pre\">for</span> <span class=\"pre\">i</span> <span class=\"pre\">in</span> <span class=\"pre\">object</span></code>) produces:</p> <ul class=\"simple\"> <li><p><strong>Series</strong>: values</p></li> <li><p><strong>DataFrame</strong>: column labels</p></li> </ul> <p>Thus, for example, iterating over a DataFrame gives you the column names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [254]: df = pd.DataFrame(\n   .....:     {\"col1\": np.random.randn(3), \"col2\": np.random.randn(3)}, index=[\"a\", \"b\", \"c\"]\n   .....: )\n   .....: \n\nIn [255]: for col in df:\n   .....:     print(col)\n   .....: \ncol1\ncol2\n</pre></div> </div> <p>pandas objects also have the dict-like <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.items#pandas.DataFrame.items\" title=\"pandas.DataFrame.items\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">items()</span></code></a> method to iterate over the (key, value) pairs.</p> <p>To iterate over the rows of a DataFrame, you can use the following methods:</p> <ul class=\"simple\"> <li><p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows\" title=\"pandas.DataFrame.iterrows\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">iterrows()</span></code></a>: Iterate over the rows of a DataFrame as (index, Series) pairs. This converts the rows to Series objects, which can change the dtypes and has some performance implications.</p></li> <li><p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples\" title=\"pandas.DataFrame.itertuples\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">itertuples()</span></code></a>: Iterate over the rows of a DataFrame as namedtuples of the values. This is a lot faster than <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows\" title=\"pandas.DataFrame.iterrows\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">iterrows()</span></code></a>, and is in most cases preferable to use to iterate over the values of a DataFrame.</p></li> </ul> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Iterating through pandas objects is generally <strong>slow</strong>. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:</p> <ul class=\"simple\"> <li><p>Look for a <em>vectorized</em> solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, …</p></li> <li><p>When you have a function that cannot work on the full DataFrame/Series at once, it is better to use <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a> instead of iterating over the values. See the docs on <a class=\"reference internal\" href=\"#basics-apply\"><span class=\"std std-ref\">function application</span></a>.</p></li> <li><p>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the <a class=\"reference internal\" href=\"enhancingperf#enhancingperf\"><span class=\"std std-ref\">enhancing performance</span></a> section for some examples of this approach.</p></li> </ul> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>You should <strong>never modify</strong> something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect!</p> <p>For example, in the following case setting the value has no effect:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [256]: df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]})\n\nIn [257]: for index, row in df.iterrows():\n   .....:     row[\"a\"] = 10\n   .....: \n\nIn [258]: df\nOut[258]: \n   a  b\n0  1  a\n1  2  b\n2  3  c\n</pre></div> </div> </div> <section id=\"items\"> <h3>items</h3> <p>Consistent with the dict-like interface, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.items#pandas.DataFrame.items\" title=\"pandas.DataFrame.items\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">items()</span></code></a> iterates through key-value pairs:</p> <ul class=\"simple\"> <li><p><strong>Series</strong>: (index, scalar value) pairs</p></li> <li><p><strong>DataFrame</strong>: (column, Series) pairs</p></li> </ul> <p>For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [259]: for label, ser in df.items():\n   .....:     print(label)\n   .....:     print(ser)\n   .....: \na\n0    1\n1    2\n2    3\nName: a, dtype: int64\nb\n0    a\n1    b\n2    c\nName: b, dtype: object\n</pre></div> </div> </section> <section id=\"iterrows\"> <h3>iterrows</h3> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows\" title=\"pandas.DataFrame.iterrows\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">iterrows()</span></code></a> allows you to iterate through the rows of a DataFrame as Series objects. It returns an iterator yielding each index value along with a Series containing the data in each row:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [260]: for row_index, row in df.iterrows():\n   .....:     print(row_index, row, sep=\"\\n\")\n   .....: \n0\na    1\nb    a\nName: 0, dtype: object\n1\na    2\nb    b\nName: 1, dtype: object\n2\na    3\nb    c\nName: 2, dtype: object\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Because <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows\" title=\"pandas.DataFrame.iterrows\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">iterrows()</span></code></a> returns a Series for each row, it does <strong>not</strong> preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). For example,</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [261]: df_orig = pd.DataFrame([[1, 1.5]], columns=[\"int\", \"float\"])\n\nIn [262]: df_orig.dtypes\nOut[262]: \nint        int64\nfloat    float64\ndtype: object\n\nIn [263]: row = next(df_orig.iterrows())[1]\n\nIn [264]: row\nOut[264]: \nint      1.0\nfloat    1.5\nName: 0, dtype: float64\n</pre></div> </div> <p>All values in <code class=\"docutils literal notranslate\"><span class=\"pre\">row</span></code>, returned as a Series, are now upcasted to floats, also the original integer value in column <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [265]: row[\"int\"].dtype\nOut[265]: dtype('float64')\n\nIn [266]: df_orig[\"int\"].dtype\nOut[266]: dtype('int64')\n</pre></div> </div> <p>To preserve dtypes while iterating over the rows, it is better to use <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples\" title=\"pandas.DataFrame.itertuples\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">itertuples()</span></code></a> which returns namedtuples of the values and which is generally much faster than <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows\" title=\"pandas.DataFrame.iterrows\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">iterrows()</span></code></a>.</p> </div> <p>For instance, a contrived way to transpose the DataFrame would be:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [267]: df2 = pd.DataFrame({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\n\nIn [268]: print(df2)\n   x  y\n0  1  4\n1  2  5\n2  3  6\n\nIn [269]: print(df2.T)\n   0  1  2\nx  1  2  3\ny  4  5  6\n\nIn [270]: df2_t = pd.DataFrame({idx: values for idx, values in df2.iterrows()})\n\nIn [271]: print(df2_t)\n   0  1  2\nx  1  2  3\ny  4  5  6\n</pre></div> </div> </section> <section id=\"itertuples\"> <h3>itertuples</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples\" title=\"pandas.DataFrame.itertuples\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">itertuples()</span></code></a> method will return an iterator yielding a namedtuple for each row in the DataFrame. The first element of the tuple will be the row’s corresponding index value, while the remaining values are the row values.</p> <p>For instance:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [272]: for row in df.itertuples():\n   .....:     print(row)\n   .....: \nPandas(Index=0, a=1, b='a')\nPandas(Index=1, a=2, b='b')\nPandas(Index=2, a=3, b='c')\n</pre></div> </div> <p>This method does not convert the row to a Series object; it merely returns the values inside a namedtuple. Therefore, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples\" title=\"pandas.DataFrame.itertuples\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">itertuples()</span></code></a> preserves the data type of the values and is generally faster as <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows\" title=\"pandas.DataFrame.iterrows\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">iterrows()</span></code></a>.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.</p> </div> </section> </section> <section id=\"dt-accessor\"> <h2>.dt accessor</h2> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> has an accessor to succinctly return datetime like properties for the <em>values</em> of the Series, if it is a datetime/period like Series. This will return a Series, indexed like the existing Series.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># datetime\nIn [273]: s = pd.Series(pd.date_range(\"20130101 09:10:12\", periods=4))\n\nIn [274]: s\nOut[274]: \n0   2013-01-01 09:10:12\n1   2013-01-02 09:10:12\n2   2013-01-03 09:10:12\n3   2013-01-04 09:10:12\ndtype: datetime64[ns]\n\nIn [275]: s.dt.hour\nOut[275]: \n0    9\n1    9\n2    9\n3    9\ndtype: int64\n\nIn [276]: s.dt.second\nOut[276]: \n0    12\n1    12\n2    12\n3    12\ndtype: int64\n\nIn [277]: s.dt.day\nOut[277]: \n0    1\n1    2\n2    3\n3    4\ndtype: int64\n</pre></div> </div> <p>This enables nice expressions like this:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [278]: s[s.dt.day == 2]\nOut[278]: \n1   2013-01-02 09:10:12\ndtype: datetime64[ns]\n</pre></div> </div> <p>You can easily produces tz aware transformations:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [279]: stz = s.dt.tz_localize(\"US/Eastern\")\n\nIn [280]: stz\nOut[280]: \n0   2013-01-01 09:10:12-05:00\n1   2013-01-02 09:10:12-05:00\n2   2013-01-03 09:10:12-05:00\n3   2013-01-04 09:10:12-05:00\ndtype: datetime64[ns, US/Eastern]\n\nIn [281]: stz.dt.tz\nOut[281]: &lt;DstTzInfo 'US/Eastern' LMT-1 day, 19:04:00 STD&gt;\n</pre></div> </div> <p>You can also chain these types of operations:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [282]: s.dt.tz_localize(\"UTC\").dt.tz_convert(\"US/Eastern\")\nOut[282]: \n0   2013-01-01 04:10:12-05:00\n1   2013-01-02 04:10:12-05:00\n2   2013-01-03 04:10:12-05:00\n3   2013-01-04 04:10:12-05:00\ndtype: datetime64[ns, US/Eastern]\n</pre></div> </div> <p>You can also format datetime values as strings with <a class=\"reference internal\" href=\"../reference/api/pandas.series.dt.strftime#pandas.Series.dt.strftime\" title=\"pandas.Series.dt.strftime\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.dt.strftime()</span></code></a> which supports the same format as the standard <a class=\"reference external\" href=\"https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime\" title=\"(in Python v3.10)\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">strftime()</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># DatetimeIndex\nIn [283]: s = pd.Series(pd.date_range(\"20130101\", periods=4))\n\nIn [284]: s\nOut[284]: \n0   2013-01-01\n1   2013-01-02\n2   2013-01-03\n3   2013-01-04\ndtype: datetime64[ns]\n\nIn [285]: s.dt.strftime(\"%Y/%m/%d\")\nOut[285]: \n0    2013/01/01\n1    2013/01/02\n2    2013/01/03\n3    2013/01/04\ndtype: object\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># PeriodIndex\nIn [286]: s = pd.Series(pd.period_range(\"20130101\", periods=4))\n\nIn [287]: s\nOut[287]: \n0    2013-01-01\n1    2013-01-02\n2    2013-01-03\n3    2013-01-04\ndtype: period[D]\n\nIn [288]: s.dt.strftime(\"%Y/%m/%d\")\nOut[288]: \n0    2013/01/01\n1    2013/01/02\n2    2013/01/03\n3    2013/01/04\ndtype: object\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">.dt</span></code> accessor works for period and timedelta dtypes.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># period\nIn [289]: s = pd.Series(pd.period_range(\"20130101\", periods=4, freq=\"D\"))\n\nIn [290]: s\nOut[290]: \n0    2013-01-01\n1    2013-01-02\n2    2013-01-03\n3    2013-01-04\ndtype: period[D]\n\nIn [291]: s.dt.year\nOut[291]: \n0    2013\n1    2013\n2    2013\n3    2013\ndtype: int64\n\nIn [292]: s.dt.day\nOut[292]: \n0    1\n1    2\n2    3\n3    4\ndtype: int64\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># timedelta\nIn [293]: s = pd.Series(pd.timedelta_range(\"1 day 00:00:05\", periods=4, freq=\"s\"))\n\nIn [294]: s\nOut[294]: \n0   1 days 00:00:05\n1   1 days 00:00:06\n2   1 days 00:00:07\n3   1 days 00:00:08\ndtype: timedelta64[ns]\n\nIn [295]: s.dt.days\nOut[295]: \n0    1\n1    1\n2    1\n3    1\ndtype: int64\n\nIn [296]: s.dt.seconds\nOut[296]: \n0    5\n1    6\n2    7\n3    8\ndtype: int64\n\nIn [297]: s.dt.components\nOut[297]: \n   days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds\n0     1      0        0        5             0             0            0\n1     1      0        0        6             0             0            0\n2     1      0        0        7             0             0            0\n3     1      0        0        8             0             0            0\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">Series.dt</span></code> will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">TypeError</span></code> if you access with a non-datetime-like values.</p> </div> </section> <section id=\"vectorized-string-methods\"> <h2>Vectorized string methods</h2> <p>Series is equipped with a set of string processing methods that make it easy to operate on each element of the array. Perhaps most importantly, these methods exclude missing/NA values automatically. These are accessed via the Series’s <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> attribute and generally have names matching the equivalent (scalar) built-in string methods. For example:</p> <blockquote> <div>\n<div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [298]: s = pd.Series(\n   .....:     [\"A\", \"B\", \"C\", \"Aaba\", \"Baca\", np.nan, \"CABA\", \"dog\", \"cat\"], dtype=\"string\"\n   .....: )\n   .....: \n\nIn [299]: s.str.lower()\nOut[299]: \n0       a\n1       b\n2       c\n3    aaba\n4    baca\n5    &lt;NA&gt;\n6    caba\n7     dog\n8     cat\ndtype: string\n</pre></div> </div> </div>\n</blockquote> <p>Powerful pattern-matching methods are provided as well, but note that pattern-matching generally uses <a class=\"reference external\" href=\"https://docs.python.org/3/library/re.html\">regular expressions</a> by default (and in some cases always uses them).</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Prior to pandas 1.0, string methods were only available on <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> -dtype <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>. pandas 1.0 added the <a class=\"reference internal\" href=\"../reference/api/pandas.stringdtype#pandas.StringDtype\" title=\"pandas.StringDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StringDtype</span></code></a> which is dedicated to strings. See <a class=\"reference internal\" href=\"text#text-types\"><span class=\"std std-ref\">Text data types</span></a> for more.</p> </div> <p>Please see <a class=\"reference internal\" href=\"text#text-string-methods\"><span class=\"std std-ref\">Vectorized String Methods</span></a> for a complete description.</p> </section> <section id=\"sorting\"> <h2>Sorting</h2> <p>pandas supports three kinds of sorting: sorting by index labels, sorting by column values, and sorting by a combination of both.</p> <section id=\"by-index\"> <h3>By index</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.series.sort_index#pandas.Series.sort_index\" title=\"pandas.Series.sort_index\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.sort_index()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.sort_index#pandas.DataFrame.sort_index\" title=\"pandas.DataFrame.sort_index\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.sort_index()</span></code></a> methods are used to sort a pandas object by its index levels.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [300]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"one\": pd.Series(np.random.randn(3), index=[\"a\", \"b\", \"c\"]),\n   .....:         \"two\": pd.Series(np.random.randn(4), index=[\"a\", \"b\", \"c\", \"d\"]),\n   .....:         \"three\": pd.Series(np.random.randn(3), index=[\"b\", \"c\", \"d\"]),\n   .....:     }\n   .....: )\n   .....: \n\nIn [301]: unsorted_df = df.reindex(\n   .....:     index=[\"a\", \"d\", \"c\", \"b\"], columns=[\"three\", \"two\", \"one\"]\n   .....: )\n   .....: \n\nIn [302]: unsorted_df\nOut[302]: \n      three       two       one\na       NaN -1.152244  0.562973\nd -0.252916 -0.109597       NaN\nc  1.273388 -0.167123  0.640382\nb -0.098217  0.009797 -1.299504\n\n# DataFrame\nIn [303]: unsorted_df.sort_index()\nOut[303]: \n      three       two       one\na       NaN -1.152244  0.562973\nb -0.098217  0.009797 -1.299504\nc  1.273388 -0.167123  0.640382\nd -0.252916 -0.109597       NaN\n\nIn [304]: unsorted_df.sort_index(ascending=False)\nOut[304]: \n      three       two       one\nd -0.252916 -0.109597       NaN\nc  1.273388 -0.167123  0.640382\nb -0.098217  0.009797 -1.299504\na       NaN -1.152244  0.562973\n\nIn [305]: unsorted_df.sort_index(axis=1)\nOut[305]: \n        one     three       two\na  0.562973       NaN -1.152244\nd       NaN -0.252916 -0.109597\nc  0.640382  1.273388 -0.167123\nb -1.299504 -0.098217  0.009797\n\n# Series\nIn [306]: unsorted_df[\"three\"].sort_index()\nOut[306]: \na         NaN\nb   -0.098217\nc    1.273388\nd   -0.252916\nName: three, dtype: float64\n</pre></div> </div> <div class=\"versionadded\" id=\"basics-sort-index-key\"> <p><span class=\"versionmodified added\">New in version 1.1.0.</span></p> </div> <p>Sorting by index also supports a <code class=\"docutils literal notranslate\"><span class=\"pre\">key</span></code> parameter that takes a callable function to apply to the index being sorted. For <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> objects, the key is applied per-level to the levels specified by <code class=\"docutils literal notranslate\"><span class=\"pre\">level</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [307]: s1 = pd.DataFrame({\"a\": [\"B\", \"a\", \"C\"], \"b\": [1, 2, 3], \"c\": [2, 3, 4]}).set_index(\n   .....:     list(\"ab\")\n   .....: )\n   .....: \n\nIn [308]: s1\nOut[308]: \n     c\na b   \nB 1  2\na 2  3\nC 3  4\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [309]: s1.sort_index(level=\"a\")\nOut[309]: \n     c\na b   \nB 1  2\nC 3  4\na 2  3\n\nIn [310]: s1.sort_index(level=\"a\", key=lambda idx: idx.str.lower())\nOut[310]: \n     c\na b   \na 2  3\nB 1  2\nC 3  4\n</pre></div> </div> <p>For information on key sorting by value, see <a class=\"reference internal\" href=\"#basics-sort-value-key\"><span class=\"std std-ref\">value sorting</span></a>.</p> </section> <section id=\"by-values\"> <h3>By values</h3> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.series.sort_values#pandas.Series.sort_values\" title=\"pandas.Series.sort_values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.sort_values()</span></code></a> method is used to sort a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> by its values. The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.sort_values#pandas.DataFrame.sort_values\" title=\"pandas.DataFrame.sort_values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.sort_values()</span></code></a> method is used to sort a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> by its column or row values. The optional <code class=\"docutils literal notranslate\"><span class=\"pre\">by</span></code> parameter to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.sort_values#pandas.DataFrame.sort_values\" title=\"pandas.DataFrame.sort_values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.sort_values()</span></code></a> may used to specify one or more columns to use to determine the sorted order.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [311]: df1 = pd.DataFrame(\n   .....:     {\"one\": [2, 1, 1, 1], \"two\": [1, 3, 2, 4], \"three\": [5, 4, 3, 2]}\n   .....: )\n   .....: \n\nIn [312]: df1.sort_values(by=\"two\")\nOut[312]: \n   one  two  three\n0    2    1      5\n2    1    2      3\n1    1    3      4\n3    1    4      2\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">by</span></code> parameter can take a list of column names, e.g.:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [313]: df1[[\"one\", \"two\", \"three\"]].sort_values(by=[\"one\", \"two\"])\nOut[313]: \n   one  two  three\n2    1    2      3\n1    1    3      4\n3    1    4      2\n0    2    1      5\n</pre></div> </div> <p>These methods have special treatment of NA values via the <code class=\"docutils literal notranslate\"><span class=\"pre\">na_position</span></code> argument:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [314]: s[2] = np.nan\n\nIn [315]: s.sort_values()\nOut[315]: \n0       A\n3    Aaba\n1       B\n4    Baca\n6    CABA\n8     cat\n7     dog\n2    &lt;NA&gt;\n5    &lt;NA&gt;\ndtype: string\n\nIn [316]: s.sort_values(na_position=\"first\")\nOut[316]: \n2    &lt;NA&gt;\n5    &lt;NA&gt;\n0       A\n3    Aaba\n1       B\n4    Baca\n6    CABA\n8     cat\n7     dog\ndtype: string\n</pre></div> </div> <div class=\"versionadded\" id=\"basics-sort-value-key\"> <p><span class=\"versionmodified added\">New in version 1.1.0.</span></p> </div> <p>Sorting also supports a <code class=\"docutils literal notranslate\"><span class=\"pre\">key</span></code> parameter that takes a callable function to apply to the values being sorted.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [317]: s1 = pd.Series([\"B\", \"a\", \"C\"])\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [318]: s1.sort_values()\nOut[318]: \n0    B\n2    C\n1    a\ndtype: object\n\nIn [319]: s1.sort_values(key=lambda x: x.str.lower())\nOut[319]: \n1    a\n0    B\n2    C\ndtype: object\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">key</span></code> will be given the <a class=\"reference internal\" href=\"../reference/api/pandas.series#pandas.Series\" title=\"pandas.Series\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Series</span></code></a> of values and should return a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> or array of the same shape with the transformed values. For <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> objects, the key is applied per column, so the key should still expect a Series and return a Series, e.g.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [320]: df = pd.DataFrame({\"a\": [\"B\", \"a\", \"C\"], \"b\": [1, 2, 3]})\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [321]: df.sort_values(by=\"a\")\nOut[321]: \n   a  b\n0  B  1\n2  C  3\n1  a  2\n\nIn [322]: df.sort_values(by=\"a\", key=lambda col: col.str.lower())\nOut[322]: \n   a  b\n1  a  2\n0  B  1\n2  C  3\n</pre></div> </div> <p>The name or type of each column can be used to apply different functions to different columns.</p> </section> <section id=\"by-indexes-and-values\"> <h3>By indexes and values</h3> <p>Strings passed as the <code class=\"docutils literal notranslate\"><span class=\"pre\">by</span></code> parameter to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.sort_values#pandas.DataFrame.sort_values\" title=\"pandas.DataFrame.sort_values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.sort_values()</span></code></a> may refer to either columns or index level names.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Build MultiIndex\nIn [323]: idx = pd.MultiIndex.from_tuples(\n   .....:     [(\"a\", 1), (\"a\", 2), (\"a\", 2), (\"b\", 2), (\"b\", 1), (\"b\", 1)]\n   .....: )\n   .....: \n\nIn [324]: idx.names = [\"first\", \"second\"]\n\n# Build DataFrame\nIn [325]: df_multi = pd.DataFrame({\"A\": np.arange(6, 0, -1)}, index=idx)\n\nIn [326]: df_multi\nOut[326]: \n              A\nfirst second   \na     1       6\n      2       5\n      2       4\nb     2       3\n      1       2\n      1       1\n</pre></div> </div> <p>Sort by ‘second’ (index) and ‘A’ (column)</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [327]: df_multi.sort_values(by=[\"second\", \"A\"])\nOut[327]: \n              A\nfirst second   \nb     1       1\n      1       2\na     1       6\nb     2       3\na     2       4\n      2       5\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>If a string matches both a column name and an index level name then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</p> </div> </section> <section id=\"searchsorted\"> <h3>searchsorted</h3> <p>Series has the <a class=\"reference internal\" href=\"../reference/api/pandas.series.searchsorted#pandas.Series.searchsorted\" title=\"pandas.Series.searchsorted\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">searchsorted()</span></code></a> method, which works similarly to <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">numpy.ndarray.searchsorted()</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [328]: ser = pd.Series([1, 2, 3])\n\nIn [329]: ser.searchsorted([0, 3])\nOut[329]: array([0, 2])\n\nIn [330]: ser.searchsorted([0, 4])\nOut[330]: array([0, 3])\n\nIn [331]: ser.searchsorted([1, 3], side=\"right\")\nOut[331]: array([1, 3])\n\nIn [332]: ser.searchsorted([1, 3], side=\"left\")\nOut[332]: array([0, 2])\n\nIn [333]: ser = pd.Series([3, 1, 2])\n\nIn [334]: ser.searchsorted([0, 3], sorter=np.argsort(ser))\nOut[334]: array([0, 2])\n</pre></div> </div> </section> <section id=\"smallest-largest-values\"> <h3>smallest / largest values</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> has the <a class=\"reference internal\" href=\"../reference/api/pandas.series.nsmallest#pandas.Series.nsmallest\" title=\"pandas.Series.nsmallest\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">nsmallest()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.series.nlargest#pandas.Series.nlargest\" title=\"pandas.Series.nlargest\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">nlargest()</span></code></a> methods which return the smallest or largest <span class=\"math notranslate nohighlight\">\\(n\\)</span> values. For a large <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> this can be much faster than sorting the entire Series and calling <code class=\"docutils literal notranslate\"><span class=\"pre\">head(n)</span></code> on the result.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [335]: s = pd.Series(np.random.permutation(10))\n\nIn [336]: s\nOut[336]: \n0    2\n1    0\n2    3\n3    7\n4    1\n5    5\n6    9\n7    6\n8    8\n9    4\ndtype: int64\n\nIn [337]: s.sort_values()\nOut[337]: \n1    0\n4    1\n0    2\n2    3\n9    4\n5    5\n7    6\n3    7\n8    8\n6    9\ndtype: int64\n\nIn [338]: s.nsmallest(3)\nOut[338]: \n1    0\n4    1\n0    2\ndtype: int64\n\nIn [339]: s.nlargest(3)\nOut[339]: \n6    9\n8    8\n3    7\ndtype: int64\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> also has the <code class=\"docutils literal notranslate\"><span class=\"pre\">nlargest</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">nsmallest</span></code> methods.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [340]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"a\": [-2, -1, 1, 10, 8, 11, -1],\n   .....:         \"b\": list(\"abdceff\"),\n   .....:         \"c\": [1.0, 2.0, 4.0, 3.2, np.nan, 3.0, 4.0],\n   .....:     }\n   .....: )\n   .....: \n\nIn [341]: df.nlargest(3, \"a\")\nOut[341]: \n    a  b    c\n5  11  f  3.0\n3  10  c  3.2\n4   8  e  NaN\n\nIn [342]: df.nlargest(5, [\"a\", \"c\"])\nOut[342]: \n    a  b    c\n5  11  f  3.0\n3  10  c  3.2\n4   8  e  NaN\n2   1  d  4.0\n6  -1  f  4.0\n\nIn [343]: df.nsmallest(3, \"a\")\nOut[343]: \n   a  b    c\n0 -2  a  1.0\n1 -1  b  2.0\n6 -1  f  4.0\n\nIn [344]: df.nsmallest(5, [\"a\", \"c\"])\nOut[344]: \n   a  b    c\n0 -2  a  1.0\n1 -1  b  2.0\n6 -1  f  4.0\n2  1  d  4.0\n4  8  e  NaN\n</pre></div> </div> </section> <section id=\"sorting-by-a-multiindex-column\"> <h3>Sorting by a MultiIndex column</h3> <p>You must be explicit about sorting when the column is a MultiIndex, and fully specify all levels to <code class=\"docutils literal notranslate\"><span class=\"pre\">by</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [345]: df1.columns = pd.MultiIndex.from_tuples(\n   .....:     [(\"a\", \"one\"), (\"a\", \"two\"), (\"b\", \"three\")]\n   .....: )\n   .....: \n\nIn [346]: df1.sort_values(by=(\"a\", \"two\"))\nOut[346]: \n    a         b\n  one two three\n0   2   1     5\n2   1   2     3\n1   1   3     4\n3   1   4     2\n</pre></div> </div> </section> </section> <section id=\"copying\"> <h2>Copying</h2> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.copy#pandas.DataFrame.copy\" title=\"pandas.DataFrame.copy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">copy()</span></code></a> method on pandas objects copies the underlying data (though not the axis indexes, since they are immutable) and returns a new object. Note that <strong>it is seldom necessary to copy objects</strong>. For example, there are only a handful of ways to alter a DataFrame <em>in-place</em>:</p> <ul class=\"simple\"> <li><p>Inserting, deleting, or modifying a column.</p></li> <li><p>Assigning to the <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> attributes.</p></li> <li><p>For homogeneous data, directly modifying the values via the <code class=\"docutils literal notranslate\"><span class=\"pre\">values</span></code> attribute or advanced indexing.</p></li> </ul> <p>To be clear, no pandas method has the side effect of modifying your data; almost every method returns a new object, leaving the original object untouched. If the data is modified, it is because you did so explicitly.</p> </section> <section id=\"dtypes\"> <h2>dtypes</h2> <p>For the most part, pandas uses NumPy arrays and dtypes for Series or individual columns of a DataFrame. NumPy provides support for <code class=\"docutils literal notranslate\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">bool</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">timedelta64[ns]</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">datetime64[ns]</span></code> (note that NumPy does not support timezone-aware datetimes).</p> <p>pandas and third-party libraries <em>extend</em> NumPy’s type system in a few places. This section describes the extensions pandas has made internally. See <a class=\"reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/development/extending.html#extending-extension-types\"><span class=\"std std-ref\">Extension types</span></a> for how to write your own extension that works with pandas. See <a class=\"reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/ecosystem.html#ecosystem-extensions\"><span class=\"std std-ref\">Extension data types</span></a> for a list of third-party libraries that have implemented an extension.</p> <p>The following table lists all of pandas extension types. For methods requiring <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> arguments, strings can be specified as indicated. See the respective documentation sections for more on each type.</p> <table class=\"table\"> <colgroup> <col style=\"width: 30%\"> <col style=\"width: 9%\"> <col style=\"width: 7%\"> <col style=\"width: 5%\"> <col style=\"width: 7%\"> <col style=\"width: 19%\"> <col style=\"width: 24%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Kind of Data</p></th> <th class=\"head\" colspan=\"2\"><p>Data Type</p></th> <th class=\"head\" colspan=\"2\"><p>Scalar</p></th> <th class=\"head\"><p>Array</p></th> <th class=\"head\"><p>String Aliases</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p><a class=\"reference internal\" href=\"timeseries#timeseries-timezone\"><span class=\"std std-ref\">tz-aware datetime</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.datetimetzdtype#pandas.DatetimeTZDtype\" title=\"pandas.DatetimeTZDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DatetimeTZDtype</span></code></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.timestamp#pandas.Timestamp\" title=\"pandas.Timestamp\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Timestamp</span></code></a></p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.arrays.datetimearray#pandas.arrays.DatetimeArray\" title=\"pandas.arrays.DatetimeArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.DatetimeArray</span></code></a></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'datetime64[ns,</span> <span class=\"pre\">&lt;tz&gt;]'</span></code></p></td> </tr> <tr class=\"row-odd\">\n<td><p><a class=\"reference internal\" href=\"categorical#categorical\"><span class=\"std std-ref\">Categorical</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.categoricaldtype#pandas.CategoricalDtype\" title=\"pandas.CategoricalDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CategoricalDtype</span></code></a></p></td> <td colspan=\"2\"><p>(none)</p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.categorical#pandas.Categorical\" title=\"pandas.Categorical\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Categorical</span></code></a></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'category'</span></code></p></td> </tr> <tr class=\"row-even\">\n<td><p><a class=\"reference internal\" href=\"timeseries#timeseries-periods\"><span class=\"std std-ref\">period (time spans)</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.perioddtype#pandas.PeriodDtype\" title=\"pandas.PeriodDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">PeriodDtype</span></code></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.period#pandas.Period\" title=\"pandas.Period\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Period</span></code></a></p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.arrays.periodarray#pandas.arrays.PeriodArray\" title=\"pandas.arrays.PeriodArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.PeriodArray</span></code></a> <code class=\"docutils literal notranslate\"><span class=\"pre\">'Period[&lt;freq&gt;]'</span></code></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'period[&lt;freq&gt;]'</span></code>,</p></td> </tr> <tr class=\"row-odd\">\n<td><p><a class=\"reference internal\" href=\"sparse#sparse\"><span class=\"std std-ref\">sparse</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.sparsedtype#pandas.SparseDtype\" title=\"pandas.SparseDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SparseDtype</span></code></a></p></td> <td colspan=\"2\"><p>(none)</p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.arrays.sparsearray#pandas.arrays.SparseArray\" title=\"pandas.arrays.SparseArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.SparseArray</span></code></a></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'Sparse'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Sparse[int]'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Sparse[float]'</span></code></p></td> </tr> <tr class=\"row-even\">\n<td><p><a class=\"reference internal\" href=\"advanced#advanced-intervalindex\"><span class=\"std std-ref\">intervals</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.intervaldtype#pandas.IntervalDtype\" title=\"pandas.IntervalDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IntervalDtype</span></code></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.interval#pandas.Interval\" title=\"pandas.Interval\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Interval</span></code></a></p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.arrays.intervalarray#pandas.arrays.IntervalArray\" title=\"pandas.arrays.IntervalArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.IntervalArray</span></code></a></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'interval'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Interval'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Interval[&lt;numpy_dtype&gt;]'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Interval[datetime64[ns,</span> <span class=\"pre\">&lt;tz&gt;]]'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Interval[timedelta64[&lt;freq&gt;]]'</span></code></p></td> </tr> <tr class=\"row-odd\">\n<td><p><a class=\"reference internal\" href=\"integer_na#integer-na\"><span class=\"std std-ref\">nullable integer</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.int64dtype#pandas.Int64Dtype\" title=\"pandas.Int64Dtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Int64Dtype</span></code></a>, …</p></td> <td colspan=\"2\"><p>(none)</p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.arrays.integerarray#pandas.arrays.IntegerArray\" title=\"pandas.arrays.IntegerArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.IntegerArray</span></code></a></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'Int8'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Int16'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Int32'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'Int64'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'UInt8'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'UInt16'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'UInt32'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'UInt64'</span></code></p></td> </tr> <tr class=\"row-even\">\n<td><p><a class=\"reference internal\" href=\"text#text\"><span class=\"std std-ref\">Strings</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.stringdtype#pandas.StringDtype\" title=\"pandas.StringDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StringDtype</span></code></a></p></td> <td colspan=\"2\"><p><a class=\"reference external\" href=\"https://docs.python.org/3/library/stdtypes.html#str\" title=\"(in Python v3.10)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a></p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.arrays.stringarray#pandas.arrays.StringArray\" title=\"pandas.arrays.StringArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.StringArray</span></code></a></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'string'</span></code></p></td> </tr> <tr class=\"row-odd\">\n<td><p><a class=\"reference internal\" href=\"../reference/arrays#api-arrays-bool\"><span class=\"std std-ref\">Boolean (with NA)</span></a></p></td> <td colspan=\"2\"><p><a class=\"reference internal\" href=\"../reference/api/pandas.booleandtype#pandas.BooleanDtype\" title=\"pandas.BooleanDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">BooleanDtype</span></code></a></p></td> <td colspan=\"2\"><p><a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#bool\" title=\"(in Python v3.10)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bool</span></code></a></p></td> <td><p><a class=\"reference internal\" href=\"../reference/api/pandas.arrays.booleanarray#pandas.arrays.BooleanArray\" title=\"pandas.arrays.BooleanArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">arrays.BooleanArray</span></code></a></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'boolean'</span></code></p></td> </tr> </tbody> </table> <p>pandas has two ways to store strings.</p> <ol class=\"arabic simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> dtype, which can hold any Python object, including strings.</p></li> <li><p><a class=\"reference internal\" href=\"../reference/api/pandas.stringdtype#pandas.StringDtype\" title=\"pandas.StringDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StringDtype</span></code></a>, which is dedicated to strings.</p></li> </ol> <p>Generally, we recommend using <a class=\"reference internal\" href=\"../reference/api/pandas.stringdtype#pandas.StringDtype\" title=\"pandas.StringDtype\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StringDtype</span></code></a>. See <a class=\"reference internal\" href=\"text#text-types\"><span class=\"std std-ref\">Text data types</span></a> for more.</p> <p>Finally, arbitrary objects may be stored using the <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> dtype, but should be avoided to the extent possible (for performance and interoperability with other libraries and methods. See <a class=\"reference internal\" href=\"#basics-object-conversion\"><span class=\"std std-ref\">object conversion</span></a>).</p> <p>A convenient <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.dtypes#pandas.DataFrame.dtypes\" title=\"pandas.DataFrame.dtypes\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">dtypes</span></code></a> attribute for DataFrame returns a Series with the data type of each column.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [347]: dft = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": np.random.rand(3),\n   .....:         \"B\": 1,\n   .....:         \"C\": \"foo\",\n   .....:         \"D\": pd.Timestamp(\"20010102\"),\n   .....:         \"E\": pd.Series([1.0] * 3).astype(\"float32\"),\n   .....:         \"F\": False,\n   .....:         \"G\": pd.Series([1] * 3, dtype=\"int8\"),\n   .....:     }\n   .....: )\n   .....: \n\nIn [348]: dft\nOut[348]: \n          A  B    C          D    E      F  G\n0  0.035962  1  foo 2001-01-02  1.0  False  1\n1  0.701379  1  foo 2001-01-02  1.0  False  1\n2  0.281885  1  foo 2001-01-02  1.0  False  1\n\nIn [349]: dft.dtypes\nOut[349]: \nA           float64\nB             int64\nC            object\nD    datetime64[ns]\nE           float32\nF              bool\nG              int8\ndtype: object\n</pre></div> </div> <p>On a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> object, use the <a class=\"reference internal\" href=\"../reference/api/pandas.series.dtype#pandas.Series.dtype\" title=\"pandas.Series.dtype\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">dtype</span></code></a> attribute.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [350]: dft[\"A\"].dtype\nOut[350]: dtype('float64')\n</pre></div> </div> <p>If a pandas object contains data with multiple dtypes <em>in a single column</em>, the dtype of the column will be chosen to accommodate all of the data types (<code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> is the most general).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># these ints are coerced to floats\nIn [351]: pd.Series([1, 2, 3, 4, 5, 6.0])\nOut[351]: \n0    1.0\n1    2.0\n2    3.0\n3    4.0\n4    5.0\n5    6.0\ndtype: float64\n\n# string data forces an ``object`` dtype\nIn [352]: pd.Series([1, 2, 3, 6.0, \"foo\"])\nOut[352]: \n0      1\n1      2\n2      3\n3    6.0\n4    foo\ndtype: object\n</pre></div> </div> <p>The number of columns of each type in a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> can be found by calling <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.dtypes.value_counts()</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [353]: dft.dtypes.value_counts()\nOut[353]: \nfloat64           1\nint64             1\nobject            1\ndatetime64[ns]    1\nfloat32           1\nbool              1\nint8              1\ndtype: int64\n</pre></div> </div> <p>Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> keyword, a passed <code class=\"docutils literal notranslate\"><span class=\"pre\">ndarray</span></code>, or a passed <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>), then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will <strong>NOT</strong> be combined. The following example will give you a taste.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [354]: df1 = pd.DataFrame(np.random.randn(8, 1), columns=[\"A\"], dtype=\"float32\")\n\nIn [355]: df1\nOut[355]: \n          A\n0  0.224364\n1  1.890546\n2  0.182879\n3  0.787847\n4 -0.188449\n5  0.667715\n6 -0.011736\n7 -0.399073\n\nIn [356]: df1.dtypes\nOut[356]: \nA    float32\ndtype: object\n\nIn [357]: df2 = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": pd.Series(np.random.randn(8), dtype=\"float16\"),\n   .....:         \"B\": pd.Series(np.random.randn(8)),\n   .....:         \"C\": pd.Series(np.array(np.random.randn(8), dtype=\"uint8\")),\n   .....:     }\n   .....: )\n   .....: \n\nIn [358]: df2\nOut[358]: \n          A         B    C\n0  0.823242  0.256090    0\n1  1.607422  1.426469    0\n2 -0.333740 -0.416203  255\n3 -0.063477  1.139976    0\n4 -1.014648 -1.193477    0\n5  0.678711  0.096706    0\n6 -0.040863 -1.956850    1\n7 -0.357422 -0.714337    0\n\nIn [359]: df2.dtypes\nOut[359]: \nA    float16\nB    float64\nC      uint8\ndtype: object\n</pre></div> </div> <section id=\"defaults\"> <h3>defaults</h3> <p>By default integer types are <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code> and float types are <code class=\"docutils literal notranslate\"><span class=\"pre\">float64</span></code>, <em>regardless</em> of platform (32-bit or 64-bit). The following will all result in <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code> dtypes.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [360]: pd.DataFrame([1, 2], columns=[\"a\"]).dtypes\nOut[360]: \na    int64\ndtype: object\n\nIn [361]: pd.DataFrame({\"a\": [1, 2]}).dtypes\nOut[361]: \na    int64\ndtype: object\n\nIn [362]: pd.DataFrame({\"a\": 1}, index=list(range(2))).dtypes\nOut[362]: \na    int64\ndtype: object\n</pre></div> </div> <p>Note that Numpy will choose <em>platform-dependent</em> types when creating arrays. The following <strong>WILL</strong> result in <code class=\"docutils literal notranslate\"><span class=\"pre\">int32</span></code> on 32-bit platform.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [363]: frame = pd.DataFrame(np.array([1, 2]))\n</pre></div> </div> </section> <section id=\"upcasting\"> <h3>upcasting</h3> <p>Types can potentially be <em>upcasted</em> when combined with other types, meaning they are promoted from the current type (e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">float</span></code>).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [364]: df3 = df1.reindex_like(df2).fillna(value=0.0) + df2\n\nIn [365]: df3\nOut[365]: \n          A         B      C\n0  1.047606  0.256090    0.0\n1  3.497968  1.426469    0.0\n2 -0.150862 -0.416203  255.0\n3  0.724370  1.139976    0.0\n4 -1.203098 -1.193477    0.0\n5  1.346426  0.096706    0.0\n6 -0.052599 -1.956850    1.0\n7 -0.756495 -0.714337    0.0\n\nIn [366]: df3.dtypes\nOut[366]: \nA    float32\nB    float64\nC    float64\ndtype: object\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy\" title=\"pandas.DataFrame.to_numpy\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_numpy()</span></code></a> will return the <em>lower-common-denominator</em> of the dtypes, meaning the dtype that can accommodate <strong>ALL</strong> of the types in the resulting homogeneous dtyped NumPy array. This can force some <em>upcasting</em>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [367]: df3.to_numpy().dtype\nOut[367]: dtype('float64')\n</pre></div> </div> </section> <section id=\"astype\"> <h3>astype</h3> <p id=\"basics-cast\">You can use the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype\" title=\"pandas.DataFrame.astype\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">astype()</span></code></a> method to explicitly convert dtypes from one to another. These will by default return a copy, even if the dtype was unchanged (pass <code class=\"docutils literal notranslate\"><span class=\"pre\">copy=False</span></code> to change this behavior). In addition, they will raise an exception if the astype operation is invalid.</p> <p>Upcasting is always according to the <strong>NumPy</strong> rules. If two different dtypes are involved in an operation, then the more <em>general</em> one will be used as the result of the operation.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [368]: df3\nOut[368]: \n          A         B      C\n0  1.047606  0.256090    0.0\n1  3.497968  1.426469    0.0\n2 -0.150862 -0.416203  255.0\n3  0.724370  1.139976    0.0\n4 -1.203098 -1.193477    0.0\n5  1.346426  0.096706    0.0\n6 -0.052599 -1.956850    1.0\n7 -0.756495 -0.714337    0.0\n\nIn [369]: df3.dtypes\nOut[369]: \nA    float32\nB    float64\nC    float64\ndtype: object\n\n# conversion of dtypes\nIn [370]: df3.astype(\"float32\").dtypes\nOut[370]: \nA    float32\nB    float32\nC    float32\ndtype: object\n</pre></div> </div> <p>Convert a subset of columns to a specified type using <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype\" title=\"pandas.DataFrame.astype\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">astype()</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [371]: dft = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6], \"c\": [7, 8, 9]})\n\nIn [372]: dft[[\"a\", \"b\"]] = dft[[\"a\", \"b\"]].astype(np.uint8)\n\nIn [373]: dft\nOut[373]: \n   a  b  c\n0  1  4  7\n1  2  5  8\n2  3  6  9\n\nIn [374]: dft.dtypes\nOut[374]: \na    uint8\nb    uint8\nc    int64\ndtype: object\n</pre></div> </div> <p>Convert certain columns to a specific dtype by passing a dict to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype\" title=\"pandas.DataFrame.astype\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">astype()</span></code></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [375]: dft1 = pd.DataFrame({\"a\": [1, 0, 1], \"b\": [4, 5, 6], \"c\": [7, 8, 9]})\n\nIn [376]: dft1 = dft1.astype({\"a\": np.bool_, \"c\": np.float64})\n\nIn [377]: dft1\nOut[377]: \n       a  b    c\n0   True  4  7.0\n1  False  5  8.0\n2   True  6  9.0\n\nIn [378]: dft1.dtypes\nOut[378]: \na       bool\nb      int64\nc    float64\ndtype: object\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>When trying to convert a subset of columns to a specified type using <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype\" title=\"pandas.DataFrame.astype\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">astype()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.loc#pandas.DataFrame.loc\" title=\"pandas.DataFrame.loc\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">loc()</span></code></a>, upcasting occurs.</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.loc#pandas.DataFrame.loc\" title=\"pandas.DataFrame.loc\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">loc()</span></code></a> tries to fit in what we are assigning to the current dtypes, while <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> will overwrite them taking the dtype from the right hand side. Therefore the following piece of code produces the unintended result.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [379]: dft = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6], \"c\": [7, 8, 9]})\n\nIn [380]: dft.loc[:, [\"a\", \"b\"]].astype(np.uint8).dtypes\nOut[380]: \na    uint8\nb    uint8\ndtype: object\n\nIn [381]: dft.loc[:, [\"a\", \"b\"]] = dft.loc[:, [\"a\", \"b\"]].astype(np.uint8)\n\nIn [382]: dft.dtypes\nOut[382]: \na    int64\nb    int64\nc    int64\ndtype: object\n</pre></div> </div> </div> </section> <section id=\"object-conversion\"> <h3>object conversion</h3> <p>pandas offers various functions to try to force conversion of types from the <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> dtype to other types. In cases where the data is already of the correct type, but stored in an <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> array, the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.infer_objects#pandas.DataFrame.infer_objects\" title=\"pandas.DataFrame.infer_objects\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.infer_objects()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.series.infer_objects#pandas.Series.infer_objects\" title=\"pandas.Series.infer_objects\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.infer_objects()</span></code></a> methods can be used to soft convert to the correct type.</p> <blockquote> <div>\n<div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [383]: import datetime\n\nIn [384]: df = pd.DataFrame(\n   .....:     [\n   .....:         [1, 2],\n   .....:         [\"a\", \"b\"],\n   .....:         [datetime.datetime(2016, 3, 2), datetime.datetime(2016, 3, 2)],\n   .....:     ]\n   .....: )\n   .....: \n\nIn [385]: df = df.T\n\nIn [386]: df\nOut[386]: \n   0  1          2\n0  1  a 2016-03-02\n1  2  b 2016-03-02\n\nIn [387]: df.dtypes\nOut[387]: \n0            object\n1            object\n2    datetime64[ns]\ndtype: object\n</pre></div> </div> </div>\n</blockquote> <p>Because the data was transposed the original inference stored all columns as object, which <code class=\"docutils literal notranslate\"><span class=\"pre\">infer_objects</span></code> will correct.</p> <blockquote> <div>\n<div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [388]: df.infer_objects().dtypes\nOut[388]: \n0             int64\n1            object\n2    datetime64[ns]\ndtype: object\n</pre></div> </div> </div>\n</blockquote> <p>The following functions are available for one dimensional object arrays or scalars to perform hard conversion of objects to a specified type:</p> <ul> <li>\n<p><a class=\"reference internal\" href=\"../reference/api/pandas.to_numeric#pandas.to_numeric\" title=\"pandas.to_numeric\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_numeric()</span></code></a> (conversion to numeric dtypes)</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [389]: m = [\"1.1\", 2, 3]\n\nIn [390]: pd.to_numeric(m)\nOut[390]: array([1.1, 2. , 3. ])\n</pre></div> </div> </li> <li>\n<p><a class=\"reference internal\" href=\"../reference/api/pandas.to_datetime#pandas.to_datetime\" title=\"pandas.to_datetime\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_datetime()</span></code></a> (conversion to datetime objects)</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [391]: import datetime\n\nIn [392]: m = [\"2016-07-09\", datetime.datetime(2016, 3, 2)]\n\nIn [393]: pd.to_datetime(m)\nOut[393]: DatetimeIndex(['2016-07-09', '2016-03-02'], dtype='datetime64[ns]', freq=None)\n</pre></div> </div> </li> <li>\n<p><a class=\"reference internal\" href=\"../reference/api/pandas.to_timedelta#pandas.to_timedelta\" title=\"pandas.to_timedelta\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_timedelta()</span></code></a> (conversion to timedelta objects)</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [394]: m = [\"5us\", pd.Timedelta(\"1day\")]\n\nIn [395]: pd.to_timedelta(m)\nOut[395]: TimedeltaIndex(['0 days 00:00:00.000005', '1 days 00:00:00'], dtype='timedelta64[ns]', freq=None)\n</pre></div> </div> </li> </ul> <p>To force a conversion, we can pass in an <code class=\"docutils literal notranslate\"><span class=\"pre\">errors</span></code> argument, which specifies how pandas should deal with elements that cannot be converted to desired dtype or object. By default, <code class=\"docutils literal notranslate\"><span class=\"pre\">errors='raise'</span></code>, meaning that any errors encountered will be raised during the conversion process. However, if <code class=\"docutils literal notranslate\"><span class=\"pre\">errors='coerce'</span></code>, these errors will be ignored and pandas will convert problematic elements to <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.NaT</span></code> (for datetime and timedelta) or <code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code> (for numeric). This might be useful if you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime), but occasionally has non-conforming elements intermixed that you want to represent as missing:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [396]: import datetime\n\nIn [397]: m = [\"apple\", datetime.datetime(2016, 3, 2)]\n\nIn [398]: pd.to_datetime(m, errors=\"coerce\")\nOut[398]: DatetimeIndex(['NaT', '2016-03-02'], dtype='datetime64[ns]', freq=None)\n\nIn [399]: m = [\"apple\", 2, 3]\n\nIn [400]: pd.to_numeric(m, errors=\"coerce\")\nOut[400]: array([nan,  2.,  3.])\n\nIn [401]: m = [\"apple\", pd.Timedelta(\"1day\")]\n\nIn [402]: pd.to_timedelta(m, errors=\"coerce\")\nOut[402]: TimedeltaIndex([NaT, '1 days'], dtype='timedelta64[ns]', freq=None)\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">errors</span></code> parameter has a third option of <code class=\"docutils literal notranslate\"><span class=\"pre\">errors='ignore'</span></code>, which will simply return the passed in data if it encounters any errors with the conversion to a desired data type:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [403]: import datetime\n\nIn [404]: m = [\"apple\", datetime.datetime(2016, 3, 2)]\n\nIn [405]: pd.to_datetime(m, errors=\"ignore\")\nOut[405]: Index(['apple', 2016-03-02 00:00:00], dtype='object')\n\nIn [406]: m = [\"apple\", 2, 3]\n\nIn [407]: pd.to_numeric(m, errors=\"ignore\")\nOut[407]: array(['apple', 2, 3], dtype=object)\n\nIn [408]: m = [\"apple\", pd.Timedelta(\"1day\")]\n\nIn [409]: pd.to_timedelta(m, errors=\"ignore\")\nOut[409]: array(['apple', Timedelta('1 days 00:00:00')], dtype=object)\n</pre></div> </div> <p>In addition to object conversion, <a class=\"reference internal\" href=\"../reference/api/pandas.to_numeric#pandas.to_numeric\" title=\"pandas.to_numeric\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_numeric()</span></code></a> provides another argument <code class=\"docutils literal notranslate\"><span class=\"pre\">downcast</span></code>, which gives the option of downcasting the newly (or already) numeric data to a smaller dtype, which can conserve memory:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [410]: m = [\"1\", 2, 3]\n\nIn [411]: pd.to_numeric(m, downcast=\"integer\")  # smallest signed int dtype\nOut[411]: array([1, 2, 3], dtype=int8)\n\nIn [412]: pd.to_numeric(m, downcast=\"signed\")  # same as 'integer'\nOut[412]: array([1, 2, 3], dtype=int8)\n\nIn [413]: pd.to_numeric(m, downcast=\"unsigned\")  # smallest unsigned int dtype\nOut[413]: array([1, 2, 3], dtype=uint8)\n\nIn [414]: pd.to_numeric(m, downcast=\"float\")  # smallest float dtype\nOut[414]: array([1., 2., 3.], dtype=float32)\n</pre></div> </div> <p>As these methods apply only to one-dimensional arrays, lists or scalars; they cannot be used directly on multi-dimensional objects such as DataFrames. However, with <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply\" title=\"pandas.DataFrame.apply\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">apply()</span></code></a>, we can “apply” the function over each column efficiently:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [415]: import datetime\n\nIn [416]: df = pd.DataFrame([[\"2016-07-09\", datetime.datetime(2016, 3, 2)]] * 2, dtype=\"O\")\n\nIn [417]: df\nOut[417]: \n            0                    1\n0  2016-07-09  2016-03-02 00:00:00\n1  2016-07-09  2016-03-02 00:00:00\n\nIn [418]: df.apply(pd.to_datetime)\nOut[418]: \n           0          1\n0 2016-07-09 2016-03-02\n1 2016-07-09 2016-03-02\n\nIn [419]: df = pd.DataFrame([[\"1.1\", 2, 3]] * 2, dtype=\"O\")\n\nIn [420]: df\nOut[420]: \n     0  1  2\n0  1.1  2  3\n1  1.1  2  3\n\nIn [421]: df.apply(pd.to_numeric)\nOut[421]: \n     0  1  2\n0  1.1  2  3\n1  1.1  2  3\n\nIn [422]: df = pd.DataFrame([[\"5us\", pd.Timedelta(\"1day\")]] * 2, dtype=\"O\")\n\nIn [423]: df\nOut[423]: \n     0                1\n0  5us  1 days 00:00:00\n1  5us  1 days 00:00:00\n\nIn [424]: df.apply(pd.to_timedelta)\nOut[424]: \n                       0      1\n0 0 days 00:00:00.000005 1 days\n1 0 days 00:00:00.000005 1 days\n</pre></div> </div> </section> <section id=\"gotchas\"> <h3>gotchas</h3> <p>Performing selection operations on <code class=\"docutils literal notranslate\"><span class=\"pre\">integer</span></code> type data can easily upcast the data to <code class=\"docutils literal notranslate\"><span class=\"pre\">floating</span></code>. The dtype of the input data will be preserved in cases where <code class=\"docutils literal notranslate\"><span class=\"pre\">nans</span></code> are not introduced. See also <a class=\"reference internal\" href=\"gotchas#gotchas-intna\"><span class=\"std std-ref\">Support for integer NA</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [425]: dfi = df3.astype(\"int32\")\n\nIn [426]: dfi[\"E\"] = 1\n\nIn [427]: dfi\nOut[427]: \n   A  B    C  E\n0  1  0    0  1\n1  3  1    0  1\n2  0  0  255  1\n3  0  1    0  1\n4 -1 -1    0  1\n5  1  0    0  1\n6  0 -1    1  1\n7  0  0    0  1\n\nIn [428]: dfi.dtypes\nOut[428]: \nA    int32\nB    int32\nC    int32\nE    int64\ndtype: object\n\nIn [429]: casted = dfi[dfi &gt; 0]\n\nIn [430]: casted\nOut[430]: \n     A    B      C  E\n0  1.0  NaN    NaN  1\n1  3.0  1.0    NaN  1\n2  NaN  NaN  255.0  1\n3  NaN  1.0    NaN  1\n4  NaN  NaN    NaN  1\n5  1.0  NaN    NaN  1\n6  NaN  NaN    1.0  1\n7  NaN  NaN    NaN  1\n\nIn [431]: casted.dtypes\nOut[431]: \nA    float64\nB    float64\nC    float64\nE      int64\ndtype: object\n</pre></div> </div> <p>While float dtypes are unchanged.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [432]: dfa = df3.copy()\n\nIn [433]: dfa[\"A\"] = dfa[\"A\"].astype(\"float32\")\n\nIn [434]: dfa.dtypes\nOut[434]: \nA    float32\nB    float64\nC    float64\ndtype: object\n\nIn [435]: casted = dfa[df2 &gt; 0]\n\nIn [436]: casted\nOut[436]: \n          A         B      C\n0  1.047606  0.256090    NaN\n1  3.497968  1.426469    NaN\n2       NaN       NaN  255.0\n3       NaN  1.139976    NaN\n4       NaN       NaN    NaN\n5  1.346426  0.096706    NaN\n6       NaN       NaN    1.0\n7       NaN       NaN    NaN\n\nIn [437]: casted.dtypes\nOut[437]: \nA    float32\nB    float64\nC    float64\ndtype: object\n</pre></div> </div> </section> </section> <section id=\"selecting-columns-based-on-dtype\"> <h2>Selecting columns based on <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code>\n</h2> <p id=\"basics-selectdtypes\">The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.select_dtypes#pandas.DataFrame.select_dtypes\" title=\"pandas.DataFrame.select_dtypes\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">select_dtypes()</span></code></a> method implements subsetting of columns based on their <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code>.</p> <p>First, let’s create a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> with a slew of different dtypes:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [438]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"string\": list(\"abc\"),\n   .....:         \"int64\": list(range(1, 4)),\n   .....:         \"uint8\": np.arange(3, 6).astype(\"u1\"),\n   .....:         \"float64\": np.arange(4.0, 7.0),\n   .....:         \"bool1\": [True, False, True],\n   .....:         \"bool2\": [False, True, False],\n   .....:         \"dates\": pd.date_range(\"now\", periods=3),\n   .....:         \"category\": pd.Series(list(\"ABC\")).astype(\"category\"),\n   .....:     }\n   .....: )\n   .....: \n\nIn [439]: df[\"tdeltas\"] = df.dates.diff()\n\nIn [440]: df[\"uint64\"] = np.arange(3, 6).astype(\"u8\")\n\nIn [441]: df[\"other_dates\"] = pd.date_range(\"20130101\", periods=3)\n\nIn [442]: df[\"tz_aware_dates\"] = pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\")\n\nIn [443]: df\nOut[443]: \n  string  int64  uint8  float64  bool1  bool2                      dates category tdeltas  uint64 other_dates            tz_aware_dates\n0      a      1      3      4.0   True  False 2022-01-22 10:50:03.741897        A     NaT       3  2013-01-01 2013-01-01 00:00:00-05:00\n1      b      2      4      5.0  False   True 2022-01-23 10:50:03.741897        B  1 days       4  2013-01-02 2013-01-02 00:00:00-05:00\n2      c      3      5      6.0   True  False 2022-01-24 10:50:03.741897        C  1 days       5  2013-01-03 2013-01-03 00:00:00-05:00\n</pre></div> </div> <p>And the dtypes:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [444]: df.dtypes\nOut[444]: \nstring                                object\nint64                                  int64\nuint8                                  uint8\nfloat64                              float64\nbool1                                   bool\nbool2                                   bool\ndates                         datetime64[ns]\ncategory                            category\ntdeltas                      timedelta64[ns]\nuint64                                uint64\nother_dates                   datetime64[ns]\ntz_aware_dates    datetime64[ns, US/Eastern]\ndtype: object\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.select_dtypes#pandas.DataFrame.select_dtypes\" title=\"pandas.DataFrame.select_dtypes\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">select_dtypes()</span></code></a> has two parameters <code class=\"docutils literal notranslate\"><span class=\"pre\">include</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">exclude</span></code> that allow you to say “give me the columns <em>with</em> these dtypes” (<code class=\"docutils literal notranslate\"><span class=\"pre\">include</span></code>) and/or “give the columns <em>without</em> these dtypes” (<code class=\"docutils literal notranslate\"><span class=\"pre\">exclude</span></code>).</p> <p>For example, to select <code class=\"docutils literal notranslate\"><span class=\"pre\">bool</span></code> columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [445]: df.select_dtypes(include=[bool])\nOut[445]: \n   bool1  bool2\n0   True  False\n1  False   True\n2   True  False\n</pre></div> </div> <p>You can also pass the name of a dtype in the <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/arrays.scalars.html\">NumPy dtype hierarchy</a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [446]: df.select_dtypes(include=[\"bool\"])\nOut[446]: \n   bool1  bool2\n0   True  False\n1  False   True\n2   True  False\n</pre></div> </div> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.select_dtypes#pandas.DataFrame.select_dtypes\" title=\"pandas.DataFrame.select_dtypes\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">select_dtypes()</span></code></a> also works with generic dtypes as well.</p> <p>For example, to select all numeric and boolean columns while excluding unsigned integers:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [447]: df.select_dtypes(include=[\"number\", \"bool\"], exclude=[\"unsignedinteger\"])\nOut[447]: \n   int64  float64  bool1  bool2 tdeltas\n0      1      4.0   True  False     NaT\n1      2      5.0  False   True  1 days\n2      3      6.0   True  False  1 days\n</pre></div> </div> <p>To select string columns you must use the <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> dtype:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [448]: df.select_dtypes(include=[\"object\"])\nOut[448]: \n  string\n0      a\n1      b\n2      c\n</pre></div> </div> <p>To see all the child dtypes of a generic <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> like <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy.number</span></code> you can define a function that returns a tree of child dtypes:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [449]: def subdtypes(dtype):\n   .....:     subs = dtype.__subclasses__()\n   .....:     if not subs:\n   .....:         return dtype\n   .....:     return [dtype, [subdtypes(dt) for dt in subs]]\n   .....: \n</pre></div> </div> <p>All NumPy dtypes are subclasses of <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy.generic</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [450]: subdtypes(np.generic)\nOut[450]: \n[numpy.generic,\n [[numpy.number,\n   [[numpy.integer,\n     [[numpy.signedinteger,\n       [numpy.int8,\n        numpy.int16,\n        numpy.int32,\n        numpy.int64,\n        numpy.longlong,\n        numpy.timedelta64]],\n      [numpy.unsignedinteger,\n       [numpy.uint8,\n        numpy.uint16,\n        numpy.uint32,\n        numpy.uint64,\n        numpy.ulonglong]]]],\n    [numpy.inexact,\n     [[numpy.floating,\n       [numpy.float16, numpy.float32, numpy.float64, numpy.float128]],\n      [numpy.complexfloating,\n       [numpy.complex64, numpy.complex128, numpy.complex256]]]]]],\n  [numpy.flexible,\n   [[numpy.character, [numpy.bytes_, numpy.str_]],\n    [numpy.void, [numpy.record]]]],\n  numpy.bool_,\n  numpy.datetime64,\n  numpy.object_]]\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>pandas also defines the types <code class=\"docutils literal notranslate\"><span class=\"pre\">category</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">datetime64[ns,</span> <span class=\"pre\">tz]</span></code>, which are not integrated into the normal NumPy hierarchy and won’t show up with the above function.</p> </div> </section><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>\n    <a href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/basics.html\" class=\"_attribution-link\">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/basics.html</a>\n  </p>\n</div>\n","user_guide/io":"<h1>IO tools (text, CSV, HDF5, …)</h1> <p>The pandas I/O API is a set of top level <code class=\"docutils literal notranslate\"><span class=\"pre\">reader</span></code> functions accessed like <a class=\"reference internal\" href=\"../reference/api/pandas.read_csv#pandas.read_csv\" title=\"pandas.read_csv\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">pandas.read_csv()</span></code></a> that generally return a pandas object. The corresponding <code class=\"docutils literal notranslate\"><span class=\"pre\">writer</span></code> functions are object methods that are accessed like <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_csv#pandas.DataFrame.to_csv\" title=\"pandas.DataFrame.to_csv\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_csv()</span></code></a>. Below is a table containing available <code class=\"docutils literal notranslate\"><span class=\"pre\">readers</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">writers</span></code>.</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 12%\"> <col style=\"width: 40%\"> <col style=\"width: 24%\"> <col style=\"width: 24%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Format Type</p></th> <th class=\"head\"><p>Data Description</p></th> <th class=\"head\"><p>Reader</p></th> <th class=\"head\"><p>Writer</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>text</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Comma-separated_values\">CSV</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-read-csv-table\"><span class=\"std std-ref\">read_csv</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-store-in-csv\"><span class=\"std std-ref\">to_csv</span></a></p></td> </tr> <tr class=\"row-odd\">\n<td><p>text</p></td> <td><p>Fixed-Width Text File</p></td> <td><p><a class=\"reference internal\" href=\"#io-fwf-reader\"><span class=\"std std-ref\">read_fwf</span></a></p></td> <td></td> </tr> <tr class=\"row-even\">\n<td><p>text</p></td> <td><p><a class=\"reference external\" href=\"https://www.json.org/\">JSON</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-json-reader\"><span class=\"std std-ref\">read_json</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-json-writer\"><span class=\"std std-ref\">to_json</span></a></p></td> </tr> <tr class=\"row-odd\">\n<td><p>text</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/HTML\">HTML</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-read-html\"><span class=\"std std-ref\">read_html</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-html\"><span class=\"std std-ref\">to_html</span></a></p></td> </tr> <tr class=\"row-even\">\n<td><p>text</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/LaTeX\">LaTeX</a></p></td> <td></td> <td><p><a class=\"reference internal\" href=\"#io-latex\"><span class=\"std std-ref\">Styler.to_latex</span></a></p></td> </tr> <tr class=\"row-odd\">\n<td><p>text</p></td> <td><p><a class=\"reference external\" href=\"https://www.w3.org/standards/xml/core\">XML</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-read-xml\"><span class=\"std std-ref\">read_xml</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-xml\"><span class=\"std std-ref\">to_xml</span></a></p></td> </tr> <tr class=\"row-even\">\n<td><p>text</p></td> <td><p>Local clipboard</p></td> <td><p><a class=\"reference internal\" href=\"#io-clipboard\"><span class=\"std std-ref\">read_clipboard</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-clipboard\"><span class=\"std std-ref\">to_clipboard</span></a></p></td> </tr> <tr class=\"row-odd\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Microsoft_Excel\">MS Excel</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-excel-reader\"><span class=\"std std-ref\">read_excel</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-excel-writer\"><span class=\"std std-ref\">to_excel</span></a></p></td> </tr> <tr class=\"row-even\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"http://opendocumentformat.org\">OpenDocument</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-ods\"><span class=\"std std-ref\">read_excel</span></a></p></td> <td></td> </tr> <tr class=\"row-odd\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://support.hdfgroup.org/HDF5/whatishdf5.html\">HDF5 Format</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-hdf5\"><span class=\"std std-ref\">read_hdf</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-hdf5\"><span class=\"std std-ref\">to_hdf</span></a></p></td> </tr> <tr class=\"row-even\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://github.com/wesm/feather\">Feather Format</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-feather\"><span class=\"std std-ref\">read_feather</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-feather\"><span class=\"std std-ref\">to_feather</span></a></p></td> </tr> <tr class=\"row-odd\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://parquet.apache.org/\">Parquet Format</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-parquet\"><span class=\"std std-ref\">read_parquet</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-parquet\"><span class=\"std std-ref\">to_parquet</span></a></p></td> </tr> <tr class=\"row-even\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://orc.apache.org/\">ORC Format</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-orc\"><span class=\"std std-ref\">read_orc</span></a></p></td> <td></td> </tr> <tr class=\"row-odd\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Stata\">Stata</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-stata-reader\"><span class=\"std std-ref\">read_stata</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-stata-writer\"><span class=\"std std-ref\">to_stata</span></a></p></td> </tr> <tr class=\"row-even\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/SAS_(software)\">SAS</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-sas-reader\"><span class=\"std std-ref\">read_sas</span></a></p></td> <td></td> </tr> <tr class=\"row-odd\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/SPSS\">SPSS</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-spss-reader\"><span class=\"std std-ref\">read_spss</span></a></p></td> <td></td> </tr> <tr class=\"row-even\">\n<td><p>binary</p></td> <td><p><a class=\"reference external\" href=\"https://docs.python.org/3/library/pickle.html\">Python Pickle Format</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-pickle\"><span class=\"std std-ref\">read_pickle</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-pickle\"><span class=\"std std-ref\">to_pickle</span></a></p></td> </tr> <tr class=\"row-odd\">\n<td><p>SQL</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/SQL\">SQL</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-sql\"><span class=\"std std-ref\">read_sql</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-sql\"><span class=\"std std-ref\">to_sql</span></a></p></td> </tr> <tr class=\"row-even\">\n<td><p>SQL</p></td> <td><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/BigQuery\">Google BigQuery</a></p></td> <td><p><a class=\"reference internal\" href=\"#io-bigquery\"><span class=\"std std-ref\">read_gbq</span></a></p></td> <td><p><a class=\"reference internal\" href=\"#io-bigquery\"><span class=\"std std-ref\">to_gbq</span></a></p></td> </tr> </tbody> </table> <p><a class=\"reference internal\" href=\"#io-perf\"><span class=\"std std-ref\">Here</span></a> is an informal performance comparison for some of these IO methods.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>For examples that use the <code class=\"docutils literal notranslate\"><span class=\"pre\">StringIO</span></code> class, make sure you import it with <code class=\"docutils literal notranslate\"><span class=\"pre\">from</span> <span class=\"pre\">io</span> <span class=\"pre\">import</span> <span class=\"pre\">StringIO</span></code> for Python 3.</p> </div> <section id=\"csv-text-files\"> <h2>CSV &amp; text files</h2> <p>The workhorse function for reading text files (a.k.a. flat files) is <a class=\"reference internal\" href=\"../reference/api/pandas.read_csv#pandas.read_csv\" title=\"pandas.read_csv\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_csv()</span></code></a>. See the <a class=\"reference internal\" href=\"cookbook#cookbook-csv\"><span class=\"std std-ref\">cookbook</span></a> for some advanced strategies.</p> <section id=\"parsing-options\"> <h3>Parsing options</h3> <p><a class=\"reference internal\" href=\"../reference/api/pandas.read_csv#pandas.read_csv\" title=\"pandas.read_csv\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_csv()</span></code></a> accepts the following common arguments:</p> <section id=\"basic\"> <h4>Basic</h4> <dl> <dt>filepath_or_buffer<span class=\"classifier\">:various</span>\n</dt>\n<dd>\n<p>Either a path to a file (a <a class=\"reference external\" href=\"https://docs.python.org/3/library/stdtypes.html#str\" title=\"(in Python v3.10)\"><code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code></a>, <a class=\"reference external\" href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path\" title=\"(in Python v3.10)\"><code class=\"docutils literal notranslate\"><span class=\"pre\">pathlib.Path</span></code></a>, or <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">py:py._path.local.LocalPath</span></code>), URL (including http, ftp, and S3 locations), or any object with a <code class=\"docutils literal notranslate\"><span class=\"pre\">read()</span></code> method (such as an open file or <a class=\"reference external\" href=\"https://docs.python.org/3/library/io.html#io.StringIO\" title=\"(in Python v3.10)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StringIO</span></code></a>).</p> </dd> <dt>sep<span class=\"classifier\">:str, defaults to ',' for read_csv(), \\t for read_table()</span>\n</dt>\n<dd>\n<p>Delimiter to use. If sep is <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>, the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python’s builtin sniffer tool, <a class=\"reference external\" href=\"https://docs.python.org/3/library/csv.html#csv.Sniffer\" title=\"(in Python v3.10)\"><code class=\"docutils literal notranslate\"><span class=\"pre\">csv.Sniffer</span></code></a>. In addition, separators longer than 1 character and different from <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\s+'</span></code> will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\\\r\\\\t'</span></code>.</p> </dd> <dt>delimiter<span class=\"classifier\">:str, default None</span>\n</dt>\n<dd>\n<p>Alternative argument name for sep.</p> </dd> <dt>delim_whitespace<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>Specifies whether or not whitespace (e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">'</span> <span class=\"pre\">'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\t'</span></code>) will be used as the delimiter. Equivalent to setting <code class=\"docutils literal notranslate\"><span class=\"pre\">sep='\\s+'</span></code>. If this option is set to <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, nothing should be passed in for the <code class=\"docutils literal notranslate\"><span class=\"pre\">delimiter</span></code> parameter.</p> </dd> </dl> </section> <section id=\"column-and-index-locations-and-names\"> <h4>Column and index locations and names</h4> <dl> <dt>header<span class=\"classifier\">:int or list of ints, default 'infer'</span>\n</dt>\n<dd>\n<p>Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to <code class=\"docutils literal notranslate\"><span class=\"pre\">header=0</span></code> and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to <code class=\"docutils literal notranslate\"><span class=\"pre\">header=None</span></code>. Explicitly pass <code class=\"docutils literal notranslate\"><span class=\"pre\">header=0</span></code> to be able to replace existing names.</p> <p>The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">[0,1,3]</span></code>. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if <code class=\"docutils literal notranslate\"><span class=\"pre\">skip_blank_lines=True</span></code>, so header=0 denotes the first line of data rather than the first line of the file.</p> </dd> <dt>names<span class=\"classifier\">:array-like, default None</span>\n</dt>\n<dd>\n<p>List of column names to use. If file contains no header row, then you should explicitly pass <code class=\"docutils literal notranslate\"><span class=\"pre\">header=None</span></code>. Duplicates in this list are not allowed.</p> </dd> <dt>index_col<span class=\"classifier\">:int, str, sequence of int / str, or False, optional, default None</span>\n</dt>\n<dd>\n<p>Column(s) to use as the row labels of the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>, either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used.</p> <p>Note: <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col=False</span></code> can be used to force pandas to <em>not</em> use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line.</p> <p>The default value of <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used. If it is larger, then the first columns are used as index so that the remaining number of fields in the body are equal to the number of fields in the header.</p> <p>The first row after the header is used to determine the number of columns, which will go into the index. If the subsequent rows contain less columns than the first row, they are filled with <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>.</p> <p>This can be avoided through <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code>. This ensures that the columns are taken as is and the trailing data are ignored.</p> </dd> <dt>usecols<span class=\"classifier\">:list-like or callable, default None</span>\n</dt>\n<dd>\n<p>Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in <code class=\"docutils literal notranslate\"><span class=\"pre\">names</span></code> or inferred from the document header row(s). If <code class=\"docutils literal notranslate\"><span class=\"pre\">names</span></code> are given, the document header row(s) are not taken into account. For example, a valid list-like <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> parameter would be <code class=\"docutils literal notranslate\"><span class=\"pre\">[0,</span> <span class=\"pre\">1,</span> <span class=\"pre\">2]</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">['foo',</span> <span class=\"pre\">'bar',</span> <span class=\"pre\">'baz']</span></code>.</p> <p>Element order is ignored, so <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols=[0,</span> <span class=\"pre\">1]</span></code> is the same as <code class=\"docutils literal notranslate\"><span class=\"pre\">[1,</span> <span class=\"pre\">0]</span></code>. To instantiate a DataFrame from <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code> with element order preserved use <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.read_csv(data,</span> <span class=\"pre\">usecols=['foo',</span> <span class=\"pre\">'bar'])[['foo',</span> <span class=\"pre\">'bar']]</span></code> for columns in <code class=\"docutils literal notranslate\"><span class=\"pre\">['foo',</span> <span class=\"pre\">'bar']</span></code> order or <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.read_csv(data,</span> <span class=\"pre\">usecols=['foo',</span> <span class=\"pre\">'bar'])[['bar',</span> <span class=\"pre\">'foo']]</span></code> for <code class=\"docutils literal notranslate\"><span class=\"pre\">['bar',</span> <span class=\"pre\">'foo']</span></code> order.</p> <p>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [1]: import pandas as pd\n\nIn [2]: from io import StringIO\n\nIn [3]: data = \"col1,col2,col3\\na,b,1\\na,b,2\\nc,d,3\"\n\nIn [4]: pd.read_csv(StringIO(data))\nOut[4]: \n  col1 col2  col3\n0    a    b     1\n1    a    b     2\n2    c    d     3\n\nIn [5]: pd.read_csv(StringIO(data), usecols=lambda x: x.upper() in [\"COL1\", \"COL3\"])\nOut[5]: \n  col1  col3\n0    a     1\n1    a     2\n2    c     3\n</pre></div> </div> <p>Using this parameter results in much faster parsing time and lower memory usage when using the c engine. The Python engine loads the data first before deciding which columns to drop.</p> </dd> <dt>squeeze<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>If the parsed data only contains one column then return a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>.</p> <div class=\"deprecated\"> <p><span class=\"versionmodified deprecated\">Deprecated since version 1.4.0: </span>Append <code class=\"docutils literal notranslate\"><span class=\"pre\">.squeeze(\"columns\")</span></code> to the call to <code class=\"docutils literal notranslate\"><span class=\"pre\">{func_name}</span></code> to squeeze the data.</p> </div> </dd> <dt>prefix<span class=\"classifier\">:str, default None</span>\n</dt>\n<dd>\n<p>Prefix to add to column numbers when no header, e.g. ‘X’ for X0, X1, …</p> <div class=\"deprecated\"> <p><span class=\"versionmodified deprecated\">Deprecated since version 1.4.0: </span>Use a list comprehension on the DataFrame’s columns after calling <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code>.</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [6]: data = \"col1,col2,col3\\na,b,1\"\n\nIn [7]: df = pd.read_csv(StringIO(data))\n\nIn [8]: df.columns = [f\"pre_{col}\" for col in df.columns]\n\nIn [9]: df\nOut[9]: \n  pre_col1 pre_col2  pre_col3\n0        a        b         1\n</pre></div> </div> </dd> <dt>mangle_dupe_cols<span class=\"classifier\">:boolean, default True</span>\n</dt>\n<dd>\n<p>Duplicate columns will be specified as ‘X’, ‘X.1’…’X.N’, rather than ‘X’…’X’. Passing in <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code> will cause data to be overwritten if there are duplicate names in the columns.</p> </dd> </dl> </section> <section id=\"general-parsing-configuration\"> <h4>General parsing configuration</h4> <dl> <dt>dtype<span class=\"classifier\">:Type name or dict of column -&gt; type, default None</span>\n</dt>\n<dd>\n<p>Data type for data or columns. E.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">{'a':</span> <span class=\"pre\">np.float64,</span> <span class=\"pre\">'b':</span> <span class=\"pre\">np.int32}</span></code> (unsupported with <code class=\"docutils literal notranslate\"><span class=\"pre\">engine='python'</span></code>). Use <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> together with suitable <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> settings to preserve and not interpret dtype.</p> </dd> <dt>engine<span class=\"classifier\">:{'c', 'python', 'pyarrow'}</span>\n</dt>\n<dd>\n<p>Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine.</p> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.4.0: </span>The “pyarrow” engine was added as an <em>experimental</em> engine, and some features are unsupported, or may not work correctly, with this engine.</p> </div> </dd> <dt>converters<span class=\"classifier\">:dict, default None</span>\n</dt>\n<dd>\n<p>Dict of functions for converting values in certain columns. Keys can either be integers or column labels.</p> </dd> <dt>true_values<span class=\"classifier\">:list, default None</span>\n</dt>\n<dd>\n<p>Values to consider as <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>.</p> </dd> <dt>false_values<span class=\"classifier\">:list, default None</span>\n</dt>\n<dd>\n<p>Values to consider as <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>.</p> </dd> <dt>skipinitialspace<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>Skip spaces after delimiter.</p> </dd> <dt>skiprows<span class=\"classifier\">:list-like or integer, default None</span>\n</dt>\n<dd>\n<p>Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file.</p> <p>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [10]: data = \"col1,col2,col3\\na,b,1\\na,b,2\\nc,d,3\"\n\nIn [11]: pd.read_csv(StringIO(data))\nOut[11]: \n  col1 col2  col3\n0    a    b     1\n1    a    b     2\n2    c    d     3\n\nIn [12]: pd.read_csv(StringIO(data), skiprows=lambda x: x % 2 != 0)\nOut[12]: \n  col1 col2  col3\n0    a    b     2\n</pre></div> </div> </dd> <dt>skipfooter<span class=\"classifier\">:int, default 0</span>\n</dt>\n<dd>\n<p>Number of lines at bottom of file to skip (unsupported with engine=’c’).</p> </dd> <dt>nrows<span class=\"classifier\">:int, default None</span>\n</dt>\n<dd>\n<p>Number of rows of file to read. Useful for reading pieces of large files.</p> </dd> <dt>low_memory<span class=\"classifier\">:boolean, default True</span>\n</dt>\n<dd>\n<p>Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, or specify the type with the <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> parameter. Note that the entire file is read into a single <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> regardless, use the <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">iterator</span></code> parameter to return the data in chunks. (Only valid with C parser)</p> </dd> <dt>memory_map<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>If a filepath is provided for <code class=\"docutils literal notranslate\"><span class=\"pre\">filepath_or_buffer</span></code>, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</p> </dd> </dl> </section> <section id=\"na-and-missing-data-handling\"> <h4>NA and missing data handling</h4> <dl> <dt>na_values<span class=\"classifier\">:scalar, str, list-like, or dict, default None</span>\n</dt>\n<dd>\n<p>Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See <a class=\"reference internal\" href=\"#io-navaluesconst\"><span class=\"std std-ref\">na values const</span></a> below for a list of the values interpreted as NaN by default.</p> </dd> <dt>keep_default_na<span class=\"classifier\">:boolean, default True</span>\n</dt>\n<dd>\n<p>Whether or not to include the default NaN values when parsing the data. Depending on whether <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> is passed in, the behavior is as follows:</p> <ul class=\"simple\"> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">keep_default_na</span></code> is <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> are specified, <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> is appended to the default NaN values used for parsing.</p></li> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">keep_default_na</span></code> is <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> are not specified, only the default NaN values are used for parsing.</p></li> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">keep_default_na</span></code> is <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> are specified, only the NaN values specified <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> are used for parsing.</p></li> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">keep_default_na</span></code> is <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> are not specified, no strings will be parsed as NaN.</p></li> </ul> <p>Note that if <code class=\"docutils literal notranslate\"><span class=\"pre\">na_filter</span></code> is passed in as <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, the <code class=\"docutils literal notranslate\"><span class=\"pre\">keep_default_na</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code> parameters will be ignored.</p> </dd> <dt>na_filter<span class=\"classifier\">:boolean, default True</span>\n</dt>\n<dd>\n<p>Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing <code class=\"docutils literal notranslate\"><span class=\"pre\">na_filter=False</span></code> can improve the performance of reading a large file.</p> </dd> <dt>verbose<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>Indicate number of NA values placed in non-numeric columns.</p> </dd> <dt>skip_blank_lines<span class=\"classifier\">:boolean, default True</span>\n</dt>\n<dd>\n<p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, skip over blank lines rather than interpreting as NaN values.</p> </dd> </dl> </section> <section id=\"datetime-handling\"> <h4>Datetime handling</h4> <dl> <dt>parse_dates<span class=\"classifier\">:boolean or list of ints or names or list of lists or dict, default False.</span>\n</dt>\n<dd>\n<ul class=\"simple\"> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> -&gt; try parsing the index.</p></li> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">[1,</span> <span class=\"pre\">2,</span> <span class=\"pre\">3]</span></code> -&gt; try parsing columns 1, 2, 3 each as a separate date column.</p></li> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">[[1,</span> <span class=\"pre\">3]]</span></code> -&gt; combine columns 1 and 3 and parse as a single date column.</p></li> <li><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">{'foo':</span> <span class=\"pre\">[1,</span> <span class=\"pre\">3]}</span></code> -&gt; parse columns 1, 3 as date and call result ‘foo’. A fast-path exists for iso8601-formatted dates.</p></li> </ul> </dd> <dt>infer_datetime_format<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing.</p> </dd> <dt>keep_date_col<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> and parse_dates specifies combining multiple columns then keep the original columns.</p> </dd> <dt>date_parser<span class=\"classifier\">:function, default None</span>\n</dt>\n<dd>\n<p>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses <code class=\"docutils literal notranslate\"><span class=\"pre\">dateutil.parser.parser</span></code> to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments.</p> </dd> <dt>dayfirst<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>DD/MM format dates, international and European format.</p> </dd> <dt>cache_dates<span class=\"classifier\">:boolean, default True</span>\n</dt>\n<dd>\n<p>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.</p> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 0.25.0.</span></p> </div> </dd> </dl> </section> <section id=\"iteration\"> <h4>Iteration</h4> <dl> <dt>iterator<span class=\"classifier\">:boolean, default False</span>\n</dt>\n<dd>\n<p>Return <code class=\"docutils literal notranslate\"><span class=\"pre\">TextFileReader</span></code> object for iteration or getting chunks with <code class=\"docutils literal notranslate\"><span class=\"pre\">get_chunk()</span></code>.</p> </dd> <dt>chunksize<span class=\"classifier\">:int, default None</span>\n</dt>\n<dd>\n<p>Return <code class=\"docutils literal notranslate\"><span class=\"pre\">TextFileReader</span></code> object for iteration. See <a class=\"reference internal\" href=\"#io-chunking\"><span class=\"std std-ref\">iterating and chunking</span></a> below.</p> </dd> </dl> </section> <section id=\"quoting-compression-and-file-format\"> <h4>Quoting, compression, and file format</h4> <dl> <dt>compression<span class=\"classifier\">:{'infer', 'gzip', 'bz2', 'zip', 'xz', 'zstd', None, dict}, default 'infer'</span>\n</dt>\n<dd>\n<p>For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, xz, or zstandard if <code class=\"docutils literal notranslate\"><span class=\"pre\">filepath_or_buffer</span></code> is path-like ending in ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> for no decompression. Can also be a dict with key <code class=\"docutils literal notranslate\"><span class=\"pre\">'method'</span></code> set to one of {<code class=\"docutils literal notranslate\"><span class=\"pre\">'zip'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'gzip'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'bz2'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'zstd'</span></code>} and other key-value pairs are forwarded to <code class=\"docutils literal notranslate\"><span class=\"pre\">zipfile.ZipFile</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">gzip.GzipFile</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">bz2.BZ2File</span></code>, or <code class=\"docutils literal notranslate\"><span class=\"pre\">zstandard.ZstdDecompressor</span></code>. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: <code class=\"docutils literal notranslate\"><span class=\"pre\">compression={'method':</span> <span class=\"pre\">'gzip',</span> <span class=\"pre\">'compresslevel':</span> <span class=\"pre\">1,</span> <span class=\"pre\">'mtime':</span> <span class=\"pre\">1}</span></code>.</p> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 1.1.0: </span>dict option extended to support <code class=\"docutils literal notranslate\"><span class=\"pre\">gzip</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">bz2</span></code>.</p> </div> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 1.2.0: </span>Previous versions forwarded dict entries for ‘gzip’ to <code class=\"docutils literal notranslate\"><span class=\"pre\">gzip.open</span></code>.</p> </div> </dd> <dt>thousands<span class=\"classifier\">:str, default None</span>\n</dt>\n<dd>\n<p>Thousands separator.</p> </dd> <dt>decimal<span class=\"classifier\">:str, default '.'</span>\n</dt>\n<dd>\n<p>Character to recognize as decimal point. E.g. use <code class=\"docutils literal notranslate\"><span class=\"pre\">','</span></code> for European data.</p> </dd> <dt>float_precision<span class=\"classifier\">:string, default None</span>\n</dt>\n<dd>\n<p>Specifies which converter the C engine should use for floating-point values. The options are <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> for the ordinary converter, <code class=\"docutils literal notranslate\"><span class=\"pre\">high</span></code> for the high-precision converter, and <code class=\"docutils literal notranslate\"><span class=\"pre\">round_trip</span></code> for the round-trip converter.</p> </dd> <dt>lineterminator<span class=\"classifier\">:str (length 1), default None</span>\n</dt>\n<dd>\n<p>Character to break file into lines. Only valid with C parser.</p> </dd> <dt>quotechar<span class=\"classifier\">:str (length 1)</span>\n</dt>\n<dd>\n<p>The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored.</p> </dd> <dt>quoting<span class=\"classifier\">:int or csv.QUOTE_* instance, default 0</span>\n</dt>\n<dd>\n<p>Control field quoting behavior per <code class=\"docutils literal notranslate\"><span class=\"pre\">csv.QUOTE_*</span></code> constants. Use one of <code class=\"docutils literal notranslate\"><span class=\"pre\">QUOTE_MINIMAL</span></code> (0), <code class=\"docutils literal notranslate\"><span class=\"pre\">QUOTE_ALL</span></code> (1), <code class=\"docutils literal notranslate\"><span class=\"pre\">QUOTE_NONNUMERIC</span></code> (2) or <code class=\"docutils literal notranslate\"><span class=\"pre\">QUOTE_NONE</span></code> (3).</p> </dd> <dt>doublequote<span class=\"classifier\">:boolean, default True</span>\n</dt>\n<dd>\n<p>When <code class=\"docutils literal notranslate\"><span class=\"pre\">quotechar</span></code> is specified and <code class=\"docutils literal notranslate\"><span class=\"pre\">quoting</span></code> is not <code class=\"docutils literal notranslate\"><span class=\"pre\">QUOTE_NONE</span></code>, indicate whether or not to interpret two consecutive <code class=\"docutils literal notranslate\"><span class=\"pre\">quotechar</span></code> elements <strong>inside</strong> a field as a single <code class=\"docutils literal notranslate\"><span class=\"pre\">quotechar</span></code> element.</p> </dd> <dt>escapechar<span class=\"classifier\">:str (length 1), default None</span>\n</dt>\n<dd>\n<p>One-character string used to escape delimiter when quoting is <code class=\"docutils literal notranslate\"><span class=\"pre\">QUOTE_NONE</span></code>.</p> </dd> <dt>comment<span class=\"classifier\">:str, default None</span>\n</dt>\n<dd>\n<p>Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as <code class=\"docutils literal notranslate\"><span class=\"pre\">skip_blank_lines=True</span></code>), fully commented lines are ignored by the parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> but not by <code class=\"docutils literal notranslate\"><span class=\"pre\">skiprows</span></code>. For example, if <code class=\"docutils literal notranslate\"><span class=\"pre\">comment='#'</span></code>, parsing ‘#empty\\na,b,c\\n1,2,3’ with <code class=\"docutils literal notranslate\"><span class=\"pre\">header=0</span></code> will result in ‘a,b,c’ being treated as the header.</p> </dd> <dt>encoding<span class=\"classifier\">:str, default None</span>\n</dt>\n<dd>\n<p>Encoding to use for UTF when reading/writing (e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">'utf-8'</span></code>). <a class=\"reference external\" href=\"https://docs.python.org/3/library/codecs.html#standard-encodings\">List of Python standard encodings</a>.</p> </dd> <dt>dialect<span class=\"classifier\">:str or csv.Dialect instance, default None</span>\n</dt>\n<dd>\n<p>If provided, this parameter will override values (default or not) for the following parameters: <code class=\"docutils literal notranslate\"><span class=\"pre\">delimiter</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">doublequote</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">escapechar</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">skipinitialspace</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">quotechar</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">quoting</span></code>. If it is necessary to override values, a ParserWarning will be issued. See <a class=\"reference external\" href=\"https://docs.python.org/3/library/csv.html#csv.Dialect\" title=\"(in Python v3.10)\"><code class=\"docutils literal notranslate\"><span class=\"pre\">csv.Dialect</span></code></a> documentation for more details.</p> </dd> </dl> </section> <section id=\"error-handling\"> <h4>Error handling</h4> <dl> <dt>error_bad_lines<span class=\"classifier\">:boolean, optional, default None</span>\n</dt>\n<dd>\n<p>Lines with too many fields (e.g. a csv line with too many commas) will by default cause an exception to be raised, and no <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> will be returned. If <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, then these “bad lines” will dropped from the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> that is returned. See <a class=\"reference internal\" href=\"#io-bad-lines\"><span class=\"std std-ref\">bad lines</span></a> below.</p> <div class=\"deprecated\"> <p><span class=\"versionmodified deprecated\">Deprecated since version 1.3.0: </span>The <code class=\"docutils literal notranslate\"><span class=\"pre\">on_bad_lines</span></code> parameter should be used instead to specify behavior upon encountering a bad line instead.</p> </div> </dd> <dt>warn_bad_lines<span class=\"classifier\">:boolean, optional, default None</span>\n</dt>\n<dd>\n<p>If error_bad_lines is <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, and warn_bad_lines is <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, a warning for each “bad line” will be output.</p> <div class=\"deprecated\"> <p><span class=\"versionmodified deprecated\">Deprecated since version 1.3.0: </span>The <code class=\"docutils literal notranslate\"><span class=\"pre\">on_bad_lines</span></code> parameter should be used instead to specify behavior upon encountering a bad line instead.</p> </div> </dd> <dt>on_bad_lines<span class=\"classifier\">:(‘error’, ‘warn’, ‘skip’), default ‘error’</span>\n</dt>\n<dd>\n<p>Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>‘error’, raise an ParserError when a bad line is encountered.</p></li> <li><p>‘warn’, print a warning when a bad line is encountered and skip that line.</p></li> <li><p>‘skip’, skip bad lines without raising or warning when they are encountered.</p></li> </ul> </div>\n</blockquote> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.3.0.</span></p> </div> </dd> </dl> </section> </section> <section id=\"specifying-column-data-types\"> <h3>Specifying column data types</h3> <p>You can indicate the data type for the whole <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> or individual columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [13]: import numpy as np\n\nIn [14]: data = \"a,b,c,d\\n1,2,3,4\\n5,6,7,8\\n9,10,11\"\n\nIn [15]: print(data)\na,b,c,d\n1,2,3,4\n5,6,7,8\n9,10,11\n\nIn [16]: df = pd.read_csv(StringIO(data), dtype=object)\n\nIn [17]: df\nOut[17]: \n   a   b   c    d\n0  1   2   3    4\n1  5   6   7    8\n2  9  10  11  NaN\n\nIn [18]: df[\"a\"][0]\nOut[18]: '1'\n\nIn [19]: df = pd.read_csv(StringIO(data), dtype={\"b\": object, \"c\": np.float64, \"d\": \"Int64\"})\n\nIn [20]: df.dtypes\nOut[20]: \na      int64\nb     object\nc    float64\nd      Int64\ndtype: object\n</pre></div> </div> <p>Fortunately, pandas offers more than one way to ensure that your column(s) contain only one <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code>. If you’re unfamiliar with these concepts, you can see <a class=\"reference internal\" href=\"basics#basics-dtypes\"><span class=\"std std-ref\">here</span></a> to learn more about dtypes, and <a class=\"reference internal\" href=\"basics#basics-object-conversion\"><span class=\"std std-ref\">here</span></a> to learn more about <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> conversion in pandas.</p> <p>For instance, you can use the <code class=\"docutils literal notranslate\"><span class=\"pre\">converters</span></code> argument of <a class=\"reference internal\" href=\"../reference/api/pandas.read_csv#pandas.read_csv\" title=\"pandas.read_csv\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_csv()</span></code></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [21]: data = \"col_1\\n1\\n2\\n'A'\\n4.22\"\n\nIn [22]: df = pd.read_csv(StringIO(data), converters={\"col_1\": str})\n\nIn [23]: df\nOut[23]: \n  col_1\n0     1\n1     2\n2   'A'\n3  4.22\n\nIn [24]: df[\"col_1\"].apply(type).value_counts()\nOut[24]: \n&lt;class 'str'&gt;    4\nName: col_1, dtype: int64\n</pre></div> </div> <p>Or you can use the <a class=\"reference internal\" href=\"../reference/api/pandas.to_numeric#pandas.to_numeric\" title=\"pandas.to_numeric\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_numeric()</span></code></a> function to coerce the dtypes after reading in the data,</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [25]: df2 = pd.read_csv(StringIO(data))\n\nIn [26]: df2[\"col_1\"] = pd.to_numeric(df2[\"col_1\"], errors=\"coerce\")\n\nIn [27]: df2\nOut[27]: \n   col_1\n0   1.00\n1   2.00\n2    NaN\n3   4.22\n\nIn [28]: df2[\"col_1\"].apply(type).value_counts()\nOut[28]: \n&lt;class 'float'&gt;    4\nName: col_1, dtype: int64\n</pre></div> </div> <p>which will convert all valid parsing to floats, leaving the invalid parsing as <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>.</p> <p>Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code> out the data anomalies, then <a class=\"reference internal\" href=\"../reference/api/pandas.to_numeric#pandas.to_numeric\" title=\"pandas.to_numeric\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_numeric()</span></code></a> is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the <code class=\"docutils literal notranslate\"><span class=\"pre\">converters</span></code> argument of <a class=\"reference internal\" href=\"../reference/api/pandas.read_csv#pandas.read_csv\" title=\"pandas.read_csv\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_csv()</span></code></a> would certainly be worth trying.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example,</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [29]: col_1 = list(range(500000)) + [\"a\", \"b\"] + list(range(500000))\n\nIn [30]: df = pd.DataFrame({\"col_1\": col_1})\n\nIn [31]: df.to_csv(\"foo.csv\")\n\nIn [32]: mixed_df = pd.read_csv(\"foo.csv\")\n\nIn [33]: mixed_df[\"col_1\"].apply(type).value_counts()\nOut[33]: \n&lt;class 'int'&gt;    737858\n&lt;class 'str'&gt;    262144\nName: col_1, dtype: int64\n\nIn [34]: mixed_df[\"col_1\"].dtype\nOut[34]: dtype('O')\n</pre></div> </div> <p>will result with <code class=\"docutils literal notranslate\"><span class=\"pre\">mixed_df</span></code> containing an <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> dtype for certain chunks of the column, and <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> of <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code>, which is used for columns with mixed dtypes.</p> </div> </section> <section id=\"specifying-categorical-dtype\"> <h3>Specifying categorical dtype</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> columns can be parsed directly by specifying <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype='category'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype=CategoricalDtype(categories,</span> <span class=\"pre\">ordered)</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [35]: data = \"col1,col2,col3\\na,b,1\\na,b,2\\nc,d,3\"\n\nIn [36]: pd.read_csv(StringIO(data))\nOut[36]: \n  col1 col2  col3\n0    a    b     1\n1    a    b     2\n2    c    d     3\n\nIn [37]: pd.read_csv(StringIO(data)).dtypes\nOut[37]: \ncol1    object\ncol2    object\ncol3     int64\ndtype: object\n\nIn [38]: pd.read_csv(StringIO(data), dtype=\"category\").dtypes\nOut[38]: \ncol1    category\ncol2    category\ncol3    category\ndtype: object\n</pre></div> </div> <p>Individual columns can be parsed as a <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> using a dict specification:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [39]: pd.read_csv(StringIO(data), dtype={\"col1\": \"category\"}).dtypes\nOut[39]: \ncol1    category\ncol2      object\ncol3       int64\ndtype: object\n</pre></div> </div> <p>Specifying <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype='category'</span></code> will result in an unordered <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> whose <code class=\"docutils literal notranslate\"><span class=\"pre\">categories</span></code> are the unique values observed in the data. For more control on the categories and order, create a <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CategoricalDtype</span></code> ahead of time, and pass that for that column’s <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [40]: from pandas.api.types import CategoricalDtype\n\nIn [41]: dtype = CategoricalDtype([\"d\", \"c\", \"b\", \"a\"], ordered=True)\n\nIn [42]: pd.read_csv(StringIO(data), dtype={\"col1\": dtype}).dtypes\nOut[42]: \ncol1    category\ncol2      object\ncol3       int64\ndtype: object\n</pre></div> </div> <p>When using <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype=CategoricalDtype</span></code>, “unexpected” values outside of <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype.categories</span></code> are treated as missing values.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [43]: dtype = CategoricalDtype([\"a\", \"b\", \"d\"])  # No 'c'\n\nIn [44]: pd.read_csv(StringIO(data), dtype={\"col1\": dtype}).col1\nOut[44]: \n0      a\n1      a\n2    NaN\nName: col1, dtype: category\nCategories (3, object): ['a', 'b', 'd']\n</pre></div> </div> <p>This matches the behavior of <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Categorical.set_categories()</span></code>.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype='category'</span></code>, the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the <a class=\"reference internal\" href=\"../reference/api/pandas.to_numeric#pandas.to_numeric\" title=\"pandas.to_numeric\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_numeric()</span></code></a> function, or as appropriate, another converter such as <a class=\"reference internal\" href=\"../reference/api/pandas.to_datetime#pandas.to_datetime\" title=\"pandas.to_datetime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_datetime()</span></code></a>.</p> <p>When <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> is a <code class=\"docutils literal notranslate\"><span class=\"pre\">CategoricalDtype</span></code> with homogeneous <code class=\"docutils literal notranslate\"><span class=\"pre\">categories</span></code> ( all numeric, all datetimes, etc.), the conversion is done automatically.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [45]: df = pd.read_csv(StringIO(data), dtype=\"category\")\n\nIn [46]: df.dtypes\nOut[46]: \ncol1    category\ncol2    category\ncol3    category\ndtype: object\n\nIn [47]: df[\"col3\"]\nOut[47]: \n0    1\n1    2\n2    3\nName: col3, dtype: category\nCategories (3, object): ['1', '2', '3']\n\nIn [48]: df[\"col3\"].cat.categories = pd.to_numeric(df[\"col3\"].cat.categories)\n\nIn [49]: df[\"col3\"]\nOut[49]: \n0    1\n1    2\n2    3\nName: col3, dtype: category\nCategories (3, int64): [1, 2, 3]\n</pre></div> </div> </div> </section> <section id=\"naming-and-using-columns\"> <h3>Naming and using columns</h3> <section id=\"handling-column-names\"> <h4>Handling column names</h4> <p>A file may or may not have a header row. pandas assumes the first row should be used as the column names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [50]: data = \"a,b,c\\n1,2,3\\n4,5,6\\n7,8,9\"\n\nIn [51]: print(data)\na,b,c\n1,2,3\n4,5,6\n7,8,9\n\nIn [52]: pd.read_csv(StringIO(data))\nOut[52]: \n   a  b  c\n0  1  2  3\n1  4  5  6\n2  7  8  9\n</pre></div> </div> <p>By specifying the <code class=\"docutils literal notranslate\"><span class=\"pre\">names</span></code> argument in conjunction with <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> you can indicate other names to use and whether or not to throw away the header row (if any):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [53]: print(data)\na,b,c\n1,2,3\n4,5,6\n7,8,9\n\nIn [54]: pd.read_csv(StringIO(data), names=[\"foo\", \"bar\", \"baz\"], header=0)\nOut[54]: \n   foo  bar  baz\n0    1    2    3\n1    4    5    6\n2    7    8    9\n\nIn [55]: pd.read_csv(StringIO(data), names=[\"foo\", \"bar\", \"baz\"], header=None)\nOut[55]: \n  foo bar baz\n0   a   b   c\n1   1   2   3\n2   4   5   6\n3   7   8   9\n</pre></div> </div> <p>If the header is in a row other than the first, pass the row number to <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code>. This will skip the preceding rows:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [56]: data = \"skip this skip it\\na,b,c\\n1,2,3\\n4,5,6\\n7,8,9\"\n\nIn [57]: pd.read_csv(StringIO(data), header=1)\nOut[57]: \n   a  b  c\n0  1  2  3\n1  4  5  6\n2  7  8  9\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Default behavior is to infer the column names: if no names are passed the behavior is identical to <code class=\"docutils literal notranslate\"><span class=\"pre\">header=0</span></code> and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to <code class=\"docutils literal notranslate\"><span class=\"pre\">header=None</span></code>.</p> </div> </section> </section> <section id=\"duplicate-names-parsing\"> <h3>Duplicate names parsing</h3> <p>If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [58]: data = \"a,b,a\\n0,1,2\\n3,4,5\"\n\nIn [59]: pd.read_csv(StringIO(data))\nOut[59]: \n   a  b  a.1\n0  0  1    2\n1  3  4    5\n</pre></div> </div> <p>There is no more duplicate data because <code class=\"docutils literal notranslate\"><span class=\"pre\">mangle_dupe_cols=True</span></code> by default, which modifies a series of duplicate columns ‘X’, …, ‘X’ to become ‘X’, ‘X.1’, …, ‘X.N’. If <code class=\"docutils literal notranslate\"><span class=\"pre\">mangle_dupe_cols=False</span></code>, duplicate data can arise:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [2]: data = 'a,b,a\\n0,1,2\\n3,4,5'\nIn [3]: pd.read_csv(StringIO(data), mangle_dupe_cols=False)\nOut[3]:\n   a  b  a\n0  2  1  2\n1  5  4  5\n</pre></div> </div> <p>To prevent users from encountering this problem with duplicate data, a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code> exception is raised if <code class=\"docutils literal notranslate\"><span class=\"pre\">mangle_dupe_cols</span> <span class=\"pre\">!=</span> <span class=\"pre\">True</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [2]: data = 'a,b,a\\n0,1,2\\n3,4,5'\nIn [3]: pd.read_csv(StringIO(data), mangle_dupe_cols=False)\n...\nValueError: Setting mangle_dupe_cols=False is not supported yet\n</pre></div> </div> <section id=\"filtering-columns-usecols\"> <h4>Filtering columns (<code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code>)</h4> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [60]: data = \"a,b,c,d\\n1,2,3,foo\\n4,5,6,bar\\n7,8,9,baz\"\n\nIn [61]: pd.read_csv(StringIO(data))\nOut[61]: \n   a  b  c    d\n0  1  2  3  foo\n1  4  5  6  bar\n2  7  8  9  baz\n\nIn [62]: pd.read_csv(StringIO(data), usecols=[\"b\", \"d\"])\nOut[62]: \n   b    d\n0  2  foo\n1  5  bar\n2  8  baz\n\nIn [63]: pd.read_csv(StringIO(data), usecols=[0, 2, 3])\nOut[63]: \n   a  c    d\n0  1  3  foo\n1  4  6  bar\n2  7  9  baz\n\nIn [64]: pd.read_csv(StringIO(data), usecols=lambda x: x.upper() in [\"A\", \"C\"])\nOut[64]: \n   a  c\n0  1  3\n1  4  6\n2  7  9\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> argument can also be used to specify which columns not to use in the final result:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [65]: pd.read_csv(StringIO(data), usecols=lambda x: x not in [\"a\", \"c\"])\nOut[65]: \n   b    d\n0  2  foo\n1  5  bar\n2  8  baz\n</pre></div> </div> <p>In this case, the callable is specifying that we exclude the “a” and “c” columns from the output.</p> </section> </section> <section id=\"comments-and-empty-lines\"> <h3>Comments and empty lines</h3> <section id=\"ignoring-line-comments-and-empty-lines\"> <h4>Ignoring line comments and empty lines</h4> <p>If the <code class=\"docutils literal notranslate\"><span class=\"pre\">comment</span></code> parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [66]: data = \"\\na,b,c\\n  \\n# commented line\\n1,2,3\\n\\n4,5,6\"\n\nIn [67]: print(data)\n\na,b,c\n  \n# commented line\n1,2,3\n\n4,5,6\n\nIn [68]: pd.read_csv(StringIO(data), comment=\"#\")\nOut[68]: \n   a  b  c\n0  1  2  3\n1  4  5  6\n</pre></div> </div> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">skip_blank_lines=False</span></code>, then <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> will not ignore blank lines:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [69]: data = \"a,b,c\\n\\n1,2,3\\n\\n\\n4,5,6\"\n\nIn [70]: pd.read_csv(StringIO(data), skip_blank_lines=False)\nOut[70]: \n     a    b    c\n0  NaN  NaN  NaN\n1  1.0  2.0  3.0\n2  NaN  NaN  NaN\n3  NaN  NaN  NaN\n4  4.0  5.0  6.0\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>The presence of ignored lines might create ambiguities involving line numbers; the parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> uses row numbers (ignoring commented/empty lines), while <code class=\"docutils literal notranslate\"><span class=\"pre\">skiprows</span></code> uses line numbers (including commented/empty lines):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [71]: data = \"#comment\\na,b,c\\nA,B,C\\n1,2,3\"\n\nIn [72]: pd.read_csv(StringIO(data), comment=\"#\", header=1)\nOut[72]: \n   A  B  C\n0  1  2  3\n\nIn [73]: data = \"A,B,C\\n#comment\\na,b,c\\n1,2,3\"\n\nIn [74]: pd.read_csv(StringIO(data), comment=\"#\", skiprows=2)\nOut[74]: \n   a  b  c\n0  1  2  3\n</pre></div> </div> <p>If both <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">skiprows</span></code> are specified, <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> will be relative to the end of <code class=\"docutils literal notranslate\"><span class=\"pre\">skiprows</span></code>. For example:</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [75]: data = (\n   ....:     \"# empty\\n\"\n   ....:     \"# second empty line\\n\"\n   ....:     \"# third emptyline\\n\"\n   ....:     \"X,Y,Z\\n\"\n   ....:     \"1,2,3\\n\"\n   ....:     \"A,B,C\\n\"\n   ....:     \"1,2.,4.\\n\"\n   ....:     \"5.,NaN,10.0\\n\"\n   ....: )\n   ....: \n\nIn [76]: print(data)\n# empty\n# second empty line\n# third emptyline\nX,Y,Z\n1,2,3\nA,B,C\n1,2.,4.\n5.,NaN,10.0\n\n\nIn [77]: pd.read_csv(StringIO(data), comment=\"#\", skiprows=4, header=1)\nOut[77]: \n     A    B     C\n0  1.0  2.0   4.0\n1  5.0  NaN  10.0\n</pre></div> </div> </section> <section id=\"comments\"> <h4>Comments</h4> <p>Sometimes comments or meta data may be included in a file:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [78]: print(open(\"tmp.csv\").read())\nID,level,category\nPatient1,123000,x # really unpleasant\nPatient2,23000,y # wouldn't take his medicine\nPatient3,1234018,z # awesome\n</pre></div> </div> <p>By default, the parser includes the comments in the output:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [79]: df = pd.read_csv(\"tmp.csv\")\n\nIn [80]: df\nOut[80]: \n         ID    level                        category\n0  Patient1   123000           x # really unpleasant\n1  Patient2    23000  y # wouldn't take his medicine\n2  Patient3  1234018                     z # awesome\n</pre></div> </div> <p>We can suppress the comments using the <code class=\"docutils literal notranslate\"><span class=\"pre\">comment</span></code> keyword:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [81]: df = pd.read_csv(\"tmp.csv\", comment=\"#\")\n\nIn [82]: df\nOut[82]: \n         ID    level category\n0  Patient1   123000       x \n1  Patient2    23000       y \n2  Patient3  1234018       z \n</pre></div> </div> </section> </section> <section id=\"dealing-with-unicode-data\"> <h3>Dealing with Unicode data</h3> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">encoding</span></code> argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [83]: from io import BytesIO\n\nIn [84]: data = b\"word,length\\n\" b\"Tr\\xc3\\xa4umen,7\\n\" b\"Gr\\xc3\\xbc\\xc3\\x9fe,5\"\n\nIn [85]: data = data.decode(\"utf8\").encode(\"latin-1\")\n\nIn [86]: df = pd.read_csv(BytesIO(data), encoding=\"latin-1\")\n\nIn [87]: df\nOut[87]: \n      word  length\n0  Träumen       7\n1    Grüße       5\n\nIn [88]: df[\"word\"][1]\nOut[88]: 'Grüße'\n</pre></div> </div> <p>Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding. <a class=\"reference external\" href=\"https://docs.python.org/3/library/codecs.html#standard-encodings\">Full list of Python standard encodings</a>.</p> </section> <section id=\"index-columns-and-trailing-delimiters\"> <h3>Index columns and trailing delimiters</h3> <p>If a file has one more column of data than the number of column names, the first column will be used as the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>’s row names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [89]: data = \"a,b,c\\n4,apple,bat,5.7\\n8,orange,cow,10\"\n\nIn [90]: pd.read_csv(StringIO(data))\nOut[90]: \n        a    b     c\n4   apple  bat   5.7\n8  orange  cow  10.0\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [91]: data = \"index,a,b,c\\n4,apple,bat,5.7\\n8,orange,cow,10\"\n\nIn [92]: pd.read_csv(StringIO(data), index_col=0)\nOut[92]: \n            a    b     c\nindex                   \n4       apple  bat   5.7\n8      orange  cow  10.0\n</pre></div> </div> <p>Ordinarily, you can achieve this behavior using the <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col</span></code> option.</p> <p>There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col=False</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [93]: data = \"a,b,c\\n4,apple,bat,\\n8,orange,cow,\"\n\nIn [94]: print(data)\na,b,c\n4,apple,bat,\n8,orange,cow,\n\nIn [95]: pd.read_csv(StringIO(data))\nOut[95]: \n        a    b   c\n4   apple  bat NaN\n8  orange  cow NaN\n\nIn [96]: pd.read_csv(StringIO(data), index_col=False)\nOut[96]: \n   a       b    c\n0  4   apple  bat\n1  8  orange  cow\n</pre></div> </div> <p>If a subset of data is being parsed using the <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> option, the <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col</span></code> specification is based on that subset, not the original data.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [97]: data = \"a,b,c\\n4,apple,bat,\\n8,orange,cow,\"\n\nIn [98]: print(data)\na,b,c\n4,apple,bat,\n8,orange,cow,\n\nIn [99]: pd.read_csv(StringIO(data), usecols=[\"b\", \"c\"])\nOut[99]: \n     b   c\n4  bat NaN\n8  cow NaN\n\nIn [100]: pd.read_csv(StringIO(data), usecols=[\"b\", \"c\"], index_col=0)\nOut[100]: \n     b   c\n4  bat NaN\n8  cow NaN\n</pre></div> </div> </section> <section id=\"date-handling\"> <h3>Date Handling</h3> <section id=\"specifying-date-columns\"> <h4>Specifying date columns</h4> <p>To better facilitate working with datetime data, <a class=\"reference internal\" href=\"../reference/api/pandas.read_csv#pandas.read_csv\" title=\"pandas.read_csv\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_csv()</span></code></a> uses the keyword arguments <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser</span></code> to allow users to specify a variety of columns and date/time formats to turn the input text data into <code class=\"docutils literal notranslate\"><span class=\"pre\">datetime</span></code> objects.</p> <p>The simplest case is to just pass in <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates=True</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Use a column as an index, and parse it as dates.\nIn [101]: df = pd.read_csv(\"foo.csv\", index_col=0, parse_dates=True)\n\nIn [102]: df\nOut[102]: \n            A  B  C\ndate               \n2009-01-01  a  1  2\n2009-01-02  b  3  4\n2009-01-03  c  4  5\n\n# These are Python datetime objects\nIn [103]: df.index\nOut[103]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', name='date', freq=None)\n</pre></div> </div> <p>It is often the case that we may want to store date and time data separately, or store various date fields separately. the <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates</span></code> keyword can be used to specify a combination of columns to parse the dates and/or times from.</p> <p>You can specify a list of column lists to <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates</span></code>, the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [104]: print(open(\"tmp.csv\").read())\nKORD,19990127, 19:00:00, 18:56:00, 0.8100\nKORD,19990127, 20:00:00, 19:56:00, 0.0100\nKORD,19990127, 21:00:00, 20:56:00, -0.5900\nKORD,19990127, 21:00:00, 21:18:00, -0.9900\nKORD,19990127, 22:00:00, 21:56:00, -0.5900\nKORD,19990127, 23:00:00, 22:56:00, -0.5900\n\nIn [105]: df = pd.read_csv(\"tmp.csv\", header=None, parse_dates=[[1, 2], [1, 3]])\n\nIn [106]: df\nOut[106]: \n                  1_2                 1_3     0     4\n0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81\n1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01\n2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59\n3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99\n4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59\n5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59\n</pre></div> </div> <p>By default the parser removes the component date columns, but you can choose to retain them via the <code class=\"docutils literal notranslate\"><span class=\"pre\">keep_date_col</span></code> keyword:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [107]: df = pd.read_csv(\n   .....:     \"tmp.csv\", header=None, parse_dates=[[1, 2], [1, 3]], keep_date_col=True\n   .....: )\n   .....: \n\nIn [108]: df\nOut[108]: \n                  1_2                 1_3     0         1          2          3     4\n0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  19990127   19:00:00   18:56:00  0.81\n1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  19990127   20:00:00   19:56:00  0.01\n2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD  19990127   21:00:00   20:56:00 -0.59\n3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD  19990127   21:00:00   21:18:00 -0.99\n4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD  19990127   22:00:00   21:56:00 -0.59\n5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD  19990127   23:00:00   22:56:00 -0.59\n</pre></div> </div> <p>Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates=[1,</span> <span class=\"pre\">2]</span></code> indicates that the second and third columns should each be parsed as separate date columns while <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates=[[1,</span> <span class=\"pre\">2]]</span></code> means the two columns should be parsed into a single column.</p> <p>You can also use a dict to specify custom name columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [109]: date_spec = {\"nominal\": [1, 2], \"actual\": [1, 3]}\n\nIn [110]: df = pd.read_csv(\"tmp.csv\", header=None, parse_dates=date_spec)\n\nIn [111]: df\nOut[111]: \n              nominal              actual     0     4\n0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81\n1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01\n2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59\n3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99\n4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59\n5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59\n</pre></div> </div> <p>It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col</span></code> specification is based off of this new set of columns rather than the original data columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [112]: date_spec = {\"nominal\": [1, 2], \"actual\": [1, 3]}\n\nIn [113]: df = pd.read_csv(\n   .....:     \"tmp.csv\", header=None, parse_dates=date_spec, index_col=0\n   .....: )  # index is the nominal column\n   .....: \n\nIn [114]: df\nOut[114]: \n                                 actual     0     4\nnominal                                            \n1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81\n1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01\n1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59\n1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99\n1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59\n1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use <a class=\"reference internal\" href=\"../reference/api/pandas.to_datetime#pandas.to_datetime\" title=\"pandas.to_datetime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_datetime()</span></code></a> after <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.read_csv</span></code>.</p> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed.</p> </div> </section> <section id=\"date-parsing-functions\"> <h4>Date parsing functions</h4> <p>Finally, the parser allows you to specify a custom <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser</span></code> function to take full advantage of the flexibility of the date parsing API:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [115]: df = pd.read_csv(\n   .....:     \"tmp.csv\", header=None, parse_dates=date_spec, date_parser=pd.to_datetime\n   .....: )\n   .....: \n\nIn [116]: df\nOut[116]: \n              nominal              actual     0     4\n0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81\n1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01\n2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59\n3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99\n4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59\n5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59\n</pre></div> </div> <p>pandas will try to call the <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser</span></code> function in three different ways. If an exception is raised, the next one is tried:</p> <ol class=\"arabic simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser</span></code> is first called with one or more arrays as arguments, as defined using <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates</span></code> (e.g., <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser(['2013',</span> <span class=\"pre\">'2013'],</span> <span class=\"pre\">['1',</span> <span class=\"pre\">'2'])</span></code>).</p></li> <li><p>If #1 fails, <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser</span></code> is called with all the columns concatenated row-wise into a single array (e.g., <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser(['2013</span> <span class=\"pre\">1',</span> <span class=\"pre\">'2013</span> <span class=\"pre\">2'])</span></code>).</p></li> </ol> <p>Note that performance-wise, you should try these methods of parsing dates in order:</p> <ol class=\"arabic simple\"> <li><p>Try to infer the format using <code class=\"docutils literal notranslate\"><span class=\"pre\">infer_datetime_format=True</span></code> (see section below).</p></li> <li><p>If you know the format, use <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.to_datetime()</span></code>: <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser=lambda</span> <span class=\"pre\">x:</span> <span class=\"pre\">pd.to_datetime(x,</span> <span class=\"pre\">format=...)</span></code>.</p></li> <li><p>If you have a really non-standard format, use a custom <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser</span></code> function. For optimal performance, this should be vectorized, i.e., it should accept arrays as arguments.</p></li> </ol> </section> <section id=\"parsing-a-csv-with-mixed-timezones\"> <h4>Parsing a CSV with mixed timezones</h4> <p>pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [117]: content = \"\"\"\\\n   .....: a\n   .....: 2000-01-01T00:00:00+05:00\n   .....: 2000-01-01T00:00:00+06:00\"\"\"\n   .....: \n\nIn [118]: df = pd.read_csv(StringIO(content), parse_dates=[\"a\"])\n\nIn [119]: df[\"a\"]\nOut[119]: \n0    2000-01-01 00:00:00+05:00\n1    2000-01-01 00:00:00+06:00\nName: a, dtype: object\n</pre></div> </div> <p>To parse the mixed-timezone values as a datetime column, pass a partially-applied <a class=\"reference internal\" href=\"../reference/api/pandas.to_datetime#pandas.to_datetime\" title=\"pandas.to_datetime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_datetime()</span></code></a> with <code class=\"docutils literal notranslate\"><span class=\"pre\">utc=True</span></code> as the <code class=\"docutils literal notranslate\"><span class=\"pre\">date_parser</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [120]: df = pd.read_csv(\n   .....:     StringIO(content),\n   .....:     parse_dates=[\"a\"],\n   .....:     date_parser=lambda col: pd.to_datetime(col, utc=True),\n   .....: )\n   .....: \n\nIn [121]: df[\"a\"]\nOut[121]: \n0   1999-12-31 19:00:00+00:00\n1   1999-12-31 18:00:00+00:00\nName: a, dtype: datetime64[ns, UTC]\n</pre></div> </div> </section> <section id=\"inferring-datetime-format\"> <h4>Inferring datetime format</h4> <p>If you have <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates</span></code> enabled for some or all of your columns, and your datetime strings are all formatted the same way, you may get a large speed up by setting <code class=\"docutils literal notranslate\"><span class=\"pre\">infer_datetime_format=True</span></code>. If set, pandas will attempt to guess the format of your datetime strings, and then use a faster means of parsing the strings. 5-10x parsing speeds have been observed. pandas will fallback to the usual parsing if either the format cannot be guessed or the format that was guessed cannot properly parse the entire column of strings. So in general, <code class=\"docutils literal notranslate\"><span class=\"pre\">infer_datetime_format</span></code> should not have any negative consequences if enabled.</p> <p>Here are some examples of datetime strings that can be guessed (All representing December 30th, 2011 at 00:00:00):</p> <ul class=\"simple\"> <li><p>“20111230”</p></li> <li><p>“2011/12/30”</p></li> <li><p>“20111230 00:00:00”</p></li> <li><p>“12/30/2011 00:00:00”</p></li> <li><p>“30/Dec/2011 00:00:00”</p></li> <li><p>“30/December/2011 00:00:00”</p></li> </ul> <p>Note that <code class=\"docutils literal notranslate\"><span class=\"pre\">infer_datetime_format</span></code> is sensitive to <code class=\"docutils literal notranslate\"><span class=\"pre\">dayfirst</span></code>. With <code class=\"docutils literal notranslate\"><span class=\"pre\">dayfirst=True</span></code>, it will guess “01/12/2011” to be December 1st. With <code class=\"docutils literal notranslate\"><span class=\"pre\">dayfirst=False</span></code> (default) it will guess “01/12/2011” to be January 12th.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Try to infer the format for the index column\nIn [122]: df = pd.read_csv(\n   .....:     \"foo.csv\",\n   .....:     index_col=0,\n   .....:     parse_dates=True,\n   .....:     infer_datetime_format=True,\n   .....: )\n   .....: \n\nIn [123]: df\nOut[123]: \n            A  B  C\ndate               \n2009-01-01  a  1  2\n2009-01-02  b  3  4\n2009-01-03  c  4  5\n</pre></div> </div> </section> <section id=\"international-date-formats\"> <h4>International date formats</h4> <p>While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a <code class=\"docutils literal notranslate\"><span class=\"pre\">dayfirst</span></code> keyword is provided:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [124]: print(open(\"tmp.csv\").read())\ndate,value,cat\n1/6/2000,5,a\n2/6/2000,10,b\n3/6/2000,15,c\n\nIn [125]: pd.read_csv(\"tmp.csv\", parse_dates=[0])\nOut[125]: \n        date  value cat\n0 2000-01-06      5   a\n1 2000-02-06     10   b\n2 2000-03-06     15   c\n\nIn [126]: pd.read_csv(\"tmp.csv\", dayfirst=True, parse_dates=[0])\nOut[126]: \n        date  value cat\n0 2000-06-01      5   a\n1 2000-06-02     10   b\n2 2000-06-03     15   c\n</pre></div> </div> </section> <section id=\"writing-csvs-to-binary-file-objects\"> <h4>Writing CSVs to binary file objects</h4> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.2.0.</span></p> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">df.to_csv(...,</span> <span class=\"pre\">mode=\"wb\")</span></code> allows writing a CSV to a file object opened binary mode. In most cases, it is not necessary to specify <code class=\"docutils literal notranslate\"><span class=\"pre\">mode</span></code> as Pandas will auto-detect whether the file object is opened in text or binary mode.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [127]: import io\n\nIn [128]: data = pd.DataFrame([0, 1, 2])\n\nIn [129]: buffer = io.BytesIO()\n\nIn [130]: data.to_csv(buffer, encoding=\"utf-8\", compression=\"gzip\")\n</pre></div> </div> </section> </section> <section id=\"specifying-method-for-floating-point-conversion\"> <h3>Specifying method for floating-point conversion</h3> <p>The parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">float_precision</span></code> can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [131]: val = \"0.3066101993807095471566981359501369297504425048828125\"\n\nIn [132]: data = \"a,b,c\\n1,2,{0}\".format(val)\n\nIn [133]: abs(\n   .....:     pd.read_csv(\n   .....:         StringIO(data),\n   .....:         engine=\"c\",\n   .....:         float_precision=None,\n   .....:     )[\"c\"][0] - float(val)\n   .....: )\n   .....: \nOut[133]: 5.551115123125783e-17\n\nIn [134]: abs(\n   .....:     pd.read_csv(\n   .....:         StringIO(data),\n   .....:         engine=\"c\",\n   .....:         float_precision=\"high\",\n   .....:     )[\"c\"][0] - float(val)\n   .....: )\n   .....: \nOut[134]: 5.551115123125783e-17\n\nIn [135]: abs(\n   .....:     pd.read_csv(StringIO(data), engine=\"c\", float_precision=\"round_trip\")[\"c\"][0]\n   .....:     - float(val)\n   .....: )\n   .....: \nOut[135]: 0.0\n</pre></div> </div> </section> <section id=\"thousand-separators\"> <h3>Thousand separators</h3> <p>For large numbers that have been written with a thousands separator, you can set the <code class=\"docutils literal notranslate\"><span class=\"pre\">thousands</span></code> keyword to a string of length 1 so that integers will be parsed correctly:</p> <p>By default, numbers with a thousands separator will be parsed as strings:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [136]: print(open(\"tmp.csv\").read())\nID|level|category\nPatient1|123,000|x\nPatient2|23,000|y\nPatient3|1,234,018|z\n\nIn [137]: df = pd.read_csv(\"tmp.csv\", sep=\"|\")\n\nIn [138]: df\nOut[138]: \n         ID      level category\n0  Patient1    123,000        x\n1  Patient2     23,000        y\n2  Patient3  1,234,018        z\n\nIn [139]: df.level.dtype\nOut[139]: dtype('O')\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">thousands</span></code> keyword allows integers to be parsed correctly:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [140]: print(open(\"tmp.csv\").read())\nID|level|category\nPatient1|123,000|x\nPatient2|23,000|y\nPatient3|1,234,018|z\n\nIn [141]: df = pd.read_csv(\"tmp.csv\", sep=\"|\", thousands=\",\")\n\nIn [142]: df\nOut[142]: \n         ID    level category\n0  Patient1   123000        x\n1  Patient2    23000        y\n2  Patient3  1234018        z\n\nIn [143]: df.level.dtype\nOut[143]: dtype('int64')\n</pre></div> </div> </section> <section id=\"na-values\"> <h3>NA values</h3> <p>To control which values are parsed as missing values (which are signified by <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>), specify a string in <code class=\"docutils literal notranslate\"><span class=\"pre\">na_values</span></code>. If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a <code class=\"docutils literal notranslate\"><span class=\"pre\">float</span></code>, like <code class=\"docutils literal notranslate\"><span class=\"pre\">5.0</span></code> or an <code class=\"docutils literal notranslate\"><span class=\"pre\">integer</span></code> like <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code>), the corresponding equivalent values will also imply a missing value (in this case effectively <code class=\"docutils literal notranslate\"><span class=\"pre\">[5.0,</span> <span class=\"pre\">5]</span></code> are recognized as <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>).</p> <p>To completely override the default values that are recognized as missing, specify <code class=\"docutils literal notranslate\"><span class=\"pre\">keep_default_na=False</span></code>.</p> <p id=\"io-navaluesconst\">The default <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code> recognized values are <code class=\"docutils literal notranslate\"><span class=\"pre\">['-1.#IND',</span> <span class=\"pre\">'1.#QNAN',</span> <span class=\"pre\">'1.#IND',</span> <span class=\"pre\">'-1.#QNAN',</span> <span class=\"pre\">'#N/A</span> <span class=\"pre\">N/A',</span> <span class=\"pre\">'#N/A',</span> <span class=\"pre\">'N/A',</span>\n<span class=\"pre\">'n/a',</span> <span class=\"pre\">'NA',</span> <span class=\"pre\">'&lt;NA&gt;',</span> <span class=\"pre\">'#NA',</span> <span class=\"pre\">'NULL',</span> <span class=\"pre\">'null',</span> <span class=\"pre\">'NaN',</span> <span class=\"pre\">'-NaN',</span> <span class=\"pre\">'nan',</span> <span class=\"pre\">'-nan',</span> <span class=\"pre\">'']</span></code>.</p> <p>Let us consider some examples:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_csv(\"path_to_file.csv\", na_values=[5])\n</pre></div> </div> <p>In the example above <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">5.0</span></code> will be recognized as <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>, in addition to the defaults. A string will first be interpreted as a numerical <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code>, then as a <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_csv(\"path_to_file.csv\", keep_default_na=False, na_values=[\"\"])\n</pre></div> </div> <p>Above, only an empty field will be recognized as <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_csv(\"path_to_file.csv\", keep_default_na=False, na_values=[\"NA\", \"0\"])\n</pre></div> </div> <p>Above, both <code class=\"docutils literal notranslate\"><span class=\"pre\">NA</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code> as strings are <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_csv(\"path_to_file.csv\", na_values=[\"Nope\"])\n</pre></div> </div> <p>The default values, in addition to the string <code class=\"docutils literal notranslate\"><span class=\"pre\">\"Nope\"</span></code> are recognized as <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>.</p> </section> <section id=\"infinity\"> <h3>Infinity</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">inf</span></code> like values will be parsed as <code class=\"docutils literal notranslate\"><span class=\"pre\">np.inf</span></code> (positive infinity), and <code class=\"docutils literal notranslate\"><span class=\"pre\">-inf</span></code> as <code class=\"docutils literal notranslate\"><span class=\"pre\">-np.inf</span></code> (negative infinity). These will ignore the case of the value, meaning <code class=\"docutils literal notranslate\"><span class=\"pre\">Inf</span></code>, will also be parsed as <code class=\"docutils literal notranslate\"><span class=\"pre\">np.inf</span></code>.</p> </section> <section id=\"returning-series\"> <h3>Returning Series</h3> <p>Using the <code class=\"docutils literal notranslate\"><span class=\"pre\">squeeze</span></code> keyword, the parser will return output with a single column as a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>:</p> <div class=\"deprecated\"> <p><span class=\"versionmodified deprecated\">Deprecated since version 1.4.0: </span>Users should append <code class=\"docutils literal notranslate\"><span class=\"pre\">.squeeze(\"columns\")</span></code> to the DataFrame returned by <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> instead.</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [144]: print(open(\"tmp.csv\").read())\nlevel\nPatient1,123000\nPatient2,23000\nPatient3,1234018\n\nIn [145]: output = pd.read_csv(\"tmp.csv\", squeeze=True)\n\nIn [146]: output\nOut[146]: \nPatient1     123000\nPatient2      23000\nPatient3    1234018\nName: level, dtype: int64\n\nIn [147]: type(output)\nOut[147]: pandas.core.series.Series\n</pre></div> </div> </section> <section id=\"boolean-values\"> <h3>Boolean values</h3> <p>The common values <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">TRUE</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">FALSE</span></code> are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the <code class=\"docutils literal notranslate\"><span class=\"pre\">true_values</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">false_values</span></code> options as follows:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [148]: data = \"a,b,c\\n1,Yes,2\\n3,No,4\"\n\nIn [149]: print(data)\na,b,c\n1,Yes,2\n3,No,4\n\nIn [150]: pd.read_csv(StringIO(data))\nOut[150]: \n   a    b  c\n0  1  Yes  2\n1  3   No  4\n\nIn [151]: pd.read_csv(StringIO(data), true_values=[\"Yes\"], false_values=[\"No\"])\nOut[151]: \n   a      b  c\n0  1   True  2\n1  3  False  4\n</pre></div> </div> </section> <section id=\"handling-bad-lines\"> <h3>Handling “bad” lines</h3> <p>Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [152]: data = \"a,b,c\\n1,2,3\\n4,5,6,7\\n8,9,10\"\n\nIn [153]: pd.read_csv(StringIO(data))\n---------------------------------------------------------------------------\nParserError                               Traceback (most recent call last)\nInput In [153], in &lt;module&gt;\n----&gt; 1 pd.read_csv(StringIO(data))\n\nFile /pandas/pandas/util/_decorators.py:311, in deprecate_nonkeyword_arguments.&lt;locals&gt;.decorate.&lt;locals&gt;.wrapper(*args, **kwargs)\n    305 if len(args) &gt; num_allow_args:\n    306     warnings.warn(\n    307         msg.format(arguments=arguments),\n    308         FutureWarning,\n    309         stacklevel=stacklevel,\n    310     )\n--&gt; 311 return func(*args, **kwargs)\n\nFile /pandas/pandas/io/parsers/readers.py:680, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, error_bad_lines, warn_bad_lines, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options)\n    665 kwds_defaults = _refine_defaults_read(\n    666     dialect,\n    667     delimiter,\n   (...)\n    676     defaults={\"delimiter\": \",\"},\n    677 )\n    678 kwds.update(kwds_defaults)\n--&gt; 680 return _read(filepath_or_buffer, kwds)\n\nFile /pandas/pandas/io/parsers/readers.py:581, in _read(filepath_or_buffer, kwds)\n    578     return parser\n    580 with parser:\n--&gt; 581     return parser.read(nrows)\n\nFile /pandas/pandas/io/parsers/readers.py:1250, in TextFileReader.read(self, nrows)\n   1248 nrows = validate_integer(\"nrows\", nrows)\n   1249 try:\n-&gt; 1250     index, columns, col_dict = self._engine.read(nrows)\n   1251 except Exception:\n   1252     self.close()\n\nFile /pandas/pandas/io/parsers/c_parser_wrapper.py:225, in CParserWrapper.read(self, nrows)\n    223 try:\n    224     if self.low_memory:\n--&gt; 225         chunks = self._reader.read_low_memory(nrows)\n    226         # destructive to chunks\n    227         data = _concatenate_chunks(chunks)\n\nFile /pandas/pandas/_libs/parsers.pyx:805, in pandas._libs.parsers.TextReader.read_low_memory()\n\nFile /pandas/pandas/_libs/parsers.pyx:861, in pandas._libs.parsers.TextReader._read_rows()\n\nFile /pandas/pandas/_libs/parsers.pyx:847, in pandas._libs.parsers.TextReader._tokenize_rows()\n\nFile /pandas/pandas/_libs/parsers.pyx:1960, in pandas._libs.parsers.raise_parser_error()\n\nParserError: Error tokenizing data. C error: Expected 3 fields in line 3, saw 4\n</pre></div> </div> <p>You can elect to skip bad lines:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [29]: pd.read_csv(StringIO(data), on_bad_lines=\"warn\")\nSkipping line 3: expected 3 fields, saw 4\n\nOut[29]:\n   a  b   c\n0  1  2   3\n1  8  9  10\n</pre></div> </div> <p>Or pass a callable function to handle the bad line if <code class=\"docutils literal notranslate\"><span class=\"pre\">engine=\"python\"</span></code>. The bad line will be a list of strings that was split by the <code class=\"docutils literal notranslate\"><span class=\"pre\">sep</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [29]: external_list = []\n\nIn [30]: def bad_lines_func(line):\n    ...:     external_list.append(line)\n    ...:     return line[-3:]\n\nIn [31]: pd.read_csv(StringIO(data), on_bad_lines=bad_lines_func, engine=\"python\")\nOut[31]:\n   a  b   c\n0  1  2   3\n1  5  6   7\n2  8  9  10\n\nIn [32]: external_list\nOut[32]: [4, 5, 6, 7]\n\n.. versionadded:: 1.4.0\n</pre></div> </div> <p>You can also use the <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> parameter to eliminate extraneous column data that appear in some lines but not others:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [33]: pd.read_csv(StringIO(data), usecols=[0, 1, 2])\n\n Out[33]:\n    a  b   c\n 0  1  2   3\n 1  4  5   6\n 2  8  9  10\n</pre></div> </div> <p>In case you want to keep all data including the lines with too many fields, you can specify a sufficient number of <code class=\"docutils literal notranslate\"><span class=\"pre\">names</span></code>. This ensures that lines with not enough fields are filled with <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [34]: pd.read_csv(StringIO(data), names=['a', 'b', 'c', 'd'])\n\nOut[34]:\n    a  b   c  d\n 0  1  2   3  NaN\n 1  4  5   6  7\n 2  8  9  10  NaN\n</pre></div> </div> </section> <section id=\"dialect\"> <h3>Dialect</h3> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">dialect</span></code> keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a <a class=\"reference external\" href=\"https://docs.python.org/3/library/csv.html#csv.Dialect\" title=\"(in Python v3.10)\"><code class=\"docutils literal notranslate\"><span class=\"pre\">csv.Dialect</span></code></a> instance.</p> <p>Suppose you had data with unenclosed quotes:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [154]: print(data)\nlabel1,label2,label3\nindex1,\"a,c,e\nindex2,b,d,f\n</pre></div> </div> <p>By default, <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote.</p> <p>We can get around this using <code class=\"docutils literal notranslate\"><span class=\"pre\">dialect</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [155]: import csv\n\nIn [156]: dia = csv.excel()\n\nIn [157]: dia.quoting = csv.QUOTE_NONE\n\nIn [158]: pd.read_csv(StringIO(data), dialect=dia)\nOut[158]: \n       label1 label2 label3\nindex1     \"a      c      e\nindex2      b      d      f\n</pre></div> </div> <p>All of the dialect options can be specified separately by keyword arguments:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [159]: data = \"a,b,c~1,2,3~4,5,6\"\n\nIn [160]: pd.read_csv(StringIO(data), lineterminator=\"~\")\nOut[160]: \n   a  b  c\n0  1  2  3\n1  4  5  6\n</pre></div> </div> <p>Another common dialect option is <code class=\"docutils literal notranslate\"><span class=\"pre\">skipinitialspace</span></code>, to skip any whitespace after a delimiter:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [161]: data = \"a, b, c\\n1, 2, 3\\n4, 5, 6\"\n\nIn [162]: print(data)\na, b, c\n1, 2, 3\n4, 5, 6\n\nIn [163]: pd.read_csv(StringIO(data), skipinitialspace=True)\nOut[163]: \n   a  b  c\n0  1  2  3\n1  4  5  6\n</pre></div> </div> <p>The parsers make every attempt to “do the right thing” and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects.</p> </section> <section id=\"quoting-and-escape-characters\"> <h3>Quoting and Escape Characters</h3> <p>Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the <code class=\"docutils literal notranslate\"><span class=\"pre\">escapechar</span></code> option:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [164]: data = 'a,b\\n\"hello, \\\\\"Bob\\\\\", nice to see you\",5'\n\nIn [165]: print(data)\na,b\n\"hello, \\\"Bob\\\", nice to see you\",5\n\nIn [166]: pd.read_csv(StringIO(data), escapechar=\"\\\\\")\nOut[166]: \n                               a  b\n0  hello, \"Bob\", nice to see you  5\n</pre></div> </div> </section> <section id=\"files-with-fixed-width-columns\"> <h3>Files with fixed width columns</h3> <p>While <a class=\"reference internal\" href=\"../reference/api/pandas.read_csv#pandas.read_csv\" title=\"pandas.read_csv\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_csv()</span></code></a> reads delimited data, the <a class=\"reference internal\" href=\"../reference/api/pandas.read_fwf#pandas.read_fwf\" title=\"pandas.read_fwf\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_fwf()</span></code></a> function works with data files that have known and fixed column widths. The function parameters to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_fwf</span></code> are largely the same as <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> with two extra parameters, and a different usage of the <code class=\"docutils literal notranslate\"><span class=\"pre\">delimiter</span></code> parameter:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">colspecs</span></code>: A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">widths</span></code>: A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">delimiter</span></code>: Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., ‘~’).</p></li> </ul> <p>Consider a typical fixed-width data file:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [167]: print(open(\"bar.csv\").read())\nid8141    360.242940   149.910199   11950.7\nid1594    444.953632   166.985655   11788.4\nid1849    364.136849   183.628767   11806.2\nid1230    413.836124   184.375703   11916.8\nid1948    502.953953   173.237159   12468.3\n</pre></div> </div> <p>In order to parse this file into a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>, we simply need to supply the column specifications to the <code class=\"docutils literal notranslate\"><span class=\"pre\">read_fwf</span></code> function along with the file name:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Column specifications are a list of half-intervals\nIn [168]: colspecs = [(0, 6), (8, 20), (21, 33), (34, 43)]\n\nIn [169]: df = pd.read_fwf(\"bar.csv\", colspecs=colspecs, header=None, index_col=0)\n\nIn [170]: df\nOut[170]: \n                 1           2        3\n0                                      \nid8141  360.242940  149.910199  11950.7\nid1594  444.953632  166.985655  11788.4\nid1849  364.136849  183.628767  11806.2\nid1230  413.836124  184.375703  11916.8\nid1948  502.953953  173.237159  12468.3\n</pre></div> </div> <p>Note how the parser automatically picks column names X.&lt;column number&gt; when <code class=\"docutils literal notranslate\"><span class=\"pre\">header=None</span></code> argument is specified. Alternatively, you can supply just the column widths for contiguous columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Widths are a list of integers\nIn [171]: widths = [6, 14, 13, 10]\n\nIn [172]: df = pd.read_fwf(\"bar.csv\", widths=widths, header=None)\n\nIn [173]: df\nOut[173]: \n        0           1           2        3\n0  id8141  360.242940  149.910199  11950.7\n1  id1594  444.953632  166.985655  11788.4\n2  id1849  364.136849  183.628767  11806.2\n3  id1230  413.836124  184.375703  11916.8\n4  id1948  502.953953  173.237159  12468.3\n</pre></div> </div> <p>The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file.</p> <p>By default, <code class=\"docutils literal notranslate\"><span class=\"pre\">read_fwf</span></code> will try to infer the file’s <code class=\"docutils literal notranslate\"><span class=\"pre\">colspecs</span></code> by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided <code class=\"docutils literal notranslate\"><span class=\"pre\">delimiter</span></code> (default delimiter is whitespace).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [174]: df = pd.read_fwf(\"bar.csv\", header=None, index_col=0)\n\nIn [175]: df\nOut[175]: \n                 1           2        3\n0                                      \nid8141  360.242940  149.910199  11950.7\nid1594  444.953632  166.985655  11788.4\nid1849  364.136849  183.628767  11806.2\nid1230  413.836124  184.375703  11916.8\nid1948  502.953953  173.237159  12468.3\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">read_fwf</span></code> supports the <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> parameter for specifying the types of parsed columns to be different from the inferred type.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [176]: pd.read_fwf(\"bar.csv\", header=None, index_col=0).dtypes\nOut[176]: \n1    float64\n2    float64\n3    float64\ndtype: object\n\nIn [177]: pd.read_fwf(\"bar.csv\", header=None, dtype={2: \"object\"}).dtypes\nOut[177]: \n0     object\n1    float64\n2     object\n3    float64\ndtype: object\n</pre></div> </div> </section> <section id=\"indexes\"> <h3>Indexes</h3> <section id=\"files-with-an-implicit-index-column\"> <h4>Files with an “implicit” index column</h4> <p>Consider a file with one less entry in the header than the number of data column:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [178]: print(open(\"foo.csv\").read())\nA,B,C\n20090101,a,1,2\n20090102,b,3,4\n20090103,c,4,5\n</pre></div> </div> <p>In this special case, <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> assumes that the first column is to be used as the index of the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [179]: pd.read_csv(\"foo.csv\")\nOut[179]: \n          A  B  C\n20090101  a  1  2\n20090102  b  3  4\n20090103  c  4  5\n</pre></div> </div> <p>Note that the dates weren’t automatically parsed. In that case you would need to do as before:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [180]: df = pd.read_csv(\"foo.csv\", parse_dates=True)\n\nIn [181]: df.index\nOut[181]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', freq=None)\n</pre></div> </div> </section> <section id=\"reading-an-index-with-a-multiindex\"> <h4>Reading an index with a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code>\n</h4> <p id=\"io-csv-multiindex\">Suppose you have data indexed by two columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [182]: print(open(\"data/mindex_ex.csv\").read())\nyear,indiv,zit,xit\n1977,\"A\",1.2,.6\n1977,\"B\",1.5,.5\n1977,\"C\",1.7,.8\n1978,\"A\",.2,.06\n1978,\"B\",.7,.2\n1978,\"C\",.8,.3\n1978,\"D\",.9,.5\n1978,\"E\",1.4,.9\n1979,\"C\",.2,.15\n1979,\"D\",.14,.05\n1979,\"E\",.5,.15\n1979,\"F\",1.2,.5\n1979,\"G\",3.4,1.9\n1979,\"H\",5.4,2.7\n1979,\"I\",6.4,1.2\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col</span></code> argument to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> can take a list of column numbers to turn multiple columns into a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> for the index of the returned object:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [183]: df = pd.read_csv(\"data/mindex_ex.csv\", index_col=[0, 1])\n\nIn [184]: df\nOut[184]: \n             zit   xit\nyear indiv            \n1977 A      1.20  0.60\n     B      1.50  0.50\n     C      1.70  0.80\n1978 A      0.20  0.06\n     B      0.70  0.20\n     C      0.80  0.30\n     D      0.90  0.50\n     E      1.40  0.90\n1979 C      0.20  0.15\n     D      0.14  0.05\n     E      0.50  0.15\n     F      1.20  0.50\n     G      3.40  1.90\n     H      5.40  2.70\n     I      6.40  1.20\n\nIn [185]: df.loc[1978]\nOut[185]: \n       zit   xit\nindiv           \nA      0.2  0.06\nB      0.7  0.20\nC      0.8  0.30\nD      0.9  0.50\nE      1.4  0.90\n</pre></div> </div> </section> <section id=\"reading-columns-with-a-multiindex\"> <h4>Reading columns with a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code>\n</h4> <p>By specifying list of row locations for the <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> argument, you can read in a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> for the columns. Specifying non-consecutive rows will skip the intervening rows.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [186]: from pandas._testing import makeCustomDataframe as mkdf\n\nIn [187]: df = mkdf(5, 3, r_idx_nlevels=2, c_idx_nlevels=4)\n\nIn [188]: df.to_csv(\"mi.csv\")\n\nIn [189]: print(open(\"mi.csv\").read())\nC0,,C_l0_g0,C_l0_g1,C_l0_g2\nC1,,C_l1_g0,C_l1_g1,C_l1_g2\nC2,,C_l2_g0,C_l2_g1,C_l2_g2\nC3,,C_l3_g0,C_l3_g1,C_l3_g2\nR0,R1,,,\nR_l0_g0,R_l1_g0,R0C0,R0C1,R0C2\nR_l0_g1,R_l1_g1,R1C0,R1C1,R1C2\nR_l0_g2,R_l1_g2,R2C0,R2C1,R2C2\nR_l0_g3,R_l1_g3,R3C0,R3C1,R3C2\nR_l0_g4,R_l1_g4,R4C0,R4C1,R4C2\n\n\nIn [190]: pd.read_csv(\"mi.csv\", header=[0, 1, 2, 3], index_col=[0, 1])\nOut[190]: \nC0              C_l0_g0 C_l0_g1 C_l0_g2\nC1              C_l1_g0 C_l1_g1 C_l1_g2\nC2              C_l2_g0 C_l2_g1 C_l2_g2\nC3              C_l3_g0 C_l3_g1 C_l3_g2\nR0      R1                             \nR_l0_g0 R_l1_g0    R0C0    R0C1    R0C2\nR_l0_g1 R_l1_g1    R1C0    R1C1    R1C2\nR_l0_g2 R_l1_g2    R2C0    R2C1    R2C2\nR_l0_g3 R_l1_g3    R3C0    R3C1    R3C2\nR_l0_g4 R_l1_g4    R4C0    R4C1    R4C2\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> is also able to interpret a more common format of multi-columns indices.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [191]: print(open(\"mi2.csv\").read())\n,a,a,a,b,c,c\n,q,r,s,t,u,v\none,1,2,3,4,5,6\ntwo,7,8,9,10,11,12\n\nIn [192]: pd.read_csv(\"mi2.csv\", header=[0, 1], index_col=0)\nOut[192]: \n     a         b   c    \n     q  r  s   t   u   v\none  1  2  3   4   5   6\ntwo  7  8  9  10  11  12\n</pre></div> </div> <p>Note: If an <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col</span></code> is not specified (e.g. you don’t have an index, or wrote it with <code class=\"docutils literal notranslate\"><span class=\"pre\">df.to_csv(...,</span> <span class=\"pre\">index=False)</span></code>, then any <code class=\"docutils literal notranslate\"><span class=\"pre\">names</span></code> on the columns index will be <em>lost</em>.</p> </section> </section> <section id=\"automatically-sniffing-the-delimiter\"> <h3>Automatically “sniffing” the delimiter</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the <a class=\"reference external\" href=\"https://docs.python.org/3/library/csv.html#csv.Sniffer\" title=\"(in Python v3.10)\"><code class=\"docutils literal notranslate\"><span class=\"pre\">csv.Sniffer</span></code></a> class of the csv module. For this, you have to specify <code class=\"docutils literal notranslate\"><span class=\"pre\">sep=None</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [193]: print(open(\"tmp2.sv\").read())\n:0:1:2:3\n0:0.4691122999071863:-0.2828633443286633:-1.5090585031735124:-1.1356323710171934\n1:1.2121120250208506:-0.17321464905330858:0.11920871129693428:-1.0442359662799567\n2:-0.8618489633477999:-2.1045692188948086:-0.4949292740687813:1.071803807037338\n3:0.7215551622443669:-0.7067711336300845:-1.0395749851146963:0.27185988554282986\n4:-0.42497232978883753:0.567020349793672:0.27623201927771873:-1.0874006912859915\n5:-0.6736897080883706:0.1136484096888855:-1.4784265524372235:0.5249876671147047\n6:0.4047052186802365:0.5770459859204836:-1.7150020161146375:-1.0392684835147725\n7:-0.3706468582364464:-1.1578922506419993:-1.344311812731667:0.8448851414248841\n8:1.0757697837155533:-0.10904997528022223:1.6435630703622064:-1.4693879595399115\n9:0.35702056413309086:-0.6746001037299882:-1.776903716971867:-0.9689138124473498\n\n\nIn [194]: pd.read_csv(\"tmp2.sv\", sep=None, engine=\"python\")\nOut[194]: \n   Unnamed: 0         0         1         2         3\n0           0  0.469112 -0.282863 -1.509059 -1.135632\n1           1  1.212112 -0.173215  0.119209 -1.044236\n2           2 -0.861849 -2.104569 -0.494929  1.071804\n3           3  0.721555 -0.706771 -1.039575  0.271860\n4           4 -0.424972  0.567020  0.276232 -1.087401\n5           5 -0.673690  0.113648 -1.478427  0.524988\n6           6  0.404705  0.577046 -1.715002 -1.039268\n7           7 -0.370647 -1.157892 -1.344312  0.844885\n8           8  1.075770 -0.109050  1.643563 -1.469388\n9           9  0.357021 -0.674600 -1.776904 -0.968914\n</pre></div> </div> </section> <section id=\"reading-multiple-files-to-create-a-single-dataframe\"> <h3>Reading multiple files to create a single DataFrame</h3> <p>It’s best to use <a class=\"reference internal\" href=\"../reference/api/pandas.concat#pandas.concat\" title=\"pandas.concat\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">concat()</span></code></a> to combine multiple files. See the <a class=\"reference internal\" href=\"cookbook#cookbook-csv-multiple-files\"><span class=\"std std-ref\">cookbook</span></a> for an example.</p> </section> <section id=\"iterating-through-files-chunk-by-chunk\"> <h3>Iterating through files chunk by chunk</h3> <p>Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [195]: print(open(\"tmp.sv\").read())\n|0|1|2|3\n0|0.4691122999071863|-0.2828633443286633|-1.5090585031735124|-1.1356323710171934\n1|1.2121120250208506|-0.17321464905330858|0.11920871129693428|-1.0442359662799567\n2|-0.8618489633477999|-2.1045692188948086|-0.4949292740687813|1.071803807037338\n3|0.7215551622443669|-0.7067711336300845|-1.0395749851146963|0.27185988554282986\n4|-0.42497232978883753|0.567020349793672|0.27623201927771873|-1.0874006912859915\n5|-0.6736897080883706|0.1136484096888855|-1.4784265524372235|0.5249876671147047\n6|0.4047052186802365|0.5770459859204836|-1.7150020161146375|-1.0392684835147725\n7|-0.3706468582364464|-1.1578922506419993|-1.344311812731667|0.8448851414248841\n8|1.0757697837155533|-0.10904997528022223|1.6435630703622064|-1.4693879595399115\n9|0.35702056413309086|-0.6746001037299882|-1.776903716971867|-0.9689138124473498\n\n\nIn [196]: table = pd.read_csv(\"tmp.sv\", sep=\"|\")\n\nIn [197]: table\nOut[197]: \n   Unnamed: 0         0         1         2         3\n0           0  0.469112 -0.282863 -1.509059 -1.135632\n1           1  1.212112 -0.173215  0.119209 -1.044236\n2           2 -0.861849 -2.104569 -0.494929  1.071804\n3           3  0.721555 -0.706771 -1.039575  0.271860\n4           4 -0.424972  0.567020  0.276232 -1.087401\n5           5 -0.673690  0.113648 -1.478427  0.524988\n6           6  0.404705  0.577046 -1.715002 -1.039268\n7           7 -0.370647 -1.157892 -1.344312  0.844885\n8           8  1.075770 -0.109050  1.643563 -1.469388\n9           9  0.357021 -0.674600 -1.776904 -0.968914\n</pre></div> </div> <p>By specifying a <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code>, the return value will be an iterable object of type <code class=\"docutils literal notranslate\"><span class=\"pre\">TextFileReader</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [198]: with pd.read_csv(\"tmp.sv\", sep=\"|\", chunksize=4) as reader:\n   .....:     reader\n   .....:     for chunk in reader:\n   .....:         print(chunk)\n   .....: \n   Unnamed: 0         0         1         2         3\n0           0  0.469112 -0.282863 -1.509059 -1.135632\n1           1  1.212112 -0.173215  0.119209 -1.044236\n2           2 -0.861849 -2.104569 -0.494929  1.071804\n3           3  0.721555 -0.706771 -1.039575  0.271860\n   Unnamed: 0         0         1         2         3\n4           4 -0.424972  0.567020  0.276232 -1.087401\n5           5 -0.673690  0.113648 -1.478427  0.524988\n6           6  0.404705  0.577046 -1.715002 -1.039268\n7           7 -0.370647 -1.157892 -1.344312  0.844885\n   Unnamed: 0         0        1         2         3\n8           8  1.075770 -0.10905  1.643563 -1.469388\n9           9  0.357021 -0.67460 -1.776904 -0.968914\n</pre></div> </div> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 1.2: </span><code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv/json/sas</span></code> return a context-manager when iterating through a file.</p> </div> <p>Specifying <code class=\"docutils literal notranslate\"><span class=\"pre\">iterator=True</span></code> will also return the <code class=\"docutils literal notranslate\"><span class=\"pre\">TextFileReader</span></code> object:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [199]: with pd.read_csv(\"tmp.sv\", sep=\"|\", iterator=True) as reader:\n   .....:     reader.get_chunk(5)\n   .....: \n</pre></div> </div> </section> <section id=\"specifying-the-parser-engine\"> <h3>Specifying the parser engine</h3> <p>Pandas currently supports three engines, the C engine, the python engine, and an experimental pyarrow engine (requires the <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> package). In general, the pyarrow engine is fastest on larger workloads and is equivalent in speed to the C engine on most other workloads. The python engine tends to be slower than the pyarrow and C engines on most workloads. However, the pyarrow engine is much less robust than the C engine, which lacks a few features compared to the Python engine.</p> <p>Where possible, pandas uses the C parser (specified as <code class=\"docutils literal notranslate\"><span class=\"pre\">engine='c'</span></code>), but it may fall back to Python if C-unsupported options are specified.</p> <p>Currently, options unsupported by the C and pyarrow engines include:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">sep</span></code> other than a single character (e.g. regex separators)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">skipfooter</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">sep=None</span></code> with <code class=\"docutils literal notranslate\"><span class=\"pre\">delim_whitespace=False</span></code></p></li> </ul> <p>Specifying any of the above options will produce a <code class=\"docutils literal notranslate\"><span class=\"pre\">ParserWarning</span></code> unless the python engine is selected explicitly using <code class=\"docutils literal notranslate\"><span class=\"pre\">engine='python'</span></code>.</p> <p>Options that are unsupported by the pyarrow engine which are not covered by the list above include:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">float_precision</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">comment</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">nrows</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">thousands</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">memory_map</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">dialect</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">warn_bad_lines</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">error_bad_lines</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">on_bad_lines</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">delim_whitespace</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">quoting</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">lineterminator</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">converters</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">decimal</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">iterator</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">dayfirst</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">infer_datetime_format</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">verbose</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">skipinitialspace</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">low_memory</span></code></p></li> </ul> <p>Specifying these options with <code class=\"docutils literal notranslate\"><span class=\"pre\">engine='pyarrow'</span></code> will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code>.</p> </section> <section id=\"reading-writing-remote-files\"> <h3>Reading/writing remote files</h3> <p>You can pass in a URL to read or write remote files to many of pandas’ IO functions - the following example shows reading a CSV file:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df = pd.read_csv(\"https://download.bls.gov/pub/time.series/cu/cu.item\", sep=\"\\t\")\n</pre></div> </div> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.3.0.</span></p> </div> <p>A custom header can be sent alongside HTTP(s) requests by passing a dictionary of header key value mappings to the <code class=\"docutils literal notranslate\"><span class=\"pre\">storage_options</span></code> keyword argument as shown below:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">headers = {\"User-Agent\": \"pandas\"}\ndf = pd.read_csv(\n    \"https://download.bls.gov/pub/time.series/cu/cu.item\",\n    sep=\"\\t\",\n    storage_options=headers\n)\n</pre></div> </div> <p>All URLs which are not local files or HTTP(s) are handled by <a class=\"reference external\" href=\"https://filesystem-spec.readthedocs.io/en/latest/\">fsspec</a>, if installed, and its various filesystem implementations (including Amazon S3, Google Cloud, SSH, FTP, webHDFS…). Some of these implementations will require additional packages to be installed, for example S3 URLs require the <a class=\"reference external\" href=\"https://pypi.org/project/s3fs/\">s3fs</a> library:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df = pd.read_json(\"s3://pandas-test/adatafile.json\")\n</pre></div> </div> <p>When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the <a class=\"reference external\" href=\"https://s3fs.readthedocs.io/en/latest/#credentials\">S3Fs documentation</a>. The same is true for several of the storage backends, and you should follow the links at <a class=\"reference external\" href=\"https://filesystem-spec.readthedocs.io/en/latest/api.html#built-in-implementations\">fsimpl1</a> for implementations built into <code class=\"docutils literal notranslate\"><span class=\"pre\">fsspec</span></code> and <a class=\"reference external\" href=\"https://filesystem-spec.readthedocs.io/en/latest/api.html#other-known-implementations\">fsimpl2</a> for those not included in the main <code class=\"docutils literal notranslate\"><span class=\"pre\">fsspec</span></code> distribution.</p> <p>You can also pass parameters directly to the backend driver. For example, if you do <em>not</em> have S3 credentials, you can still access public data by specifying an anonymous connection, such as</p> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.2.0.</span></p> </div> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_csv(\n    \"s3://ncei-wcsd-archive/data/processed/SH1305/18kHz/SaKe2013\"\n    \"-D20130523-T080854_to_SaKe2013-D20130523-T085643.csv\",\n    storage_options={\"anon\": True},\n)\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">fsspec</span></code> also allows complex URLs, for accessing data in compressed archives, local caching of files, and more. To locally cache the above example, you would modify the call to</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_csv(\n    \"simplecache::s3://ncei-wcsd-archive/data/processed/SH1305/18kHz/\"\n    \"SaKe2013-D20130523-T080854_to_SaKe2013-D20130523-T085643.csv\",\n    storage_options={\"s3\": {\"anon\": True}},\n)\n</pre></div> </div> <p>where we specify that the “anon” parameter is meant for the “s3” part of the implementation, not to the caching implementation. Note that this caches to a temporary directory for the duration of the session only, but you can also specify a permanent store.</p> </section> <section id=\"writing-out-data\"> <h3>Writing out data</h3> <section id=\"writing-to-csv-format\"> <h4>Writing to CSV format</h4> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> objects have an instance method <code class=\"docutils literal notranslate\"><span class=\"pre\">to_csv</span></code> which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">path_or_buf</span></code>: A string path to the file to write or a file object. If a file object it must be opened with <code class=\"docutils literal notranslate\"><span class=\"pre\">newline=''</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">sep</span></code> : Field delimiter for the output file (default “,”)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">na_rep</span></code>: A string representation of a missing value (default ‘’)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">float_format</span></code>: Format string for floating point numbers</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code>: Columns to write (default None)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code>: Whether to write out the column names (default True)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>: whether to write row (index) names (default True)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">index_label</span></code>: Column label(s) for index column(s) if desired. If None (default), and <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> are True, then the index names are used. (A sequence should be given if the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> uses MultiIndex).</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">mode</span></code> : Python write mode, default ‘w’</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">encoding</span></code>: a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">line_terminator</span></code>: Character sequence denoting line end (default <code class=\"docutils literal notranslate\"><span class=\"pre\">os.linesep</span></code>)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">quoting</span></code>: Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a <code class=\"docutils literal notranslate\"><span class=\"pre\">float_format</span></code> then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">quotechar</span></code>: Character used to quote fields (default ‘”’)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">doublequote</span></code>: Control quoting of <code class=\"docutils literal notranslate\"><span class=\"pre\">quotechar</span></code> in fields (default True)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">escapechar</span></code>: Character used to escape <code class=\"docutils literal notranslate\"><span class=\"pre\">sep</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">quotechar</span></code> when appropriate (default None)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code>: Number of rows to write at a time</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">date_format</span></code>: Format string for datetime objects</p></li> </ul> </section> <section id=\"writing-a-formatted-string\"> <h4>Writing a formatted string</h4> <p id=\"io-formatting\">The <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> object has an instance method <code class=\"docutils literal notranslate\"><span class=\"pre\">to_string</span></code> which allows control over the string representation of the object. All arguments are optional:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">buf</span></code> default None, for example a StringIO object</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> default None, which columns to write</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">col_space</span></code> default None, minimum width of each column.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">na_rep</span></code> default <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>, representation of NA value</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">formatters</span></code> default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">float_format</span></code> default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">sparsify</span></code> default True, set to False for a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> with a hierarchical index to print every MultiIndex key at each row.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">index_names</span></code> default True, will print the names of the indices</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> default True, will print the index (ie, row labels)</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code> default True, will print the column labels</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">justify</span></code> default <code class=\"docutils literal notranslate\"><span class=\"pre\">left</span></code>, will print column headers left- or right-justified</p></li> </ul> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> object also has a <code class=\"docutils literal notranslate\"><span class=\"pre\">to_string</span></code> method, but with only the <code class=\"docutils literal notranslate\"><span class=\"pre\">buf</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">na_rep</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">float_format</span></code> arguments. There is also a <code class=\"docutils literal notranslate\"><span class=\"pre\">length</span></code> argument which, if set to <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, will additionally output the length of the Series.</p> </section> </section> </section> <section id=\"json\"> <h2>JSON</h2> <p>Read and write <code class=\"docutils literal notranslate\"><span class=\"pre\">JSON</span></code> format files and strings.</p> <section id=\"writing-json\"> <h3>Writing JSON</h3> <p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> can be converted to a valid JSON string. Use <code class=\"docutils literal notranslate\"><span class=\"pre\">to_json</span></code> with optional parameters:</p> <ul> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">path_or_buf</span></code> : the pathname or buffer to write the output This can be <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> in which case a JSON string is returned</p></li> <li>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">orient</span></code> :</p> <dl class=\"simple\"> <dt>\n<code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>:</dt>\n<dd>\n<ul class=\"simple\"> <li><p>default is <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code></p></li> <li><p>allowed values are {<code class=\"docutils literal notranslate\"><span class=\"pre\">split</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>}</p></li> </ul> </dd> <dt>\n<code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>:</dt>\n<dd>\n<ul class=\"simple\"> <li><p>default is <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code></p></li> <li><p>allowed values are {<code class=\"docutils literal notranslate\"><span class=\"pre\">split</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">values</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code>}</p></li> </ul> </dd> </dl> <p>The format of the JSON string</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 12%\"> <col style=\"width: 88%\"> </colgroup> <tbody> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">split</span></code></p></td> <td><p>dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code></p></td> <td><p>list like [{column -&gt; value}, … , {column -&gt; value}]</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code></p></td> <td><p>dict like {index -&gt; {column -&gt; value}}</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code></p></td> <td><p>dict like {column -&gt; {index -&gt; value}}</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">values</span></code></p></td> <td><p>just the values array</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code></p></td> <td><p>adhering to the JSON <a class=\"reference external\" href=\"https://specs.frictionlessdata.io/table-schema/\">Table Schema</a></p></td> </tr> </tbody> </table> </li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">date_format</span></code> : string, type of date conversion, ‘epoch’ for timestamp, ‘iso’ for ISO8601.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">double_precision</span></code> : The number of decimal places to use when encoding floating point values, default 10.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">force_ascii</span></code> : force encoded string to be ASCII, default True.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">date_unit</span></code> : The time unit to encode to, governs timestamp and ISO8601 precision. One of ‘s’, ‘ms’, ‘us’ or ‘ns’ for seconds, milliseconds, microseconds and nanoseconds respectively. Default ‘ms’.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">default_handler</span></code> : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">lines</span></code> : If <code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code> orient, then will write each record per line as json.</p></li> </ul> <p>Note <code class=\"docutils literal notranslate\"><span class=\"pre\">NaN</span></code>’s, <code class=\"docutils literal notranslate\"><span class=\"pre\">NaT</span></code>’s and <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> will be converted to <code class=\"docutils literal notranslate\"><span class=\"pre\">null</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">datetime</span></code> objects will be converted based on the <code class=\"docutils literal notranslate\"><span class=\"pre\">date_format</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">date_unit</span></code> parameters.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [200]: dfj = pd.DataFrame(np.random.randn(5, 2), columns=list(\"AB\"))\n\nIn [201]: json = dfj.to_json()\n\nIn [202]: json\nOut[202]: '{\"A\":{\"0\":-1.2945235903,\"1\":0.2766617129,\"2\":-0.0139597524,\"3\":-0.0061535699,\"4\":0.8957173022},\"B\":{\"0\":0.4137381054,\"1\":-0.472034511,\"2\":-0.3625429925,\"3\":-0.923060654,\"4\":0.8052440254}}'\n</pre></div> </div> <section id=\"orient-options\"> <h4>Orient options</h4> <p>There are a number of different options for the format of the resulting JSON file / string. Consider the following <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [203]: dfjo = pd.DataFrame(\n   .....:     dict(A=range(1, 4), B=range(4, 7), C=range(7, 10)),\n   .....:     columns=list(\"ABC\"),\n   .....:     index=list(\"xyz\"),\n   .....: )\n   .....: \n\nIn [204]: dfjo\nOut[204]: \n   A  B  C\nx  1  4  7\ny  2  5  8\nz  3  6  9\n\nIn [205]: sjo = pd.Series(dict(x=15, y=16, z=17), name=\"D\")\n\nIn [206]: sjo\nOut[206]: \nx    15\ny    16\nz    17\nName: D, dtype: int64\n</pre></div> </div> <p><strong>Column oriented</strong> (the default for <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>) serializes the data as nested JSON objects with column labels acting as the primary index:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [207]: dfjo.to_json(orient=\"columns\")\nOut[207]: '{\"A\":{\"x\":1,\"y\":2,\"z\":3},\"B\":{\"x\":4,\"y\":5,\"z\":6},\"C\":{\"x\":7,\"y\":8,\"z\":9}}'\n\n# Not available for Series\n</pre></div> </div> <p><strong>Index oriented</strong> (the default for <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>) similar to column oriented but the index labels are now primary:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [208]: dfjo.to_json(orient=\"index\")\nOut[208]: '{\"x\":{\"A\":1,\"B\":4,\"C\":7},\"y\":{\"A\":2,\"B\":5,\"C\":8},\"z\":{\"A\":3,\"B\":6,\"C\":9}}'\n\nIn [209]: sjo.to_json(orient=\"index\")\nOut[209]: '{\"x\":15,\"y\":16,\"z\":17}'\n</pre></div> </div> <p><strong>Record oriented</strong> serializes the data to a JSON array of column -&gt; value records, index labels are not included. This is useful for passing <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> data to plotting libraries, for example the JavaScript library <code class=\"docutils literal notranslate\"><span class=\"pre\">d3.js</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [210]: dfjo.to_json(orient=\"records\")\nOut[210]: '[{\"A\":1,\"B\":4,\"C\":7},{\"A\":2,\"B\":5,\"C\":8},{\"A\":3,\"B\":6,\"C\":9}]'\n\nIn [211]: sjo.to_json(orient=\"records\")\nOut[211]: '[15,16,17]'\n</pre></div> </div> <p><strong>Value oriented</strong> is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [212]: dfjo.to_json(orient=\"values\")\nOut[212]: '[[1,4,7],[2,5,8],[3,6,9]]'\n\n# Not available for Series\n</pre></div> </div> <p><strong>Split oriented</strong> serializes to a JSON object containing separate entries for values, index and columns. Name is also included for <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [213]: dfjo.to_json(orient=\"split\")\nOut[213]: '{\"columns\":[\"A\",\"B\",\"C\"],\"index\":[\"x\",\"y\",\"z\"],\"data\":[[1,4,7],[2,5,8],[3,6,9]]}'\n\nIn [214]: sjo.to_json(orient=\"split\")\nOut[214]: '{\"name\":\"D\",\"index\":[\"x\",\"y\",\"z\"],\"data\":[15,16,17]}'\n</pre></div> </div> <p><strong>Table oriented</strong> serializes to the JSON <a class=\"reference external\" href=\"https://specs.frictionlessdata.io/table-schema/\">Table Schema</a>, allowing for the preservation of metadata including but not limited to dtypes and index names.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the <code class=\"docutils literal notranslate\"><span class=\"pre\">split</span></code> option as it uses ordered containers.</p> </div> </section> <section id=\"id1\"> <h4>Date handling</h4> <p>Writing in ISO date format:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [215]: dfd = pd.DataFrame(np.random.randn(5, 2), columns=list(\"AB\"))\n\nIn [216]: dfd[\"date\"] = pd.Timestamp(\"20130101\")\n\nIn [217]: dfd = dfd.sort_index(axis=1, ascending=False)\n\nIn [218]: json = dfd.to_json(date_format=\"iso\")\n\nIn [219]: json\nOut[219]: '{\"date\":{\"0\":\"2013-01-01T00:00:00.000Z\",\"1\":\"2013-01-01T00:00:00.000Z\",\"2\":\"2013-01-01T00:00:00.000Z\",\"3\":\"2013-01-01T00:00:00.000Z\",\"4\":\"2013-01-01T00:00:00.000Z\"},\"B\":{\"0\":2.5656459463,\"1\":1.3403088498,\"2\":-0.2261692849,\"3\":0.8138502857,\"4\":-0.8273169356},\"A\":{\"0\":-1.2064117817,\"1\":1.4312559863,\"2\":-1.1702987971,\"3\":0.4108345112,\"4\":0.1320031703}}'\n</pre></div> </div> <p>Writing in ISO date format, with microseconds:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [220]: json = dfd.to_json(date_format=\"iso\", date_unit=\"us\")\n\nIn [221]: json\nOut[221]: '{\"date\":{\"0\":\"2013-01-01T00:00:00.000000Z\",\"1\":\"2013-01-01T00:00:00.000000Z\",\"2\":\"2013-01-01T00:00:00.000000Z\",\"3\":\"2013-01-01T00:00:00.000000Z\",\"4\":\"2013-01-01T00:00:00.000000Z\"},\"B\":{\"0\":2.5656459463,\"1\":1.3403088498,\"2\":-0.2261692849,\"3\":0.8138502857,\"4\":-0.8273169356},\"A\":{\"0\":-1.2064117817,\"1\":1.4312559863,\"2\":-1.1702987971,\"3\":0.4108345112,\"4\":0.1320031703}}'\n</pre></div> </div> <p>Epoch timestamps, in seconds:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [222]: json = dfd.to_json(date_format=\"epoch\", date_unit=\"s\")\n\nIn [223]: json\nOut[223]: '{\"date\":{\"0\":1356998400,\"1\":1356998400,\"2\":1356998400,\"3\":1356998400,\"4\":1356998400},\"B\":{\"0\":2.5656459463,\"1\":1.3403088498,\"2\":-0.2261692849,\"3\":0.8138502857,\"4\":-0.8273169356},\"A\":{\"0\":-1.2064117817,\"1\":1.4312559863,\"2\":-1.1702987971,\"3\":0.4108345112,\"4\":0.1320031703}}'\n</pre></div> </div> <p>Writing to a file, with a date index and a date column:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [224]: dfj2 = dfj.copy()\n\nIn [225]: dfj2[\"date\"] = pd.Timestamp(\"20130101\")\n\nIn [226]: dfj2[\"ints\"] = list(range(5))\n\nIn [227]: dfj2[\"bools\"] = True\n\nIn [228]: dfj2.index = pd.date_range(\"20130101\", periods=5)\n\nIn [229]: dfj2.to_json(\"test.json\")\n\nIn [230]: with open(\"test.json\") as fh:\n   .....:     print(fh.read())\n   .....: \n{\"A\":{\"1356998400000\":-1.2945235903,\"1357084800000\":0.2766617129,\"1357171200000\":-0.0139597524,\"1357257600000\":-0.0061535699,\"1357344000000\":0.8957173022},\"B\":{\"1356998400000\":0.4137381054,\"1357084800000\":-0.472034511,\"1357171200000\":-0.3625429925,\"1357257600000\":-0.923060654,\"1357344000000\":0.8052440254},\"date\":{\"1356998400000\":1356998400000,\"1357084800000\":1356998400000,\"1357171200000\":1356998400000,\"1357257600000\":1356998400000,\"1357344000000\":1356998400000},\"ints\":{\"1356998400000\":0,\"1357084800000\":1,\"1357171200000\":2,\"1357257600000\":3,\"1357344000000\":4},\"bools\":{\"1356998400000\":true,\"1357084800000\":true,\"1357171200000\":true,\"1357257600000\":true,\"1357344000000\":true}}\n</pre></div> </div> </section> <section id=\"fallback-behavior\"> <h4>Fallback behavior</h4> <p>If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:</p> <ul> <li><p>if the dtype is unsupported (e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">np.complex_</span></code>) then the <code class=\"docutils literal notranslate\"><span class=\"pre\">default_handler</span></code>, if provided, will be called for each value, otherwise an exception is raised.</p></li> <li>\n<p>if an object is unsupported it will attempt the following:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>check if the object has defined a <code class=\"docutils literal notranslate\"><span class=\"pre\">toDict</span></code> method and call it. A <code class=\"docutils literal notranslate\"><span class=\"pre\">toDict</span></code> method should return a <code class=\"docutils literal notranslate\"><span class=\"pre\">dict</span></code> which will then be JSON serialized.</p></li> <li><p>invoke the <code class=\"docutils literal notranslate\"><span class=\"pre\">default_handler</span></code> if one was provided.</p></li> <li><p>convert the object to a <code class=\"docutils literal notranslate\"><span class=\"pre\">dict</span></code> by traversing its contents. However this will often fail with an <code class=\"docutils literal notranslate\"><span class=\"pre\">OverflowError</span></code> or give unexpected results.</p></li> </ul> </div>\n</blockquote> </li> </ul> <p>In general the best approach for unsupported objects or dtypes is to provide a <code class=\"docutils literal notranslate\"><span class=\"pre\">default_handler</span></code>. For example:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; DataFrame([1.0, 2.0, complex(1.0, 2.0)]).to_json()  # raises\nRuntimeError: Unhandled numpy dtype 15\n</pre></div> </div> <p>can be dealt with by specifying a simple <code class=\"docutils literal notranslate\"><span class=\"pre\">default_handler</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [231]: pd.DataFrame([1.0, 2.0, complex(1.0, 2.0)]).to_json(default_handler=str)\nOut[231]: '{\"0\":{\"0\":\"(1+0j)\",\"1\":\"(2+0j)\",\"2\":\"(1+2j)\"}}'\n</pre></div> </div> </section> </section> <section id=\"reading-json\"> <h3>Reading JSON</h3> <p>Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> if <code class=\"docutils literal notranslate\"><span class=\"pre\">typ</span></code> is not supplied or is <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>. To explicitly force <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> parsing, pass <code class=\"docutils literal notranslate\"><span class=\"pre\">typ=series</span></code></p> <ul> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">filepath_or_buffer</span></code> : a <strong>VALID</strong> JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">typ</span></code> : type of object to recover (series or frame), default ‘frame’</p></li> <li>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">orient</span></code> :</p> <dl class=\"simple\"> <dt>Series :</dt>\n<dd>\n<ul class=\"simple\"> <li><p>default is <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code></p></li> <li><p>allowed values are {<code class=\"docutils literal notranslate\"><span class=\"pre\">split</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>}</p></li> </ul> </dd> <dt>DataFrame</dt>\n<dd>\n<ul class=\"simple\"> <li><p>default is <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code></p></li> <li><p>allowed values are {<code class=\"docutils literal notranslate\"><span class=\"pre\">split</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">values</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code>}</p></li> </ul> </dd> </dl> <p>The format of the JSON string</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 12%\"> <col style=\"width: 88%\"> </colgroup> <tbody> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">split</span></code></p></td> <td><p>dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code></p></td> <td><p>list like [{column -&gt; value}, … , {column -&gt; value}]</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code></p></td> <td><p>dict like {index -&gt; {column -&gt; value}}</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code></p></td> <td><p>dict like {column -&gt; {index -&gt; value}}</p></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">values</span></code></p></td> <td><p>just the values array</p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code></p></td> <td><p>adhering to the JSON <a class=\"reference external\" href=\"https://specs.frictionlessdata.io/table-schema/\">Table Schema</a></p></td> </tr> </tbody> </table> </li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> : if True, infer dtypes, if a dict of column to dtype, then use those, if <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>, then don’t infer dtypes at all, default is True, apply only to the data.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">convert_axes</span></code> : boolean, try to convert the axes to the proper dtypes, default is <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">convert_dates</span></code> : a list of columns to parse for dates; If <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, then try to parse date-like columns, default is <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">keep_default_dates</span></code> : boolean, default <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>. If parsing dates, then parse the default date-like columns.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> : direct decoding to NumPy arrays. default is <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>; Supports numeric data only, although labels may be non-numeric. Also note that the JSON ordering <strong>MUST</strong> be the same for each term if <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy=True</span></code>.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">precise_float</span></code> : boolean, default <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>. Set to enable usage of higher precision (strtod) function when decoding string to double values. Default (<code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>) is to use fast but less precise builtin functionality.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">date_unit</span></code> : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">lines</span></code> : reads file as one json object per line.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">encoding</span></code> : The encoding to use to decode py3 bytes.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> : when used in combination with <code class=\"docutils literal notranslate\"><span class=\"pre\">lines=True</span></code>, return a JsonReader which reads in <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> lines per iteration.</p></li> </ul> <p>The parser will raise one of <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError/TypeError/AssertionError</span></code> if the JSON is not parseable.</p> <p>If a non-default <code class=\"docutils literal notranslate\"><span class=\"pre\">orient</span></code> was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see <a class=\"reference internal\" href=\"#orient-options\">Orient Options</a> for an overview.</p> <section id=\"data-conversion\"> <h4>Data conversion</h4> <p>The default of <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_axes=True</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype=True</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_dates=True</span></code> will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_axes</span></code> should only be set to <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code> if you need to preserve string-like numbers (e.g. ‘1’, ‘2’) in an axes.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Large integer values may be converted to dates if <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_dates=True</span></code> and the data and / or column labels appear ‘date-like’. The exact threshold depends on the <code class=\"docutils literal notranslate\"><span class=\"pre\">date_unit</span></code> specified. ‘date-like’ means that the column label meets one of the following criteria:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>it ends with <code class=\"docutils literal notranslate\"><span class=\"pre\">'_at'</span></code></p></li> <li><p>it ends with <code class=\"docutils literal notranslate\"><span class=\"pre\">'_time'</span></code></p></li> <li><p>it begins with <code class=\"docutils literal notranslate\"><span class=\"pre\">'timestamp'</span></code></p></li> <li><p>it is <code class=\"docutils literal notranslate\"><span class=\"pre\">'modified'</span></code></p></li> <li><p>it is <code class=\"docutils literal notranslate\"><span class=\"pre\">'date'</span></code></p></li> </ul> </div>\n</blockquote> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>When reading JSON data, automatic coercing into dtypes has some quirks:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization</p></li> <li><p>a column that was <code class=\"docutils literal notranslate\"><span class=\"pre\">float</span></code> data will be converted to <code class=\"docutils literal notranslate\"><span class=\"pre\">integer</span></code> if it can be done safely, e.g. a column of <code class=\"docutils literal notranslate\"><span class=\"pre\">1.</span></code></p></li> <li><p>bool columns will be converted to <code class=\"docutils literal notranslate\"><span class=\"pre\">integer</span></code> on reconstruction</p></li> </ul> </div>\n</blockquote> <p>Thus there are times where you may want to specify specific dtypes via the <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> keyword argument.</p> </div> <p>Reading from a JSON string:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [232]: pd.read_json(json)\nOut[232]: \n        date         B         A\n0 2013-01-01  2.565646 -1.206412\n1 2013-01-01  1.340309  1.431256\n2 2013-01-01 -0.226169 -1.170299\n3 2013-01-01  0.813850  0.410835\n4 2013-01-01 -0.827317  0.132003\n</pre></div> </div> <p>Reading from a file:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [233]: pd.read_json(\"test.json\")\nOut[233]: \n                   A         B       date  ints  bools\n2013-01-01 -1.294524  0.413738 2013-01-01     0   True\n2013-01-02  0.276662 -0.472035 2013-01-01     1   True\n2013-01-03 -0.013960 -0.362543 2013-01-01     2   True\n2013-01-04 -0.006154 -0.923061 2013-01-01     3   True\n2013-01-05  0.895717  0.805244 2013-01-01     4   True\n</pre></div> </div> <p>Don’t convert any data (but still convert axes and dates):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [234]: pd.read_json(\"test.json\", dtype=object).dtypes\nOut[234]: \nA        object\nB        object\ndate     object\nints     object\nbools    object\ndtype: object\n</pre></div> </div> <p>Specify dtypes for conversion:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [235]: pd.read_json(\"test.json\", dtype={\"A\": \"float32\", \"bools\": \"int8\"}).dtypes\nOut[235]: \nA               float32\nB               float64\ndate     datetime64[ns]\nints              int64\nbools              int8\ndtype: object\n</pre></div> </div> <p>Preserve string indices:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [236]: si = pd.DataFrame(\n   .....:     np.zeros((4, 4)), columns=list(range(4)), index=[str(i) for i in range(4)]\n   .....: )\n   .....: \n\nIn [237]: si\nOut[237]: \n     0    1    2    3\n0  0.0  0.0  0.0  0.0\n1  0.0  0.0  0.0  0.0\n2  0.0  0.0  0.0  0.0\n3  0.0  0.0  0.0  0.0\n\nIn [238]: si.index\nOut[238]: Index(['0', '1', '2', '3'], dtype='object')\n\nIn [239]: si.columns\nOut[239]: Int64Index([0, 1, 2, 3], dtype='int64')\n\nIn [240]: json = si.to_json()\n\nIn [241]: sij = pd.read_json(json, convert_axes=False)\n\nIn [242]: sij\nOut[242]: \n   0  1  2  3\n0  0  0  0  0\n1  0  0  0  0\n2  0  0  0  0\n3  0  0  0  0\n\nIn [243]: sij.index\nOut[243]: Index(['0', '1', '2', '3'], dtype='object')\n\nIn [244]: sij.columns\nOut[244]: Index(['0', '1', '2', '3'], dtype='object')\n</pre></div> </div> <p>Dates written in nanoseconds need to be read back in nanoseconds:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [245]: json = dfj2.to_json(date_unit=\"ns\")\n\n# Try to parse timestamps as milliseconds -&gt; Won't Work\nIn [246]: dfju = pd.read_json(json, date_unit=\"ms\")\n\nIn [247]: dfju\nOut[247]: \n                            A         B                 date  ints  bools\n1356998400000000000 -1.294524  0.413738  1356998400000000000     0   True\n1357084800000000000  0.276662 -0.472035  1356998400000000000     1   True\n1357171200000000000 -0.013960 -0.362543  1356998400000000000     2   True\n1357257600000000000 -0.006154 -0.923061  1356998400000000000     3   True\n1357344000000000000  0.895717  0.805244  1356998400000000000     4   True\n\n# Let pandas detect the correct precision\nIn [248]: dfju = pd.read_json(json)\n\nIn [249]: dfju\nOut[249]: \n                   A         B       date  ints  bools\n2013-01-01 -1.294524  0.413738 2013-01-01     0   True\n2013-01-02  0.276662 -0.472035 2013-01-01     1   True\n2013-01-03 -0.013960 -0.362543 2013-01-01     2   True\n2013-01-04 -0.006154 -0.923061 2013-01-01     3   True\n2013-01-05  0.895717  0.805244 2013-01-01     4   True\n\n# Or specify that all timestamps are in nanoseconds\nIn [250]: dfju = pd.read_json(json, date_unit=\"ns\")\n\nIn [251]: dfju\nOut[251]: \n                   A         B       date  ints  bools\n2013-01-01 -1.294524  0.413738 2013-01-01     0   True\n2013-01-02  0.276662 -0.472035 2013-01-01     1   True\n2013-01-03 -0.013960 -0.362543 2013-01-01     2   True\n2013-01-04 -0.006154 -0.923061 2013-01-01     3   True\n2013-01-05  0.895717  0.805244 2013-01-01     4   True\n</pre></div> </div> </section> <section id=\"the-numpy-parameter\"> <h4>The Numpy parameter</h4> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>This param has been deprecated as of version 1.0.0 and will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">FutureWarning</span></code>.</p> <p>This supports numeric data only. Index and columns labels may be non-numeric, e.g. strings, dates etc.</p> </div> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy=True</span></code> is passed to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_json</span></code> an attempt will be made to sniff an appropriate dtype during deserialization and to subsequently decode directly to NumPy arrays, bypassing the need for intermediate Python objects.</p> <p>This can provide speedups if you are deserialising a large amount of numeric data:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [252]: randfloats = np.random.uniform(-100, 1000, 10000)\n\nIn [253]: randfloats.shape = (1000, 10)\n\nIn [254]: dffloats = pd.DataFrame(randfloats, columns=list(\"ABCDEFGHIJ\"))\n\nIn [255]: jsonfloats = dffloats.to_json()\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [256]: %timeit pd.read_json(jsonfloats)\n7.95 ms +- 597 us per loop (mean +- std. dev. of 7 runs, 100 loops each)\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [257]: %timeit pd.read_json(jsonfloats, numpy=True)\n5.89 ms +- 407 us per loop (mean +- std. dev. of 7 runs, 100 loops each)\n</pre></div> </div> <p>The speedup is less noticeable for smaller datasets:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [258]: jsonfloats = dffloats.head(100).to_json()\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [259]: %timeit pd.read_json(jsonfloats)\n5.39 ms +- 316 us per loop (mean +- std. dev. of 7 runs, 100 loops each)\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [260]: %timeit pd.read_json(jsonfloats, numpy=True)\n4.76 ms +- 436 us per loop (mean +- std. dev. of 7 runs, 100 loops each)\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Direct NumPy decoding makes a number of assumptions and may fail or produce unexpected output if these assumptions are not satisfied:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>data is numeric.</p></li> <li><p>data is uniform. The dtype is sniffed from the first value decoded. A <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code> may be raised, or incorrect output may be produced if this condition is not satisfied.</p></li> <li><p>labels are ordered. Labels are only read from the first container, it is assumed that each subsequent row / column has been encoded in the same order. This should be satisfied if the data was encoded using <code class=\"docutils literal notranslate\"><span class=\"pre\">to_json</span></code> but may not be the case if the JSON is from another source.</p></li> </ul> </div>\n</blockquote> </div> </section> </section> <section id=\"normalization\"> <h3>Normalization</h3> <p>pandas provides a utility function to take a dict or list of dicts and <em>normalize</em> this semi-structured data into a flat table.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [261]: data = [\n   .....:     {\"id\": 1, \"name\": {\"first\": \"Coleen\", \"last\": \"Volk\"}},\n   .....:     {\"name\": {\"given\": \"Mark\", \"family\": \"Regner\"}},\n   .....:     {\"id\": 2, \"name\": \"Faye Raker\"},\n   .....: ]\n   .....: \n\nIn [262]: pd.json_normalize(data)\nOut[262]: \n    id name.first name.last name.given name.family        name\n0  1.0     Coleen      Volk        NaN         NaN         NaN\n1  NaN        NaN       NaN       Mark      Regner         NaN\n2  2.0        NaN       NaN        NaN         NaN  Faye Raker\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [263]: data = [\n   .....:     {\n   .....:         \"state\": \"Florida\",\n   .....:         \"shortname\": \"FL\",\n   .....:         \"info\": {\"governor\": \"Rick Scott\"},\n   .....:         \"county\": [\n   .....:             {\"name\": \"Dade\", \"population\": 12345},\n   .....:             {\"name\": \"Broward\", \"population\": 40000},\n   .....:             {\"name\": \"Palm Beach\", \"population\": 60000},\n   .....:         ],\n   .....:     },\n   .....:     {\n   .....:         \"state\": \"Ohio\",\n   .....:         \"shortname\": \"OH\",\n   .....:         \"info\": {\"governor\": \"John Kasich\"},\n   .....:         \"county\": [\n   .....:             {\"name\": \"Summit\", \"population\": 1234},\n   .....:             {\"name\": \"Cuyahoga\", \"population\": 1337},\n   .....:         ],\n   .....:     },\n   .....: ]\n   .....: \n\nIn [264]: pd.json_normalize(data, \"county\", [\"state\", \"shortname\", [\"info\", \"governor\"]])\nOut[264]: \n         name  population    state shortname info.governor\n0        Dade       12345  Florida        FL    Rick Scott\n1     Broward       40000  Florida        FL    Rick Scott\n2  Palm Beach       60000  Florida        FL    Rick Scott\n3      Summit        1234     Ohio        OH   John Kasich\n4    Cuyahoga        1337     Ohio        OH   John Kasich\n</pre></div> </div> <p>The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [265]: data = [\n   .....:     {\n   .....:         \"CreatedBy\": {\"Name\": \"User001\"},\n   .....:         \"Lookup\": {\n   .....:             \"TextField\": \"Some text\",\n   .....:             \"UserField\": {\"Id\": \"ID001\", \"Name\": \"Name001\"},\n   .....:         },\n   .....:         \"Image\": {\"a\": \"b\"},\n   .....:     }\n   .....: ]\n   .....: \n\nIn [266]: pd.json_normalize(data, max_level=1)\nOut[266]: \n  CreatedBy.Name Lookup.TextField                    Lookup.UserField Image.a\n0        User001        Some text  {'Id': 'ID001', 'Name': 'Name001'}       b\n</pre></div> </div> </section> <section id=\"line-delimited-json\"> <h3>Line delimited json</h3> <p>pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark.</p> <p>For line-delimited json files, pandas can also return an iterator which reads in <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> lines at a time. This can be useful for large files or to read from a stream.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [267]: jsonl = \"\"\"\n   .....:     {\"a\": 1, \"b\": 2}\n   .....:     {\"a\": 3, \"b\": 4}\n   .....: \"\"\"\n   .....: \n\nIn [268]: df = pd.read_json(jsonl, lines=True)\n\nIn [269]: df\nOut[269]: \n   a  b\n0  1  2\n1  3  4\n\nIn [270]: df.to_json(orient=\"records\", lines=True)\nOut[270]: '{\"a\":1,\"b\":2}\\n{\"a\":3,\"b\":4}\\n'\n\n# reader is an iterator that returns ``chunksize`` lines each iteration\nIn [271]: with pd.read_json(StringIO(jsonl), lines=True, chunksize=1) as reader:\n   .....:     reader\n   .....:     for chunk in reader:\n   .....:         print(chunk)\n   .....: \nEmpty DataFrame\nColumns: []\nIndex: []\n   a  b\n0  1  2\n   a  b\n1  3  4\n</pre></div> </div> </section> <section id=\"table-schema\"> <h3>Table schema</h3> <p><a class=\"reference external\" href=\"https://specs.frictionlessdata.io/table-schema/\">Table Schema</a> is a spec for describing tabular datasets as a JSON object. The JSON includes information on the field names, types, and other attributes. You can use the orient <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> to build a JSON string with two fields, <code class=\"docutils literal notranslate\"><span class=\"pre\">schema</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [272]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": [1, 2, 3],\n   .....:         \"B\": [\"a\", \"b\", \"c\"],\n   .....:         \"C\": pd.date_range(\"2016-01-01\", freq=\"d\", periods=3),\n   .....:     },\n   .....:     index=pd.Index(range(3), name=\"idx\"),\n   .....: )\n   .....: \n\nIn [273]: df\nOut[273]: \n     A  B          C\nidx                 \n0    1  a 2016-01-01\n1    2  b 2016-01-02\n2    3  c 2016-01-03\n\nIn [274]: df.to_json(orient=\"table\", date_format=\"iso\")\nOut[274]: '{\"schema\":{\"fields\":[{\"name\":\"idx\",\"type\":\"integer\"},{\"name\":\"A\",\"type\":\"integer\"},{\"name\":\"B\",\"type\":\"string\"},{\"name\":\"C\",\"type\":\"datetime\"}],\"primaryKey\":[\"idx\"],\"pandas_version\":\"1.4.0\"},\"data\":[{\"idx\":0,\"A\":1,\"B\":\"a\",\"C\":\"2016-01-01T00:00:00.000Z\"},{\"idx\":1,\"A\":2,\"B\":\"b\",\"C\":\"2016-01-02T00:00:00.000Z\"},{\"idx\":2,\"A\":3,\"B\":\"c\",\"C\":\"2016-01-03T00:00:00.000Z\"}]}'\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">schema</span></code> field contains the <code class=\"docutils literal notranslate\"><span class=\"pre\">fields</span></code> key, which itself contains a list of column name to type pairs, including the <code class=\"docutils literal notranslate\"><span class=\"pre\">Index</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> (see below for a list of types). The <code class=\"docutils literal notranslate\"><span class=\"pre\">schema</span></code> field also contains a <code class=\"docutils literal notranslate\"><span class=\"pre\">primaryKey</span></code> field if the (Multi)index is unique.</p> <p>The second field, <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code>, contains the serialized data with the <code class=\"docutils literal notranslate\"><span class=\"pre\">records</span></code> orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec.</p> <p>The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types:</p> <table class=\"table\"> <colgroup> <col style=\"width: 47%\"> <col style=\"width: 53%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>pandas type</p></th> <th class=\"head\"><p>Table Schema type</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>int64</p></td> <td><p>integer</p></td> </tr> <tr class=\"row-odd\">\n<td><p>float64</p></td> <td><p>number</p></td> </tr> <tr class=\"row-even\">\n<td><p>bool</p></td> <td><p>boolean</p></td> </tr> <tr class=\"row-odd\">\n<td><p>datetime64[ns]</p></td> <td><p>datetime</p></td> </tr> <tr class=\"row-even\">\n<td><p>timedelta64[ns]</p></td> <td><p>duration</p></td> </tr> <tr class=\"row-odd\">\n<td><p>categorical</p></td> <td><p>any</p></td> </tr> <tr class=\"row-even\">\n<td><p>object</p></td> <td><p>str</p></td> </tr> </tbody> </table> <p>A few notes on the generated table schema:</p> <ul> <li><p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">schema</span></code> object contains a <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas_version</span></code> field. This contains the version of pandas’ dialect of the schema, and will be incremented with each revision.</p></li> <li>\n<p>All dates are converted to UTC when serializing. Even timezone naive values, which are treated as UTC with an offset of 0.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [275]: from pandas.io.json import build_table_schema\n\nIn [276]: s = pd.Series(pd.date_range(\"2016\", periods=4))\n\nIn [277]: build_table_schema(s)\nOut[277]: \n{'fields': [{'name': 'index', 'type': 'integer'},\n  {'name': 'values', 'type': 'datetime'}],\n 'primaryKey': ['index'],\n 'pandas_version': '1.4.0'}\n</pre></div> </div> </li> <li>\n<p>datetimes with a timezone (before serializing), include an additional field <code class=\"docutils literal notranslate\"><span class=\"pre\">tz</span></code> with the time zone name (e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">'US/Central'</span></code>).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [278]: s_tz = pd.Series(pd.date_range(\"2016\", periods=12, tz=\"US/Central\"))\n\nIn [279]: build_table_schema(s_tz)\nOut[279]: \n{'fields': [{'name': 'index', 'type': 'integer'},\n  {'name': 'values', 'type': 'datetime', 'tz': 'US/Central'}],\n 'primaryKey': ['index'],\n 'pandas_version': '1.4.0'}\n</pre></div> </div> </li> <li>\n<p>Periods are converted to timestamps before serialization, and so have the same behavior of being converted to UTC. In addition, periods will contain and additional field <code class=\"docutils literal notranslate\"><span class=\"pre\">freq</span></code> with the period’s frequency, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">'A-DEC'</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [280]: s_per = pd.Series(1, index=pd.period_range(\"2016\", freq=\"A-DEC\", periods=4))\n\nIn [281]: build_table_schema(s_per)\nOut[281]: \n{'fields': [{'name': 'index', 'type': 'datetime', 'freq': 'A-DEC'},\n  {'name': 'values', 'type': 'integer'}],\n 'primaryKey': ['index'],\n 'pandas_version': '1.4.0'}\n</pre></div> </div> </li> <li>\n<p>Categoricals use the <code class=\"docutils literal notranslate\"><span class=\"pre\">any</span></code> type and an <code class=\"docutils literal notranslate\"><span class=\"pre\">enum</span></code> constraint listing the set of possible values. Additionally, an <code class=\"docutils literal notranslate\"><span class=\"pre\">ordered</span></code> field is included:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [282]: s_cat = pd.Series(pd.Categorical([\"a\", \"b\", \"a\"]))\n\nIn [283]: build_table_schema(s_cat)\nOut[283]: \n{'fields': [{'name': 'index', 'type': 'integer'},\n  {'name': 'values',\n   'type': 'any',\n   'constraints': {'enum': ['a', 'b']},\n   'ordered': False}],\n 'primaryKey': ['index'],\n 'pandas_version': '1.4.0'}\n</pre></div> </div> </li> <li>\n<p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">primaryKey</span></code> field, containing an array of labels, is included <em>if the index is unique</em>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [284]: s_dupe = pd.Series([1, 2], index=[1, 1])\n\nIn [285]: build_table_schema(s_dupe)\nOut[285]: \n{'fields': [{'name': 'index', 'type': 'integer'},\n  {'name': 'values', 'type': 'integer'}],\n 'pandas_version': '1.4.0'}\n</pre></div> </div> </li> <li>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">primaryKey</span></code> behavior is the same with MultiIndexes, but in this case the <code class=\"docutils literal notranslate\"><span class=\"pre\">primaryKey</span></code> is an array:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [286]: s_multi = pd.Series(1, index=pd.MultiIndex.from_product([(\"a\", \"b\"), (0, 1)]))\n\nIn [287]: build_table_schema(s_multi)\nOut[287]: \n{'fields': [{'name': 'level_0', 'type': 'string'},\n  {'name': 'level_1', 'type': 'integer'},\n  {'name': 'values', 'type': 'integer'}],\n 'primaryKey': FrozenList(['level_0', 'level_1']),\n 'pandas_version': '1.4.0'}\n</pre></div> </div> </li> <li>\n<p>The default naming roughly follows these rules:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>For series, the <code class=\"docutils literal notranslate\"><span class=\"pre\">object.name</span></code> is used. If that’s none, then the name is <code class=\"docutils literal notranslate\"><span class=\"pre\">values</span></code></p></li> <li><p>For <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code>, the stringified version of the column name is used</p></li> <li><p>For <code class=\"docutils literal notranslate\"><span class=\"pre\">Index</span></code> (not <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code>), <code class=\"docutils literal notranslate\"><span class=\"pre\">index.name</span></code> is used, with a fallback to <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> if that is None.</p></li> <li><p>For <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">mi.names</span></code> is used. If any level has no name, then <code class=\"docutils literal notranslate\"><span class=\"pre\">level_&lt;i&gt;</span></code> is used.</p></li> </ul> </div>\n</blockquote> </li> </ul> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">read_json</span></code> also accepts <code class=\"docutils literal notranslate\"><span class=\"pre\">orient='table'</span></code> as an argument. This allows for the preservation of metadata such as dtypes and index names in a round-trippable manner.</p> <blockquote> <div>\n<div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [288]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"foo\": [1, 2, 3, 4],\n   .....:         \"bar\": [\"a\", \"b\", \"c\", \"d\"],\n   .....:         \"baz\": pd.date_range(\"2018-01-01\", freq=\"d\", periods=4),\n   .....:         \"qux\": pd.Categorical([\"a\", \"b\", \"c\", \"c\"]),\n   .....:     },\n   .....:     index=pd.Index(range(4), name=\"idx\"),\n   .....: )\n   .....: \n\nIn [289]: df\nOut[289]: \n     foo bar        baz qux\nidx                        \n0      1   a 2018-01-01   a\n1      2   b 2018-01-02   b\n2      3   c 2018-01-03   c\n3      4   d 2018-01-04   c\n\nIn [290]: df.dtypes\nOut[290]: \nfoo             int64\nbar            object\nbaz    datetime64[ns]\nqux          category\ndtype: object\n\nIn [291]: df.to_json(\"test.json\", orient=\"table\")\n\nIn [292]: new_df = pd.read_json(\"test.json\", orient=\"table\")\n\nIn [293]: new_df\nOut[293]: \n     foo bar        baz qux\nidx                        \n0      1   a 2018-01-01   a\n1      2   b 2018-01-02   b\n2      3   c 2018-01-03   c\n3      4   d 2018-01-04   c\n\nIn [294]: new_df.dtypes\nOut[294]: \nfoo             int64\nbar            object\nbaz    datetime64[ns]\nqux          category\ndtype: object\n</pre></div> </div> </div>\n</blockquote> <p>Please note that the literal string ‘index’ as the name of an <a class=\"reference internal\" href=\"../reference/api/pandas.index#pandas.Index\" title=\"pandas.Index\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Index</span></code></a> is not round-trippable, nor are any names beginning with <code class=\"docutils literal notranslate\"><span class=\"pre\">'level_'</span></code> within a <a class=\"reference internal\" href=\"../reference/api/pandas.multiindex#pandas.MultiIndex\" title=\"pandas.MultiIndex\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code></a>. These are used by default in <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_json#pandas.DataFrame.to_json\" title=\"pandas.DataFrame.to_json\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">DataFrame.to_json()</span></code></a> to indicate missing values and the subsequent read cannot distinguish the intent.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [295]: df.index.name = \"index\"\n\nIn [296]: df.to_json(\"test.json\", orient=\"table\")\n\nIn [297]: new_df = pd.read_json(\"test.json\", orient=\"table\")\n\nIn [298]: print(new_df.index.name)\nNone\n</pre></div> </div> <p>When using <code class=\"docutils literal notranslate\"><span class=\"pre\">orient='table'</span></code> along with user-defined <code class=\"docutils literal notranslate\"><span class=\"pre\">ExtensionArray</span></code>, the generated schema will contain an additional <code class=\"docutils literal notranslate\"><span class=\"pre\">extDtype</span></code> key in the respective <code class=\"docutils literal notranslate\"><span class=\"pre\">fields</span></code> element. This extra key is not standard but does enable JSON roundtrips for extension types (e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">read_json(df.to_json(orient=\"table\"),</span> <span class=\"pre\">orient=\"table\")</span></code>).</p> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">extDtype</span></code> key carries the name of the extension, if you have properly registered the <code class=\"docutils literal notranslate\"><span class=\"pre\">ExtensionDtype</span></code>, pandas will use said name to perform a lookup into the registry and re-convert the serialized data into your custom dtype.</p> </section> </section> <section id=\"html\"> <h2>HTML</h2> <section id=\"reading-html-content\"> <h3>Reading HTML content</h3> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>We <strong>highly encourage</strong> you to read the <a class=\"reference internal\" href=\"#io-html-gotchas\"><span class=\"std std-ref\">HTML Table Parsing gotchas</span></a> below regarding the issues surrounding the BeautifulSoup4/html5lib/lxml parsers.</p> </div> <p>The top-level <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_html()</span></code> function can accept an HTML string/file/URL and will parse HTML tables into list of pandas <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code>. Let’s look at a few examples.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">read_html</span></code> returns a <code class=\"docutils literal notranslate\"><span class=\"pre\">list</span></code> of <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> objects, even if there is only a single table contained in the HTML content.</p> </div> <p>Read a URL with no options:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [299]: url = \"https://www.fdic.gov/resources/resolutions/bank-failures/failed-bank-list\"\n\nIn [300]: dfs = pd.read_html(url)\n\nIn [301]: dfs\nOut[301]: \n[                         Bank NameBank           CityCity StateSt  CertCert              Acquiring InstitutionAI Closing DateClosing  FundFund\n 0                    Almena State Bank             Almena      KS     15426                          Equity Bank    October 23, 2020     10538\n 1           First City Bank of Florida  Fort Walton Beach      FL     16748            United Fidelity Bank, fsb    October 16, 2020     10537\n 2                 The First State Bank      Barboursville      WV     14361                       MVB Bank, Inc.       April 3, 2020     10536\n 3                   Ericson State Bank            Ericson      NE     18265           Farmers and Merchants Bank   February 14, 2020     10535\n 4     City National Bank of New Jersey             Newark      NJ     21111                      Industrial Bank    November 1, 2019     10534\n ..                                 ...                ...     ...       ...                                  ...                 ...       ...\n 558                 Superior Bank, FSB           Hinsdale      IL     32646                Superior Federal, FSB       July 27, 2001      6004\n 559                Malta National Bank              Malta      OH      6629                    North Valley Bank         May 3, 2001      4648\n 560    First Alliance Bank &amp; Trust Co.         Manchester      NH     34264  Southern New Hampshire Bank &amp; Trust    February 2, 2001      4647\n 561  National State Bank of Metropolis         Metropolis      IL      3815              Banterra Bank of Marion   December 14, 2000      4646\n 562                   Bank of Honolulu           Honolulu      HI     21029                   Bank of the Orient    October 13, 2000      4645\n \n [563 rows x 7 columns]]\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The data from the above URL changes every Monday so the resulting data above and the data below may be slightly different.</p> </div> <p>Read in the content of the file from the above URL and pass it to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_html</span></code> as a string:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [302]: with open(file_path, \"r\") as f:\n   .....:     dfs = pd.read_html(f.read())\n   .....: \n\nIn [303]: dfs\nOut[303]: \n[                                    Bank Name          City  ST  ...                Acquiring Institution       Closing Date       Updated Date\n 0    Banks of Wisconsin d/b/a Bank of Kenosha       Kenosha  WI  ...                North Shore Bank, FSB       May 31, 2013       May 31, 2013\n 1                        Central Arizona Bank    Scottsdale  AZ  ...                   Western State Bank       May 14, 2013       May 20, 2013\n 2                                Sunrise Bank      Valdosta  GA  ...                         Synovus Bank       May 10, 2013       May 21, 2013\n 3                       Pisgah Community Bank     Asheville  NC  ...                   Capital Bank, N.A.       May 10, 2013       May 14, 2013\n 4                         Douglas County Bank  Douglasville  GA  ...                  Hamilton State Bank     April 26, 2013       May 16, 2013\n ..                                        ...           ...  ..  ...                                  ...                ...                ...\n 501                        Superior Bank, FSB      Hinsdale  IL  ...                Superior Federal, FSB      July 27, 2001       June 5, 2012\n 502                       Malta National Bank         Malta  OH  ...                    North Valley Bank        May 3, 2001  November 18, 2002\n 503           First Alliance Bank &amp; Trust Co.    Manchester  NH  ...  Southern New Hampshire Bank &amp; Trust   February 2, 2001  February 18, 2003\n 504         National State Bank of Metropolis    Metropolis  IL  ...              Banterra Bank of Marion  December 14, 2000     March 17, 2005\n 505                          Bank of Honolulu      Honolulu  HI  ...                   Bank of the Orient   October 13, 2000     March 17, 2005\n \n [506 rows x 7 columns]]\n</pre></div> </div> <p>You can even pass in an instance of <code class=\"docutils literal notranslate\"><span class=\"pre\">StringIO</span></code> if you so desire:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [304]: with open(file_path, \"r\") as f:\n   .....:     sio = StringIO(f.read())\n   .....: \n\nIn [305]: dfs = pd.read_html(sio)\n\nIn [306]: dfs\nOut[306]: \n[                                    Bank Name          City  ST  ...                Acquiring Institution       Closing Date       Updated Date\n 0    Banks of Wisconsin d/b/a Bank of Kenosha       Kenosha  WI  ...                North Shore Bank, FSB       May 31, 2013       May 31, 2013\n 1                        Central Arizona Bank    Scottsdale  AZ  ...                   Western State Bank       May 14, 2013       May 20, 2013\n 2                                Sunrise Bank      Valdosta  GA  ...                         Synovus Bank       May 10, 2013       May 21, 2013\n 3                       Pisgah Community Bank     Asheville  NC  ...                   Capital Bank, N.A.       May 10, 2013       May 14, 2013\n 4                         Douglas County Bank  Douglasville  GA  ...                  Hamilton State Bank     April 26, 2013       May 16, 2013\n ..                                        ...           ...  ..  ...                                  ...                ...                ...\n 501                        Superior Bank, FSB      Hinsdale  IL  ...                Superior Federal, FSB      July 27, 2001       June 5, 2012\n 502                       Malta National Bank         Malta  OH  ...                    North Valley Bank        May 3, 2001  November 18, 2002\n 503           First Alliance Bank &amp; Trust Co.    Manchester  NH  ...  Southern New Hampshire Bank &amp; Trust   February 2, 2001  February 18, 2003\n 504         National State Bank of Metropolis    Metropolis  IL  ...              Banterra Bank of Marion  December 14, 2000     March 17, 2005\n 505                          Bank of Honolulu      Honolulu  HI  ...                   Bank of the Orient   October 13, 2000     March 17, 2005\n \n [506 rows x 7 columns]]\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The following examples are not run by the IPython evaluator due to the fact that having so many network-accessing functions slows down the documentation build. If you spot an error or an example that doesn’t run, please do not hesitate to report it over on <a class=\"reference external\" href=\"https://github.com/pandas-dev/pandas/issues\">pandas GitHub issues page</a>.</p> </div> <p>Read a URL and match a table that contains specific text:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">match = \"Metcalf Bank\"\ndf_list = pd.read_html(url, match=match)\n</pre></div> </div> <p>Specify a header row (by default <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;th&gt;</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;td&gt;</span></code> elements located within a <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;thead&gt;</span></code> are used to form the column index, if multiple rows are contained within <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;thead&gt;</span></code> then a MultiIndex is created); if specified, the header row is taken from the data minus the parsed header elements (<code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;th&gt;</span></code> elements).</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, header=0)\n</pre></div> </div> <p>Specify an index column:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, index_col=0)\n</pre></div> </div> <p>Specify a number of rows to skip:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, skiprows=0)\n</pre></div> </div> <p>Specify a number of rows to skip using a list (<code class=\"docutils literal notranslate\"><span class=\"pre\">range</span></code> works as well):</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, skiprows=range(2))\n</pre></div> </div> <p>Specify an HTML attribute:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs1 = pd.read_html(url, attrs={\"id\": \"table\"})\ndfs2 = pd.read_html(url, attrs={\"class\": \"sortable\"})\nprint(np.array_equal(dfs1[0], dfs2[0]))  # Should be True\n</pre></div> </div> <p>Specify values that should be converted to NaN:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, na_values=[\"No Acquirer\"])\n</pre></div> </div> <p>Specify whether to keep the default set of NaN values:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, keep_default_na=False)\n</pre></div> </div> <p>Specify converters for columns. This is useful for numerical text data that has leading zeros. By default columns that are numerical are cast to numeric types and the leading zeros are lost. To avoid this, we can convert these columns to strings.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">url_mcc = \"https://en.wikipedia.org/wiki/Mobile_country_code\"\ndfs = pd.read_html(\n    url_mcc,\n    match=\"Telekom Albania\",\n    header=0,\n    converters={\"MNC\": str},\n)\n</pre></div> </div> <p>Use some combination of the above:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, match=\"Metcalf Bank\", index_col=0)\n</pre></div> </div> <p>Read in pandas <code class=\"docutils literal notranslate\"><span class=\"pre\">to_html</span></code> output (with some loss of floating point precision):</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df = pd.DataFrame(np.random.randn(2, 2))\ns = df.to_html(float_format=\"{0:.40g}\".format)\ndfin = pd.read_html(s, index_col=0)\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">lxml</span></code> backend will raise an error on a failed parse if that is the only parser you provide. If you only have a single parser you can provide just a string, but it is considered good practice to pass a list with one string if, for example, the function expects a sequence of strings. You may use:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, \"Metcalf Bank\", index_col=0, flavor=[\"lxml\"])\n</pre></div> </div> <p>Or you could pass <code class=\"docutils literal notranslate\"><span class=\"pre\">flavor='lxml'</span></code> without a list:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, \"Metcalf Bank\", index_col=0, flavor=\"lxml\")\n</pre></div> </div> <p>However, if you have bs4 and html5lib installed and pass <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">['lxml',</span>\n<span class=\"pre\">'bs4']</span></code> then the parse will most likely succeed. Note that <em>as soon as a parse succeeds, the function will return</em>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">dfs = pd.read_html(url, \"Metcalf Bank\", index_col=0, flavor=[\"lxml\", \"bs4\"])\n</pre></div> </div> </section> <section id=\"writing-to-html-files\"> <h3>Writing to HTML files</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> objects have an instance method <code class=\"docutils literal notranslate\"><span class=\"pre\">to_html</span></code> which renders the contents of the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> as an HTML table. The function arguments are as in the method <code class=\"docutils literal notranslate\"><span class=\"pre\">to_string</span></code> described above.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Not all of the possible options for <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.to_html</span></code> are shown here for brevity’s sake. See <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_html()</span></code> for the full set of options.</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [307]: df = pd.DataFrame(np.random.randn(2, 2))\n\nIn [308]: df\nOut[308]: \n          0         1\n0 -0.184744  0.496971\n1 -0.856240  1.857977\n\nIn [309]: print(df.to_html())  # raw html\n&lt;table border=\"1\" class=\"dataframe\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;th&gt;1&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;td&gt;-0.184744&lt;/td&gt;\n      &lt;td&gt;0.496971&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;1&lt;/th&gt;\n      &lt;td&gt;-0.856240&lt;/td&gt;\n      &lt;td&gt;1.857977&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <p>HTML:</p> <table border=\"1\" class=\"dataframe\"> <thead> <tr style=\"text-align: right;\"> <th></th> <th>0</th> <th>1</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>-0.184744</td> <td>0.496971</td> </tr> <tr> <th>1</th> <td>-0.856240</td> <td>1.857977</td> </tr> </tbody> </table>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> argument will limit the columns shown:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [310]: print(df.to_html(columns=[0]))\n&lt;table border=\"1\" class=\"dataframe\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;0&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;td&gt;-0.184744&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;1&lt;/th&gt;\n      &lt;td&gt;-0.856240&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <p>HTML:</p> <table border=\"1\" class=\"dataframe\"> <thead> <tr style=\"text-align: right;\"> <th></th> <th>0</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>-0.184744</td> </tr> <tr> <th>1</th> <td>-0.856240</td> </tr> </tbody> </table>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">float_format</span></code> takes a Python callable to control the precision of floating point values:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [311]: print(df.to_html(float_format=\"{0:.10f}\".format))\n&lt;table border=\"1\" class=\"dataframe\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;th&gt;1&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;td&gt;-0.1847438576&lt;/td&gt;\n      &lt;td&gt;0.4969711327&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;1&lt;/th&gt;\n      &lt;td&gt;-0.8562396763&lt;/td&gt;\n      &lt;td&gt;1.8579766508&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <p>HTML:</p> <table border=\"1\" class=\"dataframe\"> <thead> <tr style=\"text-align: right;\"> <th></th> <th>0</th> <th>1</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>-0.1847438576</td> <td>0.4969711327</td> </tr> <tr> <th>1</th> <td>-0.8562396763</td> <td>1.8579766508</td> </tr> </tbody> </table>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">bold_rows</span></code> will make the row labels bold by default, but you can turn that off:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [312]: print(df.to_html(bold_rows=False))\n&lt;table border=\"1\" class=\"dataframe\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;th&gt;1&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;0&lt;/td&gt;\n      &lt;td&gt;-0.184744&lt;/td&gt;\n      &lt;td&gt;0.496971&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;1&lt;/td&gt;\n      &lt;td&gt;-0.856240&lt;/td&gt;\n      &lt;td&gt;1.857977&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <table border=\"1\" class=\"dataframe\"> <thead> <tr style=\"text-align: right;\"> <th></th> <th>0</th> <th>1</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>-0.184744</td> <td>0.496971</td> </tr> <tr> <td>1</td> <td>-0.856240</td> <td>1.857977</td> </tr> </tbody> </table>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">classes</span></code> argument provides the ability to give the resulting HTML table CSS classes. Note that these classes are <em>appended</em> to the existing <code class=\"docutils literal notranslate\"><span class=\"pre\">'dataframe'</span></code> class.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [313]: print(df.to_html(classes=[\"awesome_table_class\", \"even_more_awesome_class\"]))\n&lt;table border=\"1\" class=\"dataframe awesome_table_class even_more_awesome_class\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;th&gt;1&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;td&gt;-0.184744&lt;/td&gt;\n      &lt;td&gt;0.496971&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;1&lt;/th&gt;\n      &lt;td&gt;-0.856240&lt;/td&gt;\n      &lt;td&gt;1.857977&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">render_links</span></code> argument provides the ability to add hyperlinks to cells that contain URLs.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [314]: url_df = pd.DataFrame(\n   .....:     {\n   .....:         \"name\": [\"Python\", \"pandas\"],\n   .....:         \"url\": [\"https://www.python.org/\", \"https://pandas.pydata.org\"],\n   .....:     }\n   .....: )\n   .....: \n\nIn [315]: print(url_df.to_html(render_links=True))\n&lt;table border=\"1\" class=\"dataframe\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;name&lt;/th&gt;\n      &lt;th&gt;url&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;td&gt;Python&lt;/td&gt;\n      &lt;td&gt;&lt;a href=\"https://www.python.org/\" target=\"_blank\"&gt;https://www.python.org/&lt;/a&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;1&lt;/th&gt;\n      &lt;td&gt;pandas&lt;/td&gt;\n      &lt;td&gt;&lt;a href=\"https://pandas.pydata.org\" target=\"_blank\"&gt;https://pandas.pydata.org&lt;/a&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <p>HTML:</p> <table border=\"1\" class=\"dataframe\"> <thead> <tr style=\"text-align: right;\"> <th></th> <th>name</th> <th>url</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>Python</td> <td><a href=\"https://www.python.org/\" target=\"_blank\">https://www.python.org/</a></td> </tr> <tr> <th>1</th> <td>pandas</td> <td><a href=\"https://pandas.pydata.org\" target=\"_blank\">https://pandas.pydata.org</a></td> </tr> </tbody> </table>\n<p>Finally, the <code class=\"docutils literal notranslate\"><span class=\"pre\">escape</span></code> argument allows you to control whether the “&lt;”, “&gt;” and “&amp;” characters escaped in the resulting HTML (by default it is <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>). So to get the HTML without escaped characters pass <code class=\"docutils literal notranslate\"><span class=\"pre\">escape=False</span></code></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [316]: df = pd.DataFrame({\"a\": list(\"&amp;&lt;&gt;\"), \"b\": np.random.randn(3)})\n</pre></div> </div> <p>Escaped:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [317]: print(df.to_html())\n&lt;table border=\"1\" class=\"dataframe\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;a&lt;/th&gt;\n      &lt;th&gt;b&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;td&gt;&amp;amp;&lt;/td&gt;\n      &lt;td&gt;-0.474063&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;1&lt;/th&gt;\n      &lt;td&gt;&amp;lt;&lt;/td&gt;\n      &lt;td&gt;-0.230305&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;2&lt;/th&gt;\n      &lt;td&gt;&amp;gt;&lt;/td&gt;\n      &lt;td&gt;-0.400654&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <table border=\"1\" class=\"dataframe\"> <thead> <tr style=\"text-align: right;\"> <th></th> <th>a</th> <th>b</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>&amp;</td> <td>-0.474063</td> </tr> <tr> <th>1</th> <td>&lt;</td> <td>-0.230305</td> </tr> <tr> <th>2</th> <td>&gt;</td> <td>-0.400654</td> </tr> </tbody> </table>\n<p>Not escaped:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [318]: print(df.to_html(escape=False))\n&lt;table border=\"1\" class=\"dataframe\"&gt;\n  &lt;thead&gt;\n    &lt;tr style=\"text-align: right;\"&gt;\n      &lt;th&gt;&lt;/th&gt;\n      &lt;th&gt;a&lt;/th&gt;\n      &lt;th&gt;b&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;0&lt;/th&gt;\n      &lt;td&gt;&amp;&lt;/td&gt;\n      &lt;td&gt;-0.474063&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;1&lt;/th&gt;\n      &lt;td&gt;&lt;&lt;/td&gt;\n      &lt;td&gt;-0.230305&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;2&lt;/th&gt;\n      &lt;td&gt;&gt;&lt;/td&gt;\n      &lt;td&gt;-0.400654&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</pre></div> </div> <table border=\"1\" class=\"dataframe\"> <thead> <tr style=\"text-align: right;\"> <th></th> <th>a</th> <th>b</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>&amp;</td> <td>-0.474063</td> </tr> <tr> <th>1</th> <td>&lt;</td> <td>-0.230305</td> </tr> <tr> <th>2</th> <td>&gt;</td> <td>-0.400654</td> </tr> </tbody> </table>\n<div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Some browsers may not show a difference in the rendering of the previous two HTML tables.</p> </div> </section> <section id=\"html-table-parsing-gotchas\"> <h3>HTML Table Parsing Gotchas</h3> <p>There are some versioning issues surrounding the libraries that are used to parse HTML tables in the top-level pandas io function <code class=\"docutils literal notranslate\"><span class=\"pre\">read_html</span></code>.</p> <p><strong>Issues with</strong> <a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a></p> <ul> <li>\n<p>Benefits</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p><a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> is very fast.</p></li> <li><p><a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> requires Cython to install correctly.</p></li> </ul> </div>\n</blockquote> </li> <li>\n<p>Drawbacks</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p><a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> does <em>not</em> make any guarantees about the results of its parse <em>unless</em> it is given <a class=\"reference external\" href=\"https://validator.w3.org/docs/help.html#validation_basics\"><strong>strictly valid markup</strong></a>.</p></li> <li><p>In light of the above, we have chosen to allow you, the user, to use the <a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> backend, but <strong>this backend will use</strong> <a class=\"reference external\" href=\"https://github.com/html5lib/html5lib-python\"><strong>html5lib</strong></a> if <a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> fails to parse</p></li> <li><p>It is therefore <em>highly recommended</em> that you install both <a class=\"reference external\" href=\"https://www.crummy.com/software/BeautifulSoup\"><strong>BeautifulSoup4</strong></a> and <a class=\"reference external\" href=\"https://github.com/html5lib/html5lib-python\"><strong>html5lib</strong></a>, so that you will still get a valid result (provided everything else is valid) even if <a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> fails.</p></li> </ul> </div>\n</blockquote> </li> </ul> <p><strong>Issues with</strong> <a class=\"reference external\" href=\"https://www.crummy.com/software/BeautifulSoup\"><strong>BeautifulSoup4</strong></a> <strong>using</strong> <a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> <strong>as a backend</strong></p> <ul class=\"simple\"> <li><p>The above issues hold here as well since <a class=\"reference external\" href=\"https://www.crummy.com/software/BeautifulSoup\"><strong>BeautifulSoup4</strong></a> is essentially just a wrapper around a parser backend.</p></li> </ul> <p><strong>Issues with</strong> <a class=\"reference external\" href=\"https://www.crummy.com/software/BeautifulSoup\"><strong>BeautifulSoup4</strong></a> <strong>using</strong> <a class=\"reference external\" href=\"https://github.com/html5lib/html5lib-python\"><strong>html5lib</strong></a> <strong>as a backend</strong></p> <ul> <li>\n<p>Benefits</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p><a class=\"reference external\" href=\"https://github.com/html5lib/html5lib-python\"><strong>html5lib</strong></a> is far more lenient than <a class=\"reference external\" href=\"https://lxml.de\"><strong>lxml</strong></a> and consequently deals with <em>real-life markup</em> in a much saner way rather than just, e.g., dropping an element without notifying you.</p></li> <li><p><a class=\"reference external\" href=\"https://github.com/html5lib/html5lib-python\"><strong>html5lib</strong></a> <em>generates valid HTML5 markup from invalid markup automatically</em>. This is extremely important for parsing HTML tables, since it guarantees a valid document. However, that does NOT mean that it is “correct”, since the process of fixing markup does not have a single definition.</p></li> <li><p><a class=\"reference external\" href=\"https://github.com/html5lib/html5lib-python\"><strong>html5lib</strong></a> is pure Python and requires no additional build steps beyond its own installation.</p></li> </ul> </div>\n</blockquote> </li> <li>\n<p>Drawbacks</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>The biggest drawback to using <a class=\"reference external\" href=\"https://github.com/html5lib/html5lib-python\"><strong>html5lib</strong></a> is that it is slow as molasses. However consider the fact that many tables on the web are not big enough for the parsing algorithm runtime to matter. It is more likely that the bottleneck will be in the process of reading the raw text from the URL over the web, i.e., IO (input-output). For very large tables, this might not be true.</p></li> </ul> </div>\n</blockquote> </li> </ul> </section> </section> <section id=\"latex\"> <h2>LaTeX</h2> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.3.0.</span></p> </div> <p>Currently there are no methods to read from LaTeX, only output methods.</p> <section id=\"writing-to-latex-files\"> <h3>Writing to LaTeX files</h3> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>DataFrame <em>and</em> Styler objects currently have a <code class=\"docutils literal notranslate\"><span class=\"pre\">to_latex</span></code> method. We recommend using the <a class=\"reference internal\" href=\"../reference/api/pandas.io.formats.style.styler.to_latex\"><span class=\"doc\">Styler.to_latex()</span></a> method over <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_latex\"><span class=\"doc\">DataFrame.to_latex()</span></a> due to the former’s greater flexibility with conditional styling, and the latter’s possible future deprecation.</p> </div> <p>Review the documentation for <a class=\"reference internal\" href=\"../reference/api/pandas.io.formats.style.styler.to_latex\"><span class=\"doc\">Styler.to_latex</span></a>, which gives examples of conditional styling and explains the operation of its keyword arguments.</p> <p>For simple application the following pattern is sufficient.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [319]: df = pd.DataFrame([[1, 2], [3, 4]], index=[\"a\", \"b\"], columns=[\"c\", \"d\"])\n\nIn [320]: print(df.style.to_latex())\n\\begin{tabular}{lrr}\n &amp; c &amp; d \\\\\na &amp; 1 &amp; 2 \\\\\nb &amp; 3 &amp; 4 \\\\\n\\end{tabular}\n</pre></div> </div> <p>To format values before output, chain the <a class=\"reference internal\" href=\"../reference/api/pandas.io.formats.style.styler.format\"><span class=\"doc\">Styler.format</span></a> method.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [321]: print(df.style.format(\"€ {}\").to_latex())\n\\begin{tabular}{lrr}\n &amp; c &amp; d \\\\\na &amp; € 1 &amp; € 2 \\\\\nb &amp; € 3 &amp; € 4 \\\\\n\\end{tabular}\n</pre></div> </div> </section> </section> <section id=\"xml\"> <h2>XML</h2> <section id=\"reading-xml\"> <h3>Reading XML</h3> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.3.0.</span></p> </div> <p>The top-level <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_xml()</span></code> function can accept an XML string/file/URL and will parse nodes and attributes into a pandas <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Since there is no standard XML structure where design types can vary in many ways, <code class=\"docutils literal notranslate\"><span class=\"pre\">read_xml</span></code> works best with flatter, shallow versions. If an XML document is deeply nested, use the <code class=\"docutils literal notranslate\"><span class=\"pre\">stylesheet</span></code> feature to transform XML into a flatter version.</p> </div> <p>Let’s look at a few examples.</p> <p>Read an XML string:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [322]: xml = \"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n   .....: &lt;bookstore&gt;\n   .....:   &lt;book category=\"cooking\"&gt;\n   .....:     &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt;\n   .....:     &lt;author&gt;Giada De Laurentiis&lt;/author&gt;\n   .....:     &lt;year&gt;2005&lt;/year&gt;\n   .....:     &lt;price&gt;30.00&lt;/price&gt;\n   .....:   &lt;/book&gt;\n   .....:   &lt;book category=\"children\"&gt;\n   .....:     &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt;\n   .....:     &lt;author&gt;J K. Rowling&lt;/author&gt;\n   .....:     &lt;year&gt;2005&lt;/year&gt;\n   .....:     &lt;price&gt;29.99&lt;/price&gt;\n   .....:   &lt;/book&gt;\n   .....:   &lt;book category=\"web\"&gt;\n   .....:     &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt;\n   .....:     &lt;author&gt;Erik T. Ray&lt;/author&gt;\n   .....:     &lt;year&gt;2003&lt;/year&gt;\n   .....:     &lt;price&gt;39.95&lt;/price&gt;\n   .....:   &lt;/book&gt;\n   .....: &lt;/bookstore&gt;\"\"\"\n   .....: \n\nIn [323]: df = pd.read_xml(xml)\n\nIn [324]: df\nOut[324]: \n   category             title               author  year  price\n0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00\n1  children      Harry Potter         J K. Rowling  2005  29.99\n2       web      Learning XML          Erik T. Ray  2003  39.95\n</pre></div> </div> <p>Read a URL with no options:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [325]: df = pd.read_xml(\"https://www.w3schools.com/xml/books.xml\")\n\nIn [326]: df\nOut[326]: \n   category              title                  author  year  price      cover\n0   cooking   Everyday Italian     Giada De Laurentiis  2005  30.00       None\n1  children       Harry Potter            J K. Rowling  2005  29.99       None\n2       web  XQuery Kick Start  Vaidyanathan Nagarajan  2003  49.99       None\n3       web       Learning XML             Erik T. Ray  2003  39.95  paperback\n</pre></div> </div> <p>Read in the content of the “books.xml” file and pass it to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_xml</span></code> as a string:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [327]: with open(file_path, \"r\") as f:\n   .....:     df = pd.read_xml(f.read())\n   .....: \n\nIn [328]: df\nOut[328]: \n   category             title               author  year  price\n0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00\n1  children      Harry Potter         J K. Rowling  2005  29.99\n2       web      Learning XML          Erik T. Ray  2003  39.95\n</pre></div> </div> <p>Read in the content of the “books.xml” as instance of <code class=\"docutils literal notranslate\"><span class=\"pre\">StringIO</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">BytesIO</span></code> and pass it to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_xml</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [329]: with open(file_path, \"r\") as f:\n   .....:     sio = StringIO(f.read())\n   .....: \n\nIn [330]: df = pd.read_xml(sio)\n\nIn [331]: df\nOut[331]: \n   category             title               author  year  price\n0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00\n1  children      Harry Potter         J K. Rowling  2005  29.99\n2       web      Learning XML          Erik T. Ray  2003  39.95\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [332]: with open(file_path, \"rb\") as f:\n   .....:     bio = BytesIO(f.read())\n   .....: \n\nIn [333]: df = pd.read_xml(bio)\n\nIn [334]: df\nOut[334]: \n   category             title               author  year  price\n0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00\n1  children      Harry Potter         J K. Rowling  2005  29.99\n2       web      Learning XML          Erik T. Ray  2003  39.95\n</pre></div> </div> <p>Even read XML from AWS S3 buckets such as Python Software Foundation’s IRS 990 Form:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [335]: df = pd.read_xml(\n   .....:     \"s3://irs-form-990/201923199349319487_public.xml\",\n   .....:     xpath=\".//irs:Form990PartVIISectionAGrp\",\n   .....:     namespaces={\"irs\": \"http://www.irs.gov/efile\"}\n   .....: )\n   .....: \n\nIn [336]: df\nOut[336]: \n               PersonNm                                 TitleTxt  ...  OtherCompensationAmt  HighestCompensatedEmployeeInd\n0           Naomi Ceder                                    Chair  ...                     0                           None\n1          Van Lindberg              Vice Chair, General Counsel  ...                     0                           None\n2           Kurt Kaiser                                Treasurer  ...                     0                           None\n3         Ewa Jodlowska        Secretary, Director of Operations  ...                     0                           None\n4        Thomas Wouters                     Director, Vice Chair  ...                     0                           None\n..                  ...                                      ...  ...                   ...                            ...\n16        Kenneth Reitz                                 Director  ...                     0                           None\n17     Jeffrey Triplett                                 Director  ...                     0                           None\n18    Betsy Waliszewski   Assistant Secretary, Event Coordinator  ...                     0                           None\n19     Guido van Rossum                                President  ...                     0                           None\n20  Ernest W Durbin III  Director of Infrastructure, PyCon Chair  ...                     0                              X\n\n[21 rows x 10 columns]\n</pre></div> </div> <p>With <a class=\"reference external\" href=\"https://lxml.de\">lxml</a> as default <code class=\"docutils literal notranslate\"><span class=\"pre\">parser</span></code>, you access the full-featured XML library that extends Python’s ElementTree API. One powerful tool is ability to query nodes selectively or conditionally with more expressive XPath:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [337]: df = pd.read_xml(file_path, xpath=\"//book[year=2005]\")\n\nIn [338]: df\nOut[338]: \n   category             title               author  year  price\n0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00\n1  children      Harry Potter         J K. Rowling  2005  29.99\n</pre></div> </div> <p>Specify only elements or only attributes to parse:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [339]: df = pd.read_xml(file_path, elems_only=True)\n\nIn [340]: df\nOut[340]: \n              title               author  year  price\n0  Everyday Italian  Giada De Laurentiis  2005  30.00\n1      Harry Potter         J K. Rowling  2005  29.99\n2      Learning XML          Erik T. Ray  2003  39.95\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [341]: df = pd.read_xml(file_path, attrs_only=True)\n\nIn [342]: df\nOut[342]: \n   category\n0   cooking\n1  children\n2       web\n</pre></div> </div> <p>XML documents can have namespaces with prefixes and default namespaces without prefixes both of which are denoted with a special attribute <code class=\"docutils literal notranslate\"><span class=\"pre\">xmlns</span></code>. In order to parse by node under a namespace context, <code class=\"docutils literal notranslate\"><span class=\"pre\">xpath</span></code> must reference a prefix.</p> <p>For example, below XML contains a namespace with prefix, <code class=\"docutils literal notranslate\"><span class=\"pre\">doc</span></code>, and URI at <code class=\"docutils literal notranslate\"><span class=\"pre\">https://example.com</span></code>. In order to parse <code class=\"docutils literal notranslate\"><span class=\"pre\">doc:row</span></code> nodes, <code class=\"docutils literal notranslate\"><span class=\"pre\">namespaces</span></code> must be used.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [343]: xml = \"\"\"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n   .....: &lt;doc:data xmlns:doc=\"https://example.com\"&gt;\n   .....:   &lt;doc:row&gt;\n   .....:     &lt;doc:shape&gt;square&lt;/doc:shape&gt;\n   .....:     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;\n   .....:     &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;\n   .....:   &lt;/doc:row&gt;\n   .....:   &lt;doc:row&gt;\n   .....:     &lt;doc:shape&gt;circle&lt;/doc:shape&gt;\n   .....:     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;\n   .....:     &lt;doc:sides/&gt;\n   .....:   &lt;/doc:row&gt;\n   .....:   &lt;doc:row&gt;\n   .....:     &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;\n   .....:     &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;\n   .....:     &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;\n   .....:   &lt;/doc:row&gt;\n   .....: &lt;/doc:data&gt;\"\"\"\n   .....: \n\nIn [344]: df = pd.read_xml(xml,\n   .....:                  xpath=\"//doc:row\",\n   .....:                  namespaces={\"doc\": \"https://example.com\"})\n   .....: \n\nIn [345]: df\nOut[345]: \n      shape  degrees  sides\n0    square      360    4.0\n1    circle      360    NaN\n2  triangle      180    3.0\n</pre></div> </div> <p>Similarly, an XML document can have a default namespace without prefix. Failing to assign a temporary prefix will return no nodes and raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code>. But assigning <em>any</em> temporary name to correct URI allows parsing by nodes.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [346]: xml = \"\"\"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n   .....: &lt;data xmlns=\"https://example.com\"&gt;\n   .....:  &lt;row&gt;\n   .....:    &lt;shape&gt;square&lt;/shape&gt;\n   .....:    &lt;degrees&gt;360&lt;/degrees&gt;\n   .....:    &lt;sides&gt;4.0&lt;/sides&gt;\n   .....:  &lt;/row&gt;\n   .....:  &lt;row&gt;\n   .....:    &lt;shape&gt;circle&lt;/shape&gt;\n   .....:    &lt;degrees&gt;360&lt;/degrees&gt;\n   .....:    &lt;sides/&gt;\n   .....:  &lt;/row&gt;\n   .....:  &lt;row&gt;\n   .....:    &lt;shape&gt;triangle&lt;/shape&gt;\n   .....:    &lt;degrees&gt;180&lt;/degrees&gt;\n   .....:    &lt;sides&gt;3.0&lt;/sides&gt;\n   .....:  &lt;/row&gt;\n   .....: &lt;/data&gt;\"\"\"\n   .....: \n\nIn [347]: df = pd.read_xml(xml,\n   .....:                  xpath=\"//pandas:row\",\n   .....:                  namespaces={\"pandas\": \"https://example.com\"})\n   .....: \n\nIn [348]: df\nOut[348]: \n      shape  degrees  sides\n0    square      360    4.0\n1    circle      360    NaN\n2  triangle      180    3.0\n</pre></div> </div> <p>However, if XPath does not reference node names such as default, <code class=\"docutils literal notranslate\"><span class=\"pre\">/*</span></code>, then <code class=\"docutils literal notranslate\"><span class=\"pre\">namespaces</span></code> is not required.</p> <p>With <a class=\"reference external\" href=\"https://lxml.de\">lxml</a> as parser, you can flatten nested XML documents with an XSLT script which also can be string/file/URL types. As background, <a class=\"reference external\" href=\"https://www.w3.org/TR/xslt/\">XSLT</a> is a special-purpose language written in a special XML file that can transform original XML documents into other XML, HTML, even text (CSV, JSON, etc.) using an XSLT processor.</p> <p>For example, consider this somewhat nested structure of Chicago “L” Rides where station and rides elements encapsulate data in their own sections. With below XSLT, <code class=\"docutils literal notranslate\"><span class=\"pre\">lxml</span></code> can transform original nested document into a flatter output (as shown below for demonstration) for easier parse into <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [349]: xml = \"\"\"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n   .....:  &lt;response&gt;\n   .....:   &lt;row&gt;\n   .....:     &lt;station id=\"40850\" name=\"Library\"/&gt;\n   .....:     &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;\n   .....:     &lt;rides&gt;\n   .....:       &lt;avg_weekday_rides&gt;864.2&lt;/avg_weekday_rides&gt;\n   .....:       &lt;avg_saturday_rides&gt;534&lt;/avg_saturday_rides&gt;\n   .....:       &lt;avg_sunday_holiday_rides&gt;417.2&lt;/avg_sunday_holiday_rides&gt;\n   .....:     &lt;/rides&gt;\n   .....:   &lt;/row&gt;\n   .....:   &lt;row&gt;\n   .....:     &lt;station id=\"41700\" name=\"Washington/Wabash\"/&gt;\n   .....:     &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;\n   .....:     &lt;rides&gt;\n   .....:       &lt;avg_weekday_rides&gt;2707.4&lt;/avg_weekday_rides&gt;\n   .....:       &lt;avg_saturday_rides&gt;1909.8&lt;/avg_saturday_rides&gt;\n   .....:       &lt;avg_sunday_holiday_rides&gt;1438.6&lt;/avg_sunday_holiday_rides&gt;\n   .....:     &lt;/rides&gt;\n   .....:   &lt;/row&gt;\n   .....:   &lt;row&gt;\n   .....:     &lt;station id=\"40380\" name=\"Clark/Lake\"/&gt;\n   .....:     &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;\n   .....:     &lt;rides&gt;\n   .....:       &lt;avg_weekday_rides&gt;2949.6&lt;/avg_weekday_rides&gt;\n   .....:       &lt;avg_saturday_rides&gt;1657&lt;/avg_saturday_rides&gt;\n   .....:       &lt;avg_sunday_holiday_rides&gt;1453.8&lt;/avg_sunday_holiday_rides&gt;\n   .....:     &lt;/rides&gt;\n   .....:   &lt;/row&gt;\n   .....:  &lt;/response&gt;\"\"\"\n   .....: \n\nIn [350]: xsl = \"\"\"&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n   .....:    &lt;xsl:output method=\"xml\" omit-xml-declaration=\"no\" indent=\"yes\"/&gt;\n   .....:    &lt;xsl:strip-space elements=\"*\"/&gt;\n   .....:    &lt;xsl:template match=\"/response\"&gt;\n   .....:       &lt;xsl:copy&gt;\n   .....:         &lt;xsl:apply-templates select=\"row\"/&gt;\n   .....:       &lt;/xsl:copy&gt;\n   .....:    &lt;/xsl:template&gt;\n   .....:    &lt;xsl:template match=\"row\"&gt;\n   .....:       &lt;xsl:copy&gt;\n   .....:         &lt;station_id&gt;&lt;xsl:value-of select=\"station/@id\"/&gt;&lt;/station_id&gt;\n   .....:         &lt;station_name&gt;&lt;xsl:value-of select=\"station/@name\"/&gt;&lt;/station_name&gt;\n   .....:         &lt;xsl:copy-of select=\"month|rides/*\"/&gt;\n   .....:       &lt;/xsl:copy&gt;\n   .....:    &lt;/xsl:template&gt;\n   .....:  &lt;/xsl:stylesheet&gt;\"\"\"\n   .....: \n\nIn [351]: output = \"\"\"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n   .....:  &lt;response&gt;\n   .....:    &lt;row&gt;\n   .....:       &lt;station_id&gt;40850&lt;/station_id&gt;\n   .....:       &lt;station_name&gt;Library&lt;/station_name&gt;\n   .....:       &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;\n   .....:       &lt;avg_weekday_rides&gt;864.2&lt;/avg_weekday_rides&gt;\n   .....:       &lt;avg_saturday_rides&gt;534&lt;/avg_saturday_rides&gt;\n   .....:       &lt;avg_sunday_holiday_rides&gt;417.2&lt;/avg_sunday_holiday_rides&gt;\n   .....:    &lt;/row&gt;\n   .....:    &lt;row&gt;\n   .....:       &lt;station_id&gt;41700&lt;/station_id&gt;\n   .....:       &lt;station_name&gt;Washington/Wabash&lt;/station_name&gt;\n   .....:       &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;\n   .....:       &lt;avg_weekday_rides&gt;2707.4&lt;/avg_weekday_rides&gt;\n   .....:       &lt;avg_saturday_rides&gt;1909.8&lt;/avg_saturday_rides&gt;\n   .....:       &lt;avg_sunday_holiday_rides&gt;1438.6&lt;/avg_sunday_holiday_rides&gt;\n   .....:    &lt;/row&gt;\n   .....:    &lt;row&gt;\n   .....:       &lt;station_id&gt;40380&lt;/station_id&gt;\n   .....:       &lt;station_name&gt;Clark/Lake&lt;/station_name&gt;\n   .....:       &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;\n   .....:       &lt;avg_weekday_rides&gt;2949.6&lt;/avg_weekday_rides&gt;\n   .....:       &lt;avg_saturday_rides&gt;1657&lt;/avg_saturday_rides&gt;\n   .....:       &lt;avg_sunday_holiday_rides&gt;1453.8&lt;/avg_sunday_holiday_rides&gt;\n   .....:    &lt;/row&gt;\n   .....:  &lt;/response&gt;\"\"\"\n   .....: \n\nIn [352]: df = pd.read_xml(xml, stylesheet=xsl)\n\nIn [353]: df\nOut[353]: \n   station_id       station_name                month  avg_weekday_rides  avg_saturday_rides  avg_sunday_holiday_rides\n0       40850            Library  2020-09-01T00:00:00              864.2               534.0                     417.2\n1       41700  Washington/Wabash  2020-09-01T00:00:00             2707.4              1909.8                    1438.6\n2       40380         Clark/Lake  2020-09-01T00:00:00             2949.6              1657.0                    1453.8\n</pre></div> </div> </section> <section id=\"writing-xml\"> <h3>Writing XML</h3> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.3.0.</span></p> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> objects have an instance method <code class=\"docutils literal notranslate\"><span class=\"pre\">to_xml</span></code> which renders the contents of the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> as an XML document.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>This method does not support special properties of XML including DTD, CData, XSD schemas, processing instructions, comments, and others. Only namespaces at the root level is supported. However, <code class=\"docutils literal notranslate\"><span class=\"pre\">stylesheet</span></code> allows design changes after initial output.</p> </div> <p>Let’s look at a few examples.</p> <p>Write an XML without options:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [354]: geom_df = pd.DataFrame(\n   .....:     {\n   .....:         \"shape\": [\"square\", \"circle\", \"triangle\"],\n   .....:         \"degrees\": [360, 360, 180],\n   .....:         \"sides\": [4, np.nan, 3],\n   .....:     }\n   .....: )\n   .....: \n\nIn [355]: print(geom_df.to_xml())\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;data&gt;\n  &lt;row&gt;\n    &lt;index&gt;0&lt;/index&gt;\n    &lt;shape&gt;square&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides&gt;4.0&lt;/sides&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;index&gt;1&lt;/index&gt;\n    &lt;shape&gt;circle&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides/&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;index&gt;2&lt;/index&gt;\n    &lt;shape&gt;triangle&lt;/shape&gt;\n    &lt;degrees&gt;180&lt;/degrees&gt;\n    &lt;sides&gt;3.0&lt;/sides&gt;\n  &lt;/row&gt;\n&lt;/data&gt;\n</pre></div> </div> <p>Write an XML with new root and row name:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [356]: print(geom_df.to_xml(root_name=\"geometry\", row_name=\"objects\"))\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;geometry&gt;\n  &lt;objects&gt;\n    &lt;index&gt;0&lt;/index&gt;\n    &lt;shape&gt;square&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides&gt;4.0&lt;/sides&gt;\n  &lt;/objects&gt;\n  &lt;objects&gt;\n    &lt;index&gt;1&lt;/index&gt;\n    &lt;shape&gt;circle&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides/&gt;\n  &lt;/objects&gt;\n  &lt;objects&gt;\n    &lt;index&gt;2&lt;/index&gt;\n    &lt;shape&gt;triangle&lt;/shape&gt;\n    &lt;degrees&gt;180&lt;/degrees&gt;\n    &lt;sides&gt;3.0&lt;/sides&gt;\n  &lt;/objects&gt;\n&lt;/geometry&gt;\n</pre></div> </div> <p>Write an attribute-centric XML:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [357]: print(geom_df.to_xml(attr_cols=geom_df.columns.tolist()))\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;data&gt;\n  &lt;row index=\"0\" shape=\"square\" degrees=\"360\" sides=\"4.0\"/&gt;\n  &lt;row index=\"1\" shape=\"circle\" degrees=\"360\"/&gt;\n  &lt;row index=\"2\" shape=\"triangle\" degrees=\"180\" sides=\"3.0\"/&gt;\n&lt;/data&gt;\n</pre></div> </div> <p>Write a mix of elements and attributes:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [358]: print(\n   .....:     geom_df.to_xml(\n   .....:         index=False,\n   .....:         attr_cols=['shape'],\n   .....:         elem_cols=['degrees', 'sides'])\n   .....: )\n   .....: \n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;data&gt;\n  &lt;row shape=\"square\"&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides&gt;4.0&lt;/sides&gt;\n  &lt;/row&gt;\n  &lt;row shape=\"circle\"&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides/&gt;\n  &lt;/row&gt;\n  &lt;row shape=\"triangle\"&gt;\n    &lt;degrees&gt;180&lt;/degrees&gt;\n    &lt;sides&gt;3.0&lt;/sides&gt;\n  &lt;/row&gt;\n&lt;/data&gt;\n</pre></div> </div> <p>Any <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code> with hierarchical columns will be flattened for XML element names with levels delimited by underscores:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [359]: ext_geom_df = pd.DataFrame(\n   .....:     {\n   .....:         \"type\": [\"polygon\", \"other\", \"polygon\"],\n   .....:         \"shape\": [\"square\", \"circle\", \"triangle\"],\n   .....:         \"degrees\": [360, 360, 180],\n   .....:         \"sides\": [4, np.nan, 3],\n   .....:     }\n   .....: )\n   .....: \n\nIn [360]: pvt_df = ext_geom_df.pivot_table(index='shape',\n   .....:                                  columns='type',\n   .....:                                  values=['degrees', 'sides'],\n   .....:                                  aggfunc='sum')\n   .....: \n\nIn [361]: pvt_df\nOut[361]: \n         degrees         sides        \ntype       other polygon other polygon\nshape                                 \ncircle     360.0     NaN   0.0     NaN\nsquare       NaN   360.0   NaN     4.0\ntriangle     NaN   180.0   NaN     3.0\n\nIn [362]: print(pvt_df.to_xml())\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;data&gt;\n  &lt;row&gt;\n    &lt;shape&gt;circle&lt;/shape&gt;\n    &lt;degrees_other&gt;360.0&lt;/degrees_other&gt;\n    &lt;degrees_polygon/&gt;\n    &lt;sides_other&gt;0.0&lt;/sides_other&gt;\n    &lt;sides_polygon/&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;shape&gt;square&lt;/shape&gt;\n    &lt;degrees_other/&gt;\n    &lt;degrees_polygon&gt;360.0&lt;/degrees_polygon&gt;\n    &lt;sides_other/&gt;\n    &lt;sides_polygon&gt;4.0&lt;/sides_polygon&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;shape&gt;triangle&lt;/shape&gt;\n    &lt;degrees_other/&gt;\n    &lt;degrees_polygon&gt;180.0&lt;/degrees_polygon&gt;\n    &lt;sides_other/&gt;\n    &lt;sides_polygon&gt;3.0&lt;/sides_polygon&gt;\n  &lt;/row&gt;\n&lt;/data&gt;\n</pre></div> </div> <p>Write an XML with default namespace:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [363]: print(geom_df.to_xml(namespaces={\"\": \"https://example.com\"}))\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;data xmlns=\"https://example.com\"&gt;\n  &lt;row&gt;\n    &lt;index&gt;0&lt;/index&gt;\n    &lt;shape&gt;square&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides&gt;4.0&lt;/sides&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;index&gt;1&lt;/index&gt;\n    &lt;shape&gt;circle&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides/&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;index&gt;2&lt;/index&gt;\n    &lt;shape&gt;triangle&lt;/shape&gt;\n    &lt;degrees&gt;180&lt;/degrees&gt;\n    &lt;sides&gt;3.0&lt;/sides&gt;\n  &lt;/row&gt;\n&lt;/data&gt;\n</pre></div> </div> <p>Write an XML with namespace prefix:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [364]: print(\n   .....:     geom_df.to_xml(namespaces={\"doc\": \"https://example.com\"},\n   .....:                    prefix=\"doc\")\n   .....: )\n   .....: \n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;doc:data xmlns:doc=\"https://example.com\"&gt;\n  &lt;doc:row&gt;\n    &lt;doc:index&gt;0&lt;/doc:index&gt;\n    &lt;doc:shape&gt;square&lt;/doc:shape&gt;\n    &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;\n    &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;\n  &lt;/doc:row&gt;\n  &lt;doc:row&gt;\n    &lt;doc:index&gt;1&lt;/doc:index&gt;\n    &lt;doc:shape&gt;circle&lt;/doc:shape&gt;\n    &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;\n    &lt;doc:sides/&gt;\n  &lt;/doc:row&gt;\n  &lt;doc:row&gt;\n    &lt;doc:index&gt;2&lt;/doc:index&gt;\n    &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;\n    &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;\n    &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;\n  &lt;/doc:row&gt;\n&lt;/doc:data&gt;\n</pre></div> </div> <p>Write an XML without declaration or pretty print:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [365]: print(\n   .....:     geom_df.to_xml(xml_declaration=False,\n   .....:                    pretty_print=False)\n   .....: )\n   .....: \n&lt;data&gt;&lt;row&gt;&lt;index&gt;0&lt;/index&gt;&lt;shape&gt;square&lt;/shape&gt;&lt;degrees&gt;360&lt;/degrees&gt;&lt;sides&gt;4.0&lt;/sides&gt;&lt;/row&gt;&lt;row&gt;&lt;index&gt;1&lt;/index&gt;&lt;shape&gt;circle&lt;/shape&gt;&lt;degrees&gt;360&lt;/degrees&gt;&lt;sides/&gt;&lt;/row&gt;&lt;row&gt;&lt;index&gt;2&lt;/index&gt;&lt;shape&gt;triangle&lt;/shape&gt;&lt;degrees&gt;180&lt;/degrees&gt;&lt;sides&gt;3.0&lt;/sides&gt;&lt;/row&gt;&lt;/data&gt;\n</pre></div> </div> <p>Write an XML and transform with stylesheet:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [366]: xsl = \"\"\"&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n   .....:    &lt;xsl:output method=\"xml\" omit-xml-declaration=\"no\" indent=\"yes\"/&gt;\n   .....:    &lt;xsl:strip-space elements=\"*\"/&gt;\n   .....:    &lt;xsl:template match=\"/data\"&gt;\n   .....:      &lt;geometry&gt;\n   .....:        &lt;xsl:apply-templates select=\"row\"/&gt;\n   .....:      &lt;/geometry&gt;\n   .....:    &lt;/xsl:template&gt;\n   .....:    &lt;xsl:template match=\"row\"&gt;\n   .....:      &lt;object index=\"{index}\"&gt;\n   .....:        &lt;xsl:if test=\"shape!='circle'\"&gt;\n   .....:            &lt;xsl:attribute name=\"type\"&gt;polygon&lt;/xsl:attribute&gt;\n   .....:        &lt;/xsl:if&gt;\n   .....:        &lt;xsl:copy-of select=\"shape\"/&gt;\n   .....:        &lt;property&gt;\n   .....:            &lt;xsl:copy-of select=\"degrees|sides\"/&gt;\n   .....:        &lt;/property&gt;\n   .....:      &lt;/object&gt;\n   .....:    &lt;/xsl:template&gt;\n   .....:  &lt;/xsl:stylesheet&gt;\"\"\"\n   .....: \n\nIn [367]: print(geom_df.to_xml(stylesheet=xsl))\n&lt;?xml version=\"1.0\"?&gt;\n&lt;geometry&gt;\n  &lt;object index=\"0\" type=\"polygon\"&gt;\n    &lt;shape&gt;square&lt;/shape&gt;\n    &lt;property&gt;\n      &lt;degrees&gt;360&lt;/degrees&gt;\n      &lt;sides&gt;4.0&lt;/sides&gt;\n    &lt;/property&gt;\n  &lt;/object&gt;\n  &lt;object index=\"1\"&gt;\n    &lt;shape&gt;circle&lt;/shape&gt;\n    &lt;property&gt;\n      &lt;degrees&gt;360&lt;/degrees&gt;\n      &lt;sides/&gt;\n    &lt;/property&gt;\n  &lt;/object&gt;\n  &lt;object index=\"2\" type=\"polygon\"&gt;\n    &lt;shape&gt;triangle&lt;/shape&gt;\n    &lt;property&gt;\n      &lt;degrees&gt;180&lt;/degrees&gt;\n      &lt;sides&gt;3.0&lt;/sides&gt;\n    &lt;/property&gt;\n  &lt;/object&gt;\n&lt;/geometry&gt;\n</pre></div> </div> </section> <section id=\"xml-final-notes\"> <h3>XML Final Notes</h3> <ul class=\"simple\"> <li><p>All XML documents adhere to <a class=\"reference external\" href=\"https://www.w3.org/TR/xml/\">W3C specifications</a>. Both <code class=\"docutils literal notranslate\"><span class=\"pre\">etree</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">lxml</span></code> parsers will fail to parse any markup document that is not well-formed or follows XML syntax rules. Do be aware HTML is not an XML document unless it follows XHTML specs. However, other popular markup types including KML, XAML, RSS, MusicML, MathML are compliant <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/List_of_types_of_XML_schemas\">XML schemas</a>.</p></li> <li><p>For above reason, if your application builds XML prior to pandas operations, use appropriate DOM libraries like <code class=\"docutils literal notranslate\"><span class=\"pre\">etree</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">lxml</span></code> to build the necessary document and not by string concatenation or regex adjustments. Always remember XML is a <em>special</em> text file with markup rules.</p></li> <li><p>With very large XML files (several hundred MBs to GBs), XPath and XSLT can become memory-intensive operations. Be sure to have enough available RAM for reading and writing to large XML files (roughly about 5 times the size of text).</p></li> <li><p>Because XSLT is a programming language, use it with caution since such scripts can pose a security risk in your environment and can run large or infinite recursive operations. Always test scripts on small fragments before full run.</p></li> <li><p>The <a class=\"reference external\" href=\"https://docs.python.org/3/library/xml.etree.elementtree.html\">etree</a> parser supports all functionality of both <code class=\"docutils literal notranslate\"><span class=\"pre\">read_xml</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">to_xml</span></code> except for complex XPath and any XSLT. Though limited in features, <code class=\"docutils literal notranslate\"><span class=\"pre\">etree</span></code> is still a reliable and capable parser and tree builder. Its performance may trail <code class=\"docutils literal notranslate\"><span class=\"pre\">lxml</span></code> to a certain degree for larger files but relatively unnoticeable on small to medium size files.</p></li> </ul> </section> </section> <section id=\"excel-files\"> <h2>Excel files</h2> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.read_excel#pandas.read_excel\" title=\"pandas.read_excel\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_excel()</span></code></a> method can read Excel 2007+ (<code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsx</span></code>) files using the <code class=\"docutils literal notranslate\"><span class=\"pre\">openpyxl</span></code> Python module. Excel 2003 (<code class=\"docutils literal notranslate\"><span class=\"pre\">.xls</span></code>) files can be read using <code class=\"docutils literal notranslate\"><span class=\"pre\">xlrd</span></code>. Binary Excel (<code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsb</span></code>) files can be read using <code class=\"docutils literal notranslate\"><span class=\"pre\">pyxlsb</span></code>. The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_excel#pandas.DataFrame.to_excel\" title=\"pandas.DataFrame.to_excel\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">to_excel()</span></code></a> instance method is used for saving a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> to Excel. Generally the semantics are similar to working with <a class=\"reference internal\" href=\"#io-read-csv-table\"><span class=\"std std-ref\">csv</span></a> data. See the <a class=\"reference internal\" href=\"cookbook#cookbook-excel\"><span class=\"std std-ref\">cookbook</span></a> for some advanced strategies.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>The <a class=\"reference external\" href=\"https://xlwt.readthedocs.io/en/latest/\">xlwt</a> package for writing old-style <code class=\"docutils literal notranslate\"><span class=\"pre\">.xls</span></code> excel files is no longer maintained. The <a class=\"reference external\" href=\"https://xlrd.readthedocs.io/en/latest/\">xlrd</a> package is now only for reading old-style <code class=\"docutils literal notranslate\"><span class=\"pre\">.xls</span></code> files.</p> <p>Before pandas 1.3.0, the default argument <code class=\"docutils literal notranslate\"><span class=\"pre\">engine=None</span></code> to <a class=\"reference internal\" href=\"../reference/api/pandas.read_excel#pandas.read_excel\" title=\"pandas.read_excel\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_excel()</span></code></a> would result in using the <code class=\"docutils literal notranslate\"><span class=\"pre\">xlrd</span></code> engine in many cases, including new Excel 2007+ (<code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsx</span></code>) files. pandas will now default to using the <a class=\"reference external\" href=\"https://openpyxl.readthedocs.io/en/stable/\">openpyxl</a> engine.</p> <p>It is strongly encouraged to install <code class=\"docutils literal notranslate\"><span class=\"pre\">openpyxl</span></code> to read Excel 2007+ (<code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsx</span></code>) files. <strong>Please do not report issues when using ``xlrd`` to read ``.xlsx`` files.</strong> This is no longer supported, switch to using <code class=\"docutils literal notranslate\"><span class=\"pre\">openpyxl</span></code> instead.</p> <p>Attempting to use the the <code class=\"docutils literal notranslate\"><span class=\"pre\">xlwt</span></code> engine will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">FutureWarning</span></code> unless the option <code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">io.excel.xls.writer</span></code> is set to <code class=\"docutils literal notranslate\"><span class=\"pre\">\"xlwt\"</span></code>. While this option is now deprecated and will also raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">FutureWarning</span></code>, it can be globally set and the warning suppressed. Users are recommended to write <code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsx</span></code> files using the <code class=\"docutils literal notranslate\"><span class=\"pre\">openpyxl</span></code> engine instead.</p> </div> <section id=\"reading-excel-files\"> <h3>Reading Excel files</h3> <p>In the most basic use-case, <code class=\"docutils literal notranslate\"><span class=\"pre\">read_excel</span></code> takes a path to an Excel file, and the <code class=\"docutils literal notranslate\"><span class=\"pre\">sheet_name</span></code> indicating which sheet to parse.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns a DataFrame\npd.read_excel(\"path_to_file.xls\", sheet_name=\"Sheet1\")\n</pre></div> </div> <section id=\"excelfile-class\"> <h4>\n<code class=\"docutils literal notranslate\"><span class=\"pre\">ExcelFile</span></code> class</h4> <p>To facilitate working with multiple sheets from the same file, the <code class=\"docutils literal notranslate\"><span class=\"pre\">ExcelFile</span></code> class can be used to wrap the file and can be passed into <code class=\"docutils literal notranslate\"><span class=\"pre\">read_excel</span></code> There will be a performance benefit for reading multiple sheets as the file is read into memory only once.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">xlsx = pd.ExcelFile(\"path_to_file.xls\")\ndf = pd.read_excel(xlsx, \"Sheet1\")\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">ExcelFile</span></code> class can also be used as a context manager.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">with pd.ExcelFile(\"path_to_file.xls\") as xls:\n    df1 = pd.read_excel(xls, \"Sheet1\")\n    df2 = pd.read_excel(xls, \"Sheet2\")\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">sheet_names</span></code> property will generate a list of the sheet names in the file.</p> <p>The primary use-case for an <code class=\"docutils literal notranslate\"><span class=\"pre\">ExcelFile</span></code> is parsing multiple sheets with different parameters:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">data = {}\n# For when Sheet1's format differs from Sheet2\nwith pd.ExcelFile(\"path_to_file.xls\") as xls:\n    data[\"Sheet1\"] = pd.read_excel(xls, \"Sheet1\", index_col=None, na_values=[\"NA\"])\n    data[\"Sheet2\"] = pd.read_excel(xls, \"Sheet2\", index_col=1)\n</pre></div> </div> <p>Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to <code class=\"docutils literal notranslate\"><span class=\"pre\">read_excel</span></code> with no loss in performance.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># using the ExcelFile class\ndata = {}\nwith pd.ExcelFile(\"path_to_file.xls\") as xls:\n    data[\"Sheet1\"] = pd.read_excel(xls, \"Sheet1\", index_col=None, na_values=[\"NA\"])\n    data[\"Sheet2\"] = pd.read_excel(xls, \"Sheet2\", index_col=None, na_values=[\"NA\"])\n\n# equivalent using the read_excel function\ndata = pd.read_excel(\n    \"path_to_file.xls\", [\"Sheet1\", \"Sheet2\"], index_col=None, na_values=[\"NA\"]\n)\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">ExcelFile</span></code> can also be called with a <code class=\"docutils literal notranslate\"><span class=\"pre\">xlrd.book.Book</span></code> object as a parameter. This allows the user to control how the excel file is read. For example, sheets can be loaded on demand by calling <code class=\"docutils literal notranslate\"><span class=\"pre\">xlrd.open_workbook()</span></code> with <code class=\"docutils literal notranslate\"><span class=\"pre\">on_demand=True</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">import xlrd\n\nxlrd_book = xlrd.open_workbook(\"path_to_file.xls\", on_demand=True)\nwith pd.ExcelFile(xlrd_book) as xls:\n    df1 = pd.read_excel(xls, \"Sheet1\")\n    df2 = pd.read_excel(xls, \"Sheet2\")\n</pre></div> </div> </section> <section id=\"specifying-sheets\"> <h4>Specifying sheets</h4> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The second argument is <code class=\"docutils literal notranslate\"><span class=\"pre\">sheet_name</span></code>, not to be confused with <code class=\"docutils literal notranslate\"><span class=\"pre\">ExcelFile.sheet_names</span></code>.</p> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>An ExcelFile’s attribute <code class=\"docutils literal notranslate\"><span class=\"pre\">sheet_names</span></code> provides access to a list of sheets.</p> </div> <ul class=\"simple\"> <li><p>The arguments <code class=\"docutils literal notranslate\"><span class=\"pre\">sheet_name</span></code> allows specifying the sheet or sheets to read.</p></li> <li><p>The default value for <code class=\"docutils literal notranslate\"><span class=\"pre\">sheet_name</span></code> is 0, indicating to read the first sheet</p></li> <li><p>Pass a string to refer to the name of a particular sheet in the workbook.</p></li> <li><p>Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0.</p></li> <li><p>Pass a list of either strings or integers, to return a dictionary of specified sheets.</p></li> <li><p>Pass a <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> to return a dictionary of all available sheets.</p></li> </ul> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns a DataFrame\npd.read_excel(\"path_to_file.xls\", \"Sheet1\", index_col=None, na_values=[\"NA\"])\n</pre></div> </div> <p>Using the sheet index:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns a DataFrame\npd.read_excel(\"path_to_file.xls\", 0, index_col=None, na_values=[\"NA\"])\n</pre></div> </div> <p>Using all default values:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns a DataFrame\npd.read_excel(\"path_to_file.xls\")\n</pre></div> </div> <p>Using None to get all sheets:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns a dictionary of DataFrames\npd.read_excel(\"path_to_file.xls\", sheet_name=None)\n</pre></div> </div> <p>Using a list to get multiple sheets:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns the 1st and 4th sheet, as a dictionary of DataFrames.\npd.read_excel(\"path_to_file.xls\", sheet_name=[\"Sheet1\", 3])\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">read_excel</span></code> can read more than one sheet, by setting <code class=\"docutils literal notranslate\"><span class=\"pre\">sheet_name</span></code> to either a list of sheet names, a list of sheet positions, or <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> to read all sheets. Sheets can be specified by sheet index or sheet name, using an integer or string, respectively.</p> </section> <section id=\"reading-a-multiindex\"> <h4>Reading a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code>\n</h4> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">read_excel</span></code> can read a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> index, by passing a list of columns to <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col</span></code> and a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> column by passing a list of rows to <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code>. If either the <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> have serialized level names those will be read in as well by specifying the rows/columns that make up the levels.</p> <p>For example, to read in a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> index without names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [368]: df = pd.DataFrame(\n   .....:     {\"a\": [1, 2, 3, 4], \"b\": [5, 6, 7, 8]},\n   .....:     index=pd.MultiIndex.from_product([[\"a\", \"b\"], [\"c\", \"d\"]]),\n   .....: )\n   .....: \n\nIn [369]: df.to_excel(\"path_to_file.xlsx\")\n\nIn [370]: df = pd.read_excel(\"path_to_file.xlsx\", index_col=[0, 1])\n\nIn [371]: df\nOut[371]: \n     a  b\na c  1  5\n  d  2  6\nb c  3  7\n  d  4  8\n</pre></div> </div> <p>If the index has level names, they will parsed as well, using the same parameters.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [372]: df.index = df.index.set_names([\"lvl1\", \"lvl2\"])\n\nIn [373]: df.to_excel(\"path_to_file.xlsx\")\n\nIn [374]: df = pd.read_excel(\"path_to_file.xlsx\", index_col=[0, 1])\n\nIn [375]: df\nOut[375]: \n           a  b\nlvl1 lvl2      \na    c     1  5\n     d     2  6\nb    c     3  7\n     d     4  8\n</pre></div> </div> <p>If the source file has both <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> index and columns, lists specifying each should be passed to <code class=\"docutils literal notranslate\"><span class=\"pre\">index_col</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">header</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [376]: df.columns = pd.MultiIndex.from_product([[\"a\"], [\"b\", \"d\"]], names=[\"c1\", \"c2\"])\n\nIn [377]: df.to_excel(\"path_to_file.xlsx\")\n\nIn [378]: df = pd.read_excel(\"path_to_file.xlsx\", index_col=[0, 1], header=[0, 1])\n\nIn [379]: df\nOut[379]: \nc1         a   \nc2         b  d\nlvl1 lvl2      \na    c     1  5\n     d     2  6\nb    c     3  7\n     d     4  8\n</pre></div> </div> </section> <section id=\"parsing-specific-columns\"> <h4>Parsing specific columns</h4> <p>It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. <code class=\"docutils literal notranslate\"><span class=\"pre\">read_excel</span></code> takes a <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> keyword to allow you to specify a subset of columns to parse.</p> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 1.0.0.</span></p> </div> <p>Passing in an integer for <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> will no longer work. Please pass in a list of ints from 0 to <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> inclusive instead.</p> <p>You can specify a comma-delimited set of Excel columns and ranges as a string:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_excel(\"path_to_file.xls\", \"Sheet1\", usecols=\"A,C:E\")\n</pre></div> </div> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> is a list of integers, then it is assumed to be the file column indices to be parsed.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_excel(\"path_to_file.xls\", \"Sheet1\", usecols=[0, 2, 3])\n</pre></div> </div> <p>Element order is ignored, so <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols=[0,</span> <span class=\"pre\">1]</span></code> is the same as <code class=\"docutils literal notranslate\"><span class=\"pre\">[1,</span> <span class=\"pre\">0]</span></code>.</p> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in <code class=\"docutils literal notranslate\"><span class=\"pre\">names</span></code> or inferred from the document header row(s). Those strings define which columns will be parsed:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_excel(\"path_to_file.xls\", \"Sheet1\", usecols=[\"foo\", \"bar\"])\n</pre></div> </div> <p>Element order is ignored, so <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols=['baz',</span> <span class=\"pre\">'joe']</span></code> is the same as <code class=\"docutils literal notranslate\"><span class=\"pre\">['joe',</span> <span class=\"pre\">'baz']</span></code>.</p> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_excel(\"path_to_file.xls\", \"Sheet1\", usecols=lambda x: x.isalpha())\n</pre></div> </div> </section> <section id=\"parsing-dates\"> <h4>Parsing dates</h4> <p>Datetime-like values are normally automatically converted to the appropriate dtype when reading the excel file. But if you have a column of strings that <em>look</em> like dates (but are not actually formatted as dates in excel), you can use the <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_dates</span></code> keyword to parse those strings to datetimes:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_excel(\"path_to_file.xls\", \"Sheet1\", parse_dates=[\"date_strings\"])\n</pre></div> </div> </section> <section id=\"cell-converters\"> <h4>Cell converters</h4> <p>It is possible to transform the contents of Excel cells via the <code class=\"docutils literal notranslate\"><span class=\"pre\">converters</span></code> option. For instance, to convert a column to boolean:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_excel(\"path_to_file.xls\", \"Sheet1\", converters={\"MyBools\": bool})\n</pre></div> </div> <p>This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">def cfun(x):\n    return int(x) if x else -1\n\n\npd.read_excel(\"path_to_file.xls\", \"Sheet1\", converters={\"MyInts\": cfun})\n</pre></div> </div> </section> <section id=\"dtype-specifications\"> <h4>Dtype specifications</h4> <p>As an alternative to converters, the type for an entire column can be specified using the <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> keyword, which takes a dictionary mapping column names to types. To interpret data with no type inference, use the type <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_excel(\"path_to_file.xls\", dtype={\"MyInts\": \"int64\", \"MyText\": str})\n</pre></div> </div> </section> </section> <section id=\"writing-excel-files\"> <h3>Writing Excel files</h3> <section id=\"writing-excel-files-to-disk\"> <h4>Writing Excel files to disk</h4> <p>To write a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> object to a sheet of an Excel file, you can use the <code class=\"docutils literal notranslate\"><span class=\"pre\">to_excel</span></code> instance method. The arguments are largely the same as <code class=\"docutils literal notranslate\"><span class=\"pre\">to_csv</span></code> described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> should be written. For example:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df.to_excel(\"path_to_file.xlsx\", sheet_name=\"Sheet1\")\n</pre></div> </div> <p>Files with a <code class=\"docutils literal notranslate\"><span class=\"pre\">.xls</span></code> extension will be written using <code class=\"docutils literal notranslate\"><span class=\"pre\">xlwt</span></code> and those with a <code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsx</span></code> extension will be written using <code class=\"docutils literal notranslate\"><span class=\"pre\">xlsxwriter</span></code> (if available) or <code class=\"docutils literal notranslate\"><span class=\"pre\">openpyxl</span></code>.</p> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> will be written in a way that tries to mimic the REPL output. The <code class=\"docutils literal notranslate\"><span class=\"pre\">index_label</span></code> will be placed in the second row instead of the first. You can place it in the first row by setting the <code class=\"docutils literal notranslate\"><span class=\"pre\">merge_cells</span></code> option in <code class=\"docutils literal notranslate\"><span class=\"pre\">to_excel()</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df.to_excel(\"path_to_file.xlsx\", index_label=\"label\", merge_cells=False)\n</pre></div> </div> <p>In order to write separate <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code> to separate sheets in a single Excel file, one can pass an <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExcelWriter</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">with pd.ExcelWriter(\"path_to_file.xlsx\") as writer:\n    df1.to_excel(writer, sheet_name=\"Sheet1\")\n    df2.to_excel(writer, sheet_name=\"Sheet2\")\n</pre></div> </div> </section> <section id=\"writing-excel-files-to-memory\"> <h4>Writing Excel files to memory</h4> <p>pandas supports writing Excel files to buffer-like objects such as <code class=\"docutils literal notranslate\"><span class=\"pre\">StringIO</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">BytesIO</span></code> using <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExcelWriter</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">from io import BytesIO\n\nbio = BytesIO()\n\n# By setting the 'engine' in the ExcelWriter constructor.\nwriter = pd.ExcelWriter(bio, engine=\"xlsxwriter\")\ndf.to_excel(writer, sheet_name=\"Sheet1\")\n\n# Save the workbook\nwriter.save()\n\n# Seek to the beginning and read to copy the workbook to a variable in memory\nbio.seek(0)\nworkbook = bio.read()\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">engine</span></code> is optional but recommended. Setting the engine determines the version of workbook produced. Setting <code class=\"docutils literal notranslate\"><span class=\"pre\">engine='xlrd'</span></code> will produce an Excel 2003-format workbook (xls). Using either <code class=\"docutils literal notranslate\"><span class=\"pre\">'openpyxl'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'xlsxwriter'</span></code> will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced.</p> </div> </section> </section> <section id=\"excel-writer-engines\"> <h3>Excel writer engines</h3> <div class=\"deprecated\"> <p><span class=\"versionmodified deprecated\">Deprecated since version 1.2.0: </span>As the <a class=\"reference external\" href=\"https://pypi.org/project/xlwt/\">xlwt</a> package is no longer maintained, the <code class=\"docutils literal notranslate\"><span class=\"pre\">xlwt</span></code> engine will be removed from a future version of pandas. This is the only engine in pandas that supports writing to <code class=\"docutils literal notranslate\"><span class=\"pre\">.xls</span></code> files.</p> </div> <p>pandas chooses an Excel writer via two methods:</p> <ol class=\"arabic simple\"> <li><p>the <code class=\"docutils literal notranslate\"><span class=\"pre\">engine</span></code> keyword argument</p></li> <li><p>the filename extension (via the default specified in config options)</p></li> </ol> <p>By default, pandas uses the <a class=\"reference external\" href=\"https://xlsxwriter.readthedocs.io\">XlsxWriter</a> for <code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsx</span></code>, <a class=\"reference external\" href=\"https://openpyxl.readthedocs.io/\">openpyxl</a> for <code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsm</span></code>, and <a class=\"reference external\" href=\"http://www.python-excel.org\">xlwt</a> for <code class=\"docutils literal notranslate\"><span class=\"pre\">.xls</span></code> files. If you have multiple engines installed, you can set the default engine through <a class=\"reference internal\" href=\"options#options\"><span class=\"std std-ref\">setting the config options</span></a> <code class=\"docutils literal notranslate\"><span class=\"pre\">io.excel.xlsx.writer</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">io.excel.xls.writer</span></code>. pandas will fall back on <a class=\"reference external\" href=\"https://openpyxl.readthedocs.io/\">openpyxl</a> for <code class=\"docutils literal notranslate\"><span class=\"pre\">.xlsx</span></code> files if <a class=\"reference external\" href=\"https://xlsxwriter.readthedocs.io\">Xlsxwriter</a> is not available.</p> <p>To specify which writer you want to use, you can pass an engine keyword argument to <code class=\"docutils literal notranslate\"><span class=\"pre\">to_excel</span></code> and to <code class=\"docutils literal notranslate\"><span class=\"pre\">ExcelWriter</span></code>. The built-in engines are:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">openpyxl</span></code>: version 2.4 or higher is required</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">xlsxwriter</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">xlwt</span></code></p></li> </ul> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># By setting the 'engine' in the DataFrame 'to_excel()' methods.\ndf.to_excel(\"path_to_file.xlsx\", sheet_name=\"Sheet1\", engine=\"xlsxwriter\")\n\n# By setting the 'engine' in the ExcelWriter constructor.\nwriter = pd.ExcelWriter(\"path_to_file.xlsx\", engine=\"xlsxwriter\")\n\n# Or via pandas configuration.\nfrom pandas import options  # noqa: E402\n\noptions.io.excel.xlsx.writer = \"xlsxwriter\"\n\ndf.to_excel(\"path_to_file.xlsx\", sheet_name=\"Sheet1\")\n</pre></div> </div> </section> <section id=\"style-and-formatting\"> <h3>Style and formatting</h3> <p>The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>’s <code class=\"docutils literal notranslate\"><span class=\"pre\">to_excel</span></code> method.</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">float_format</span></code> : Format string for floating point numbers (default <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>).</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">freeze_panes</span></code> : A tuple of two integers representing the bottommost row and rightmost column to freeze. Each of these parameters is one-based, so (1, 1) will freeze the first row and first column (default <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>).</p></li> </ul> <p>Using the <a class=\"reference external\" href=\"https://xlsxwriter.readthedocs.io\">Xlsxwriter</a> engine provides many options for controlling the format of an Excel worksheet created with the <code class=\"docutils literal notranslate\"><span class=\"pre\">to_excel</span></code> method. Excellent examples can be found in the <a class=\"reference external\" href=\"https://xlsxwriter.readthedocs.io\">Xlsxwriter</a> documentation here: <a class=\"reference external\" href=\"https://xlsxwriter.readthedocs.io/working_with_pandas.html\">https://xlsxwriter.readthedocs.io/working_with_pandas.html</a></p> </section> </section> <section id=\"opendocument-spreadsheets\"> <h2>OpenDocument Spreadsheets</h2> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 0.25.</span></p> </div> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.read_excel#pandas.read_excel\" title=\"pandas.read_excel\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_excel()</span></code></a> method can also read OpenDocument spreadsheets using the <code class=\"docutils literal notranslate\"><span class=\"pre\">odfpy</span></code> module. The semantics and features for reading OpenDocument spreadsheets match what can be done for <a class=\"reference internal\" href=\"#excel-files\">Excel files</a> using <code class=\"docutils literal notranslate\"><span class=\"pre\">engine='odf'</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns a DataFrame\npd.read_excel(\"path_to_file.ods\", engine=\"odf\")\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Currently pandas only supports <em>reading</em> OpenDocument spreadsheets. Writing is not implemented.</p> </div> </section> <section id=\"binary-excel-xlsb-files\"> <h2>Binary Excel (.xlsb) files</h2> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.0.0.</span></p> </div> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.read_excel#pandas.read_excel\" title=\"pandas.read_excel\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_excel()</span></code></a> method can also read binary Excel files using the <code class=\"docutils literal notranslate\"><span class=\"pre\">pyxlsb</span></code> module. The semantics and features for reading binary Excel files mostly match what can be done for <a class=\"reference internal\" href=\"#excel-files\">Excel files</a> using <code class=\"docutils literal notranslate\"><span class=\"pre\">engine='pyxlsb'</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">pyxlsb</span></code> does not recognize datetime types in files and will return floats instead.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Returns a DataFrame\npd.read_excel(\"path_to_file.xlsb\", engine=\"pyxlsb\")\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Currently pandas only supports <em>reading</em> binary Excel files. Writing is not implemented.</p> </div> </section> <section id=\"clipboard\"> <h2>Clipboard</h2> <p>A handy way to grab data is to use the <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">read_clipboard()</span></code> method, which takes the contents of the clipboard buffer and passes them to the <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> method. For instance, you can copy the following text to the clipboard (CTRL-C on many operating systems):</p> <div class=\"highlight-console notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">  A B C\nx 1 4 p\ny 2 5 q\nz 3 6 r\n</pre></div> </div> <p>And then import the data directly to a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> by calling:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; clipdf = pd.read_clipboard()\n&gt;&gt;&gt; clipdf\n  A B C\nx 1 4 p\ny 2 5 q\nz 3 6 r\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">to_clipboard</span></code> method can be used to write the contents of a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> to the clipboard. Following which you can paste the clipboard contents into other applications (CTRL-V on many operating systems). Here we illustrate writing a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> into clipboard and reading it back.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; df = pd.DataFrame(\n...     {\"A\": [1, 2, 3], \"B\": [4, 5, 6], \"C\": [\"p\", \"q\", \"r\"]}, index=[\"x\", \"y\", \"z\"]\n... )\n\n&gt;&gt;&gt; df\n  A B C\nx 1 4 p\ny 2 5 q\nz 3 6 r\n&gt;&gt;&gt; df.to_clipboard()\n&gt;&gt;&gt; pd.read_clipboard()\n  A B C\nx 1 4 p\ny 2 5 q\nz 3 6 r\n</pre></div> </div> <p>We can see that we got the same content back, which we had earlier written to the clipboard.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>You may need to install xclip or xsel (with PyQt5, PyQt4 or qtpy) on Linux to use these methods.</p> </div> </section> <section id=\"pickling\"> <h2>Pickling</h2> <p>All pandas objects are equipped with <code class=\"docutils literal notranslate\"><span class=\"pre\">to_pickle</span></code> methods which use Python’s <code class=\"docutils literal notranslate\"><span class=\"pre\">cPickle</span></code> module to save data structures to disk using the pickle format.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [380]: df\nOut[380]: \nc1         a   \nc2         b  d\nlvl1 lvl2      \na    c     1  5\n     d     2  6\nb    c     3  7\n     d     4  8\n\nIn [381]: df.to_pickle(\"foo.pkl\")\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">read_pickle</span></code> function in the <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas</span></code> namespace can be used to load any pickled pandas object (or any other pickled object) from file:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [382]: pd.read_pickle(\"foo.pkl\")\nOut[382]: \nc1         a   \nc2         b  d\nlvl1 lvl2      \na    c     1  5\n     d     2  6\nb    c     3  7\n     d     4  8\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Loading pickled data received from untrusted sources can be unsafe.</p> <p>See: <a class=\"reference external\" href=\"https://docs.python.org/3/library/pickle.html\">https://docs.python.org/3/library/pickle.html</a></p> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.read_pickle#pandas.read_pickle\" title=\"pandas.read_pickle\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_pickle()</span></code></a> is only guaranteed backwards compatible back to pandas version 0.20.3</p> </div> <section id=\"compressed-pickle-files\"> <h3>Compressed pickle files</h3> <p><a class=\"reference internal\" href=\"../reference/api/pandas.read_pickle#pandas.read_pickle\" title=\"pandas.read_pickle\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_pickle()</span></code></a>, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_pickle#pandas.DataFrame.to_pickle\" title=\"pandas.DataFrame.to_pickle\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">DataFrame.to_pickle()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.series.to_pickle#pandas.Series.to_pickle\" title=\"pandas.Series.to_pickle\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Series.to_pickle()</span></code></a> can read and write compressed pickle files. The compression types of <code class=\"docutils literal notranslate\"><span class=\"pre\">gzip</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">bz2</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">xz</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">zstd</span></code> are supported for reading and writing. The <code class=\"docutils literal notranslate\"><span class=\"pre\">zip</span></code> file format only supports reading and must contain only one data file to be read.</p> <p>The compression type can be an explicit parameter or be inferred from the file extension. If ‘infer’, then use <code class=\"docutils literal notranslate\"><span class=\"pre\">gzip</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">bz2</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">zip</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">xz</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">zstd</span></code> if filename ends in <code class=\"docutils literal notranslate\"><span class=\"pre\">'.gz'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'.bz2'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'.zip'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'.xz'</span></code>, or <code class=\"docutils literal notranslate\"><span class=\"pre\">'.zst'</span></code>, respectively.</p> <p>The compression parameter can also be a <code class=\"docutils literal notranslate\"><span class=\"pre\">dict</span></code> in order to pass options to the compression protocol. It must have a <code class=\"docutils literal notranslate\"><span class=\"pre\">'method'</span></code> key set to the name of the compression protocol, which must be one of {<code class=\"docutils literal notranslate\"><span class=\"pre\">'zip'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'gzip'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'bz2'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'xz'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'zstd'</span></code>}. All other key-value pairs are passed to the underlying compression library.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [383]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": np.random.randn(1000),\n   .....:         \"B\": \"foo\",\n   .....:         \"C\": pd.date_range(\"20130101\", periods=1000, freq=\"s\"),\n   .....:     }\n   .....: )\n   .....: \n\nIn [384]: df\nOut[384]: \n            A    B                   C\n0   -0.288267  foo 2013-01-01 00:00:00\n1   -0.084905  foo 2013-01-01 00:00:01\n2    0.004772  foo 2013-01-01 00:00:02\n3    1.382989  foo 2013-01-01 00:00:03\n4    0.343635  foo 2013-01-01 00:00:04\n..        ...  ...                 ...\n995 -0.220893  foo 2013-01-01 00:16:35\n996  0.492996  foo 2013-01-01 00:16:36\n997 -0.461625  foo 2013-01-01 00:16:37\n998  1.361779  foo 2013-01-01 00:16:38\n999 -1.197988  foo 2013-01-01 00:16:39\n\n[1000 rows x 3 columns]\n</pre></div> </div> <p>Using an explicit compression type:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [385]: df.to_pickle(\"data.pkl.compress\", compression=\"gzip\")\n\nIn [386]: rt = pd.read_pickle(\"data.pkl.compress\", compression=\"gzip\")\n\nIn [387]: rt\nOut[387]: \n            A    B                   C\n0   -0.288267  foo 2013-01-01 00:00:00\n1   -0.084905  foo 2013-01-01 00:00:01\n2    0.004772  foo 2013-01-01 00:00:02\n3    1.382989  foo 2013-01-01 00:00:03\n4    0.343635  foo 2013-01-01 00:00:04\n..        ...  ...                 ...\n995 -0.220893  foo 2013-01-01 00:16:35\n996  0.492996  foo 2013-01-01 00:16:36\n997 -0.461625  foo 2013-01-01 00:16:37\n998  1.361779  foo 2013-01-01 00:16:38\n999 -1.197988  foo 2013-01-01 00:16:39\n\n[1000 rows x 3 columns]\n</pre></div> </div> <p>Inferring compression type from the extension:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [388]: df.to_pickle(\"data.pkl.xz\", compression=\"infer\")\n\nIn [389]: rt = pd.read_pickle(\"data.pkl.xz\", compression=\"infer\")\n\nIn [390]: rt\nOut[390]: \n            A    B                   C\n0   -0.288267  foo 2013-01-01 00:00:00\n1   -0.084905  foo 2013-01-01 00:00:01\n2    0.004772  foo 2013-01-01 00:00:02\n3    1.382989  foo 2013-01-01 00:00:03\n4    0.343635  foo 2013-01-01 00:00:04\n..        ...  ...                 ...\n995 -0.220893  foo 2013-01-01 00:16:35\n996  0.492996  foo 2013-01-01 00:16:36\n997 -0.461625  foo 2013-01-01 00:16:37\n998  1.361779  foo 2013-01-01 00:16:38\n999 -1.197988  foo 2013-01-01 00:16:39\n\n[1000 rows x 3 columns]\n</pre></div> </div> <p>The default is to ‘infer’:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [391]: df.to_pickle(\"data.pkl.gz\")\n\nIn [392]: rt = pd.read_pickle(\"data.pkl.gz\")\n\nIn [393]: rt\nOut[393]: \n            A    B                   C\n0   -0.288267  foo 2013-01-01 00:00:00\n1   -0.084905  foo 2013-01-01 00:00:01\n2    0.004772  foo 2013-01-01 00:00:02\n3    1.382989  foo 2013-01-01 00:00:03\n4    0.343635  foo 2013-01-01 00:00:04\n..        ...  ...                 ...\n995 -0.220893  foo 2013-01-01 00:16:35\n996  0.492996  foo 2013-01-01 00:16:36\n997 -0.461625  foo 2013-01-01 00:16:37\n998  1.361779  foo 2013-01-01 00:16:38\n999 -1.197988  foo 2013-01-01 00:16:39\n\n[1000 rows x 3 columns]\n\nIn [394]: df[\"A\"].to_pickle(\"s1.pkl.bz2\")\n\nIn [395]: rt = pd.read_pickle(\"s1.pkl.bz2\")\n\nIn [396]: rt\nOut[396]: \n0     -0.288267\n1     -0.084905\n2      0.004772\n3      1.382989\n4      0.343635\n         ...   \n995   -0.220893\n996    0.492996\n997   -0.461625\n998    1.361779\n999   -1.197988\nName: A, Length: 1000, dtype: float64\n</pre></div> </div> <p>Passing options to the compression protocol in order to speed up compression:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [397]: df.to_pickle(\"data.pkl.gz\", compression={\"method\": \"gzip\", \"compresslevel\": 1})\n</pre></div> </div> </section> </section> <section id=\"msgpack\"> <h2>msgpack</h2> <p>pandas support for <code class=\"docutils literal notranslate\"><span class=\"pre\">msgpack</span></code> has been removed in version 1.0.0. It is recommended to use <a class=\"reference internal\" href=\"#io-pickle\"><span class=\"std std-ref\">pickle</span></a> instead.</p> <p>Alternatively, you can also the Arrow IPC serialization format for on-the-wire transmission of pandas objects. For documentation on pyarrow, see <a class=\"reference external\" href=\"https://arrow.apache.org/docs/python/ipc.html\">here</a>.</p> </section> <section id=\"hdf5-pytables\"> <h2>HDF5 (PyTables)</h2> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> is a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent <a class=\"reference external\" href=\"https://www.pytables.org/\">PyTables</a> library. See the <a class=\"reference internal\" href=\"cookbook#cookbook-hdf\"><span class=\"std std-ref\">cookbook</span></a> for some advanced strategies</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle. Loading pickled data received from untrusted sources can be unsafe.</p> <p>See: <a class=\"reference external\" href=\"https://docs.python.org/3/library/pickle.html\">https://docs.python.org/3/library/pickle.html</a> for more.</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [398]: store = pd.HDFStore(\"store.h5\")\n\nIn [399]: print(store)\n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n</pre></div> </div> <p>Objects can be written to the file just like adding key-value pairs to a dict:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [400]: index = pd.date_range(\"1/1/2000\", periods=8)\n\nIn [401]: s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\nIn [402]: df = pd.DataFrame(np.random.randn(8, 3), index=index, columns=[\"A\", \"B\", \"C\"])\n\n# store.put('s', s) is an equivalent method\nIn [403]: store[\"s\"] = s\n\nIn [404]: store[\"df\"] = df\n\nIn [405]: store\nOut[405]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n</pre></div> </div> <p>In a current or later Python session, you can retrieve stored objects:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># store.get('df') is an equivalent method\nIn [406]: store[\"df\"]\nOut[406]: \n                   A         B         C\n2000-01-01  1.334065  0.521036  0.930384\n2000-01-02 -1.613932  1.088104 -0.632963\n2000-01-03 -0.585314 -0.275038 -0.937512\n2000-01-04  0.632369 -1.249657  0.975593\n2000-01-05  1.060617 -0.143682  0.218423\n2000-01-06  3.050329  1.317933 -0.963725\n2000-01-07 -0.539452 -0.771133  0.023751\n2000-01-08  0.649464 -1.736427  0.197288\n\n# dotted (attribute) access provides get as well\nIn [407]: store.df\nOut[407]: \n                   A         B         C\n2000-01-01  1.334065  0.521036  0.930384\n2000-01-02 -1.613932  1.088104 -0.632963\n2000-01-03 -0.585314 -0.275038 -0.937512\n2000-01-04  0.632369 -1.249657  0.975593\n2000-01-05  1.060617 -0.143682  0.218423\n2000-01-06  3.050329  1.317933 -0.963725\n2000-01-07 -0.539452 -0.771133  0.023751\n2000-01-08  0.649464 -1.736427  0.197288\n</pre></div> </div> <p>Deletion of the object specified by the key:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># store.remove('df') is an equivalent method\nIn [408]: del store[\"df\"]\n\nIn [409]: store\nOut[409]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n</pre></div> </div> <p>Closing a Store and using a context manager:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [410]: store.close()\n\nIn [411]: store\nOut[411]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n\nIn [412]: store.is_open\nOut[412]: False\n\n# Working with, and automatically closing the store using a context manager\nIn [413]: with pd.HDFStore(\"store.h5\") as store:\n   .....:     store.keys()\n   .....: \n</pre></div> </div> <section id=\"read-write-api\"> <h3>Read/write API</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> supports a top-level API using <code class=\"docutils literal notranslate\"><span class=\"pre\">read_hdf</span></code> for reading and <code class=\"docutils literal notranslate\"><span class=\"pre\">to_hdf</span></code> for writing, similar to how <code class=\"docutils literal notranslate\"><span class=\"pre\">read_csv</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">to_csv</span></code> work.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [414]: df_tl = pd.DataFrame({\"A\": list(range(5)), \"B\": list(range(5))})\n\nIn [415]: df_tl.to_hdf(\"store_tl.h5\", \"table\", append=True)\n\nIn [416]: pd.read_hdf(\"store_tl.h5\", \"table\", where=[\"index&gt;2\"])\nOut[416]: \n   A  B\n3  3  3\n4  4  4\n</pre></div> </div> <p>HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting <code class=\"docutils literal notranslate\"><span class=\"pre\">dropna=True</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [417]: df_with_missing = pd.DataFrame(\n   .....:     {\n   .....:         \"col1\": [0, np.nan, 2],\n   .....:         \"col2\": [1, np.nan, np.nan],\n   .....:     }\n   .....: )\n   .....: \n\nIn [418]: df_with_missing\nOut[418]: \n   col1  col2\n0   0.0   1.0\n1   NaN   NaN\n2   2.0   NaN\n\nIn [419]: df_with_missing.to_hdf(\"file.h5\", \"df_with_missing\", format=\"table\", mode=\"w\")\n\nIn [420]: pd.read_hdf(\"file.h5\", \"df_with_missing\")\nOut[420]: \n   col1  col2\n0   0.0   1.0\n1   NaN   NaN\n2   2.0   NaN\n\nIn [421]: df_with_missing.to_hdf(\n   .....:     \"file.h5\", \"df_with_missing\", format=\"table\", mode=\"w\", dropna=True\n   .....: )\n   .....: \n\nIn [422]: pd.read_hdf(\"file.h5\", \"df_with_missing\")\nOut[422]: \n   col1  col2\n0   0.0   1.0\n2   2.0   NaN\n</pre></div> </div> </section> <section id=\"fixed-format\"> <h3>Fixed format</h3> <p>The examples above show storing using <code class=\"docutils literal notranslate\"><span class=\"pre\">put</span></code>, which write the HDF5 to <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> in a fixed array format, called the <code class=\"docutils literal notranslate\"><span class=\"pre\">fixed</span></code> format. These types of stores are <strong>not</strong> appendable once written (though you can simply remove them and rewrite). Nor are they <strong>queryable</strong>; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The <code class=\"docutils literal notranslate\"><span class=\"pre\">fixed</span></code> format stores offer very fast writing and slightly faster reading than <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> stores. This format is specified by default when using <code class=\"docutils literal notranslate\"><span class=\"pre\">put</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">to_hdf</span></code> or by <code class=\"docutils literal notranslate\"><span class=\"pre\">format='fixed'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">format='f'</span></code>.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">fixed</span></code> format will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">TypeError</span></code> if you try to retrieve using a <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code>:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; pd.DataFrame(np.random.randn(10, 2)).to_hdf(\"test_fixed.h5\", \"df\")\n&gt;&gt;&gt; pd.read_hdf(\"test_fixed.h5\", \"df\", where=\"index&gt;5\")\nTypeError: cannot pass a where specification when reading a fixed format.\n           this store must be selected in its entirety\n</pre></div> </div> </div> </section> <section id=\"table-format\"> <h3>Table format</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> supports another <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> format on disk, the <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> format. Conceptually a <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> is shaped very much like a DataFrame, with rows and columns. A <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> may be appended to in the same or other sessions. In addition, delete and query type operations are supported. This format is specified by <code class=\"docutils literal notranslate\"><span class=\"pre\">format='table'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">format='t'</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">append</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">put</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">to_hdf</span></code>.</p> <p>This format can be set as an option as well <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.set_option('io.hdf.default_format','table')</span></code> to enable <code class=\"docutils literal notranslate\"><span class=\"pre\">put/append/to_hdf</span></code> to by default store in the <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> format.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [423]: store = pd.HDFStore(\"store.h5\")\n\nIn [424]: df1 = df[0:4]\n\nIn [425]: df2 = df[4:]\n\n# append data (creates a table automatically)\nIn [426]: store.append(\"df\", df1)\n\nIn [427]: store.append(\"df\", df2)\n\nIn [428]: store\nOut[428]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n\n# select the entire object\nIn [429]: store.select(\"df\")\nOut[429]: \n                   A         B         C\n2000-01-01  1.334065  0.521036  0.930384\n2000-01-02 -1.613932  1.088104 -0.632963\n2000-01-03 -0.585314 -0.275038 -0.937512\n2000-01-04  0.632369 -1.249657  0.975593\n2000-01-05  1.060617 -0.143682  0.218423\n2000-01-06  3.050329  1.317933 -0.963725\n2000-01-07 -0.539452 -0.771133  0.023751\n2000-01-08  0.649464 -1.736427  0.197288\n\n# the type of stored data\nIn [430]: store.root.df._v_attrs.pandas_type\nOut[430]: 'frame_table'\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>You can also create a <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> by passing <code class=\"docutils literal notranslate\"><span class=\"pre\">format='table'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">format='t'</span></code> to a <code class=\"docutils literal notranslate\"><span class=\"pre\">put</span></code> operation.</p> </div> </section> <section id=\"hierarchical-keys\"> <h3>Hierarchical keys</h3> <p>Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">foo/bar/bah</span></code>), which will generate a hierarchy of sub-stores (or <code class=\"docutils literal notranslate\"><span class=\"pre\">Groups</span></code> in PyTables parlance). Keys can be specified without the leading ‘/’ and are <strong>always</strong> absolute (e.g. ‘foo’ refers to ‘/foo’). Removal operations can remove everything in the sub-store and <strong>below</strong>, so be <em>careful</em>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [431]: store.put(\"foo/bar/bah\", df)\n\nIn [432]: store.append(\"food/orange\", df)\n\nIn [433]: store.append(\"food/apple\", df)\n\nIn [434]: store\nOut[434]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n\n# a list of keys are returned\nIn [435]: store.keys()\nOut[435]: ['/df', '/food/apple', '/food/orange', '/foo/bar/bah']\n\n# remove all nodes under this level\nIn [436]: store.remove(\"food\")\n\nIn [437]: store\nOut[437]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n</pre></div> </div> <p>You can walk through the group hierarchy using the <code class=\"docutils literal notranslate\"><span class=\"pre\">walk</span></code> method which will yield a tuple for each group key along with the relative keys of its contents.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [438]: for (path, subgroups, subkeys) in store.walk():\n   .....:     for subgroup in subgroups:\n   .....:         print(\"GROUP: {}/{}\".format(path, subgroup))\n   .....:     for subkey in subkeys:\n   .....:         key = \"/\".join([path, subkey])\n   .....:         print(\"KEY: {}\".format(key))\n   .....:         print(store.get(key))\n   .....: \nGROUP: /foo\nKEY: /df\n                   A         B         C\n2000-01-01  1.334065  0.521036  0.930384\n2000-01-02 -1.613932  1.088104 -0.632963\n2000-01-03 -0.585314 -0.275038 -0.937512\n2000-01-04  0.632369 -1.249657  0.975593\n2000-01-05  1.060617 -0.143682  0.218423\n2000-01-06  3.050329  1.317933 -0.963725\n2000-01-07 -0.539452 -0.771133  0.023751\n2000-01-08  0.649464 -1.736427  0.197288\nGROUP: /foo/bar\nKEY: /foo/bar/bah\n                   A         B         C\n2000-01-01  1.334065  0.521036  0.930384\n2000-01-02 -1.613932  1.088104 -0.632963\n2000-01-03 -0.585314 -0.275038 -0.937512\n2000-01-04  0.632369 -1.249657  0.975593\n2000-01-05  1.060617 -0.143682  0.218423\n2000-01-06  3.050329  1.317933 -0.963725\n2000-01-07 -0.539452 -0.771133  0.023751\n2000-01-08  0.649464 -1.736427  0.197288\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [8]: store.foo.bar.bah\nAttributeError: 'HDFStore' object has no attribute 'foo'\n\n# you can directly access the actual PyTables node but using the root node\nIn [9]: store.root.foo.bar.bah\nOut[9]:\n/foo/bar/bah (Group) ''\n  children := ['block0_items' (Array), 'block0_values' (Array), 'axis0' (Array), 'axis1' (Array)]\n</pre></div> </div> <p>Instead, use explicit string based keys:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [439]: store[\"foo/bar/bah\"]\nOut[439]: \n                   A         B         C\n2000-01-01  1.334065  0.521036  0.930384\n2000-01-02 -1.613932  1.088104 -0.632963\n2000-01-03 -0.585314 -0.275038 -0.937512\n2000-01-04  0.632369 -1.249657  0.975593\n2000-01-05  1.060617 -0.143682  0.218423\n2000-01-06  3.050329  1.317933 -0.963725\n2000-01-07 -0.539452 -0.771133  0.023751\n2000-01-08  0.649464 -1.736427  0.197288\n</pre></div> </div> </div> </section> <section id=\"storing-types\"> <h3>Storing types</h3> <section id=\"storing-mixed-types-in-a-table\"> <h4>Storing mixed types in a table</h4> <p>Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code>.</p> <p>Passing <code class=\"docutils literal notranslate\"><span class=\"pre\">min_itemsize={`values`:</span> <span class=\"pre\">size}</span></code> as a parameter to append will set a larger minimum for the string columns. Storing <code class=\"docutils literal notranslate\"><span class=\"pre\">floats,</span>\n<span class=\"pre\">strings,</span> <span class=\"pre\">ints,</span> <span class=\"pre\">bools,</span> <span class=\"pre\">datetime64</span></code> are currently supported. For string columns, passing <code class=\"docutils literal notranslate\"><span class=\"pre\">nan_rep</span> <span class=\"pre\">=</span> <span class=\"pre\">'nan'</span></code> to append will change the default nan representation on disk (which converts to/from <code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code>), this defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">nan</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [440]: df_mixed = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": np.random.randn(8),\n   .....:         \"B\": np.random.randn(8),\n   .....:         \"C\": np.array(np.random.randn(8), dtype=\"float32\"),\n   .....:         \"string\": \"string\",\n   .....:         \"int\": 1,\n   .....:         \"bool\": True,\n   .....:         \"datetime64\": pd.Timestamp(\"20010102\"),\n   .....:     },\n   .....:     index=list(range(8)),\n   .....: )\n   .....: \n\nIn [441]: df_mixed.loc[df_mixed.index[3:5], [\"A\", \"B\", \"string\", \"datetime64\"]] = np.nan\n\nIn [442]: store.append(\"df_mixed\", df_mixed, min_itemsize={\"values\": 50})\n\nIn [443]: df_mixed1 = store.select(\"df_mixed\")\n\nIn [444]: df_mixed1\nOut[444]: \n          A         B         C  string  int  bool datetime64\n0 -0.116008  0.743946 -0.398501  string    1  True 2001-01-02\n1  0.592375 -0.533097 -0.677311  string    1  True 2001-01-02\n2  0.476481 -0.140850 -0.874991  string    1  True 2001-01-02\n3       NaN       NaN -1.167564     NaN    1  True        NaT\n4       NaN       NaN -0.593353     NaN    1  True        NaT\n5  0.852727  0.463819  0.146262  string    1  True 2001-01-02\n6 -1.177365  0.793644 -0.131959  string    1  True 2001-01-02\n7  1.236988  0.221252  0.089012  string    1  True 2001-01-02\n\nIn [445]: df_mixed1.dtypes.value_counts()\nOut[445]: \nfloat64           2\nfloat32           1\nobject            1\nint64             1\nbool              1\ndatetime64[ns]    1\ndtype: int64\n\n# we have provided a minimum string column size\nIn [446]: store.root.df_mixed.table\nOut[446]: \n/df_mixed/table (Table(8,)) ''\n  description := {\n  \"index\": Int64Col(shape=(), dflt=0, pos=0),\n  \"values_block_0\": Float64Col(shape=(2,), dflt=0.0, pos=1),\n  \"values_block_1\": Float32Col(shape=(1,), dflt=0.0, pos=2),\n  \"values_block_2\": StringCol(itemsize=50, shape=(1,), dflt=b'', pos=3),\n  \"values_block_3\": Int64Col(shape=(1,), dflt=0, pos=4),\n  \"values_block_4\": BoolCol(shape=(1,), dflt=False, pos=5),\n  \"values_block_5\": Int64Col(shape=(1,), dflt=0, pos=6)}\n  byteorder := 'little'\n  chunkshape := (689,)\n  autoindex := True\n  colindexes := {\n    \"index\": Index(6, medium, shuffle, zlib(1)).is_csi=False}\n</pre></div> </div> </section> <section id=\"storing-multiindex-dataframes\"> <h4>Storing MultiIndex DataFrames</h4> <p>Storing MultiIndex <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code> as tables is very similar to storing/selecting from homogeneous index <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [447]: index = pd.MultiIndex(\n   .....:     levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n   .....:     codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n   .....:     names=[\"foo\", \"bar\"],\n   .....: )\n   .....: \n\nIn [448]: df_mi = pd.DataFrame(np.random.randn(10, 3), index=index, columns=[\"A\", \"B\", \"C\"])\n\nIn [449]: df_mi\nOut[449]: \n                  A         B         C\nfoo bar                                \nfoo one    0.667450  0.169405 -1.358046\n    two   -0.105563  0.492195  0.076693\n    three  0.213685 -0.285283 -1.210529\nbar one   -1.408386  0.941577 -0.342447\n    two    0.222031  0.052607  2.093214\nbaz two    1.064908  1.778161 -0.913867\n    three -0.030004 -0.399846 -1.234765\nqux one    0.081323 -0.268494  0.168016\n    two   -0.898283 -0.218499  1.408028\n    three -1.267828 -0.689263  0.520995\n\nIn [450]: store.append(\"df_mi\", df_mi)\n\nIn [451]: store.select(\"df_mi\")\nOut[451]: \n                  A         B         C\nfoo bar                                \nfoo one    0.667450  0.169405 -1.358046\n    two   -0.105563  0.492195  0.076693\n    three  0.213685 -0.285283 -1.210529\nbar one   -1.408386  0.941577 -0.342447\n    two    0.222031  0.052607  2.093214\nbaz two    1.064908  1.778161 -0.913867\n    three -0.030004 -0.399846 -1.234765\nqux one    0.081323 -0.268494  0.168016\n    two   -0.898283 -0.218499  1.408028\n    three -1.267828 -0.689263  0.520995\n\n# the levels are automatically included as data columns\nIn [452]: store.select(\"df_mi\", \"foo=bar\")\nOut[452]: \n                A         B         C\nfoo bar                              \nbar one -1.408386  0.941577 -0.342447\n    two  0.222031  0.052607  2.093214\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> keyword is reserved and cannot be use as a level name.</p> </div> </section> </section> <section id=\"querying\"> <h3>Querying</h3> <section id=\"querying-a-table\"> <h4>Querying a table</h4> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">select</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">delete</span></code> operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data.</p> <p>A query is specified using the <code class=\"docutils literal notranslate\"><span class=\"pre\">Term</span></code> class under the hood, as a boolean expression.</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> are supported indexers of <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrames</span></code>.</p></li> <li><p>if <code class=\"docutils literal notranslate\"><span class=\"pre\">data_columns</span></code> are specified, these can be used as additional indexers.</p></li> <li><p>level name in a MultiIndex, with default name <code class=\"docutils literal notranslate\"><span class=\"pre\">level_0</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">level_1</span></code>, … if not provided.</p></li> </ul> <p>Valid comparison operators are:</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">=,</span> <span class=\"pre\">==,</span> <span class=\"pre\">!=,</span> <span class=\"pre\">&gt;,</span> <span class=\"pre\">&gt;=,</span> <span class=\"pre\">&lt;,</span> <span class=\"pre\">&lt;=</span></code></p> <p>Valid boolean expressions are combined with:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">|</span></code> : or</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;</span></code> : and</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">(</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">)</span></code> : for grouping</p></li> </ul> <p>These rules are similar to how boolean expressions are used in pandas for indexing.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">=</span></code> will be automatically expanded to the comparison operator <code class=\"docutils literal notranslate\"><span class=\"pre\">==</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">~</span></code> is the not operator, but can only be used in very limited circumstances</p></li> <li><p>If a list/tuple of expressions is passed they will be combined via <code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;</span></code></p></li> </ul> </div> <p>The following are valid expressions:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'index</span> <span class=\"pre\">&gt;=</span> <span class=\"pre\">date'</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">\"columns</span> <span class=\"pre\">=</span> <span class=\"pre\">['A',</span> <span class=\"pre\">'D']\"</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">\"columns</span> <span class=\"pre\">in</span> <span class=\"pre\">['A',</span> <span class=\"pre\">'D']\"</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'columns</span> <span class=\"pre\">=</span> <span class=\"pre\">A'</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'columns</span> <span class=\"pre\">==</span> <span class=\"pre\">A'</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">\"~(columns</span> <span class=\"pre\">=</span> <span class=\"pre\">['A',</span> <span class=\"pre\">'B'])\"</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'index</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">df.index[3]</span> <span class=\"pre\">&amp;</span> <span class=\"pre\">string</span> <span class=\"pre\">=</span> <span class=\"pre\">\"bar\"'</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'(index</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">df.index[3]</span> <span class=\"pre\">&amp;</span> <span class=\"pre\">index</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">df.index[6])</span> <span class=\"pre\">|</span> <span class=\"pre\">string</span> <span class=\"pre\">=</span> <span class=\"pre\">\"bar\"'</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">\"ts</span> <span class=\"pre\">&gt;=</span> <span class=\"pre\">Timestamp('2012-02-01')\"</span></code></p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">\"major_axis&gt;=20130101\"</span></code></p></li> </ul> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">indexers</span></code> are on the left-hand side of the sub-expression:</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">major_axis</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">ts</span></code></p> <p>The right-hand side of the sub-expression (after a comparison operator) can be:</p> <ul class=\"simple\"> <li><p>functions that will be evaluated, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">Timestamp('2012-02-01')</span></code></p></li> <li><p>strings, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">\"bar\"</span></code></p></li> <li><p>date-like, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">20130101</span></code>, or <code class=\"docutils literal notranslate\"><span class=\"pre\">\"20130101\"</span></code></p></li> <li><p>lists, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">\"['A',</span> <span class=\"pre\">'B']\"</span></code></p></li> <li><p>variables that are defined in the local names space, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">date</span></code></p></li> </ul> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">string = \"HolyMoly'\"\nstore.select(\"df\", \"index == string\")\n</pre></div> </div> <p>instead of this</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">string = \"HolyMoly'\"\nstore.select('df', f'index == {string}')\n</pre></div> </div> <p>The latter will <strong>not</strong> work and will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">SyntaxError</span></code>.Note that there’s a single quote followed by a double quote in the <code class=\"docutils literal notranslate\"><span class=\"pre\">string</span></code> variable.</p> <p>If you <em>must</em> interpolate, use the <code class=\"docutils literal notranslate\"><span class=\"pre\">'%r'</span></code> format specifier</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">store.select(\"df\", \"index == %r\" % string)\n</pre></div> </div> <p>which will quote <code class=\"docutils literal notranslate\"><span class=\"pre\">string</span></code>.</p> </div> <p>Here are some examples:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [453]: dfq = pd.DataFrame(\n   .....:     np.random.randn(10, 4),\n   .....:     columns=list(\"ABCD\"),\n   .....:     index=pd.date_range(\"20130101\", periods=10),\n   .....: )\n   .....: \n\nIn [454]: store.append(\"dfq\", dfq, format=\"table\", data_columns=True)\n</pre></div> </div> <p>Use boolean expressions, with in-line function evaluation.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [455]: store.select(\"dfq\", \"index&gt;pd.Timestamp('20130104') &amp; columns=['A', 'B']\")\nOut[455]: \n                   A         B\n2013-01-05 -1.083889  0.811865\n2013-01-06 -0.402227  1.618922\n2013-01-07  0.948196  0.183573\n2013-01-08 -1.043530 -0.708145\n2013-01-09  0.813949  1.508891\n2013-01-10  1.176488 -1.246093\n</pre></div> </div> <p>Use inline column reference.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [456]: store.select(\"dfq\", where=\"A&gt;0 or C&gt;0\")\nOut[456]: \n                   A         B         C         D\n2013-01-01  0.620028  0.159416 -0.263043 -0.639244\n2013-01-04 -0.536722  1.005707  0.296917  0.139796\n2013-01-05 -1.083889  0.811865  1.648435 -0.164377\n2013-01-07  0.948196  0.183573  0.145277  0.308146\n2013-01-08 -1.043530 -0.708145  1.430905 -0.850136\n2013-01-09  0.813949  1.508891 -1.556154  0.187597\n2013-01-10  1.176488 -1.246093 -0.002726 -0.444249\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">columns</span></code> keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a <code class=\"docutils literal notranslate\"><span class=\"pre\">'columns=list_of_columns_to_filter'</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [457]: store.select(\"df\", \"columns=['A', 'B']\")\nOut[457]: \n                   A         B\n2000-01-01  1.334065  0.521036\n2000-01-02 -1.613932  1.088104\n2000-01-03 -0.585314 -0.275038\n2000-01-04  0.632369 -1.249657\n2000-01-05  1.060617 -0.143682\n2000-01-06  3.050329  1.317933\n2000-01-07 -0.539452 -0.771133\n2000-01-08  0.649464 -1.736427\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">start</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">stop</span></code> parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">select</span></code> will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code> if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is <strong>not</strong> a data_column.</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">select</span></code> will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">SyntaxError</span></code> if the query expression is not valid.</p> </div> </section> <section id=\"query-timedelta64-ns\"> <h4>Query timedelta64[ns]</h4> <p>You can store and query using the <code class=\"docutils literal notranslate\"><span class=\"pre\">timedelta64[ns]</span></code> type. Terms can be specified in the format: <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;float&gt;(&lt;unit&gt;)</span></code>, where float may be signed (and fractional), and unit can be <code class=\"docutils literal notranslate\"><span class=\"pre\">D,s,ms,us,ns</span></code> for the timedelta. Here’s an example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [458]: from datetime import timedelta\n\nIn [459]: dftd = pd.DataFrame(\n   .....:     {\n   .....:         \"A\": pd.Timestamp(\"20130101\"),\n   .....:         \"B\": [\n   .....:             pd.Timestamp(\"20130101\") + timedelta(days=i, seconds=10)\n   .....:             for i in range(10)\n   .....:         ],\n   .....:     }\n   .....: )\n   .....: \n\nIn [460]: dftd[\"C\"] = dftd[\"A\"] - dftd[\"B\"]\n\nIn [461]: dftd\nOut[461]: \n           A                   B                  C\n0 2013-01-01 2013-01-01 00:00:10  -1 days +23:59:50\n1 2013-01-01 2013-01-02 00:00:10  -2 days +23:59:50\n2 2013-01-01 2013-01-03 00:00:10  -3 days +23:59:50\n3 2013-01-01 2013-01-04 00:00:10  -4 days +23:59:50\n4 2013-01-01 2013-01-05 00:00:10  -5 days +23:59:50\n5 2013-01-01 2013-01-06 00:00:10  -6 days +23:59:50\n6 2013-01-01 2013-01-07 00:00:10  -7 days +23:59:50\n7 2013-01-01 2013-01-08 00:00:10  -8 days +23:59:50\n8 2013-01-01 2013-01-09 00:00:10  -9 days +23:59:50\n9 2013-01-01 2013-01-10 00:00:10 -10 days +23:59:50\n\nIn [462]: store.append(\"dftd\", dftd, data_columns=True)\n\nIn [463]: store.select(\"dftd\", \"C&lt;'-3.5D'\")\nOut[463]: \n           A                   B                  C\n4 2013-01-01 2013-01-05 00:00:10  -5 days +23:59:50\n5 2013-01-01 2013-01-06 00:00:10  -6 days +23:59:50\n6 2013-01-01 2013-01-07 00:00:10  -7 days +23:59:50\n7 2013-01-01 2013-01-08 00:00:10  -8 days +23:59:50\n8 2013-01-01 2013-01-09 00:00:10  -9 days +23:59:50\n9 2013-01-01 2013-01-10 00:00:10 -10 days +23:59:50\n</pre></div> </div> </section> <section id=\"query-multiindex\"> <h4>Query MultiIndex</h4> <p>Selecting from a <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> can be achieved by using the name of the level.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [464]: df_mi.index.names\nOut[464]: FrozenList(['foo', 'bar'])\n\nIn [465]: store.select(\"df_mi\", \"foo=baz and bar=two\")\nOut[465]: \n                A         B         C\nfoo bar                              \nbaz two  1.064908  1.778161 -0.913867\n</pre></div> </div> <p>If the <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> levels names are <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>, the levels are automatically made available via the <code class=\"docutils literal notranslate\"><span class=\"pre\">level_n</span></code> keyword with <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> the level of the <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> you want to select from.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [466]: index = pd.MultiIndex(\n   .....:     levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n   .....:     codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n   .....: )\n   .....: \n\nIn [467]: df_mi_2 = pd.DataFrame(np.random.randn(10, 3), index=index, columns=[\"A\", \"B\", \"C\"])\n\nIn [468]: df_mi_2\nOut[468]: \n                  A         B         C\nfoo one    0.856838  1.491776  0.001283\n    two    0.701816 -1.097917  0.102588\n    three  0.661740  0.443531  0.559313\nbar one   -0.459055 -1.222598 -0.455304\n    two   -0.781163  0.826204 -0.530057\nbaz two    0.296135  1.366810  1.073372\n    three -0.994957  0.755314  2.119746\nqux one   -2.628174 -0.089460 -0.133636\n    two    0.337920 -0.634027  0.421107\n    three  0.604303  1.053434  1.109090\n\nIn [469]: store.append(\"df_mi_2\", df_mi_2)\n\n# the levels are automatically included as data columns with keyword level_n\nIn [470]: store.select(\"df_mi_2\", \"level_0=foo and level_1=two\")\nOut[470]: \n                A         B         C\nfoo two  0.701816 -1.097917  0.102588\n</pre></div> </div> </section> <section id=\"indexing\"> <h4>Indexing</h4> <p>You can create/modify an index for a table with <code class=\"docutils literal notranslate\"><span class=\"pre\">create_table_index</span></code> after data is already in the table (after and <code class=\"docutils literal notranslate\"><span class=\"pre\">append/put</span></code> operation). Creating a table index is <strong>highly</strong> encouraged. This will speed your queries a great deal when you use a <code class=\"docutils literal notranslate\"><span class=\"pre\">select</span></code> with the indexed dimension as the <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code>.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing <code class=\"docutils literal notranslate\"><span class=\"pre\">index=False</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">append</span></code>.</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># we have automagically already created an index (in the first section)\nIn [471]: i = store.root.df.table.cols.index.index\n\nIn [472]: i.optlevel, i.kind\nOut[472]: (6, 'medium')\n\n# change an index by passing new parameters\nIn [473]: store.create_table_index(\"df\", optlevel=9, kind=\"full\")\n\nIn [474]: i = store.root.df.table.cols.index.index\n\nIn [475]: i.optlevel, i.kind\nOut[475]: (9, 'full')\n</pre></div> </div> <p>Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [476]: df_1 = pd.DataFrame(np.random.randn(10, 2), columns=list(\"AB\"))\n\nIn [477]: df_2 = pd.DataFrame(np.random.randn(10, 2), columns=list(\"AB\"))\n\nIn [478]: st = pd.HDFStore(\"appends.h5\", mode=\"w\")\n\nIn [479]: st.append(\"df\", df_1, data_columns=[\"B\"], index=False)\n\nIn [480]: st.append(\"df\", df_2, data_columns=[\"B\"], index=False)\n\nIn [481]: st.get_storer(\"df\").table\nOut[481]: \n/df/table (Table(20,)) ''\n  description := {\n  \"index\": Int64Col(shape=(), dflt=0, pos=0),\n  \"values_block_0\": Float64Col(shape=(1,), dflt=0.0, pos=1),\n  \"B\": Float64Col(shape=(), dflt=0.0, pos=2)}\n  byteorder := 'little'\n  chunkshape := (2730,)\n</pre></div> </div> <p>Then create the index when finished appending.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [482]: st.create_table_index(\"df\", columns=[\"B\"], optlevel=9, kind=\"full\")\n\nIn [483]: st.get_storer(\"df\").table\nOut[483]: \n/df/table (Table(20,)) ''\n  description := {\n  \"index\": Int64Col(shape=(), dflt=0, pos=0),\n  \"values_block_0\": Float64Col(shape=(1,), dflt=0.0, pos=1),\n  \"B\": Float64Col(shape=(), dflt=0.0, pos=2)}\n  byteorder := 'little'\n  chunkshape := (2730,)\n  autoindex := True\n  colindexes := {\n    \"B\": Index(9, full, shuffle, zlib(1)).is_csi=True}\n\nIn [484]: st.close()\n</pre></div> </div> <p>See <a class=\"reference external\" href=\"https://stackoverflow.com/questions/17893370/ptrepack-sortby-needs-full-index\">here</a> for how to create a completely-sorted-index (CSI) on an existing store.</p> </section> <section id=\"query-via-data-columns\"> <h4>Query via data columns</h4> <p>You can designate (and index) certain columns that you want to be able to perform queries (other than the <code class=\"docutils literal notranslate\"><span class=\"pre\">indexable</span></code> columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify <code class=\"docutils literal notranslate\"><span class=\"pre\">data_columns</span> <span class=\"pre\">=</span> <span class=\"pre\">True</span></code> to force all columns to be <code class=\"docutils literal notranslate\"><span class=\"pre\">data_columns</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [485]: df_dc = df.copy()\n\nIn [486]: df_dc[\"string\"] = \"foo\"\n\nIn [487]: df_dc.loc[df_dc.index[4:6], \"string\"] = np.nan\n\nIn [488]: df_dc.loc[df_dc.index[7:9], \"string\"] = \"bar\"\n\nIn [489]: df_dc[\"string2\"] = \"cool\"\n\nIn [490]: df_dc.loc[df_dc.index[1:3], [\"B\", \"C\"]] = 1.0\n\nIn [491]: df_dc\nOut[491]: \n                   A         B         C string string2\n2000-01-01  1.334065  0.521036  0.930384    foo    cool\n2000-01-02 -1.613932  1.000000  1.000000    foo    cool\n2000-01-03 -0.585314  1.000000  1.000000    foo    cool\n2000-01-04  0.632369 -1.249657  0.975593    foo    cool\n2000-01-05  1.060617 -0.143682  0.218423    NaN    cool\n2000-01-06  3.050329  1.317933 -0.963725    NaN    cool\n2000-01-07 -0.539452 -0.771133  0.023751    foo    cool\n2000-01-08  0.649464 -1.736427  0.197288    bar    cool\n\n# on-disk operations\nIn [492]: store.append(\"df_dc\", df_dc, data_columns=[\"B\", \"C\", \"string\", \"string2\"])\n\nIn [493]: store.select(\"df_dc\", where=\"B &gt; 0\")\nOut[493]: \n                   A         B         C string string2\n2000-01-01  1.334065  0.521036  0.930384    foo    cool\n2000-01-02 -1.613932  1.000000  1.000000    foo    cool\n2000-01-03 -0.585314  1.000000  1.000000    foo    cool\n2000-01-06  3.050329  1.317933 -0.963725    NaN    cool\n\n# getting creative\nIn [494]: store.select(\"df_dc\", \"B &gt; 0 &amp; C &gt; 0 &amp; string == foo\")\nOut[494]: \n                   A         B         C string string2\n2000-01-01  1.334065  0.521036  0.930384    foo    cool\n2000-01-02 -1.613932  1.000000  1.000000    foo    cool\n2000-01-03 -0.585314  1.000000  1.000000    foo    cool\n\n# this is in-memory version of this type of selection\nIn [495]: df_dc[(df_dc.B &gt; 0) &amp; (df_dc.C &gt; 0) &amp; (df_dc.string == \"foo\")]\nOut[495]: \n                   A         B         C string string2\n2000-01-01  1.334065  0.521036  0.930384    foo    cool\n2000-01-02 -1.613932  1.000000  1.000000    foo    cool\n2000-01-03 -0.585314  1.000000  1.000000    foo    cool\n\n# we have automagically created this index and the B/C/string/string2\n# columns are stored separately as ``PyTables`` columns\nIn [496]: store.root.df_dc.table\nOut[496]: \n/df_dc/table (Table(8,)) ''\n  description := {\n  \"index\": Int64Col(shape=(), dflt=0, pos=0),\n  \"values_block_0\": Float64Col(shape=(1,), dflt=0.0, pos=1),\n  \"B\": Float64Col(shape=(), dflt=0.0, pos=2),\n  \"C\": Float64Col(shape=(), dflt=0.0, pos=3),\n  \"string\": StringCol(itemsize=3, shape=(), dflt=b'', pos=4),\n  \"string2\": StringCol(itemsize=4, shape=(), dflt=b'', pos=5)}\n  byteorder := 'little'\n  chunkshape := (1680,)\n  autoindex := True\n  colindexes := {\n    \"index\": Index(6, medium, shuffle, zlib(1)).is_csi=False,\n    \"B\": Index(6, medium, shuffle, zlib(1)).is_csi=False,\n    \"C\": Index(6, medium, shuffle, zlib(1)).is_csi=False,\n    \"string\": Index(6, medium, shuffle, zlib(1)).is_csi=False,\n    \"string2\": Index(6, medium, shuffle, zlib(1)).is_csi=False}\n</pre></div> </div> <p>There is some performance degradation by making lots of columns into <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span> <span class=\"pre\">columns</span></code>, so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!).</p> </section> <section id=\"iterator\"> <h4>Iterator</h4> <p>You can pass <code class=\"docutils literal notranslate\"><span class=\"pre\">iterator=True</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize=number_in_a_chunk</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">select</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">select_as_multiple</span></code> to return an iterator on the results. The default is 50,000 rows returned in a chunk.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [497]: for df in store.select(\"df\", chunksize=3):\n   .....:     print(df)\n   .....: \n                   A         B         C\n2000-01-01  1.334065  0.521036  0.930384\n2000-01-02 -1.613932  1.088104 -0.632963\n2000-01-03 -0.585314 -0.275038 -0.937512\n                   A         B         C\n2000-01-04  0.632369 -1.249657  0.975593\n2000-01-05  1.060617 -0.143682  0.218423\n2000-01-06  3.050329  1.317933 -0.963725\n                   A         B         C\n2000-01-07 -0.539452 -0.771133  0.023751\n2000-01-08  0.649464 -1.736427  0.197288\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>You can also use the iterator with <code class=\"docutils literal notranslate\"><span class=\"pre\">read_hdf</span></code> which will open, then automatically close the store when finished iterating.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">for df in pd.read_hdf(\"store.h5\", \"df\", chunksize=3):\n    print(df)\n</pre></div> </div> </div> <p>Note, that the chunksize keyword applies to the <strong>source</strong> rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks.</p> <p>Here is a recipe for generating a query and using it to create equal sized return chunks.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [498]: dfeq = pd.DataFrame({\"number\": np.arange(1, 11)})\n\nIn [499]: dfeq\nOut[499]: \n   number\n0       1\n1       2\n2       3\n3       4\n4       5\n5       6\n6       7\n7       8\n8       9\n9      10\n\nIn [500]: store.append(\"dfeq\", dfeq, data_columns=[\"number\"])\n\nIn [501]: def chunks(l, n):\n   .....:     return [l[i: i + n] for i in range(0, len(l), n)]\n   .....: \n\nIn [502]: evens = [2, 4, 6, 8, 10]\n\nIn [503]: coordinates = store.select_as_coordinates(\"dfeq\", \"number=evens\")\n\nIn [504]: for c in chunks(coordinates, 2):\n   .....:     print(store.select(\"dfeq\", where=c))\n   .....: \n   number\n1       2\n3       4\n   number\n5       6\n7       8\n   number\n9      10\n</pre></div> </div> </section> <section id=\"advanced-queries\"> <h4>Advanced queries</h4> <section id=\"select-a-single-column\"> <h5>Select a single column</h5> <p>To retrieve a single indexable or data column, use the method <code class=\"docutils literal notranslate\"><span class=\"pre\">select_column</span></code>. This will, for example, enable you to get the index very quickly. These return a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> of the result, indexed by the row number. These do not currently accept the <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> selector.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [505]: store.select_column(\"df_dc\", \"index\")\nOut[505]: \n0   2000-01-01\n1   2000-01-02\n2   2000-01-03\n3   2000-01-04\n4   2000-01-05\n5   2000-01-06\n6   2000-01-07\n7   2000-01-08\nName: index, dtype: datetime64[ns]\n\nIn [506]: store.select_column(\"df_dc\", \"string\")\nOut[506]: \n0    foo\n1    foo\n2    foo\n3    foo\n4    NaN\n5    NaN\n6    foo\n7    bar\nName: string, dtype: object\n</pre></div> </div> </section> <section id=\"selecting-coordinates\"> <h5>Selecting coordinates</h5> <p>Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an <code class=\"docutils literal notranslate\"><span class=\"pre\">Int64Index</span></code> of the resulting locations. These coordinates can also be passed to subsequent <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> operations.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [507]: df_coord = pd.DataFrame(\n   .....:     np.random.randn(1000, 2), index=pd.date_range(\"20000101\", periods=1000)\n   .....: )\n   .....: \n\nIn [508]: store.append(\"df_coord\", df_coord)\n\nIn [509]: c = store.select_as_coordinates(\"df_coord\", \"index &gt; 20020101\")\n\nIn [510]: c\nOut[510]: \nInt64Index([732, 733, 734, 735, 736, 737, 738, 739, 740, 741,\n            ...\n            990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n           dtype='int64', length=268)\n\nIn [511]: store.select(\"df_coord\", where=c)\nOut[511]: \n                   0         1\n2002-01-02 -0.165548  0.646989\n2002-01-03  0.782753 -0.123409\n2002-01-04 -0.391932 -0.740915\n2002-01-05  1.211070 -0.668715\n2002-01-06  0.341987 -0.685867\n...              ...       ...\n2002-09-22  1.788110 -0.405908\n2002-09-23 -0.801912  0.768460\n2002-09-24  0.466284 -0.457411\n2002-09-25 -0.364060  0.785367\n2002-09-26 -1.463093  1.187315\n\n[268 rows x 2 columns]\n</pre></div> </div> </section> <section id=\"selecting-using-a-where-mask\"> <h5>Selecting using a where mask</h5> <p>Sometime your query can involve creating a list of rows to select. Usually this <code class=\"docutils literal notranslate\"><span class=\"pre\">mask</span></code> would be a resulting <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> from an indexing operation. This example selects the months of a datetimeindex which are 5.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [512]: df_mask = pd.DataFrame(\n   .....:     np.random.randn(1000, 2), index=pd.date_range(\"20000101\", periods=1000)\n   .....: )\n   .....: \n\nIn [513]: store.append(\"df_mask\", df_mask)\n\nIn [514]: c = store.select_column(\"df_mask\", \"index\")\n\nIn [515]: where = c[pd.DatetimeIndex(c).month == 5].index\n\nIn [516]: store.select(\"df_mask\", where=where)\nOut[516]: \n                   0         1\n2000-05-01  1.735883 -2.615261\n2000-05-02  0.422173  2.425154\n2000-05-03  0.632453 -0.165640\n2000-05-04 -1.017207 -0.005696\n2000-05-05  0.299606  0.070606\n...              ...       ...\n2002-05-27  0.234503  1.199126\n2002-05-28 -3.021833 -1.016828\n2002-05-29  0.522794  0.063465\n2002-05-30 -1.653736  0.031709\n2002-05-31 -0.968402 -0.393583\n\n[93 rows x 2 columns]\n</pre></div> </div> </section> <section id=\"storer-object\"> <h5>Storer object</h5> <p>If you want to inspect the stored object, retrieve via <code class=\"docutils literal notranslate\"><span class=\"pre\">get_storer</span></code>. You could use this programmatically to say get the number of rows in an object.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [517]: store.get_storer(\"df_dc\").nrows\nOut[517]: 8\n</pre></div> </div> </section> </section> <section id=\"multiple-table-queries\"> <h4>Multiple table queries</h4> <p>The methods <code class=\"docutils literal notranslate\"><span class=\"pre\">append_to_multiple</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">select_as_multiple</span></code> can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table’s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries.</p> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">append_to_multiple</span></code> method splits a given single DataFrame into multiple tables according to <code class=\"docutils literal notranslate\"><span class=\"pre\">d</span></code>, a dictionary that maps the table names to a list of ‘columns’ you want in that table. If <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument <code class=\"docutils literal notranslate\"><span class=\"pre\">selector</span></code> defines which table is the selector table (which you can make queries from). The argument <code class=\"docutils literal notranslate\"><span class=\"pre\">dropna</span></code> will drop rows from the input <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> to ensure tables are synchronized. This means that if a row for one of the tables being written to is entirely <code class=\"docutils literal notranslate\"><span class=\"pre\">np.NaN</span></code>, that row will be dropped from all tables.</p> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">dropna</span></code> is False, <strong>THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES</strong>. Remember that entirely <code class=\"docutils literal notranslate\"><span class=\"pre\">np.Nan</span></code> rows are not written to the HDFStore, so if you choose to call <code class=\"docutils literal notranslate\"><span class=\"pre\">dropna=False</span></code>, some tables may have more rows than others, and therefore <code class=\"docutils literal notranslate\"><span class=\"pre\">select_as_multiple</span></code> may not work or it may return unexpected results.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [518]: df_mt = pd.DataFrame(\n   .....:     np.random.randn(8, 6),\n   .....:     index=pd.date_range(\"1/1/2000\", periods=8),\n   .....:     columns=[\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\n   .....: )\n   .....: \n\nIn [519]: df_mt[\"foo\"] = \"bar\"\n\nIn [520]: df_mt.loc[df_mt.index[1], (\"A\", \"B\")] = np.nan\n\n# you can also create the tables individually\nIn [521]: store.append_to_multiple(\n   .....:     {\"df1_mt\": [\"A\", \"B\"], \"df2_mt\": None}, df_mt, selector=\"df1_mt\"\n   .....: )\n   .....: \n\nIn [522]: store\nOut[522]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: store.h5\n\n# individual tables were created\nIn [523]: store.select(\"df1_mt\")\nOut[523]: \n                   A         B\n2000-01-01  1.251079 -0.362628\n2000-01-02       NaN       NaN\n2000-01-03  0.719421 -0.448886\n2000-01-04  1.140998 -0.877922\n2000-01-05  1.043605  1.798494\n2000-01-06 -0.467812 -0.027965\n2000-01-07  0.150568  0.754820\n2000-01-08 -0.596306 -0.910022\n\nIn [524]: store.select(\"df2_mt\")\nOut[524]: \n                   C         D         E         F  foo\n2000-01-01  1.602451 -0.221229  0.712403  0.465927  bar\n2000-01-02 -0.525571  0.851566 -0.681308 -0.549386  bar\n2000-01-03 -0.044171  1.396628  1.041242 -1.588171  bar\n2000-01-04  0.463351 -0.861042 -2.192841 -1.025263  bar\n2000-01-05 -1.954845 -1.712882 -0.204377 -1.608953  bar\n2000-01-06  1.601542 -0.417884 -2.757922 -0.307713  bar\n2000-01-07 -1.935461  1.007668  0.079529 -1.459471  bar\n2000-01-08 -1.057072 -0.864360 -1.124870  1.732966  bar\n\n# as a multiple\nIn [525]: store.select_as_multiple(\n   .....:     [\"df1_mt\", \"df2_mt\"],\n   .....:     where=[\"A&gt;0\", \"B&gt;0\"],\n   .....:     selector=\"df1_mt\",\n   .....: )\n   .....: \nOut[525]: \n                   A         B         C         D         E         F  foo\n2000-01-05  1.043605  1.798494 -1.954845 -1.712882 -0.204377 -1.608953  bar\n2000-01-07  0.150568  0.754820 -1.935461  1.007668  0.079529 -1.459471  bar\n</pre></div> </div> </section> </section> <section id=\"delete-from-a-table\"> <h3>Delete from a table</h3> <p>You can delete from a table selectively by specifying a <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code>. In deleting rows, it is important to understand the <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> deletes rows by erasing the rows, then <strong>moving</strong> the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. To get optimal performance, it’s worthwhile to have the dimension you are deleting be the first of the <code class=\"docutils literal notranslate\"><span class=\"pre\">indexables</span></code>.</p> <p>Data is ordered (on the disk) in terms of the <code class=\"docutils literal notranslate\"><span class=\"pre\">indexables</span></code>. Here’s a simple use case. You store panel-type data, with dates in the <code class=\"docutils literal notranslate\"><span class=\"pre\">major_axis</span></code> and ids in the <code class=\"docutils literal notranslate\"><span class=\"pre\">minor_axis</span></code>. The data is then interleaved like this:</p> <ul class=\"simple\"> <li>\n<dl class=\"simple\"> <dt>date_1</dt>\n<dd>\n<ul> <li><p>id_1</p></li> <li><p>id_2</p></li> <li><p>.</p></li> <li><p>id_n</p></li> </ul> </dd> </dl> </li> <li>\n<dl class=\"simple\"> <dt>date_2</dt>\n<dd>\n<ul> <li><p>id_1</p></li> <li><p>.</p></li> <li><p>id_n</p></li> </ul> </dd> </dl> </li> </ul> <p>It should be clear that a delete operation on the <code class=\"docutils literal notranslate\"><span class=\"pre\">major_axis</span></code> will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the <code class=\"docutils literal notranslate\"><span class=\"pre\">minor_axis</span></code> will be very expensive. In this case it would almost certainly be faster to rewrite the table using a <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> that selects all but the missing data.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Please note that HDF5 <strong>DOES NOT RECLAIM SPACE</strong> in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, <strong>WILL TEND TO INCREASE THE FILE SIZE</strong>.</p> <p>To <em>repack and clean</em> the file, use <a class=\"reference internal\" href=\"#io-hdf5-ptrepack\"><span class=\"std std-ref\">ptrepack</span></a>.</p> </div> </section> <section id=\"notes-caveats\"> <h3>Notes &amp; caveats</h3> <section id=\"compression\"> <h4>Compression</h4> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> allows the stored data to be compressed. This applies to all kinds of stores, not just tables. Two parameters are used to control compression: <code class=\"docutils literal notranslate\"><span class=\"pre\">complevel</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">complib</span></code>.</p> <ul> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">complevel</span></code> specifies if and how hard data is to be compressed. <code class=\"docutils literal notranslate\"><span class=\"pre\">complevel=0</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">complevel=None</span></code> disables compression and <code class=\"docutils literal notranslate\"><span class=\"pre\">0&lt;complevel&lt;10</span></code> enables compression.</p></li> <li>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">complib</span></code> specifies which compression library to use. If nothing is specified the default library <code class=\"docutils literal notranslate\"><span class=\"pre\">zlib</span></code> is used. A compression library usually optimizes for either good compression rates or speed and the results will depend on the type of data. Which type of compression to choose depends on your specific needs and data. The list of supported compression libraries:</p> <ul> <li><p><a class=\"reference external\" href=\"https://zlib.net/\">zlib</a>: The default compression library. A classic in terms of compression, achieves good compression rates but is somewhat slow.</p></li> <li><p><a class=\"reference external\" href=\"https://www.oberhumer.com/opensource/lzo/\">lzo</a>: Fast compression and decompression.</p></li> <li><p><a class=\"reference external\" href=\"https://sourceware.org/bzip2/\">bzip2</a>: Good compression rates.</p></li> <li>\n<p><a class=\"reference external\" href=\"https://www.blosc.org/\">blosc</a>: Fast compression and decompression.</p> <p>Support for alternative blosc compressors:</p> <ul class=\"simple\"> <li><p><a class=\"reference external\" href=\"https://www.blosc.org/\">blosc:blosclz</a> This is the default compressor for <code class=\"docutils literal notranslate\"><span class=\"pre\">blosc</span></code></p></li> <li><p><a class=\"reference external\" href=\"https://fastcompression.blogspot.com/p/lz4.html\">blosc:lz4</a>: A compact, very popular and fast compressor.</p></li> <li><p><a class=\"reference external\" href=\"https://fastcompression.blogspot.com/p/lz4.html\">blosc:lz4hc</a>: A tweaked version of LZ4, produces better compression ratios at the expense of speed.</p></li> <li><p><a class=\"reference external\" href=\"https://google.github.io/snappy/\">blosc:snappy</a>: A popular compressor used in many places.</p></li> <li><p><a class=\"reference external\" href=\"https://zlib.net/\">blosc:zlib</a>: A classic; somewhat slower than the previous ones, but achieving better compression ratios.</p></li> <li><p><a class=\"reference external\" href=\"https://facebook.github.io/zstd/\">blosc:zstd</a>: An extremely well balanced codec; it provides the best compression ratios among the others above, and at reasonably fast speed.</p></li> </ul> </li> </ul> <p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">complib</span></code> is defined as something other than the listed libraries a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code> exception is issued.</p> </li> </ul> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>If the library specified with the <code class=\"docutils literal notranslate\"><span class=\"pre\">complib</span></code> option is missing on your platform, compression defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">zlib</span></code> without further ado.</p> </div> <p>Enable compression for all objects within the file:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">store_compressed = pd.HDFStore(\n    \"store_compressed.h5\", complevel=9, complib=\"blosc:blosclz\"\n)\n</pre></div> </div> <p>Or on-the-fly compression (this only applies to tables) in stores where compression is not enabled:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">store.append(\"df\", df, complib=\"zlib\", complevel=5)\n</pre></div> </div> </section> <section id=\"ptrepack\"> <h4>ptrepack</h4> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> utility <code class=\"docutils literal notranslate\"><span class=\"pre\">ptrepack</span></code>. In addition, <code class=\"docutils literal notranslate\"><span class=\"pre\">ptrepack</span></code> can change compression levels after the fact.</p> <div class=\"highlight-console notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">ptrepack --chunkshape=auto --propindexes --complevel=9 --complib=blosc in.h5 out.h5\n</pre></div> </div> <p>Furthermore <code class=\"docutils literal notranslate\"><span class=\"pre\">ptrepack</span> <span class=\"pre\">in.h5</span> <span class=\"pre\">out.h5</span></code> will <em>repack</em> the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the <code class=\"docutils literal notranslate\"><span class=\"pre\">copy</span></code> method.</p> </section> <section id=\"caveats\"> <h4>Caveats</h4> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> is <strong>not-threadsafe for writing</strong>. The underlying <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> only supports concurrent reads (via threading or processes). If you need reading and writing <em>at the same time</em>, you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (<a class=\"reference external\" href=\"https://github.com/pandas-dev/pandas/issues/2397\">GH2397</a>) for more information.</p> </div> <ul class=\"simple\"> <li><p>If you use locks to manage write access between multiple processes, you may want to use <a class=\"reference external\" href=\"https://docs.python.org/3/library/os.html#os.fsync\" title=\"(in Python v3.10)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">fsync()</span></code></a> before releasing write locks. For convenience you can use <code class=\"docutils literal notranslate\"><span class=\"pre\">store.flush(fsync=True)</span></code> to do this for you.</p></li> <li><p>Once a <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> is created columns (DataFrame) are fixed; only exactly the same columns can be appended</p></li> <li><p>Be aware that timezones (e.g., <code class=\"docutils literal notranslate\"><span class=\"pre\">pytz.timezone('US/Eastern')</span></code>) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use <code class=\"docutils literal notranslate\"><span class=\"pre\">tz_convert</span></code> with the updated timezone definition.</p></li> </ul> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> will show a <code class=\"docutils literal notranslate\"><span class=\"pre\">NaturalNameWarning</span></code> if a column name cannot be used as an attribute selector. <em>Natural</em> identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> clause and are generally a bad idea.</p> </div> </section> </section> <section id=\"datatypes\"> <h3>DataTypes</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> will map an object dtype to the <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> underlying dtype. This means the following types are known to work:</p> <table class=\"table\"> <colgroup> <col style=\"width: 68%\"> <col style=\"width: 32%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Type</p></th> <th class=\"head\"><p>Represents missing values</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>floating : <code class=\"docutils literal notranslate\"><span class=\"pre\">float64,</span> <span class=\"pre\">float32,</span> <span class=\"pre\">float16</span></code></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code></p></td> </tr> <tr class=\"row-odd\">\n<td><p>integer : <code class=\"docutils literal notranslate\"><span class=\"pre\">int64,</span> <span class=\"pre\">int32,</span> <span class=\"pre\">int8,</span> <span class=\"pre\">uint64,uint32,</span> <span class=\"pre\">uint8</span></code></p></td> <td></td> </tr> <tr class=\"row-even\">\n<td><p>boolean</p></td> <td></td> </tr> <tr class=\"row-odd\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">datetime64[ns]</span></code></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">NaT</span></code></p></td> </tr> <tr class=\"row-even\">\n<td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">timedelta64[ns]</span></code></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">NaT</span></code></p></td> </tr> <tr class=\"row-odd\">\n<td><p>categorical : see the section below</p></td> <td></td> </tr> <tr class=\"row-even\">\n<td><p>object : <code class=\"docutils literal notranslate\"><span class=\"pre\">strings</span></code></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code></p></td> </tr> </tbody> </table> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">unicode</span></code> columns are not supported, and <strong>WILL FAIL</strong>.</p> <section id=\"categorical-data\"> <h4>Categorical data</h4> <p>You can write data that contains <code class=\"docutils literal notranslate\"><span class=\"pre\">category</span></code> dtypes to a <code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code>. Queries work the same as if it was an object array. However, the <code class=\"docutils literal notranslate\"><span class=\"pre\">category</span></code> dtyped data is stored in a more efficient manner.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [526]: dfcat = pd.DataFrame(\n   .....:     {\"A\": pd.Series(list(\"aabbcdba\")).astype(\"category\"), \"B\": np.random.randn(8)}\n   .....: )\n   .....: \n\nIn [527]: dfcat\nOut[527]: \n   A         B\n0  a  0.477849\n1  a  0.283128\n2  b -2.045700\n3  b -0.338206\n4  c -0.423113\n5  d  2.314361\n6  b -0.033100\n7  a -0.965461\n\nIn [528]: dfcat.dtypes\nOut[528]: \nA    category\nB     float64\ndtype: object\n\nIn [529]: cstore = pd.HDFStore(\"cats.h5\", mode=\"w\")\n\nIn [530]: cstore.append(\"dfcat\", dfcat, format=\"table\", data_columns=[\"A\"])\n\nIn [531]: result = cstore.select(\"dfcat\", where=\"A in ['b', 'c']\")\n\nIn [532]: result\nOut[532]: \n   A         B\n2  b -2.045700\n3  b -0.338206\n4  c -0.423113\n6  b -0.033100\n\nIn [533]: result.dtypes\nOut[533]: \nA    category\nB     float64\ndtype: object\n</pre></div> </div> </section> <section id=\"string-columns\"> <h4>String columns</h4> <p><strong>min_itemsize</strong></p> <p>The underlying implementation of <code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the <code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code>, <strong>in the first append</strong>. Subsequent appends, may introduce a string for a column <strong>larger</strong> than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur.</p> <p>Pass <code class=\"docutils literal notranslate\"><span class=\"pre\">min_itemsize</span></code> on the first table creation to a-priori specify the minimum length of a particular string column. <code class=\"docutils literal notranslate\"><span class=\"pre\">min_itemsize</span></code> can be an integer, or a dict mapping a column name to an integer. You can pass <code class=\"docutils literal notranslate\"><span class=\"pre\">values</span></code> as a key to allow all <em>indexables</em> or <em>data_columns</em> to have this min_itemsize.</p> <p>Passing a <code class=\"docutils literal notranslate\"><span class=\"pre\">min_itemsize</span></code> dict will cause all passed columns to be created as <em>data_columns</em> automatically.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>If you are not passing any <code class=\"docutils literal notranslate\"><span class=\"pre\">data_columns</span></code>, then the <code class=\"docutils literal notranslate\"><span class=\"pre\">min_itemsize</span></code> will be the maximum of the length of any string passed</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [534]: dfs = pd.DataFrame({\"A\": \"foo\", \"B\": \"bar\"}, index=list(range(5)))\n\nIn [535]: dfs\nOut[535]: \n     A    B\n0  foo  bar\n1  foo  bar\n2  foo  bar\n3  foo  bar\n4  foo  bar\n\n# A and B have a size of 30\nIn [536]: store.append(\"dfs\", dfs, min_itemsize=30)\n\nIn [537]: store.get_storer(\"dfs\").table\nOut[537]: \n/dfs/table (Table(5,)) ''\n  description := {\n  \"index\": Int64Col(shape=(), dflt=0, pos=0),\n  \"values_block_0\": StringCol(itemsize=30, shape=(2,), dflt=b'', pos=1)}\n  byteorder := 'little'\n  chunkshape := (963,)\n  autoindex := True\n  colindexes := {\n    \"index\": Index(6, medium, shuffle, zlib(1)).is_csi=False}\n\n# A is created as a data_column with a size of 30\n# B is size is calculated\nIn [538]: store.append(\"dfs2\", dfs, min_itemsize={\"A\": 30})\n\nIn [539]: store.get_storer(\"dfs2\").table\nOut[539]: \n/dfs2/table (Table(5,)) ''\n  description := {\n  \"index\": Int64Col(shape=(), dflt=0, pos=0),\n  \"values_block_0\": StringCol(itemsize=3, shape=(1,), dflt=b'', pos=1),\n  \"A\": StringCol(itemsize=30, shape=(), dflt=b'', pos=2)}\n  byteorder := 'little'\n  chunkshape := (1598,)\n  autoindex := True\n  colindexes := {\n    \"index\": Index(6, medium, shuffle, zlib(1)).is_csi=False,\n    \"A\": Index(6, medium, shuffle, zlib(1)).is_csi=False}\n</pre></div> </div> <p><strong>nan_rep</strong></p> <p>String columns will serialize a <code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code> (a missing value) with the <code class=\"docutils literal notranslate\"><span class=\"pre\">nan_rep</span></code> string representation. This defaults to the string value <code class=\"docutils literal notranslate\"><span class=\"pre\">nan</span></code>. You could inadvertently turn an actual <code class=\"docutils literal notranslate\"><span class=\"pre\">nan</span></code> value into a missing value.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [540]: dfss = pd.DataFrame({\"A\": [\"foo\", \"bar\", \"nan\"]})\n\nIn [541]: dfss\nOut[541]: \n     A\n0  foo\n1  bar\n2  nan\n\nIn [542]: store.append(\"dfss\", dfss)\n\nIn [543]: store.select(\"dfss\")\nOut[543]: \n     A\n0  foo\n1  bar\n2  NaN\n\n# here you need to specify a different nan rep\nIn [544]: store.append(\"dfss2\", dfss, nan_rep=\"_nan_\")\n\nIn [545]: store.select(\"dfss2\")\nOut[545]: \n     A\n0  foo\n1  bar\n2  nan\n</pre></div> </div> </section> </section> <section id=\"external-compatibility\"> <h3>External compatibility</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> writes <code class=\"docutils literal notranslate\"><span class=\"pre\">table</span></code> format objects in specific formats suitable for producing loss-less round trips to pandas objects. For external compatibility, <code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> can read native <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> format tables.</p> <p>It is possible to write an <code class=\"docutils literal notranslate\"><span class=\"pre\">HDFStore</span></code> object that can easily be imported into <code class=\"docutils literal notranslate\"><span class=\"pre\">R</span></code> using the <code class=\"docutils literal notranslate\"><span class=\"pre\">rhdf5</span></code> library (<a class=\"reference external\" href=\"https://www.bioconductor.org/packages/release/bioc/html/rhdf5.html\">Package website</a>). Create a table format store like this:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [546]: df_for_r = pd.DataFrame(\n   .....:     {\n   .....:         \"first\": np.random.rand(100),\n   .....:         \"second\": np.random.rand(100),\n   .....:         \"class\": np.random.randint(0, 2, (100,)),\n   .....:     },\n   .....:     index=range(100),\n   .....: )\n   .....: \n\nIn [547]: df_for_r.head()\nOut[547]: \n      first    second  class\n0  0.864919  0.852910      0\n1  0.030579  0.412962      1\n2  0.015226  0.978410      0\n3  0.498512  0.686761      0\n4  0.232163  0.328185      1\n\nIn [548]: store_export = pd.HDFStore(\"export.h5\")\n\nIn [549]: store_export.append(\"df_for_r\", df_for_r, data_columns=df_dc.columns)\n\nIn [550]: store_export\nOut[550]: \n&lt;class 'pandas.io.pytables.HDFStore'&gt;\nFile path: export.h5\n</pre></div> </div> <p>In R this file can be read into a <code class=\"docutils literal notranslate\"><span class=\"pre\">data.frame</span></code> object using the <code class=\"docutils literal notranslate\"><span class=\"pre\">rhdf5</span></code> library. The following example function reads the corresponding column names and data values from the values and assembles them into a <code class=\"docutils literal notranslate\"><span class=\"pre\">data.frame</span></code>:</p> <div class=\"highlight-R notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Load values and column names for all datasets from corresponding nodes and\n# insert them into one data.frame object.\n\nlibrary(rhdf5)\n\nloadhdf5data &lt;- function(h5File) {\n\nlisting &lt;- h5ls(h5File)\n# Find all data nodes, values are stored in *_values and corresponding column\n# titles in *_items\ndata_nodes &lt;- grep(\"_values\", listing$name)\nname_nodes &lt;- grep(\"_items\", listing$name)\ndata_paths = paste(listing$group[data_nodes], listing$name[data_nodes], sep = \"/\")\nname_paths = paste(listing$group[name_nodes], listing$name[name_nodes], sep = \"/\")\ncolumns = list()\nfor (idx in seq(data_paths)) {\n  # NOTE: matrices returned by h5read have to be transposed to obtain\n  # required Fortran order!\n  data &lt;- data.frame(t(h5read(h5File, data_paths[idx])))\n  names &lt;- t(h5read(h5File, name_paths[idx]))\n  entry &lt;- data.frame(data)\n  colnames(entry) &lt;- names\n  columns &lt;- append(columns, entry)\n}\n\ndata &lt;- data.frame(columns)\n\nreturn(data)\n}\n</pre></div> </div> <p>Now you can import the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> into R:</p> <div class=\"highlight-R notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt; data = loadhdf5data(\"transfer.hdf5\")\n&gt; head(data)\n         first    second class\n1 0.4170220047 0.3266449     0\n2 0.7203244934 0.5270581     0\n3 0.0001143748 0.8859421     1\n4 0.3023325726 0.3572698     1\n5 0.1467558908 0.9085352     1\n6 0.0923385948 0.6233601     1\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The R function lists the entire HDF5 file’s contents and assembles the <code class=\"docutils literal notranslate\"><span class=\"pre\">data.frame</span></code> object from all matching nodes, so use this only as a starting point if you have stored multiple <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> objects to a single HDF5 file.</p> </div> </section> <section id=\"performance\"> <h3>Performance</h3> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">tables</span></code> format come with a writing performance penalty as compared to <code class=\"docutils literal notranslate\"><span class=\"pre\">fixed</span></code> stores. The benefit is the ability to append/delete and query (potentially very large amounts of data). Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis.</p></li> <li><p>You can pass <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize=&lt;int&gt;</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">append</span></code>, specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing.</p></li> <li><p>You can pass <code class=\"docutils literal notranslate\"><span class=\"pre\">expectedrows=&lt;int&gt;</span></code> to the first <code class=\"docutils literal notranslate\"><span class=\"pre\">append</span></code>, to set the TOTAL number of rows that <code class=\"docutils literal notranslate\"><span class=\"pre\">PyTables</span></code> will expect. This will optimize read/write performance.</p></li> <li><p>Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)</p></li> <li><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">PerformanceWarning</span></code> will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See <a class=\"reference external\" href=\"https://stackoverflow.com/questions/14355151/how-to-make-pandas-hdfstore-put-operation-faster/14370190#14370190\">Here</a> for more information and some solutions.</p></li> </ul> </section> </section> <section id=\"feather\"> <h2>Feather</h2> <p>Feather provides binary columnar serialization for data frames. It is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy.</p> <p>Feather is designed to faithfully serialize and de-serialize DataFrames, supporting all of the pandas dtypes, including extension dtypes such as categorical and datetime with tz.</p> <p>Several caveats:</p> <ul class=\"simple\"> <li><p>The format will NOT write an <code class=\"docutils literal notranslate\"><span class=\"pre\">Index</span></code>, or <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> for the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> and will raise an error if a non-default one is provided. You can <code class=\"docutils literal notranslate\"><span class=\"pre\">.reset_index()</span></code> to store the index or <code class=\"docutils literal notranslate\"><span class=\"pre\">.reset_index(drop=True)</span></code> to ignore it.</p></li> <li><p>Duplicate column names and non-string columns names are not supported</p></li> <li><p>Actual Python objects in object dtype columns are not supported. These will raise a helpful error message on an attempt at serialization.</p></li> </ul> <p>See the <a class=\"reference external\" href=\"https://github.com/wesm/feather\">Full Documentation</a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [551]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"a\": list(\"abc\"),\n   .....:         \"b\": list(range(1, 4)),\n   .....:         \"c\": np.arange(3, 6).astype(\"u1\"),\n   .....:         \"d\": np.arange(4.0, 7.0, dtype=\"float64\"),\n   .....:         \"e\": [True, False, True],\n   .....:         \"f\": pd.Categorical(list(\"abc\")),\n   .....:         \"g\": pd.date_range(\"20130101\", periods=3),\n   .....:         \"h\": pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n   .....:         \"i\": pd.date_range(\"20130101\", periods=3, freq=\"ns\"),\n   .....:     }\n   .....: )\n   .....: \n\nIn [552]: df\nOut[552]: \n   a  b  c    d      e  f          g                         h                             i\n0  a  1  3  4.0   True  a 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00.000000000\n1  b  2  4  5.0  False  b 2013-01-02 2013-01-02 00:00:00-05:00 2013-01-01 00:00:00.000000001\n2  c  3  5  6.0   True  c 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-01 00:00:00.000000002\n\nIn [553]: df.dtypes\nOut[553]: \na                        object\nb                         int64\nc                         uint8\nd                       float64\ne                          bool\nf                      category\ng                datetime64[ns]\nh    datetime64[ns, US/Eastern]\ni                datetime64[ns]\ndtype: object\n</pre></div> </div> <p>Write to a feather file.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [554]: df.to_feather(\"example.feather\")\n</pre></div> </div> <p>Read from a feather file.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [555]: result = pd.read_feather(\"example.feather\")\n\nIn [556]: result\nOut[556]: \n   a  b  c    d      e  f          g                         h                             i\n0  a  1  3  4.0   True  a 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00.000000000\n1  b  2  4  5.0  False  b 2013-01-02 2013-01-02 00:00:00-05:00 2013-01-01 00:00:00.000000001\n2  c  3  5  6.0   True  c 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-01 00:00:00.000000002\n\n# we preserve dtypes\nIn [557]: result.dtypes\nOut[557]: \na                        object\nb                         int64\nc                         uint8\nd                       float64\ne                          bool\nf                      category\ng                datetime64[ns]\nh    datetime64[ns, US/Eastern]\ni                datetime64[ns]\ndtype: object\n</pre></div> </div> </section> <section id=\"parquet\"> <h2>Parquet</h2> <p><a class=\"reference external\" href=\"https://parquet.apache.org/\">Apache Parquet</a> provides a partitioned binary columnar serialization for data frames. It is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy. Parquet can use a variety of compression techniques to shrink the file size as much as possible while still maintaining good read performance.</p> <p>Parquet is designed to faithfully serialize and de-serialize <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> s, supporting all of the pandas dtypes, including extension dtypes such as datetime with tz.</p> <p>Several caveats.</p> <ul class=\"simple\"> <li><p>Duplicate column names and non-string columns names are not supported.</p></li> <li><p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> engine always writes the index to the output, but <code class=\"docutils literal notranslate\"><span class=\"pre\">fastparquet</span></code> only writes non-default indexes. This extra column can cause problems for non-pandas consumers that are not expecting it. You can force including or omitting indexes with the <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> argument, regardless of the underlying engine.</p></li> <li><p>Index level names, if specified, must be strings.</p></li> <li><p>In the <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> engine, categorical dtypes for non-string types can be serialized to parquet, but will de-serialize as their primitive dtype.</p></li> <li><p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> engine preserves the <code class=\"docutils literal notranslate\"><span class=\"pre\">ordered</span></code> flag of categorical dtypes with string types. <code class=\"docutils literal notranslate\"><span class=\"pre\">fastparquet</span></code> does not preserve the <code class=\"docutils literal notranslate\"><span class=\"pre\">ordered</span></code> flag.</p></li> <li><p>Non supported types include <code class=\"docutils literal notranslate\"><span class=\"pre\">Interval</span></code> and actual Python object types. These will raise a helpful error message on an attempt at serialization. <code class=\"docutils literal notranslate\"><span class=\"pre\">Period</span></code> type is supported with pyarrow &gt;= 0.16.0.</p></li> <li><p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> engine preserves extension data types such as the nullable integer and string data type (requiring pyarrow &gt;= 0.16.0, and requiring the extension type to implement the needed protocols, see the <a class=\"reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/development/extending.html#extending-extension-arrow\"><span class=\"std std-ref\">extension types documentation</span></a>).</p></li> </ul> <p>You can specify an <code class=\"docutils literal notranslate\"><span class=\"pre\">engine</span></code> to direct the serialization. This can be one of <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code>, or <code class=\"docutils literal notranslate\"><span class=\"pre\">fastparquet</span></code>, or <code class=\"docutils literal notranslate\"><span class=\"pre\">auto</span></code>. If the engine is NOT specified, then the <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.options.io.parquet.engine</span></code> option is checked; if this is also <code class=\"docutils literal notranslate\"><span class=\"pre\">auto</span></code>, then <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> is tried, and falling back to <code class=\"docutils literal notranslate\"><span class=\"pre\">fastparquet</span></code>.</p> <p>See the documentation for <a class=\"reference external\" href=\"https://arrow.apache.org/docs/python/\">pyarrow</a> and <a class=\"reference external\" href=\"https://fastparquet.readthedocs.io/en/latest/\">fastparquet</a>.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>These engines are very similar and should read/write nearly identical parquet format files. Currently <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> does not support timedelta data, <code class=\"docutils literal notranslate\"><span class=\"pre\">fastparquet&gt;=0.1.4</span></code> supports timezone aware datetimes. These libraries differ by having different underlying dependencies (<code class=\"docutils literal notranslate\"><span class=\"pre\">fastparquet</span></code> by using <code class=\"docutils literal notranslate\"><span class=\"pre\">numba</span></code>, while <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> uses a c-library).</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [558]: df = pd.DataFrame(\n   .....:     {\n   .....:         \"a\": list(\"abc\"),\n   .....:         \"b\": list(range(1, 4)),\n   .....:         \"c\": np.arange(3, 6).astype(\"u1\"),\n   .....:         \"d\": np.arange(4.0, 7.0, dtype=\"float64\"),\n   .....:         \"e\": [True, False, True],\n   .....:         \"f\": pd.date_range(\"20130101\", periods=3),\n   .....:         \"g\": pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n   .....:         \"h\": pd.Categorical(list(\"abc\")),\n   .....:         \"i\": pd.Categorical(list(\"abc\"), ordered=True),\n   .....:     }\n   .....: )\n   .....: \n\nIn [559]: df\nOut[559]: \n   a  b  c    d      e          f                         g  h  i\n0  a  1  3  4.0   True 2013-01-01 2013-01-01 00:00:00-05:00  a  a\n1  b  2  4  5.0  False 2013-01-02 2013-01-02 00:00:00-05:00  b  b\n2  c  3  5  6.0   True 2013-01-03 2013-01-03 00:00:00-05:00  c  c\n\nIn [560]: df.dtypes\nOut[560]: \na                        object\nb                         int64\nc                         uint8\nd                       float64\ne                          bool\nf                datetime64[ns]\ng    datetime64[ns, US/Eastern]\nh                      category\ni                      category\ndtype: object\n</pre></div> </div> <p>Write to a parquet file.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [561]: df.to_parquet(\"example_pa.parquet\", engine=\"pyarrow\")\n\nIn [562]: df.to_parquet(\"example_fp.parquet\", engine=\"fastparquet\")\n</pre></div> </div> <p>Read from a parquet file.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [563]: result = pd.read_parquet(\"example_fp.parquet\", engine=\"fastparquet\")\n\nIn [564]: result = pd.read_parquet(\"example_pa.parquet\", engine=\"pyarrow\")\n\nIn [565]: result.dtypes\nOut[565]: \na                        object\nb                         int64\nc                         uint8\nd                       float64\ne                          bool\nf                datetime64[ns]\ng    datetime64[ns, US/Eastern]\nh                      category\ni                      category\ndtype: object\n</pre></div> </div> <p>Read only certain columns of a parquet file.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [566]: result = pd.read_parquet(\n   .....:     \"example_fp.parquet\",\n   .....:     engine=\"fastparquet\",\n   .....:     columns=[\"a\", \"b\"],\n   .....: )\n   .....: \n\nIn [567]: result = pd.read_parquet(\n   .....:     \"example_pa.parquet\",\n   .....:     engine=\"pyarrow\",\n   .....:     columns=[\"a\", \"b\"],\n   .....: )\n   .....: \n\nIn [568]: result.dtypes\nOut[568]: \na    object\nb     int64\ndtype: object\n</pre></div> </div> <section id=\"handling-indexes\"> <h3>Handling indexes</h3> <p>Serializing a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> to parquet may include the implicit index as one or more columns in the output file. Thus, this code:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [569]: df = pd.DataFrame({\"a\": [1, 2], \"b\": [3, 4]})\n\nIn [570]: df.to_parquet(\"test.parquet\", engine=\"pyarrow\")\n</pre></div> </div> <p>creates a parquet file with <em>three</em> columns if you use <code class=\"docutils literal notranslate\"><span class=\"pre\">pyarrow</span></code> for serialization: <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">__index_level_0__</span></code>. If you’re using <code class=\"docutils literal notranslate\"><span class=\"pre\">fastparquet</span></code>, the index <a class=\"reference external\" href=\"https://fastparquet.readthedocs.io/en/latest/api.html#fastparquet.write\">may or may not</a> be written to the file.</p> <p>This unexpected extra column causes some databases like Amazon Redshift to reject the file, because that column doesn’t exist in the target table.</p> <p>If you want to omit a dataframe’s indexes when writing, pass <code class=\"docutils literal notranslate\"><span class=\"pre\">index=False</span></code> to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_parquet#pandas.DataFrame.to_parquet\" title=\"pandas.DataFrame.to_parquet\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_parquet()</span></code></a>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [571]: df.to_parquet(\"test.parquet\", index=False)\n</pre></div> </div> <p>This creates a parquet file with just the two expected columns, <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code>. If your <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> has a custom index, you won’t get it back when you load this file into a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p> <p>Passing <code class=\"docutils literal notranslate\"><span class=\"pre\">index=True</span></code> will <em>always</em> write the index, even if that’s not the underlying engine’s default behavior.</p> </section> <section id=\"partitioning-parquet-files\"> <h3>Partitioning Parquet files</h3> <p>Parquet supports partitioning of data based on the values of one or more columns.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [572]: df = pd.DataFrame({\"a\": [0, 0, 1, 1], \"b\": [0, 1, 0, 1]})\n\nIn [573]: df.to_parquet(path=\"test\", engine=\"pyarrow\", partition_cols=[\"a\"], compression=None)\n</pre></div> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">path</span></code> specifies the parent directory to which data will be saved. The <code class=\"docutils literal notranslate\"><span class=\"pre\">partition_cols</span></code> are the column names by which the dataset will be partitioned. Columns are partitioned in the order they are given. The partition splits are determined by the unique values in the partition columns. The above example creates a partitioned dataset that may look like:</p> <div class=\"highlight-text notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">test\n├── a=0\n│   ├── 0bac803e32dc42ae83fddfd029cbdebc.parquet\n│   └──  ...\n└── a=1\n    ├── e6ab24a4f45147b49b54a662f0c412a3.parquet\n    └── ...\n</pre></div> </div> </section> </section> <section id=\"orc\"> <h2>ORC</h2> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 1.0.0.</span></p> </div> <p>Similar to the <a class=\"reference internal\" href=\"#io-parquet\"><span class=\"std std-ref\">parquet</span></a> format, the <a class=\"reference external\" href=\"https://orc.apache.org/\">ORC Format</a> is a binary columnar serialization for data frames. It is designed to make reading data frames efficient. pandas provides <em>only</em> a reader for the ORC format, <a class=\"reference internal\" href=\"../reference/api/pandas.read_orc#pandas.read_orc\" title=\"pandas.read_orc\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_orc()</span></code></a>. This requires the <a class=\"reference external\" href=\"https://arrow.apache.org/docs/python/\">pyarrow</a> library.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <ul class=\"simple\"> <li><p>It is <em>highly recommended</em> to install pyarrow using conda due to some issues occurred by pyarrow.</p></li> <li><p><a class=\"reference internal\" href=\"../reference/api/pandas.read_orc#pandas.read_orc\" title=\"pandas.read_orc\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_orc()</span></code></a> is not supported on Windows yet, you can find valid environments on <a class=\"reference internal\" href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/getting_started/install.html#install-warn-orc\"><span class=\"std std-ref\">install optional dependencies</span></a>.</p></li> </ul> </div> </section> <section id=\"sql-queries\"> <h2>SQL queries</h2> <p>The <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">pandas.io.sql</span></code> module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Database abstraction is provided by SQLAlchemy if installed. In addition you will need a driver library for your database. Examples of such drivers are <a class=\"reference external\" href=\"https://www.psycopg.org/\">psycopg2</a> for PostgreSQL or <a class=\"reference external\" href=\"https://github.com/PyMySQL/PyMySQL\">pymysql</a> for MySQL. For <a class=\"reference external\" href=\"https://docs.python.org/3/library/sqlite3.html\">SQLite</a> this is included in Python’s standard library by default. You can find an overview of supported drivers for each SQL dialect in the <a class=\"reference external\" href=\"https://docs.sqlalchemy.org/en/latest/dialects/index.html\">SQLAlchemy docs</a>.</p> <p>If SQLAlchemy is not installed, a fallback is only provided for sqlite (and for mysql for backwards compatibility, but this is deprecated and will be removed in a future version). This mode requires a Python database adapter which respect the <a class=\"reference external\" href=\"https://www.python.org/dev/peps/pep-0249/\">Python DB-API</a>.</p> <p>See also some <a class=\"reference internal\" href=\"cookbook#cookbook-sql\"><span class=\"std std-ref\">cookbook examples</span></a> for some advanced strategies.</p> <p>The key functions are:</p> <table class=\"longtable table autosummary\"> <colgroup> <col style=\"width: 10%\"> <col style=\"width: 90%\"> </colgroup> <tbody> <tr class=\"row-odd\">\n<td><p><a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_table#pandas.read_sql_table\" title=\"pandas.read_sql_table\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">read_sql_table</span></code></a>(table_name, con[, schema, ...])</p></td> <td><p>Read SQL database table into a DataFrame.</p></td> </tr> <tr class=\"row-even\">\n<td><p><a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_query#pandas.read_sql_query\" title=\"pandas.read_sql_query\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">read_sql_query</span></code></a>(sql, con[, index_col, ...])</p></td> <td><p>Read SQL query into a DataFrame.</p></td> </tr> <tr class=\"row-odd\">\n<td><p><a class=\"reference internal\" href=\"../reference/api/pandas.read_sql#pandas.read_sql\" title=\"pandas.read_sql\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">read_sql</span></code></a>(sql, con[, index_col, ...])</p></td> <td><p>Read SQL query or database table into a DataFrame.</p></td> </tr> <tr class=\"row-even\">\n<td><p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_sql#pandas.DataFrame.to_sql\" title=\"pandas.DataFrame.to_sql\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DataFrame.to_sql</span></code></a>(name, con[, schema, ...])</p></td> <td><p>Write records stored in a DataFrame to a SQL database.</p></td> </tr> </tbody> </table> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The function <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql#pandas.read_sql\" title=\"pandas.read_sql\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql()</span></code></a> is a convenience wrapper around <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_table#pandas.read_sql_table\" title=\"pandas.read_sql_table\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_table()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_query#pandas.read_sql_query\" title=\"pandas.read_sql_query\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_query()</span></code></a> (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters.</p> </div> <p>In the following example, we use the <a class=\"reference external\" href=\"https://www.sqlite.org/index.html\">SQlite</a> SQL database engine. You can use a temporary SQLite database where data are stored in “memory”.</p> <p>To connect with SQLAlchemy you use the <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">create_engine()</span></code> function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">create_engine()</span></code> and the URI formatting, see the examples below and the SQLAlchemy <a class=\"reference external\" href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html\">documentation</a></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [574]: from sqlalchemy import create_engine\n\n# Create your engine.\nIn [575]: engine = create_engine(\"sqlite:///:memory:\")\n</pre></div> </div> <p>If you want to manage your own connections you can pass one of those instead. The example below opens a connection to the database using a Python context manager that automatically closes the connection after the block has completed. See the <a class=\"reference external\" href=\"https://docs.sqlalchemy.org/en/latest/core/connections.html#basic-usage\">SQLAlchemy docs</a> for an explanation of how the database connection is handled.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">with engine.connect() as conn, conn.begin():\n    data = pd.read_sql_table(\"data\", conn)\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>When you open a connection to a database you are also responsible for closing it. Side effects of leaving a connection open may include locking the database or other breaking behaviour.</p> </div> <section id=\"writing-dataframes\"> <h3>Writing DataFrames</h3> <p>Assuming the following data is in a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code>, we can insert it into the database using <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_sql#pandas.DataFrame.to_sql\" title=\"pandas.DataFrame.to_sql\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_sql()</span></code></a>.</p> <table class=\"table\"> <colgroup> <col style=\"width: 13%\"> <col style=\"width: 32%\"> <col style=\"width: 18%\"> <col style=\"width: 18%\"> <col style=\"width: 18%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>id</p></th> <th class=\"head\"><p>Date</p></th> <th class=\"head\"><p>Col_1</p></th> <th class=\"head\"><p>Col_2</p></th> <th class=\"head\"><p>Col_3</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>26</p></td> <td><p>2012-10-18</p></td> <td><p>X</p></td> <td><p>25.7</p></td> <td><p>True</p></td> </tr> <tr class=\"row-odd\">\n<td><p>42</p></td> <td><p>2012-10-19</p></td> <td><p>Y</p></td> <td><p>-12.4</p></td> <td><p>False</p></td> </tr> <tr class=\"row-even\">\n<td><p>63</p></td> <td><p>2012-10-20</p></td> <td><p>Z</p></td> <td><p>5.73</p></td> <td><p>True</p></td> </tr> </tbody> </table> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [576]: data\nOut[576]: \n   id       Date Col_1  Col_2  Col_3\n0  26 2010-10-18     X  27.50   True\n1  42 2010-10-19     Y -12.50  False\n2  63 2010-10-20     Z   5.73   True\n\nIn [577]: data.to_sql(\"data\", engine)\nOut[577]: 3\n</pre></div> </div> <p>With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> parameter when calling <code class=\"docutils literal notranslate\"><span class=\"pre\">to_sql</span></code>. For example, the following writes <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code> to the database in batches of 1000 rows at a time:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [578]: data.to_sql(\"data_chunked\", engine, chunksize=1000)\nOut[578]: 3\n</pre></div> </div> <section id=\"sql-data-types\"> <h4>SQL data types</h4> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_sql#pandas.DataFrame.to_sql\" title=\"pandas.DataFrame.to_sql\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_sql()</span></code></a> will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code>, pandas will try to infer the data type.</p> <p>You can always override the default type by specifying the desired SQL type of any of the columns by using the <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code> argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy <code class=\"docutils literal notranslate\"><span class=\"pre\">String</span></code> type instead of the default <code class=\"docutils literal notranslate\"><span class=\"pre\">Text</span></code> type for string columns:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [579]: from sqlalchemy.types import String\n\nIn [580]: data.to_sql(\"data_dtype\", engine, dtype={\"Col_1\": String})\nOut[580]: 3\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Due to the limited support for timedelta’s in the different database flavors, columns with type <code class=\"docutils literal notranslate\"><span class=\"pre\">timedelta64</span></code> will be written as integer values as nanoseconds to the database and a warning will be raised.</p> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Columns of <code class=\"docutils literal notranslate\"><span class=\"pre\">category</span></code> dtype will be converted to the dense representation as you would get with <code class=\"docutils literal notranslate\"><span class=\"pre\">np.asarray(categorical)</span></code> (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does <strong>not</strong> generate a categorical.</p> </div> </section> </section> <section id=\"datetime-data-types\"> <h3>Datetime data types</h3> <p>Using SQLAlchemy, <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_sql#pandas.DataFrame.to_sql\" title=\"pandas.DataFrame.to_sql\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_sql()</span></code></a> is capable of writing datetime data that is timezone naive or timezone aware. However, the resulting data stored in the database ultimately depends on the supported data type for datetime data of the database system being used.</p> <p>The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data.</p> <table class=\"table\"> <colgroup> <col style=\"width: 15%\"> <col style=\"width: 60%\"> <col style=\"width: 25%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Database</p></th> <th class=\"head\"><p>SQL Datetime Types</p></th> <th class=\"head\"><p>Timezone Support</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>SQLite</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">TEXT</span></code></p></td> <td><p>No</p></td> </tr> <tr class=\"row-odd\">\n<td><p>MySQL</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">TIMESTAMP</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">DATETIME</span></code></p></td> <td><p>No</p></td> </tr> <tr class=\"row-even\">\n<td><p>PostgreSQL</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">TIMESTAMP</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">TIMESTAMP</span> <span class=\"pre\">WITH</span> <span class=\"pre\">TIME</span> <span class=\"pre\">ZONE</span></code></p></td> <td><p>Yes</p></td> </tr> </tbody> </table> <p>When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone.</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_table#pandas.read_sql_table\" title=\"pandas.read_sql_table\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_table()</span></code></a> is also capable of reading datetime data that is timezone aware or naive. When reading <code class=\"docutils literal notranslate\"><span class=\"pre\">TIMESTAMP</span> <span class=\"pre\">WITH</span> <span class=\"pre\">TIME</span> <span class=\"pre\">ZONE</span></code> types, pandas will convert the data to UTC.</p> <section id=\"insertion-method\"> <h4>Insertion method</h4> <p>The parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">method</span></code> controls the SQL insertion clause used. Possible values are:</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>: Uses standard SQL <code class=\"docutils literal notranslate\"><span class=\"pre\">INSERT</span></code> clause (one per row).</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">'multi'</span></code>: Pass multiple values in a single <code class=\"docutils literal notranslate\"><span class=\"pre\">INSERT</span></code> clause. It uses a <em>special</em> SQL syntax not supported by all backends. This usually provides better performance for analytic databases like <em>Presto</em> and <em>Redshift</em>, but has worse performance for traditional SQL backend if the table contains many columns. For more information check the SQLAlchemy <a class=\"reference external\" href=\"https://docs.sqlalchemy.org/en/latest/core/dml.html#sqlalchemy.sql.expression.Insert.values.params.*args\">documentation</a>.</p></li> <li><p>callable with signature <code class=\"docutils literal notranslate\"><span class=\"pre\">(pd_table,</span> <span class=\"pre\">conn,</span> <span class=\"pre\">keys,</span> <span class=\"pre\">data_iter)</span></code>: This can be used to implement a more performant insertion method based on specific backend dialect features.</p></li> </ul> <p>Example of a callable using PostgreSQL <a class=\"reference external\" href=\"https://www.postgresql.org/docs/current/sql-copy.html\">COPY clause</a>:</p> <div class=\"highlight-default notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># Alternative to_sql() *method* for DBs that support COPY FROM\nimport csv\nfrom io import StringIO\n\ndef psql_insert_copy(table, conn, keys, data_iter):\n    \"\"\"\n    Execute SQL statement inserting data\n\n    Parameters\n    ----------\n    table : pandas.io.sql.SQLTable\n    conn : sqlalchemy.engine.Engine or sqlalchemy.engine.Connection\n    keys : list of str\n        Column names\n    data_iter : Iterable that iterates the values to be inserted\n    \"\"\"\n    # gets a DBAPI connection that can provide a cursor\n    dbapi_conn = conn.connection\n    with dbapi_conn.cursor() as cur:\n        s_buf = StringIO()\n        writer = csv.writer(s_buf)\n        writer.writerows(data_iter)\n        s_buf.seek(0)\n\n        columns = ', '.join(['\"{}\"'.format(k) for k in keys])\n        if table.schema:\n            table_name = '{}.{}'.format(table.schema, table.name)\n        else:\n            table_name = table.name\n\n        sql = 'COPY {} ({}) FROM STDIN WITH CSV'.format(\n            table_name, columns)\n        cur.copy_expert(sql=sql, file=s_buf)\n</pre></div> </div> </section> </section> <section id=\"reading-tables\"> <h3>Reading tables</h3> <p><a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_table#pandas.read_sql_table\" title=\"pandas.read_sql_table\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_table()</span></code></a> will read a database table given the table name and optionally a subset of columns to read.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>In order to use <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_table#pandas.read_sql_table\" title=\"pandas.read_sql_table\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_table()</span></code></a>, you <strong>must</strong> have the SQLAlchemy optional dependency installed.</p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [581]: pd.read_sql_table(\"data\", engine)\nOut[581]: \n   index  id       Date Col_1  Col_2  Col_3\n0      0  26 2010-10-18     X  27.50   True\n1      1  42 2010-10-19     Y -12.50  False\n2      2  63 2010-10-20     Z   5.73   True\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Note that pandas infers column dtypes from query outputs, and not by looking up data types in the physical database schema. For example, assume <code class=\"docutils literal notranslate\"><span class=\"pre\">userid</span></code> is an integer column in a table. Then, intuitively, <code class=\"docutils literal notranslate\"><span class=\"pre\">select</span> <span class=\"pre\">userid</span> <span class=\"pre\">...</span></code> will return integer-valued series, while <code class=\"docutils literal notranslate\"><span class=\"pre\">select</span> <span class=\"pre\">cast(userid</span> <span class=\"pre\">as</span> <span class=\"pre\">text)</span> <span class=\"pre\">...</span></code> will return object-valued (str) series. Accordingly, if the query output is empty, then all resulting columns will be returned as object-valued (since they are most general). If you foresee that your query will sometimes generate an empty result, you may want to explicitly typecast afterwards to ensure dtype integrity.</p> </div> <p>You can also specify the name of the column as the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> index, and specify a subset of columns to be read.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [582]: pd.read_sql_table(\"data\", engine, index_col=\"id\")\nOut[582]: \n    index       Date Col_1  Col_2  Col_3\nid                                      \n26      0 2010-10-18     X  27.50   True\n42      1 2010-10-19     Y -12.50  False\n63      2 2010-10-20     Z   5.73   True\n\nIn [583]: pd.read_sql_table(\"data\", engine, columns=[\"Col_1\", \"Col_2\"])\nOut[583]: \n  Col_1  Col_2\n0     X  27.50\n1     Y -12.50\n2     Z   5.73\n</pre></div> </div> <p>And you can explicitly force columns to be parsed as dates:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [584]: pd.read_sql_table(\"data\", engine, parse_dates=[\"Date\"])\nOut[584]: \n   index  id       Date Col_1  Col_2  Col_3\n0      0  26 2010-10-18     X  27.50   True\n1      1  42 2010-10-19     Y -12.50  False\n2      2  63 2010-10-20     Z   5.73   True\n</pre></div> </div> <p>If needed you can explicitly specify a format string, or a dict of arguments to pass to <a class=\"reference internal\" href=\"../reference/api/pandas.to_datetime#pandas.to_datetime\" title=\"pandas.to_datetime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">pandas.to_datetime()</span></code></a>:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">pd.read_sql_table(\"data\", engine, parse_dates={\"Date\": \"%Y-%m-%d\"})\npd.read_sql_table(\n    \"data\",\n    engine,\n    parse_dates={\"Date\": {\"format\": \"%Y-%m-%d %H:%M:%S\"}},\n)\n</pre></div> </div> <p>You can check if a table exists using <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">has_table()</span></code></p> </section> <section id=\"schema-support\"> <h3>Schema support</h3> <p>Reading from and writing to different schema’s is supported through the <code class=\"docutils literal notranslate\"><span class=\"pre\">schema</span></code> keyword in the <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_table#pandas.read_sql_table\" title=\"pandas.read_sql_table\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_table()</span></code></a> and <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.to_sql#pandas.DataFrame.to_sql\" title=\"pandas.DataFrame.to_sql\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_sql()</span></code></a> functions. Note however that this depends on the database flavor (sqlite does not have schema’s). For example:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df.to_sql(\"table\", engine, schema=\"other_schema\")\npd.read_sql_table(\"table\", engine, schema=\"other_schema\")\n</pre></div> </div> </section> <section id=\"id5\"> <h3>Querying</h3> <p>You can query using raw SQL in the <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_query#pandas.read_sql_query\" title=\"pandas.read_sql_query\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_query()</span></code></a> function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [585]: pd.read_sql_query(\"SELECT * FROM data\", engine)\nOut[585]: \n   index  id                        Date Col_1  Col_2  Col_3\n0      0  26  2010-10-18 00:00:00.000000     X  27.50      1\n1      1  42  2010-10-19 00:00:00.000000     Y -12.50      0\n2      2  63  2010-10-20 00:00:00.000000     Z   5.73      1\n</pre></div> </div> <p>Of course, you can specify a more “complex” query.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [586]: pd.read_sql_query(\"SELECT id, Col_1, Col_2 FROM data WHERE id = 42;\", engine)\nOut[586]: \n   id Col_1  Col_2\n0  42     Y  -12.5\n</pre></div> </div> <p>The <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql_query#pandas.read_sql_query\" title=\"pandas.read_sql_query\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql_query()</span></code></a> function supports a <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> argument. Specifying this will return an iterator through chunks of the query result:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [587]: df = pd.DataFrame(np.random.randn(20, 3), columns=list(\"abc\"))\n\nIn [588]: df.to_sql(\"data_chunks\", engine, index=False)\nOut[588]: 20\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [589]: for chunk in pd.read_sql_query(\"SELECT * FROM data_chunks\", engine, chunksize=5):\n   .....:     print(chunk)\n   .....: \n          a         b         c\n0  0.092961 -0.674003  1.104153\n1 -0.092732 -0.156246 -0.585167\n2 -0.358119 -0.862331 -1.672907\n3  0.550313 -1.507513 -0.617232\n4  0.650576  1.033221  0.492464\n          a         b         c\n0 -1.627786 -0.692062  1.039548\n1 -1.802313 -0.890905 -0.881794\n2  0.630492  0.016739  0.014500\n3 -0.438358  0.647275 -0.052075\n4  0.673137  1.227539  0.203534\n          a         b         c\n0  0.861658  0.867852 -0.465016\n1  1.547012 -0.947189 -1.241043\n2  0.070470  0.901320  0.937577\n3  0.295770  1.420548 -0.005283\n4 -1.518598 -0.730065  0.226497\n          a         b         c\n0 -2.061465  0.632115  0.853619\n1  2.719155  0.139018  0.214557\n2 -1.538924 -0.366973 -0.748801\n3 -0.478137 -1.559153 -3.097759\n4 -2.320335 -0.221090  0.119763\n</pre></div> </div> <p>You can also run a plain query without creating a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> with <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">execute()</span></code>. This is useful for queries that don’t return values, such as INSERT. This is functionally equivalent to calling <code class=\"docutils literal notranslate\"><span class=\"pre\">execute</span></code> on the SQLAlchemy engine or db connection object. Again, you must use the SQL syntax variant appropriate for your database.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">from pandas.io import sql\n\nsql.execute(\"SELECT * FROM table_name\", engine)\nsql.execute(\n    \"INSERT INTO table_name VALUES(?, ?, ?)\", engine, params=[(\"id\", 1, 12.2, True)]\n)\n</pre></div> </div> </section> <section id=\"engine-connection-examples\"> <h3>Engine connection examples</h3> <p>To connect with SQLAlchemy you use the <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">create_engine()</span></code> function to create an engine object from database URI. You only need to create the engine once per database you are connecting to.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">from sqlalchemy import create_engine\n\nengine = create_engine(\"postgresql://scott:tiger@localhost:5432/mydatabase\")\n\nengine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/foo\")\n\nengine = create_engine(\"oracle://scott:tiger@127.0.0.1:1521/sidname\")\n\nengine = create_engine(\"mssql+pyodbc://mydsn\")\n\n# sqlite://&lt;nohostname&gt;/&lt;path&gt;\n# where &lt;path&gt; is relative:\nengine = create_engine(\"sqlite:///foo.db\")\n\n# or absolute, starting with a slash:\nengine = create_engine(\"sqlite:////absolute/path/to/foo.db\")\n</pre></div> </div> <p>For more information see the examples the SQLAlchemy <a class=\"reference external\" href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html\">documentation</a></p> </section> <section id=\"advanced-sqlalchemy-queries\"> <h3>Advanced SQLAlchemy queries</h3> <p>You can use SQLAlchemy constructs to describe your query.</p> <p>Use <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sqlalchemy.text()</span></code> to specify query parameters in a backend-neutral way</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [590]: import sqlalchemy as sa\n\nIn [591]: pd.read_sql(\n   .....:     sa.text(\"SELECT * FROM data where Col_1=:col1\"), engine, params={\"col1\": \"X\"}\n   .....: )\n   .....: \nOut[591]: \n   index  id                        Date Col_1  Col_2  Col_3\n0      0  26  2010-10-18 00:00:00.000000     X   27.5      1\n</pre></div> </div> <p>If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [592]: metadata = sa.MetaData()\n\nIn [593]: data_table = sa.Table(\n   .....:     \"data\",\n   .....:     metadata,\n   .....:     sa.Column(\"index\", sa.Integer),\n   .....:     sa.Column(\"Date\", sa.DateTime),\n   .....:     sa.Column(\"Col_1\", sa.String),\n   .....:     sa.Column(\"Col_2\", sa.Float),\n   .....:     sa.Column(\"Col_3\", sa.Boolean),\n   .....: )\n   .....: \n\nIn [594]: pd.read_sql(sa.select([data_table]).where(data_table.c.Col_3 is True), engine)\nOut[594]: \nEmpty DataFrame\nColumns: [index, Date, Col_1, Col_2, Col_3]\nIndex: []\n</pre></div> </div> <p>You can combine SQLAlchemy expressions with parameters passed to <a class=\"reference internal\" href=\"../reference/api/pandas.read_sql#pandas.read_sql\" title=\"pandas.read_sql\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sql()</span></code></a> using <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sqlalchemy.bindparam()</span></code></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [595]: import datetime as dt\n\nIn [596]: expr = sa.select([data_table]).where(data_table.c.Date &gt; sa.bindparam(\"date\"))\n\nIn [597]: pd.read_sql(expr, engine, params={\"date\": dt.datetime(2010, 10, 18)})\nOut[597]: \n   index       Date Col_1  Col_2  Col_3\n0      1 2010-10-19     Y -12.50  False\n1      2 2010-10-20     Z   5.73   True\n</pre></div> </div> </section> <section id=\"sqlite-fallback\"> <h3>Sqlite fallback</h3> <p>The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the <a class=\"reference external\" href=\"https://www.python.org/dev/peps/pep-0249/\">Python DB-API</a>.</p> <p>You can create connections like so:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">import sqlite3\n\ncon = sqlite3.connect(\":memory:\")\n</pre></div> </div> <p>And then issue the following queries:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">data.to_sql(\"data\", con)\npd.read_sql_query(\"SELECT * FROM data\", con)\n</pre></div> </div> </section> </section> <section id=\"google-bigquery\"> <h2>Google BigQuery</h2> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Starting in 0.20.0, pandas has split off Google BigQuery support into the separate package <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas-gbq</span></code>. You can <code class=\"docutils literal notranslate\"><span class=\"pre\">pip</span> <span class=\"pre\">install</span> <span class=\"pre\">pandas-gbq</span></code> to get it.</p> </div> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas-gbq</span></code> package provides functionality to read/write from Google BigQuery.</p> <p>pandas integrates with this external package. if <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas-gbq</span></code> is installed, you can use the pandas methods <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.read_gbq</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.to_gbq</span></code>, which will call the respective functions from <code class=\"docutils literal notranslate\"><span class=\"pre\">pandas-gbq</span></code>.</p> <p>Full documentation can be found <a class=\"reference external\" href=\"https://pandas-gbq.readthedocs.io/en/latest/\">here</a>.</p> </section> <section id=\"stata-format\"> <h2>Stata format</h2> <section id=\"writing-to-stata-format\"> <h3>Writing to stata format</h3> <p>The method <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_stata()</span></code> will write a DataFrame into a .dta file. The format version of this file is always 115 (Stata 12).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [598]: df = pd.DataFrame(np.random.randn(10, 2), columns=list(\"AB\"))\n\nIn [599]: df.to_stata(\"stata.dta\")\n</pre></div> </div> <p><em>Stata</em> data files have limited data type support; only strings with 244 or fewer characters, <code class=\"docutils literal notranslate\"><span class=\"pre\">int8</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">int16</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">int32</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">float32</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">float64</span></code> can be stored in <code class=\"docutils literal notranslate\"><span class=\"pre\">.dta</span></code> files. Additionally, <em>Stata</em> reserves certain values to represent missing data. Exporting a non-missing value that is outside of the permitted range in Stata for a particular data type will retype the variable to the next larger size. For example, <code class=\"docutils literal notranslate\"><span class=\"pre\">int8</span></code> values are restricted to lie between -127 and 100 in Stata, and so variables with values above 100 will trigger a conversion to <code class=\"docutils literal notranslate\"><span class=\"pre\">int16</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">nan</span></code> values in floating points data types are stored as the basic missing data type (<code class=\"docutils literal notranslate\"><span class=\"pre\">.</span></code> in <em>Stata</em>).</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>It is not possible to export missing data values for integer data types.</p> </div> <p>The <em>Stata</em> writer gracefully handles other data types including <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">bool</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">uint8</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">uint16</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">uint32</span></code> by casting to the smallest supported type that can represent the data. For example, data with a type of <code class=\"docutils literal notranslate\"><span class=\"pre\">uint8</span></code> will be cast to <code class=\"docutils literal notranslate\"><span class=\"pre\">int8</span></code> if all values are less than 100 (the upper bound for non-missing <code class=\"docutils literal notranslate\"><span class=\"pre\">int8</span></code> data in <em>Stata</em>), or, if values are outside of this range, the variable is cast to <code class=\"docutils literal notranslate\"><span class=\"pre\">int16</span></code>.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Conversion from <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">float64</span></code> may result in a loss of precision if <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code> values are larger than 2**53.</p> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StataWriter</span></code> and <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">to_stata()</span></code> only support fixed width strings containing up to 244 characters, a limitation imposed by the version 115 dta file format. Attempting to write <em>Stata</em> dta files with strings longer than 244 characters raises a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code>.</p> </div> </section> <section id=\"reading-from-stata-format\"> <h3>Reading from Stata format</h3> <p>The top-level function <code class=\"docutils literal notranslate\"><span class=\"pre\">read_stata</span></code> will read a dta file and return either a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> or a <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StataReader</span></code> that can be used to read the file incrementally.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [600]: pd.read_stata(\"stata.dta\")\nOut[600]: \n   index         A         B\n0      0  0.608228  1.064810\n1      1 -0.780506 -2.736887\n2      2  0.143539  1.170191\n3      3 -1.573076  0.075792\n4      4 -1.722223 -0.774650\n5      5  0.803627  0.221665\n6      6  0.584637  0.147264\n7      7  1.057825 -0.284136\n8      8  0.912395  1.552808\n9      9  0.189376 -0.109830\n</pre></div> </div> <p>Specifying a <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> yields a <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StataReader</span></code> instance that can be used to read <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> lines from the file at a time. The <code class=\"docutils literal notranslate\"><span class=\"pre\">StataReader</span></code> object can be used as an iterator.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [601]: with pd.read_stata(\"stata.dta\", chunksize=3) as reader:\n   .....:     for df in reader:\n   .....:         print(df.shape)\n   .....: \n(3, 3)\n(3, 3)\n(3, 3)\n(1, 3)\n</pre></div> </div> <p>For more fine-grained control, use <code class=\"docutils literal notranslate\"><span class=\"pre\">iterator=True</span></code> and specify <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> with each call to <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read()</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [602]: with pd.read_stata(\"stata.dta\", iterator=True) as reader:\n   .....:     chunk1 = reader.read(5)\n   .....:     chunk2 = reader.read(5)\n   .....: \n</pre></div> </div> <p>Currently the <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> is retrieved as a column.</p> <p>The parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_categoricals</span></code> indicates whether value labels should be read and used to create a <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> variable from them. Value labels can also be retrieved by the function <code class=\"docutils literal notranslate\"><span class=\"pre\">value_labels</span></code>, which requires <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read()</span></code> to be called before use.</p> <p>The parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_missing</span></code> indicates whether missing value representations in Stata should be preserved. If <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code> (the default), missing values are represented as <code class=\"docutils literal notranslate\"><span class=\"pre\">np.nan</span></code>. If <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>, missing values are represented using <code class=\"docutils literal notranslate\"><span class=\"pre\">StataMissingValue</span></code> objects, and columns containing missing values will have <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> data type.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><a class=\"reference internal\" href=\"../reference/api/pandas.read_stata#pandas.read_stata\" title=\"pandas.read_stata\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_stata()</span></code></a> and <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StataReader</span></code> support .dta formats 113-115 (Stata 10-12), 117 (Stata 13), and 118 (Stata 14).</p> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Setting <code class=\"docutils literal notranslate\"><span class=\"pre\">preserve_dtypes=False</span></code> will upcast to the standard pandas data types: <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code> for all integer types and <code class=\"docutils literal notranslate\"><span class=\"pre\">float64</span></code> for floating point data. By default, the Stata data types are preserved when importing.</p> </div> <section id=\"io-stata-categorical\"> <h4>Categorical data</h4> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> data can be exported to <em>Stata</em> data files as value labeled data. The exported data consists of the underlying category codes as integer data values and the categories as value labels. <em>Stata</em> does not have an explicit equivalent to a <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> and information about <em>whether</em> the variable is ordered is lost when exporting.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p><em>Stata</em> only supports string value labels, and so <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> is called on the categories when exporting data. Exporting <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> variables with non-string categories produces a warning, and can result a loss of information if the <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> representations of the categories are not unique.</p> </div> <p>Labeled data can similarly be imported from <em>Stata</em> data files as <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> variables using the keyword argument <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_categoricals</span></code> (<code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> by default). The keyword argument <code class=\"docutils literal notranslate\"><span class=\"pre\">order_categoricals</span></code> (<code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> by default) determines whether imported <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> variables are ordered.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>When importing categorical data, the values of the variables in the <em>Stata</em> data file are not preserved since <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> variables always use integer data types between <code class=\"docutils literal notranslate\"><span class=\"pre\">-1</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">n-1</span></code> where <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> is the number of categories. If the original values in the <em>Stata</em> data file are required, these can be imported by setting <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_categoricals=False</span></code>, which will import original data (but not the variable labels). The original values can be matched to the imported categorical data since there is a simple mapping between the original <em>Stata</em> data values and the category codes of imported Categorical variables: missing values are assigned code <code class=\"docutils literal notranslate\"><span class=\"pre\">-1</span></code>, and the smallest original value is assigned <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code>, the second smallest is assigned <code class=\"docutils literal notranslate\"><span class=\"pre\">1</span></code> and so on until the largest original value is assigned the code <code class=\"docutils literal notranslate\"><span class=\"pre\">n-1</span></code>.</p> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p><em>Stata</em> supports partially labeled series. These series have value labels for some but not all data values. Importing a partially labeled series will produce a <code class=\"docutils literal notranslate\"><span class=\"pre\">Categorical</span></code> with string categories for the values that are labeled and numeric categories for values with no label.</p> </div> </section> </section> </section> <section id=\"sas-formats\"> <h2>SAS formats</h2> <p>The top-level function <a class=\"reference internal\" href=\"../reference/api/pandas.read_sas#pandas.read_sas\" title=\"pandas.read_sas\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_sas()</span></code></a> can read (but not write) SAS XPORT (.xpt) and (since <em>v0.18.0</em>) SAS7BDAT (.sas7bdat) format files.</p> <p>SAS files only contain two value types: ASCII text and floating point values (usually 8 bytes but sometimes truncated). For xport files, there is no automatic type conversion to integers, dates, or categoricals. For SAS7BDAT files, the format codes may allow date variables to be automatically converted to dates. By default the whole file is read and returned as a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p> <p>Specify a <code class=\"docutils literal notranslate\"><span class=\"pre\">chunksize</span></code> or use <code class=\"docutils literal notranslate\"><span class=\"pre\">iterator=True</span></code> to obtain reader objects (<code class=\"docutils literal notranslate\"><span class=\"pre\">XportReader</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">SAS7BDATReader</span></code>) for incrementally reading the file. The reader objects also have attributes that contain additional information about the file and its variables.</p> <p>Read a SAS7BDAT file:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df = pd.read_sas(\"sas_data.sas7bdat\")\n</pre></div> </div> <p>Obtain an iterator and read an XPORT file 100,000 lines at a time:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">def do_something(chunk):\n    pass\n\n\nwith pd.read_sas(\"sas_xport.xpt\", chunk=100000) as rdr:\n    for chunk in rdr:\n        do_something(chunk)\n</pre></div> </div> <p>The <a class=\"reference external\" href=\"https://support.sas.com/content/dam/SAS/support/en/technical-papers/record-layout-of-a-sas-version-5-or-6-data-set-in-sas-transport-xport-format.pdf\">specification</a> for the xport file format is available from the SAS web site.</p> <p>No official documentation is available for the SAS7BDAT format.</p> </section> <section id=\"spss-formats\"> <h2>SPSS formats</h2> <div class=\"versionadded\"> <p><span class=\"versionmodified added\">New in version 0.25.0.</span></p> </div> <p>The top-level function <a class=\"reference internal\" href=\"../reference/api/pandas.read_spss#pandas.read_spss\" title=\"pandas.read_spss\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">read_spss()</span></code></a> can read (but not write) SPSS SAV (.sav) and ZSAV (.zsav) format files.</p> <p>SPSS files contain column names. By default the whole file is read, categorical columns are converted into <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.Categorical</span></code>, and a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> with all columns is returned.</p> <p>Specify the <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> parameter to obtain a subset of columns. Specify <code class=\"docutils literal notranslate\"><span class=\"pre\">convert_categoricals=False</span></code> to avoid converting categorical columns into <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.Categorical</span></code>.</p> <p>Read an SPSS file:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df = pd.read_spss(\"spss_data.sav\")\n</pre></div> </div> <p>Extract a subset of columns contained in <code class=\"docutils literal notranslate\"><span class=\"pre\">usecols</span></code> from an SPSS file and avoid converting categorical columns into <code class=\"docutils literal notranslate\"><span class=\"pre\">pd.Categorical</span></code>:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df = pd.read_spss(\n    \"spss_data.sav\",\n    usecols=[\"foo\", \"bar\"],\n    convert_categoricals=False,\n)\n</pre></div> </div> <p>More information about the SAV and ZSAV file formats is available <a class=\"reference external\" href=\"https://www.ibm.com/docs/en/spss-statistics/22.0.0\">here</a>.</p> </section> <section id=\"other-file-formats\"> <h2>Other file formats</h2> <p>pandas itself only supports IO with a limited set of file formats that map cleanly to its tabular data model. For reading and writing other file formats into and from pandas, we recommend these packages from the broader community.</p> <section id=\"netcdf\"> <h3>netCDF</h3> <p><a class=\"reference external\" href=\"https://xarray.pydata.org/en/stable/\">xarray</a> provides data structures inspired by the pandas <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> for working with multi-dimensional datasets, with a focus on the netCDF file format and easy conversion to and from pandas.</p> </section> </section> <section id=\"performance-considerations\"> <h2>Performance considerations</h2> <p>This is an informal comparison of various IO methods, using pandas 0.24.2. Timings are machine dependent and small differences should be ignored.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [1]: sz = 1000000\nIn [2]: df = pd.DataFrame({'A': np.random.randn(sz), 'B': [1] * sz})\n\nIn [3]: df.info()\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1000000 entries, 0 to 999999\nData columns (total 2 columns):\nA    1000000 non-null float64\nB    1000000 non-null int64\ndtypes: float64(1), int64(1)\nmemory usage: 15.3 MB\n</pre></div> </div> <p>The following test functions will be used below to compare the performance of several IO methods:</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">import numpy as np\n\nimport os\n\nsz = 1000000\ndf = pd.DataFrame({\"A\": np.random.randn(sz), \"B\": [1] * sz})\n\nsz = 1000000\nnp.random.seed(42)\ndf = pd.DataFrame({\"A\": np.random.randn(sz), \"B\": [1] * sz})\n\n\ndef test_sql_write(df):\n    if os.path.exists(\"test.sql\"):\n        os.remove(\"test.sql\")\n    sql_db = sqlite3.connect(\"test.sql\")\n    df.to_sql(name=\"test_table\", con=sql_db)\n    sql_db.close()\n\n\ndef test_sql_read():\n    sql_db = sqlite3.connect(\"test.sql\")\n    pd.read_sql_query(\"select * from test_table\", sql_db)\n    sql_db.close()\n\n\ndef test_hdf_fixed_write(df):\n    df.to_hdf(\"test_fixed.hdf\", \"test\", mode=\"w\")\n\n\ndef test_hdf_fixed_read():\n    pd.read_hdf(\"test_fixed.hdf\", \"test\")\n\n\ndef test_hdf_fixed_write_compress(df):\n    df.to_hdf(\"test_fixed_compress.hdf\", \"test\", mode=\"w\", complib=\"blosc\")\n\n\ndef test_hdf_fixed_read_compress():\n    pd.read_hdf(\"test_fixed_compress.hdf\", \"test\")\n\n\ndef test_hdf_table_write(df):\n    df.to_hdf(\"test_table.hdf\", \"test\", mode=\"w\", format=\"table\")\n\n\ndef test_hdf_table_read():\n    pd.read_hdf(\"test_table.hdf\", \"test\")\n\n\ndef test_hdf_table_write_compress(df):\n    df.to_hdf(\n        \"test_table_compress.hdf\", \"test\", mode=\"w\", complib=\"blosc\", format=\"table\"\n    )\n\n\ndef test_hdf_table_read_compress():\n    pd.read_hdf(\"test_table_compress.hdf\", \"test\")\n\n\ndef test_csv_write(df):\n    df.to_csv(\"test.csv\", mode=\"w\")\n\n\ndef test_csv_read():\n    pd.read_csv(\"test.csv\", index_col=0)\n\n\ndef test_feather_write(df):\n    df.to_feather(\"test.feather\")\n\n\ndef test_feather_read():\n    pd.read_feather(\"test.feather\")\n\n\ndef test_pickle_write(df):\n    df.to_pickle(\"test.pkl\")\n\n\ndef test_pickle_read():\n    pd.read_pickle(\"test.pkl\")\n\n\ndef test_pickle_write_compress(df):\n    df.to_pickle(\"test.pkl.compress\", compression=\"xz\")\n\n\ndef test_pickle_read_compress():\n    pd.read_pickle(\"test.pkl.compress\", compression=\"xz\")\n\n\ndef test_parquet_write(df):\n    df.to_parquet(\"test.parquet\")\n\n\ndef test_parquet_read():\n    pd.read_parquet(\"test.parquet\")\n</pre></div> </div> <p>When writing, the top three functions in terms of speed are <code class=\"docutils literal notranslate\"><span class=\"pre\">test_feather_write</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">test_hdf_fixed_write</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">test_hdf_fixed_write_compress</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [4]: %timeit test_sql_write(df)\n3.29 s ± 43.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [5]: %timeit test_hdf_fixed_write(df)\n19.4 ms ± 560 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [6]: %timeit test_hdf_fixed_write_compress(df)\n19.6 ms ± 308 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [7]: %timeit test_hdf_table_write(df)\n449 ms ± 5.61 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [8]: %timeit test_hdf_table_write_compress(df)\n448 ms ± 11.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [9]: %timeit test_csv_write(df)\n3.66 s ± 26.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [10]: %timeit test_feather_write(df)\n9.75 ms ± 117 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\nIn [11]: %timeit test_pickle_write(df)\n30.1 ms ± 229 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [12]: %timeit test_pickle_write_compress(df)\n4.29 s ± 15.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [13]: %timeit test_parquet_write(df)\n67.6 ms ± 706 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n</pre></div> </div> <p>When reading, the top three functions in terms of speed are <code class=\"docutils literal notranslate\"><span class=\"pre\">test_feather_read</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">test_pickle_read</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">test_hdf_fixed_read</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [14]: %timeit test_sql_read()\n1.77 s ± 17.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [15]: %timeit test_hdf_fixed_read()\n19.4 ms ± 436 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [16]: %timeit test_hdf_fixed_read_compress()\n19.5 ms ± 222 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [17]: %timeit test_hdf_table_read()\n38.6 ms ± 857 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [18]: %timeit test_hdf_table_read_compress()\n38.8 ms ± 1.49 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [19]: %timeit test_csv_read()\n452 ms ± 9.04 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [20]: %timeit test_feather_read()\n12.4 ms ± 99.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\nIn [21]: %timeit test_pickle_read()\n18.4 ms ± 191 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\nIn [22]: %timeit test_pickle_read_compress()\n915 ms ± 7.48 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\nIn [23]: %timeit test_parquet_read()\n24.4 ms ± 146 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n</pre></div> </div> <p>The files <code class=\"docutils literal notranslate\"><span class=\"pre\">test.pkl.compress</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">test.parquet</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">test.feather</span></code> took the least space on disk (in bytes).</p> <div class=\"highlight-none notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">29519500 Oct 10 06:45 test.csv\n16000248 Oct 10 06:45 test.feather\n8281983  Oct 10 06:49 test.parquet\n16000857 Oct 10 06:47 test.pkl\n7552144  Oct 10 06:48 test.pkl.compress\n34816000 Oct 10 06:42 test.sql\n24009288 Oct 10 06:43 test_fixed.hdf\n24009288 Oct 10 06:43 test_fixed_compress.hdf\n24458940 Oct 10 06:44 test_table.hdf\n24458940 Oct 10 06:44 test_table_compress.hdf\n</pre></div> </div> </section><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>\n    <a href=\"https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/io.html\" class=\"_attribution-link\">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/io.html</a>\n  </p>\n</div>\n","user_guide/indexing":"<h1>Indexing and selecting data</h1> <p>The axis labeling information in pandas objects serves many purposes:</p> <ul class=\"simple\"> <li><p>Identifies data (i.e. provides <em>metadata</em>) using known indicators, important for analysis, visualization, and interactive console display.</p></li> <li><p>Enables automatic and explicit data alignment.</p></li> <li><p>Allows intuitive getting and setting of subsets of the data set.</p></li> </ul> <p>In this section, we will focus on the final point: namely, how to slice, dice, and generally get and set subsets of pandas objects. The primary focus will be on Series and DataFrame as they have received more development attention in this area.</p> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The Python and NumPy indexing operators <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> and attribute operator <code class=\"docutils literal notranslate\"><span class=\"pre\">.</span></code> provide quick and easy access to pandas data structures across a wide range of use cases. This makes interactive work intuitive, as there’s little new to learn if you already know how to deal with Python dictionaries and NumPy arrays. However, since the type of the data to be accessed isn’t known in advance, directly using standard operators has some optimization limits. For production code, we recommended that you take advantage of the optimized pandas data access methods exposed in this chapter.</p> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called <code class=\"docutils literal notranslate\"><span class=\"pre\">chained</span> <span class=\"pre\">assignment</span></code> and should be avoided. See <a class=\"reference internal\" href=\"#indexing-view-versus-copy\"><span class=\"std std-ref\">Returning a View versus Copy</span></a>.</p> </div> <p>See the <a class=\"reference internal\" href=\"advanced#advanced\"><span class=\"std std-ref\">MultiIndex / Advanced Indexing</span></a> for <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> and more advanced indexing documentation.</p> <p>See the <a class=\"reference internal\" href=\"cookbook#cookbook-selection\"><span class=\"std std-ref\">cookbook</span></a> for some advanced strategies.</p> <section id=\"different-choices-for-indexing\"> <h2>Different choices for indexing</h2> <p>Object selection has had a number of user-requested additions in order to support more explicit location based indexing. pandas now supports three types of multi-axis indexing.</p> <ul> <li>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> is primarily label based, but may also be used with a boolean array. <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> will raise <code class=\"docutils literal notranslate\"><span class=\"pre\">KeyError</span></code> when the items are not found. Allowed inputs are:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>A single label, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'a'</span></code> (Note that <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> is interpreted as a <em>label</em> of the index. This use is <strong>not</strong> an integer position along the index.).</p></li> <li><p>A list or array of labels <code class=\"docutils literal notranslate\"><span class=\"pre\">['a',</span> <span class=\"pre\">'b',</span> <span class=\"pre\">'c']</span></code>.</p></li> <li><p>A slice object with labels <code class=\"docutils literal notranslate\"><span class=\"pre\">'a':'f'</span></code> (Note that contrary to usual Python slices, <strong>both</strong> the start and the stop are included, when present in the index! See <a class=\"reference internal\" href=\"#indexing-slicing-with-labels\"><span class=\"std std-ref\">Slicing with labels</span></a> and <a class=\"reference internal\" href=\"advanced#advanced-endpoints-are-inclusive\"><span class=\"std std-ref\">Endpoints are inclusive</span></a>.)</p></li> <li><p>A boolean array (any <code class=\"docutils literal notranslate\"><span class=\"pre\">NA</span></code> values will be treated as <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>).</p></li> <li><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">callable</span></code> function with one argument (the calling Series or DataFrame) and that returns valid output for indexing (one of the above).</p></li> </ul> </div>\n</blockquote> <p>See more at <a class=\"reference internal\" href=\"#indexing-label\"><span class=\"std std-ref\">Selection by Label</span></a>.</p> </li> <li>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code> is primarily integer position based (from <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code> to <code class=\"docutils literal notranslate\"><span class=\"pre\">length-1</span></code> of the axis), but may also be used with a boolean array. <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code> will raise <code class=\"docutils literal notranslate\"><span class=\"pre\">IndexError</span></code> if a requested indexer is out-of-bounds, except <em>slice</em> indexers which allow out-of-bounds indexing. (this conforms with Python/NumPy <em>slice</em> semantics). Allowed inputs are:</p> <blockquote> <div>\n<ul class=\"simple\"> <li><p>An integer e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code>.</p></li> <li><p>A list or array of integers <code class=\"docutils literal notranslate\"><span class=\"pre\">[4,</span> <span class=\"pre\">3,</span> <span class=\"pre\">0]</span></code>.</p></li> <li><p>A slice object with ints <code class=\"docutils literal notranslate\"><span class=\"pre\">1:7</span></code>.</p></li> <li><p>A boolean array (any <code class=\"docutils literal notranslate\"><span class=\"pre\">NA</span></code> values will be treated as <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>).</p></li> <li><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">callable</span></code> function with one argument (the calling Series or DataFrame) and that returns valid output for indexing (one of the above).</p></li> </ul> </div>\n</blockquote> <p>See more at <a class=\"reference internal\" href=\"#indexing-integer\"><span class=\"std std-ref\">Selection by Position</span></a>, <a class=\"reference internal\" href=\"advanced#advanced\"><span class=\"std std-ref\">Advanced Indexing</span></a> and <a class=\"reference internal\" href=\"advanced#advanced-advanced-hierarchical\"><span class=\"std std-ref\">Advanced Hierarchical</span></a>.</p> </li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code>, and also <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> indexing can accept a <code class=\"docutils literal notranslate\"><span class=\"pre\">callable</span></code> as indexer. See more at <a class=\"reference internal\" href=\"#indexing-callable\"><span class=\"std std-ref\">Selection By Callable</span></a>.</p></li> </ul> <p>Getting values from an object with multi-axes selection uses the following notation (using <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> as an example, but the following applies to <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code> as well). Any of the axes accessors may be the null slice <code class=\"docutils literal notranslate\"><span class=\"pre\">:</span></code>. Axes left out of the specification are assumed to be <code class=\"docutils literal notranslate\"><span class=\"pre\">:</span></code>, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">p.loc['a']</span></code> is equivalent to <code class=\"docutils literal notranslate\"><span class=\"pre\">p.loc['a',</span> <span class=\"pre\">:,</span> <span class=\"pre\">:]</span></code>.</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 38%\"> <col style=\"width: 63%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Object Type</p></th> <th class=\"head\"><p>Indexers</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>Series</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">s.loc[indexer]</span></code></p></td> </tr> <tr class=\"row-odd\">\n<td><p>DataFrame</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">df.loc[row_indexer,column_indexer]</span></code></p></td> </tr> </tbody> </table> </section> <section id=\"basics\"> <h2>Basics</h2> <p>As mentioned when introducing the data structures in the <a class=\"reference internal\" href=\"basics#basics\"><span class=\"std std-ref\">last section</span></a>, the primary function of indexing with <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> (a.k.a. <code class=\"docutils literal notranslate\"><span class=\"pre\">__getitem__</span></code> for those familiar with implementing class behavior in Python) is selecting out lower-dimensional slices. The following table shows return type values when indexing pandas objects with <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code>:</p> <table class=\"colwidths-given table\"> <colgroup> <col style=\"width: 25%\"> <col style=\"width: 25%\"> <col style=\"width: 50%\"> </colgroup> <thead> <tr class=\"row-odd\">\n<th class=\"head\"><p>Object Type</p></th> <th class=\"head\"><p>Selection</p></th> <th class=\"head\"><p>Return Value Type</p></th> </tr> </thead> <tbody> <tr class=\"row-even\">\n<td><p>Series</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">series[label]</span></code></p></td> <td><p>scalar value</p></td> </tr> <tr class=\"row-odd\">\n<td><p>DataFrame</p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">frame[colname]</span></code></p></td> <td><p><code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> corresponding to colname</p></td> </tr> </tbody> </table> <p>Here we construct a simple time series data set to use for illustrating the indexing functionality:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [1]: dates = pd.date_range('1/1/2000', periods=8)\n\nIn [2]: df = pd.DataFrame(np.random.randn(8, 4),\n   ...:                   index=dates, columns=['A', 'B', 'C', 'D'])\n   ...: \n\nIn [3]: df\nOut[3]: \n                   A         B         C         D\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2000-01-04  0.721555 -0.706771 -1.039575  0.271860\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>None of the indexing functionality is time series specific unless specifically stated.</p> </div> <p>Thus, as per above, we have the most basic indexing using <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [4]: s = df['A']\n\nIn [5]: s[dates[5]]\nOut[5]: -0.6736897080883706\n</pre></div> </div> <p>You can pass a list of columns to <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> to select columns in that order. If a column is not contained in the DataFrame, an exception will be raised. Multiple columns can also be set in this manner:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [6]: df\nOut[6]: \n                   A         B         C         D\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2000-01-04  0.721555 -0.706771 -1.039575  0.271860\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885\n\nIn [7]: df[['B', 'A']] = df[['A', 'B']]\n\nIn [8]: df\nOut[8]: \n                   A         B         C         D\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804\n2000-01-04 -0.706771  0.721555 -1.039575  0.271860\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268\n2000-01-08 -1.157892 -0.370647 -1.344312  0.844885\n</pre></div> </div> <p>You may find this useful for applying a transform (in-place) to a subset of the columns.</p> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>pandas aligns all AXES when setting <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> from <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code>.</p> <p>This will <strong>not</strong> modify <code class=\"docutils literal notranslate\"><span class=\"pre\">df</span></code> because the column alignment is before value assignment.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [9]: df[['A', 'B']]\nOut[9]: \n                   A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647\n\nIn [10]: df.loc[:, ['B', 'A']] = df[['A', 'B']]\n\nIn [11]: df[['A', 'B']]\nOut[11]: \n                   A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647\n</pre></div> </div> <p>The correct way to swap column values is by using raw values:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [12]: df.loc[:, ['B', 'A']] = df[['A', 'B']].to_numpy()\n\nIn [13]: df[['A', 'B']]\nOut[13]: \n                   A         B\n2000-01-01  0.469112 -0.282863\n2000-01-02  1.212112 -0.173215\n2000-01-03 -0.861849 -2.104569\n2000-01-04  0.721555 -0.706771\n2000-01-05 -0.424972  0.567020\n2000-01-06 -0.673690  0.113648\n2000-01-07  0.404705  0.577046\n2000-01-08 -0.370647 -1.157892\n</pre></div> </div> </div> </section> <section id=\"attribute-access\"> <h2>Attribute access</h2> <p id=\"indexing-attribute-access\">You may access an index on a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> or column on a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> directly as an attribute:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [14]: sa = pd.Series([1, 2, 3], index=list('abc'))\n\nIn [15]: dfa = df.copy()\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [16]: sa.b\nOut[16]: 2\n\nIn [17]: dfa.A\nOut[17]: \n2000-01-01    0.469112\n2000-01-02    1.212112\n2000-01-03   -0.861849\n2000-01-04    0.721555\n2000-01-05   -0.424972\n2000-01-06   -0.673690\n2000-01-07    0.404705\n2000-01-08   -0.370647\nFreq: D, Name: A, dtype: float64\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [18]: sa.a = 5\n\nIn [19]: sa\nOut[19]: \na    5\nb    2\nc    3\ndtype: int64\n\nIn [20]: dfa.A = list(range(len(dfa.index)))  # ok if A already exists\n\nIn [21]: dfa\nOut[21]: \n            A         B         C         D\n2000-01-01  0 -0.282863 -1.509059 -1.135632\n2000-01-02  1 -0.173215  0.119209 -1.044236\n2000-01-03  2 -2.104569 -0.494929  1.071804\n2000-01-04  3 -0.706771 -1.039575  0.271860\n2000-01-05  4  0.567020  0.276232 -1.087401\n2000-01-06  5  0.113648 -1.478427  0.524988\n2000-01-07  6  0.577046 -1.715002 -1.039268\n2000-01-08  7 -1.157892 -1.344312  0.844885\n\nIn [22]: dfa['A'] = list(range(len(dfa.index)))  # use this form to create a new column\n\nIn [23]: dfa\nOut[23]: \n            A         B         C         D\n2000-01-01  0 -0.282863 -1.509059 -1.135632\n2000-01-02  1 -0.173215  0.119209 -1.044236\n2000-01-03  2 -2.104569 -0.494929  1.071804\n2000-01-04  3 -0.706771 -1.039575  0.271860\n2000-01-05  4  0.567020  0.276232 -1.087401\n2000-01-06  5  0.113648 -1.478427  0.524988\n2000-01-07  6  0.577046 -1.715002 -1.039268\n2000-01-08  7 -1.157892 -1.344312  0.844885\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <ul class=\"simple\"> <li><p>You can use this access only if the index element is a valid Python identifier, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">s.1</span></code> is not allowed. See <a class=\"reference external\" href=\"https://docs.python.org/3/reference/lexical_analysis.html#identifiers\">here for an explanation of valid identifiers</a>.</p></li> <li><p>The attribute will not be available if it conflicts with an existing method name, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">s.min</span></code> is not allowed, but <code class=\"docutils literal notranslate\"><span class=\"pre\">s['min']</span></code> is possible.</p></li> <li><p>Similarly, the attribute will not be available if it conflicts with any of the following list: <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">major_axis</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">minor_axis</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">items</span></code>.</p></li> <li><p>In any of these cases, standard indexing will still work, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">s['1']</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">s['min']</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">s['index']</span></code> will access the corresponding element or column.</p></li> </ul> </div> <p>If you are using the IPython environment, you may also use tab-completion to see these accessible attributes.</p> <p>You can also assign a <code class=\"docutils literal notranslate\"><span class=\"pre\">dict</span></code> to a row of a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [24]: x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})\n\nIn [25]: x.iloc[1] = {'x': 9, 'y': 99}\n\nIn [26]: x\nOut[26]: \n   x   y\n0  1   3\n1  9  99\n2  3   5\n</pre></div> </div> <p>You can use attribute access to modify an existing element of a Series or column of a DataFrame, but be careful; if you try to use attribute access to create a new column, it creates a new attribute rather than a new column. In 0.21.0 and later, this will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">UserWarning</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [1]: df = pd.DataFrame({'one': [1., 2., 3.]})\nIn [2]: df.two = [4, 5, 6]\nUserWarning: Pandas doesn't allow Series to be assigned into nonexistent columns - see https://pandas.pydata.org/pandas-docs/stable/indexing.html#attribute_access\nIn [3]: df\nOut[3]:\n   one\n0  1.0\n1  2.0\n2  3.0\n</pre></div> </div> </section> <section id=\"slicing-ranges\"> <h2>Slicing ranges</h2> <p>The most robust and consistent way of slicing ranges along arbitrary axes is described in the <a class=\"reference internal\" href=\"#indexing-integer\"><span class=\"std std-ref\">Selection by Position</span></a> section detailing the <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code> method. For now, we explain the semantics of slicing using the <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> operator.</p> <p>With Series, the syntax works exactly as with an ndarray, returning a slice of the values and the corresponding labels:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [27]: s[:5]\nOut[27]: \n2000-01-01    0.469112\n2000-01-02    1.212112\n2000-01-03   -0.861849\n2000-01-04    0.721555\n2000-01-05   -0.424972\nFreq: D, Name: A, dtype: float64\n\nIn [28]: s[::2]\nOut[28]: \n2000-01-01    0.469112\n2000-01-03   -0.861849\n2000-01-05   -0.424972\n2000-01-07    0.404705\nFreq: 2D, Name: A, dtype: float64\n\nIn [29]: s[::-1]\nOut[29]: \n2000-01-08   -0.370647\n2000-01-07    0.404705\n2000-01-06   -0.673690\n2000-01-05   -0.424972\n2000-01-04    0.721555\n2000-01-03   -0.861849\n2000-01-02    1.212112\n2000-01-01    0.469112\nFreq: -1D, Name: A, dtype: float64\n</pre></div> </div> <p>Note that setting works as well:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [30]: s2 = s.copy()\n\nIn [31]: s2[:5] = 0\n\nIn [32]: s2\nOut[32]: \n2000-01-01    0.000000\n2000-01-02    0.000000\n2000-01-03    0.000000\n2000-01-04    0.000000\n2000-01-05    0.000000\n2000-01-06   -0.673690\n2000-01-07    0.404705\n2000-01-08   -0.370647\nFreq: D, Name: A, dtype: float64\n</pre></div> </div> <p>With DataFrame, slicing inside of <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> <strong>slices the rows</strong>. This is provided largely as a convenience since it is such a common operation.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [33]: df[:3]\nOut[33]: \n                   A         B         C         D\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n\nIn [34]: df[::-1]\nOut[34]: \n                   A         B         C         D\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401\n2000-01-04  0.721555 -0.706771 -1.039575  0.271860\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n</pre></div> </div> </section> <section id=\"selection-by-label\"> <h2>Selection by label</h2> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called <code class=\"docutils literal notranslate\"><span class=\"pre\">chained</span> <span class=\"pre\">assignment</span></code> and should be avoided. See <a class=\"reference internal\" href=\"#indexing-view-versus-copy\"><span class=\"std std-ref\">Returning a View versus Copy</span></a>.</p> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <blockquote> <div>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> is strict when you present slicers that are not compatible (or convertible) with the index type. For example using integers in a <code class=\"docutils literal notranslate\"><span class=\"pre\">DatetimeIndex</span></code>. These will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">TypeError</span></code>.</p> </div>\n</blockquote> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [35]: dfl = pd.DataFrame(np.random.randn(5, 4),\n   ....:                    columns=list('ABCD'),\n   ....:                    index=pd.date_range('20130101', periods=5))\n   ....: \n\nIn [36]: dfl\nOut[36]: \n                   A         B         C         D\n2013-01-01  1.075770 -0.109050  1.643563 -1.469388\n2013-01-02  0.357021 -0.674600 -1.776904 -0.968914\n2013-01-03 -1.294524  0.413738  0.276662 -0.472035\n2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061\n2013-01-05  0.895717  0.805244 -1.206412  2.565646\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [4]: dfl.loc[2:3]\nTypeError: cannot do slice indexing on &lt;class 'pandas.tseries.index.DatetimeIndex'&gt; with these indexers [2] of &lt;type 'int'&gt;\n</pre></div> </div> <p>String likes in slicing <em>can</em> be convertible to the type of the index and lead to natural slicing.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [37]: dfl.loc['20130102':'20130104']\nOut[37]: \n                   A         B         C         D\n2013-01-02  0.357021 -0.674600 -1.776904 -0.968914\n2013-01-03 -1.294524  0.413738  0.276662 -0.472035\n2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061\n</pre></div> </div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 1.0.0.</span></p> </div> <p>pandas will raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">KeyError</span></code> if indexing with a list with missing labels. See <a class=\"reference internal\" href=\"#indexing-deprecate-loc-reindex-listlike\"><span class=\"std std-ref\">list-like Using loc with missing keys in a list is Deprecated</span></a>.</p> </div> <p>pandas provides a suite of methods in order to have <strong>purely label based indexing</strong>. This is a strict inclusion based protocol. Every label asked for must be in the index, or a <code class=\"docutils literal notranslate\"><span class=\"pre\">KeyError</span></code> will be raised. When slicing, both the start bound <strong>AND</strong> the stop bound are <em>included</em>, if present in the index. Integers are valid labels, but they refer to the label <strong>and not the position</strong>.</p> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> attribute is the primary access method. The following are valid inputs:</p> <ul class=\"simple\"> <li><p>A single label, e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'a'</span></code> (Note that <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> is interpreted as a <em>label</em> of the index. This use is <strong>not</strong> an integer position along the index.).</p></li> <li><p>A list or array of labels <code class=\"docutils literal notranslate\"><span class=\"pre\">['a',</span> <span class=\"pre\">'b',</span> <span class=\"pre\">'c']</span></code>.</p></li> <li><p>A slice object with labels <code class=\"docutils literal notranslate\"><span class=\"pre\">'a':'f'</span></code> (Note that contrary to usual Python slices, <strong>both</strong> the start and the stop are included, when present in the index! See <a class=\"reference internal\" href=\"#indexing-slicing-with-labels\"><span class=\"std std-ref\">Slicing with labels</span></a>.</p></li> <li><p>A boolean array.</p></li> <li><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">callable</span></code>, see <a class=\"reference internal\" href=\"#indexing-callable\"><span class=\"std std-ref\">Selection By Callable</span></a>.</p></li> </ul> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [38]: s1 = pd.Series(np.random.randn(6), index=list('abcdef'))\n\nIn [39]: s1\nOut[39]: \na    1.431256\nb    1.340309\nc   -1.170299\nd   -0.226169\ne    0.410835\nf    0.813850\ndtype: float64\n\nIn [40]: s1.loc['c':]\nOut[40]: \nc   -1.170299\nd   -0.226169\ne    0.410835\nf    0.813850\ndtype: float64\n\nIn [41]: s1.loc['b']\nOut[41]: 1.3403088497993827\n</pre></div> </div> <p>Note that setting works as well:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [42]: s1.loc['c':] = 0\n\nIn [43]: s1\nOut[43]: \na    1.431256\nb    1.340309\nc    0.000000\nd    0.000000\ne    0.000000\nf    0.000000\ndtype: float64\n</pre></div> </div> <p>With a DataFrame:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [44]: df1 = pd.DataFrame(np.random.randn(6, 4),\n   ....:                    index=list('abcdef'),\n   ....:                    columns=list('ABCD'))\n   ....: \n\nIn [45]: df1\nOut[45]: \n          A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nb  1.130127 -1.436737 -1.413681  1.607920\nc  1.024180  0.569605  0.875906 -2.211372\nd  0.974466 -2.006747 -0.410001 -0.078638\ne  0.545952 -1.219217 -1.226825  0.769804\nf -1.281247 -0.727707 -0.121306 -0.097883\n\nIn [46]: df1.loc[['a', 'b', 'd'], :]\nOut[46]: \n          A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nb  1.130127 -1.436737 -1.413681  1.607920\nd  0.974466 -2.006747 -0.410001 -0.078638\n</pre></div> </div> <p>Accessing via label slices:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [47]: df1.loc['d':, 'A':'C']\nOut[47]: \n          A         B         C\nd  0.974466 -2.006747 -0.410001\ne  0.545952 -1.219217 -1.226825\nf -1.281247 -0.727707 -0.121306\n</pre></div> </div> <p>For getting a cross section using a label (equivalent to <code class=\"docutils literal notranslate\"><span class=\"pre\">df.xs('a')</span></code>):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [48]: df1.loc['a']\nOut[48]: \nA    0.132003\nB   -0.827317\nC   -0.076467\nD   -1.187678\nName: a, dtype: float64\n</pre></div> </div> <p>For getting values with a boolean array:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [49]: df1.loc['a'] &gt; 0\nOut[49]: \nA     True\nB    False\nC    False\nD    False\nName: a, dtype: bool\n\nIn [50]: df1.loc[:, df1.loc['a'] &gt; 0]\nOut[50]: \n          A\na  0.132003\nb  1.130127\nc  1.024180\nd  0.974466\ne  0.545952\nf -1.281247\n</pre></div> </div> <p>NA values in a boolean array propagate as <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>:</p> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 1.0.2.</span></p> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [51]: mask = pd.array([True, False, True, False, pd.NA, False], dtype=\"boolean\")\n\nIn [52]: mask\nOut[52]: \n&lt;BooleanArray&gt;\n[True, False, True, False, &lt;NA&gt;, False]\nLength: 6, dtype: boolean\n\nIn [53]: df1[mask]\nOut[53]: \n          A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nc  1.024180  0.569605  0.875906 -2.211372\n</pre></div> </div> <p>For getting a value explicitly:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># this is also equivalent to ``df1.at['a','A']``\nIn [54]: df1.loc['a', 'A']\nOut[54]: 0.13200317033032932\n</pre></div> </div> <section id=\"slicing-with-labels\"> <h3>Slicing with labels</h3> <p>When using <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> with slices, if both the start and the stop labels are present in the index, then elements <em>located</em> between the two (including them) are returned:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [55]: s = pd.Series(list('abcde'), index=[0, 3, 2, 5, 4])\n\nIn [56]: s.loc[3:5]\nOut[56]: \n3    b\n2    c\n5    d\ndtype: object\n</pre></div> </div> <p>If at least one of the two is absent, but the index is sorted, and can be compared against start and stop labels, then slicing will still work as expected, by selecting labels which <em>rank</em> between the two:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [57]: s.sort_index()\nOut[57]: \n0    a\n2    c\n3    b\n4    e\n5    d\ndtype: object\n\nIn [58]: s.sort_index().loc[1:6]\nOut[58]: \n2    c\n3    b\n4    e\n5    d\ndtype: object\n</pre></div> </div> <p>However, if at least one of the two is absent <em>and</em> the index is not sorted, an error will be raised (since doing otherwise would be computationally expensive, as well as potentially ambiguous for mixed type indexes). For instance, in the above example, <code class=\"docutils literal notranslate\"><span class=\"pre\">s.loc[1:6]</span></code> would raise <code class=\"docutils literal notranslate\"><span class=\"pre\">KeyError</span></code>.</p> <p>For the rationale behind this behavior, see <a class=\"reference internal\" href=\"advanced#advanced-endpoints-are-inclusive\"><span class=\"std std-ref\">Endpoints are inclusive</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [59]: s = pd.Series(list('abcdef'), index=[0, 3, 2, 5, 4, 2])\n\nIn [60]: s.loc[3:5]\nOut[60]: \n3    b\n2    c\n5    d\ndtype: object\n</pre></div> </div> <p>Also, if the index has duplicate labels <em>and</em> either the start or the stop label is duplicated, an error will be raised. For instance, in the above example, <code class=\"docutils literal notranslate\"><span class=\"pre\">s.loc[2:5]</span></code> would raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">KeyError</span></code>.</p> <p>For more information about duplicate labels, see <a class=\"reference internal\" href=\"duplicates#duplicates\"><span class=\"std std-ref\">Duplicate Labels</span></a>.</p> </section> </section> <section id=\"selection-by-position\"> <h2>Selection by position</h2> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p>Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called <code class=\"docutils literal notranslate\"><span class=\"pre\">chained</span> <span class=\"pre\">assignment</span></code> and should be avoided. See <a class=\"reference internal\" href=\"#indexing-view-versus-copy\"><span class=\"std std-ref\">Returning a View versus Copy</span></a>.</p> </div> <p>pandas provides a suite of methods in order to get <strong>purely integer based indexing</strong>. The semantics follow closely Python and NumPy slicing. These are <code class=\"docutils literal notranslate\"><span class=\"pre\">0-based</span></code> indexing. When slicing, the start bound is <em>included</em>, while the upper bound is <em>excluded</em>. Trying to use a non-integer, even a <strong>valid</strong> label will raise an <code class=\"docutils literal notranslate\"><span class=\"pre\">IndexError</span></code>.</p> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code> attribute is the primary access method. The following are valid inputs:</p> <ul class=\"simple\"> <li><p>An integer e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code>.</p></li> <li><p>A list or array of integers <code class=\"docutils literal notranslate\"><span class=\"pre\">[4,</span> <span class=\"pre\">3,</span> <span class=\"pre\">0]</span></code>.</p></li> <li><p>A slice object with ints <code class=\"docutils literal notranslate\"><span class=\"pre\">1:7</span></code>.</p></li> <li><p>A boolean array.</p></li> <li><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">callable</span></code>, see <a class=\"reference internal\" href=\"#indexing-callable\"><span class=\"std std-ref\">Selection By Callable</span></a>.</p></li> </ul> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [61]: s1 = pd.Series(np.random.randn(5), index=list(range(0, 10, 2)))\n\nIn [62]: s1\nOut[62]: \n0    0.695775\n2    0.341734\n4    0.959726\n6   -1.110336\n8   -0.619976\ndtype: float64\n\nIn [63]: s1.iloc[:3]\nOut[63]: \n0    0.695775\n2    0.341734\n4    0.959726\ndtype: float64\n\nIn [64]: s1.iloc[3]\nOut[64]: -1.110336102891167\n</pre></div> </div> <p>Note that setting works as well:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [65]: s1.iloc[:3] = 0\n\nIn [66]: s1\nOut[66]: \n0    0.000000\n2    0.000000\n4    0.000000\n6   -1.110336\n8   -0.619976\ndtype: float64\n</pre></div> </div> <p>With a DataFrame:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [67]: df1 = pd.DataFrame(np.random.randn(6, 4),\n   ....:                    index=list(range(0, 12, 2)),\n   ....:                    columns=list(range(0, 8, 2)))\n   ....: \n\nIn [68]: df1\nOut[68]: \n           0         2         4         6\n0   0.149748 -0.732339  0.687738  0.176444\n2   0.403310 -0.154951  0.301624 -2.179861\n4  -1.369849 -0.954208  1.462696 -1.743161\n6  -0.826591 -0.345352  1.314232  0.690579\n8   0.995761  2.396780  0.014871  3.357427\n10 -0.317441 -1.236269  0.896171 -0.487602\n</pre></div> </div> <p>Select via integer slicing:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [69]: df1.iloc[:3]\nOut[69]: \n          0         2         4         6\n0  0.149748 -0.732339  0.687738  0.176444\n2  0.403310 -0.154951  0.301624 -2.179861\n4 -1.369849 -0.954208  1.462696 -1.743161\n\nIn [70]: df1.iloc[1:5, 2:4]\nOut[70]: \n          4         6\n2  0.301624 -2.179861\n4  1.462696 -1.743161\n6  1.314232  0.690579\n8  0.014871  3.357427\n</pre></div> </div> <p>Select via integer list:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [71]: df1.iloc[[1, 3, 5], [1, 3]]\nOut[71]: \n           2         6\n2  -0.154951 -2.179861\n6  -0.345352  0.690579\n10 -1.236269 -0.487602\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [72]: df1.iloc[1:3, :]\nOut[72]: \n          0         2         4         6\n2  0.403310 -0.154951  0.301624 -2.179861\n4 -1.369849 -0.954208  1.462696 -1.743161\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [73]: df1.iloc[:, 1:3]\nOut[73]: \n           2         4\n0  -0.732339  0.687738\n2  -0.154951  0.301624\n4  -0.954208  1.462696\n6  -0.345352  1.314232\n8   2.396780  0.014871\n10 -1.236269  0.896171\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># this is also equivalent to ``df1.iat[1,1]``\nIn [74]: df1.iloc[1, 1]\nOut[74]: -0.1549507744249032\n</pre></div> </div> <p>For getting a cross section using an integer position (equiv to <code class=\"docutils literal notranslate\"><span class=\"pre\">df.xs(1)</span></code>):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [75]: df1.iloc[1]\nOut[75]: \n0    0.403310\n2   -0.154951\n4    0.301624\n6   -2.179861\nName: 2, dtype: float64\n</pre></div> </div> <p>Out of range slice indexes are handled gracefully just as in Python/NumPy.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># these are allowed in Python/NumPy.\nIn [76]: x = list('abcdef')\n\nIn [77]: x\nOut[77]: ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [78]: x[4:10]\nOut[78]: ['e', 'f']\n\nIn [79]: x[8:10]\nOut[79]: []\n\nIn [80]: s = pd.Series(x)\n\nIn [81]: s\nOut[81]: \n0    a\n1    b\n2    c\n3    d\n4    e\n5    f\ndtype: object\n\nIn [82]: s.iloc[4:10]\nOut[82]: \n4    e\n5    f\ndtype: object\n\nIn [83]: s.iloc[8:10]\nOut[83]: Series([], dtype: object)\n</pre></div> </div> <p>Note that using slices that go out of bounds can result in an empty axis (e.g. an empty DataFrame being returned).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [84]: dfl = pd.DataFrame(np.random.randn(5, 2), columns=list('AB'))\n\nIn [85]: dfl\nOut[85]: \n          A         B\n0 -0.082240 -2.182937\n1  0.380396  0.084844\n2  0.432390  1.519970\n3 -0.493662  0.600178\n4  0.274230  0.132885\n\nIn [86]: dfl.iloc[:, 2:3]\nOut[86]: \nEmpty DataFrame\nColumns: []\nIndex: [0, 1, 2, 3, 4]\n\nIn [87]: dfl.iloc[:, 1:3]\nOut[87]: \n          B\n0 -2.182937\n1  0.084844\n2  1.519970\n3  0.600178\n4  0.132885\n\nIn [88]: dfl.iloc[4:6]\nOut[88]: \n         A         B\n4  0.27423  0.132885\n</pre></div> </div> <p>A single indexer that is out of bounds will raise an <code class=\"docutils literal notranslate\"><span class=\"pre\">IndexError</span></code>. A list of indexers where any element is out of bounds will raise an <code class=\"docutils literal notranslate\"><span class=\"pre\">IndexError</span></code>.</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">&gt;&gt;&gt; dfl.iloc[[4, 5, 6]]\nIndexError: positional indexers are out-of-bounds\n\n&gt;&gt;&gt; dfl.iloc[:, 4]\nIndexError: single positional indexer is out-of-bounds\n</pre></div> </div> </section> <section id=\"selection-by-callable\"> <h2>Selection by callable</h2> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code>, and also <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> indexing can accept a <code class=\"docutils literal notranslate\"><span class=\"pre\">callable</span></code> as indexer. The <code class=\"docutils literal notranslate\"><span class=\"pre\">callable</span></code> must be a function with one argument (the calling Series or DataFrame) that returns valid output for indexing.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [89]: df1 = pd.DataFrame(np.random.randn(6, 4),\n   ....:                    index=list('abcdef'),\n   ....:                    columns=list('ABCD'))\n   ....: \n\nIn [90]: df1\nOut[90]: \n          A         B         C         D\na -0.023688  2.410179  1.450520  0.206053\nb -0.251905 -2.213588  1.063327  1.266143\nc  0.299368 -0.863838  0.408204 -1.048089\nd -0.025747 -0.988387  0.094055  1.262731\ne  1.289997  0.082423 -0.055758  0.536580\nf -0.489682  0.369374 -0.034571 -2.484478\n\nIn [91]: df1.loc[lambda df: df['A'] &gt; 0, :]\nOut[91]: \n          A         B         C         D\nc  0.299368 -0.863838  0.408204 -1.048089\ne  1.289997  0.082423 -0.055758  0.536580\n\nIn [92]: df1.loc[:, lambda df: ['A', 'B']]\nOut[92]: \n          A         B\na -0.023688  2.410179\nb -0.251905 -2.213588\nc  0.299368 -0.863838\nd -0.025747 -0.988387\ne  1.289997  0.082423\nf -0.489682  0.369374\n\nIn [93]: df1.iloc[:, lambda df: [0, 1]]\nOut[93]: \n          A         B\na -0.023688  2.410179\nb -0.251905 -2.213588\nc  0.299368 -0.863838\nd -0.025747 -0.988387\ne  1.289997  0.082423\nf -0.489682  0.369374\n\nIn [94]: df1[lambda df: df.columns[0]]\nOut[94]: \na   -0.023688\nb   -0.251905\nc    0.299368\nd   -0.025747\ne    1.289997\nf   -0.489682\nName: A, dtype: float64\n</pre></div> </div> <p>You can use callable indexing in <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [95]: df1['A'].loc[lambda s: s &gt; 0]\nOut[95]: \nc    0.299368\ne    1.289997\nName: A, dtype: float64\n</pre></div> </div> <p>Using these methods / indexers, you can chain data selection operations without using a temporary variable.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [96]: bb = pd.read_csv('data/baseball.csv', index_col='id')\n\nIn [97]: (bb.groupby(['year', 'team']).sum()\n   ....:    .loc[lambda df: df['r'] &gt; 100])\n   ....: \nOut[97]: \n           stint    g    ab    r    h  X2b  X3b  hr    rbi    sb   cs   bb     so   ibb   hbp    sh    sf  gidp\nyear team                                                                                                      \n2007 CIN       6  379   745  101  203   35    2  36  125.0  10.0  1.0  105  127.0  14.0   1.0   1.0  15.0  18.0\n     DET       5  301  1062  162  283   54    4  37  144.0  24.0  7.0   97  176.0   3.0  10.0   4.0   8.0  28.0\n     HOU       4  311   926  109  218   47    6  14   77.0  10.0  4.0   60  212.0   3.0   9.0  16.0   6.0  17.0\n     LAN      11  413  1021  153  293   61    3  36  154.0   7.0  5.0  114  141.0   8.0   9.0   3.0   8.0  29.0\n     NYN      13  622  1854  240  509  101    3  61  243.0  22.0  4.0  174  310.0  24.0  23.0  18.0  15.0  48.0\n     SFN       5  482  1305  198  337   67    6  40  171.0  26.0  7.0  235  188.0  51.0   8.0  16.0   6.0  41.0\n     TEX       2  198   729  115  200   40    4  28  115.0  21.0  4.0   73  140.0   4.0   5.0   2.0   8.0  16.0\n     TOR       4  459  1408  187  378   96    2  58  223.0   4.0  2.0  190  265.0  16.0  12.0   4.0  16.0  38.0\n</pre></div> </div> </section> <section id=\"combining-positional-and-label-based-indexing\"> <h2>Combining positional and label-based indexing</h2> <p>If you wish to get the 0th and the 2nd elements from the index in the ‘A’ column, you can do:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [98]: dfd = pd.DataFrame({'A': [1, 2, 3],\n   ....:                     'B': [4, 5, 6]},\n   ....:                    index=list('abc'))\n   ....: \n\nIn [99]: dfd\nOut[99]: \n   A  B\na  1  4\nb  2  5\nc  3  6\n\nIn [100]: dfd.loc[dfd.index[[0, 2]], 'A']\nOut[100]: \na    1\nc    3\nName: A, dtype: int64\n</pre></div> </div> <p>This can also be expressed using <code class=\"docutils literal notranslate\"><span class=\"pre\">.iloc</span></code>, by explicitly getting locations on the indexers, and using <em>positional</em> indexing to select things.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [101]: dfd.iloc[[0, 2], dfd.columns.get_loc('A')]\nOut[101]: \na    1\nc    3\nName: A, dtype: int64\n</pre></div> </div> <p>For getting <em>multiple</em> indexers, using <code class=\"docutils literal notranslate\"><span class=\"pre\">.get_indexer</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [102]: dfd.iloc[[0, 2], dfd.columns.get_indexer(['A', 'B'])]\nOut[102]: \n   A  B\na  1  4\nc  3  6\n</pre></div> </div> </section> <section id=\"indexing-with-list-with-missing-labels-is-deprecated\"> <h2>Indexing with list with missing labels is deprecated</h2> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <div class=\"versionchanged\"> <p><span class=\"versionmodified changed\">Changed in version 1.0.0.</span></p> </div> <p>Using <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> with a list with one or more missing labels will no longer reindex, in favor of <code class=\"docutils literal notranslate\"><span class=\"pre\">.reindex</span></code>.</p> </div> <p>In prior versions, using <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc[list-of-labels]</span></code> would work as long as <em>at least 1</em> of the keys was found (otherwise it would raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">KeyError</span></code>). This behavior was changed and will now raise a <code class=\"docutils literal notranslate\"><span class=\"pre\">KeyError</span></code> if at least one label is missing. The recommended alternative is to use <code class=\"docutils literal notranslate\"><span class=\"pre\">.reindex()</span></code>.</p> <p>For example.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [103]: s = pd.Series([1, 2, 3])\n\nIn [104]: s\nOut[104]: \n0    1\n1    2\n2    3\ndtype: int64\n</pre></div> </div> <p>Selection with all keys found is unchanged.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [105]: s.loc[[1, 2]]\nOut[105]: \n1    2\n2    3\ndtype: int64\n</pre></div> </div> <p>Previous behavior</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [4]: s.loc[[1, 2, 3]]\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64\n</pre></div> </div> <p>Current behavior</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [4]: s.loc[[1, 2, 3]]\nPassing list-likes to .loc with any non-matching elements will raise\nKeyError in the future, you can use .reindex() as an alternative.\n\nSee the documentation here:\nhttps://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike\n\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64\n</pre></div> </div> <section id=\"reindexing\"> <h3>Reindexing</h3> <p>The idiomatic way to achieve selecting potentially not-found elements is via <code class=\"docutils literal notranslate\"><span class=\"pre\">.reindex()</span></code>. See also the section on <a class=\"reference internal\" href=\"basics#basics-reindexing\"><span class=\"std std-ref\">reindexing</span></a>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [106]: s.reindex([1, 2, 3])\nOut[106]: \n1    2.0\n2    3.0\n3    NaN\ndtype: float64\n</pre></div> </div> <p>Alternatively, if you want to select only <em>valid</em> keys, the following is idiomatic and efficient; it is guaranteed to preserve the dtype of the selection.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [107]: labels = [1, 2, 3]\n\nIn [108]: s.loc[s.index.intersection(labels)]\nOut[108]: \n1    2\n2    3\ndtype: int64\n</pre></div> </div> <p>Having a duplicated index will raise for a <code class=\"docutils literal notranslate\"><span class=\"pre\">.reindex()</span></code>:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [109]: s = pd.Series(np.arange(4), index=['a', 'a', 'b', 'c'])\n\nIn [110]: labels = ['c', 'd']\n</pre></div> </div> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [17]: s.reindex(labels)\nValueError: cannot reindex on an axis with duplicate labels\n</pre></div> </div> <p>Generally, you can intersect the desired labels with the current axis, and then reindex.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [111]: s.loc[s.index.intersection(labels)].reindex(labels)\nOut[111]: \nc    3.0\nd    NaN\ndtype: float64\n</pre></div> </div> <p>However, this would <em>still</em> raise if your resulting index is duplicated.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [41]: labels = ['a', 'd']\n\nIn [42]: s.loc[s.index.intersection(labels)].reindex(labels)\nValueError: cannot reindex on an axis with duplicate labels\n</pre></div> </div> </section> </section> <section id=\"selecting-random-samples\"> <h2>Selecting random samples</h2> <p>A random selection of rows or columns from a Series or DataFrame with the <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.sample#pandas.DataFrame.sample\" title=\"pandas.DataFrame.sample\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">sample()</span></code></a> method. The method will sample rows by default, and accepts a specific number of rows/columns to return, or a fraction of rows.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [112]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\n# When no arguments are passed, returns 1 row.\nIn [113]: s.sample()\nOut[113]: \n4    4\ndtype: int64\n\n# One may specify either a number of rows:\nIn [114]: s.sample(n=3)\nOut[114]: \n0    0\n4    4\n1    1\ndtype: int64\n\n# Or a fraction of the rows:\nIn [115]: s.sample(frac=0.5)\nOut[115]: \n5    5\n3    3\n1    1\ndtype: int64\n</pre></div> </div> <p>By default, <code class=\"docutils literal notranslate\"><span class=\"pre\">sample</span></code> will return each row at most once, but one can also sample with replacement using the <code class=\"docutils literal notranslate\"><span class=\"pre\">replace</span></code> option:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [116]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\n# Without replacement (default):\nIn [117]: s.sample(n=6, replace=False)\nOut[117]: \n0    0\n1    1\n5    5\n3    3\n2    2\n4    4\ndtype: int64\n\n# With replacement:\nIn [118]: s.sample(n=6, replace=True)\nOut[118]: \n0    0\n4    4\n3    3\n2    2\n4    4\n4    4\ndtype: int64\n</pre></div> </div> <p>By default, each row has an equal probability of being selected, but if you want rows to have different probabilities, you can pass the <code class=\"docutils literal notranslate\"><span class=\"pre\">sample</span></code> function sampling weights as <code class=\"docutils literal notranslate\"><span class=\"pre\">weights</span></code>. These weights can be a list, a NumPy array, or a Series, but they must be of the same length as the object you are sampling. Missing values will be treated as a weight of zero, and inf values are not allowed. If weights do not sum to 1, they will be re-normalized by dividing all weights by the sum of the weights. For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [119]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\nIn [120]: example_weights = [0, 0, 0.2, 0.2, 0.2, 0.4]\n\nIn [121]: s.sample(n=3, weights=example_weights)\nOut[121]: \n5    5\n4    4\n3    3\ndtype: int64\n\n# Weights will be re-normalized automatically\nIn [122]: example_weights2 = [0.5, 0, 0, 0, 0, 0]\n\nIn [123]: s.sample(n=1, weights=example_weights2)\nOut[123]: \n0    0\ndtype: int64\n</pre></div> </div> <p>When applied to a DataFrame, you can use a column of the DataFrame as sampling weights (provided you are sampling rows and not columns) by simply passing the name of the column as a string.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [124]: df2 = pd.DataFrame({'col1': [9, 8, 7, 6],\n   .....:                     'weight_column': [0.5, 0.4, 0.1, 0]})\n   .....: \n\nIn [125]: df2.sample(n=3, weights='weight_column')\nOut[125]: \n   col1  weight_column\n1     8            0.4\n0     9            0.5\n2     7            0.1\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">sample</span></code> also allows users to sample columns instead of rows using the <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> argument.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [126]: df3 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})\n\nIn [127]: df3.sample(n=1, axis=1)\nOut[127]: \n   col1\n0     1\n1     2\n2     3\n</pre></div> </div> <p>Finally, one can also set a seed for <code class=\"docutils literal notranslate\"><span class=\"pre\">sample</span></code>’s random number generator using the <code class=\"docutils literal notranslate\"><span class=\"pre\">random_state</span></code> argument, which will accept either an integer (as a seed) or a NumPy RandomState object.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [128]: df4 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})\n\n# With a given seed, the sample will always draw the same rows.\nIn [129]: df4.sample(n=2, random_state=2)\nOut[129]: \n   col1  col2\n2     3     4\n1     2     3\n\nIn [130]: df4.sample(n=2, random_state=2)\nOut[130]: \n   col1  col2\n2     3     4\n1     2     3\n</pre></div> </div> </section> <section id=\"setting-with-enlargement\"> <h2>Setting with enlargement</h2> <p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc/[]</span></code> operations can perform enlargement when setting a non-existent key for that axis.</p> <p>In the <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> case this is effectively an appending operation.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [131]: se = pd.Series([1, 2, 3])\n\nIn [132]: se\nOut[132]: \n0    1\n1    2\n2    3\ndtype: int64\n\nIn [133]: se[5] = 5.\n\nIn [134]: se\nOut[134]: \n0    1.0\n1    2.0\n2    3.0\n5    5.0\ndtype: float64\n</pre></div> </div> <p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> can be enlarged on either axis via <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [135]: dfi = pd.DataFrame(np.arange(6).reshape(3, 2),\n   .....:                    columns=['A', 'B'])\n   .....: \n\nIn [136]: dfi\nOut[136]: \n   A  B\n0  0  1\n1  2  3\n2  4  5\n\nIn [137]: dfi.loc[:, 'C'] = dfi.loc[:, 'A']\n\nIn [138]: dfi\nOut[138]: \n   A  B  C\n0  0  1  0\n1  2  3  2\n2  4  5  4\n</pre></div> </div> <p>This is like an <code class=\"docutils literal notranslate\"><span class=\"pre\">append</span></code> operation on the <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [139]: dfi.loc[3] = 5\n\nIn [140]: dfi\nOut[140]: \n   A  B  C\n0  0  1  0\n1  2  3  2\n2  4  5  4\n3  5  5  5\n</pre></div> </div> </section> <section id=\"fast-scalar-value-getting-and-setting\"> <h2>Fast scalar value getting and setting</h2> <p>Since indexing with <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> must handle a lot of cases (single-label access, slicing, boolean indexing, etc.), it has a bit of overhead in order to figure out what you’re asking for. If you only want to access a scalar value, the fastest way is to use the <code class=\"docutils literal notranslate\"><span class=\"pre\">at</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">iat</span></code> methods, which are implemented on all of the data structures.</p> <p>Similarly to <code class=\"docutils literal notranslate\"><span class=\"pre\">loc</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">at</span></code> provides <strong>label</strong> based scalar lookups, while, <code class=\"docutils literal notranslate\"><span class=\"pre\">iat</span></code> provides <strong>integer</strong> based lookups analogously to <code class=\"docutils literal notranslate\"><span class=\"pre\">iloc</span></code></p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [141]: s.iat[5]\nOut[141]: 5\n\nIn [142]: df.at[dates[5], 'A']\nOut[142]: -0.6736897080883706\n\nIn [143]: df.iat[3, 0]\nOut[143]: 0.7215551622443669\n</pre></div> </div> <p>You can also set using these same indexers.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [144]: df.at[dates[5], 'E'] = 7\n\nIn [145]: df.iat[3, 0] = 7\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">at</span></code> may enlarge the object in-place as above if the indexer is missing.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [146]: df.at[dates[-1] + pd.Timedelta('1 day'), 0] = 7\n\nIn [147]: df\nOut[147]: \n                   A         B         C         D    E    0\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632  NaN  NaN\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236  NaN  NaN\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804  NaN  NaN\n2000-01-04  7.000000 -0.706771 -1.039575  0.271860  NaN  NaN\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401  NaN  NaN\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988  7.0  NaN\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268  NaN  NaN\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885  NaN  NaN\n2000-01-09       NaN       NaN       NaN       NaN  NaN  7.0\n</pre></div> </div> </section> <section id=\"boolean-indexing\"> <h2>Boolean indexing</h2> <p id=\"indexing-boolean\">Another common operation is the use of boolean vectors to filter the data. The operators are: <code class=\"docutils literal notranslate\"><span class=\"pre\">|</span></code> for <code class=\"docutils literal notranslate\"><span class=\"pre\">or</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;</span></code> for <code class=\"docutils literal notranslate\"><span class=\"pre\">and</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">~</span></code> for <code class=\"docutils literal notranslate\"><span class=\"pre\">not</span></code>. These <strong>must</strong> be grouped by using parentheses, since by default Python will evaluate an expression such as <code class=\"docutils literal notranslate\"><span class=\"pre\">df['A']</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">2</span> <span class=\"pre\">&amp;</span> <span class=\"pre\">df['B']</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">3</span></code> as <code class=\"docutils literal notranslate\"><span class=\"pre\">df['A']</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">(2</span> <span class=\"pre\">&amp;</span> <span class=\"pre\">df['B'])</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">3</span></code>, while the desired evaluation order is <code class=\"docutils literal notranslate\"><span class=\"pre\">(df['A']</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">2)</span> <span class=\"pre\">&amp;</span> <span class=\"pre\">(df['B']</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">3)</span></code>.</p> <p>Using a boolean vector to index a Series works exactly as in a NumPy ndarray:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [148]: s = pd.Series(range(-3, 4))\n\nIn [149]: s\nOut[149]: \n0   -3\n1   -2\n2   -1\n3    0\n4    1\n5    2\n6    3\ndtype: int64\n\nIn [150]: s[s &gt; 0]\nOut[150]: \n4    1\n5    2\n6    3\ndtype: int64\n\nIn [151]: s[(s &lt; -1) | (s &gt; 0.5)]\nOut[151]: \n0   -3\n1   -2\n4    1\n5    2\n6    3\ndtype: int64\n\nIn [152]: s[~(s &lt; 0)]\nOut[152]: \n3    0\n4    1\n5    2\n6    3\ndtype: int64\n</pre></div> </div> <p>You may select rows from a DataFrame using a boolean vector the same length as the DataFrame’s index (for example, something derived from one of the columns of the DataFrame):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [153]: df[df['A'] &gt; 0]\nOut[153]: \n                   A         B         C         D   E   0\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632 NaN NaN\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236 NaN NaN\n2000-01-04  7.000000 -0.706771 -1.039575  0.271860 NaN NaN\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268 NaN NaN\n</pre></div> </div> <p>List comprehensions and the <code class=\"docutils literal notranslate\"><span class=\"pre\">map</span></code> method of Series can also be used to produce more complex criteria:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [154]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'three', 'two', 'one', 'six'],\n   .....:                     'b': ['x', 'y', 'y', 'x', 'y', 'x', 'x'],\n   .....:                     'c': np.random.randn(7)})\n   .....: \n\n# only want 'two' or 'three'\nIn [155]: criterion = df2['a'].map(lambda x: x.startswith('t'))\n\nIn [156]: df2[criterion]\nOut[156]: \n       a  b         c\n2    two  y  0.041290\n3  three  x  0.361719\n4    two  y -0.238075\n\n# equivalent but slower\nIn [157]: df2[[x.startswith('t') for x in df2['a']]]\nOut[157]: \n       a  b         c\n2    two  y  0.041290\n3  three  x  0.361719\n4    two  y -0.238075\n\n# Multiple criteria\nIn [158]: df2[criterion &amp; (df2['b'] == 'x')]\nOut[158]: \n       a  b         c\n3  three  x  0.361719\n</pre></div> </div> <p>With the choice methods <a class=\"reference internal\" href=\"#indexing-label\"><span class=\"std std-ref\">Selection by Label</span></a>, <a class=\"reference internal\" href=\"#indexing-integer\"><span class=\"std std-ref\">Selection by Position</span></a>, and <a class=\"reference internal\" href=\"advanced#advanced\"><span class=\"std std-ref\">Advanced Indexing</span></a> you may select along more than one axis using boolean vectors combined with other indexing expressions.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [159]: df2.loc[criterion &amp; (df2['b'] == 'x'), 'b':'c']\nOut[159]: \n   b         c\n3  x  0.361719\n</pre></div> </div> <div class=\"admonition warning\"> <p class=\"admonition-title\">Warning</p> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">iloc</span></code> supports two kinds of boolean indexing. If the indexer is a boolean <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>, an error will be raised. For instance, in the following example, <code class=\"docutils literal notranslate\"><span class=\"pre\">df.iloc[s.values,</span> <span class=\"pre\">1]</span></code> is ok. The boolean indexer is an array. But <code class=\"docutils literal notranslate\"><span class=\"pre\">df.iloc[s,</span> <span class=\"pre\">1]</span></code> would raise <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [160]: df = pd.DataFrame([[1, 2], [3, 4], [5, 6]],\n   .....:                   index=list('abc'),\n   .....:                   columns=['A', 'B'])\n   .....: \n\nIn [161]: s = (df['A'] &gt; 2)\n\nIn [162]: s\nOut[162]: \na    False\nb     True\nc     True\nName: A, dtype: bool\n\nIn [163]: df.loc[s, 'B']\nOut[163]: \nb    4\nc    6\nName: B, dtype: int64\n\nIn [164]: df.iloc[s.values, 1]\nOut[164]: \nb    4\nc    6\nName: B, dtype: int64\n</pre></div> </div> </div> </section> <section id=\"indexing-with-isin\"> <h2>Indexing with isin</h2> <p>Consider the <a class=\"reference internal\" href=\"../reference/api/pandas.series.isin#pandas.Series.isin\" title=\"pandas.Series.isin\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">isin()</span></code></a> method of <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code>, which returns a boolean vector that is true wherever the <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> elements exist in the passed list. This allows you to select rows where one or more columns have values you want:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [165]: s = pd.Series(np.arange(5), index=np.arange(5)[::-1], dtype='int64')\n\nIn [166]: s\nOut[166]: \n4    0\n3    1\n2    2\n1    3\n0    4\ndtype: int64\n\nIn [167]: s.isin([2, 4, 6])\nOut[167]: \n4    False\n3    False\n2     True\n1    False\n0     True\ndtype: bool\n\nIn [168]: s[s.isin([2, 4, 6])]\nOut[168]: \n2    2\n0    4\ndtype: int64\n</pre></div> </div> <p>The same method is available for <code class=\"docutils literal notranslate\"><span class=\"pre\">Index</span></code> objects and is useful for the cases when you don’t know which of the sought labels are in fact present:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [169]: s[s.index.isin([2, 4, 6])]\nOut[169]: \n4    0\n2    2\ndtype: int64\n\n# compare it to the following\nIn [170]: s.reindex([2, 4, 6])\nOut[170]: \n2    2.0\n4    0.0\n6    NaN\ndtype: float64\n</pre></div> </div> <p>In addition to that, <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> allows selecting a separate level to use in the membership check:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [171]: s_mi = pd.Series(np.arange(6),\n   .....:                  index=pd.MultiIndex.from_product([[0, 1], ['a', 'b', 'c']]))\n   .....: \n\nIn [172]: s_mi\nOut[172]: \n0  a    0\n   b    1\n   c    2\n1  a    3\n   b    4\n   c    5\ndtype: int64\n\nIn [173]: s_mi.iloc[s_mi.index.isin([(1, 'a'), (2, 'b'), (0, 'c')])]\nOut[173]: \n0  c    2\n1  a    3\ndtype: int64\n\nIn [174]: s_mi.iloc[s_mi.index.isin(['a', 'c', 'e'], level=1)]\nOut[174]: \n0  a    0\n   c    2\n1  a    3\n   c    5\ndtype: int64\n</pre></div> </div> <p>DataFrame also has an <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.isin#pandas.DataFrame.isin\" title=\"pandas.DataFrame.isin\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">isin()</span></code></a> method. When calling <code class=\"docutils literal notranslate\"><span class=\"pre\">isin</span></code>, pass a set of values as either an array or dict. If values is an array, <code class=\"docutils literal notranslate\"><span class=\"pre\">isin</span></code> returns a DataFrame of booleans that is the same shape as the original DataFrame, with True wherever the element is in the sequence of values.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [175]: df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['a', 'b', 'f', 'n'],\n   .....:                    'ids2': ['a', 'n', 'c', 'n']})\n   .....: \n\nIn [176]: values = ['a', 'b', 1, 3]\n\nIn [177]: df.isin(values)\nOut[177]: \n    vals    ids   ids2\n0   True   True   True\n1  False   True  False\n2   True  False  False\n3  False  False  False\n</pre></div> </div> <p>Oftentimes you’ll want to match certain values with certain columns. Just make values a <code class=\"docutils literal notranslate\"><span class=\"pre\">dict</span></code> where the key is the column, and the value is a list of items you want to check for.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [178]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}\n\nIn [179]: df.isin(values)\nOut[179]: \n    vals    ids   ids2\n0   True   True  False\n1  False   True  False\n2   True  False  False\n3  False  False  False\n</pre></div> </div> <p>To return the DataFrame of booleans where the values are <em>not</em> in the original DataFrame, use the <code class=\"docutils literal notranslate\"><span class=\"pre\">~</span></code> operator:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [180]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}\n\nIn [181]: ~df.isin(values)\nOut[181]: \n    vals    ids  ids2\n0  False  False  True\n1   True  False  True\n2  False   True  True\n3   True   True  True\n</pre></div> </div> <p>Combine DataFrame’s <code class=\"docutils literal notranslate\"><span class=\"pre\">isin</span></code> with the <code class=\"docutils literal notranslate\"><span class=\"pre\">any()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">all()</span></code> methods to quickly select subsets of your data that meet a given criteria. To select a row where each column meets its own criterion:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [182]: values = {'ids': ['a', 'b'], 'ids2': ['a', 'c'], 'vals': [1, 3]}\n\nIn [183]: row_mask = df.isin(values).all(1)\n\nIn [184]: df[row_mask]\nOut[184]: \n   vals ids ids2\n0     1   a    a\n</pre></div> </div> </section> <section id=\"the-where-method-and-masking\"> <h2>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.where#pandas.DataFrame.where\" title=\"pandas.DataFrame.where\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">where()</span></code></a> Method and Masking</h2> <p>Selecting values from a Series with a boolean vector generally returns a subset of the data. To guarantee that selection output has the same shape as the original data, you can use the <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> method in <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p> <p>To return only the selected rows:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [185]: s[s &gt; 0]\nOut[185]: \n3    1\n2    2\n1    3\n0    4\ndtype: int64\n</pre></div> </div> <p>To return a Series of the same shape as the original:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [186]: s.where(s &gt; 0)\nOut[186]: \n4    NaN\n3    1.0\n2    2.0\n1    3.0\n0    4.0\ndtype: float64\n</pre></div> </div> <p>Selecting values from a DataFrame with a boolean criterion now also preserves input data shape. <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> is used under the hood as the implementation. The code below is equivalent to <code class=\"docutils literal notranslate\"><span class=\"pre\">df.where(df</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">0)</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [187]: df[df &lt; 0]\nOut[187]: \n                   A         B         C         D\n2000-01-01 -2.104139 -1.309525       NaN       NaN\n2000-01-02 -0.352480       NaN -1.192319       NaN\n2000-01-03 -0.864883       NaN -0.227870       NaN\n2000-01-04       NaN -1.222082       NaN -1.233203\n2000-01-05       NaN -0.605656 -1.169184       NaN\n2000-01-06       NaN -0.948458       NaN -0.684718\n2000-01-07 -2.670153 -0.114722       NaN -0.048048\n2000-01-08       NaN       NaN -0.048788 -0.808838\n</pre></div> </div> <p>In addition, <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> takes an optional <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code> argument for replacement of values where the condition is False, in the returned copy.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [188]: df.where(df &lt; 0, -df)\nOut[188]: \n                   A         B         C         D\n2000-01-01 -2.104139 -1.309525 -0.485855 -0.245166\n2000-01-02 -0.352480 -0.390389 -1.192319 -1.655824\n2000-01-03 -0.864883 -0.299674 -0.227870 -0.281059\n2000-01-04 -0.846958 -1.222082 -0.600705 -1.233203\n2000-01-05 -0.669692 -0.605656 -1.169184 -0.342416\n2000-01-06 -0.868584 -0.948458 -2.297780 -0.684718\n2000-01-07 -2.670153 -0.114722 -0.168904 -0.048048\n2000-01-08 -0.801196 -1.392071 -0.048788 -0.808838\n</pre></div> </div> <p>You may wish to set values based on some boolean criteria. This can be done intuitively like so:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [189]: s2 = s.copy()\n\nIn [190]: s2[s2 &lt; 0] = 0\n\nIn [191]: s2\nOut[191]: \n4    0\n3    1\n2    2\n1    3\n0    4\ndtype: int64\n\nIn [192]: df2 = df.copy()\n\nIn [193]: df2[df2 &lt; 0] = 0\n\nIn [194]: df2\nOut[194]: \n                   A         B         C         D\n2000-01-01  0.000000  0.000000  0.485855  0.245166\n2000-01-02  0.000000  0.390389  0.000000  1.655824\n2000-01-03  0.000000  0.299674  0.000000  0.281059\n2000-01-04  0.846958  0.000000  0.600705  0.000000\n2000-01-05  0.669692  0.000000  0.000000  0.342416\n2000-01-06  0.868584  0.000000  2.297780  0.000000\n2000-01-07  0.000000  0.000000  0.168904  0.000000\n2000-01-08  0.801196  1.392071  0.000000  0.000000\n</pre></div> </div> <p>By default, <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> returns a modified copy of the data. There is an optional parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">inplace</span></code> so that the original data can be modified without creating a copy:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [195]: df_orig = df.copy()\n\nIn [196]: df_orig.where(df &gt; 0, -df, inplace=True)\n\nIn [197]: df_orig\nOut[197]: \n                   A         B         C         D\n2000-01-01  2.104139  1.309525  0.485855  0.245166\n2000-01-02  0.352480  0.390389  1.192319  1.655824\n2000-01-03  0.864883  0.299674  0.227870  0.281059\n2000-01-04  0.846958  1.222082  0.600705  1.233203\n2000-01-05  0.669692  0.605656  1.169184  0.342416\n2000-01-06  0.868584  0.948458  2.297780  0.684718\n2000-01-07  2.670153  0.114722  0.168904  0.048048\n2000-01-08  0.801196  1.392071  0.048788  0.808838\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>The signature for <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.where#pandas.DataFrame.where\" title=\"pandas.DataFrame.where\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">DataFrame.where()</span></code></a> differs from <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">numpy.where()</span></code></a>. Roughly <code class=\"docutils literal notranslate\"><span class=\"pre\">df1.where(m,</span> <span class=\"pre\">df2)</span></code> is equivalent to <code class=\"docutils literal notranslate\"><span class=\"pre\">np.where(m,</span> <span class=\"pre\">df1,</span> <span class=\"pre\">df2)</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [198]: df.where(df &lt; 0, -df) == np.where(df &lt; 0, df, -df)\nOut[198]: \n               A     B     C     D\n2000-01-01  True  True  True  True\n2000-01-02  True  True  True  True\n2000-01-03  True  True  True  True\n2000-01-04  True  True  True  True\n2000-01-05  True  True  True  True\n2000-01-06  True  True  True  True\n2000-01-07  True  True  True  True\n2000-01-08  True  True  True  True\n</pre></div> </div> </div> <p><strong>Alignment</strong></p> <p>Furthermore, <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> aligns the input boolean condition (ndarray or DataFrame), such that partial selection with setting is possible. This is analogous to partial setting via <code class=\"docutils literal notranslate\"><span class=\"pre\">.loc</span></code> (but on the contents rather than the axis labels).</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [199]: df2 = df.copy()\n\nIn [200]: df2[df2[1:4] &gt; 0] = 3\n\nIn [201]: df2\nOut[201]: \n                   A         B         C         D\n2000-01-01 -2.104139 -1.309525  0.485855  0.245166\n2000-01-02 -0.352480  3.000000 -1.192319  3.000000\n2000-01-03 -0.864883  3.000000 -0.227870  3.000000\n2000-01-04  3.000000 -1.222082  3.000000 -1.233203\n2000-01-05  0.669692 -0.605656 -1.169184  0.342416\n2000-01-06  0.868584 -0.948458  2.297780 -0.684718\n2000-01-07 -2.670153 -0.114722  0.168904 -0.048048\n2000-01-08  0.801196  1.392071 -0.048788 -0.808838\n</pre></div> </div> <p>Where can also accept <code class=\"docutils literal notranslate\"><span class=\"pre\">axis</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">level</span></code> parameters to align the input when performing the <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [202]: df2 = df.copy()\n\nIn [203]: df2.where(df2 &gt; 0, df2['A'], axis='index')\nOut[203]: \n                   A         B         C         D\n2000-01-01 -2.104139 -2.104139  0.485855  0.245166\n2000-01-02 -0.352480  0.390389 -0.352480  1.655824\n2000-01-03 -0.864883  0.299674 -0.864883  0.281059\n2000-01-04  0.846958  0.846958  0.600705  0.846958\n2000-01-05  0.669692  0.669692  0.669692  0.342416\n2000-01-06  0.868584  0.868584  2.297780  0.868584\n2000-01-07 -2.670153 -2.670153  0.168904 -2.670153\n2000-01-08  0.801196  1.392071  0.801196  0.801196\n</pre></div> </div> <p>This is equivalent to (but faster than) the following.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [204]: df2 = df.copy()\n\nIn [205]: df.apply(lambda x, y: x.where(x &gt; 0, y), y=df['A'])\nOut[205]: \n                   A         B         C         D\n2000-01-01 -2.104139 -2.104139  0.485855  0.245166\n2000-01-02 -0.352480  0.390389 -0.352480  1.655824\n2000-01-03 -0.864883  0.299674 -0.864883  0.281059\n2000-01-04  0.846958  0.846958  0.600705  0.846958\n2000-01-05  0.669692  0.669692  0.669692  0.342416\n2000-01-06  0.868584  0.868584  2.297780  0.868584\n2000-01-07 -2.670153 -2.670153  0.168904 -2.670153\n2000-01-08  0.801196  1.392071  0.801196  0.801196\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code> can accept a callable as condition and <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code> arguments. The function must be with one argument (the calling Series or DataFrame) and that returns valid output as condition and <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code> argument.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [206]: df3 = pd.DataFrame({'A': [1, 2, 3],\n   .....:                     'B': [4, 5, 6],\n   .....:                     'C': [7, 8, 9]})\n   .....: \n\nIn [207]: df3.where(lambda x: x &gt; 4, lambda x: x + 10)\nOut[207]: \n    A   B  C\n0  11  14  7\n1  12   5  8\n2  13   6  9\n</pre></div> </div> <section id=\"mask\"> <h3>Mask</h3> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.mask#pandas.DataFrame.mask\" title=\"pandas.DataFrame.mask\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">mask()</span></code></a> is the inverse boolean operation of <code class=\"docutils literal notranslate\"><span class=\"pre\">where</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [208]: s.mask(s &gt;= 0)\nOut[208]: \n4   NaN\n3   NaN\n2   NaN\n1   NaN\n0   NaN\ndtype: float64\n\nIn [209]: df.mask(df &gt;= 0)\nOut[209]: \n                   A         B         C         D\n2000-01-01 -2.104139 -1.309525       NaN       NaN\n2000-01-02 -0.352480       NaN -1.192319       NaN\n2000-01-03 -0.864883       NaN -0.227870       NaN\n2000-01-04       NaN -1.222082       NaN -1.233203\n2000-01-05       NaN -0.605656 -1.169184       NaN\n2000-01-06       NaN -0.948458       NaN -0.684718\n2000-01-07 -2.670153 -0.114722       NaN -0.048048\n2000-01-08       NaN       NaN -0.048788 -0.808838\n</pre></div> </div> </section> </section> <section id=\"setting-with-enlargement-conditionally-using-numpy\"> <h2>Setting with enlargement conditionally using <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">numpy()</span></code>\n</h2> <p>An alternative to <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.where#pandas.DataFrame.where\" title=\"pandas.DataFrame.where\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">where()</span></code></a> is to use <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">numpy.where()</span></code></a>. Combined with setting a new column, you can use it to enlarge a DataFrame where the values are determined conditionally.</p> <p>Consider you have two choices to choose from in the following DataFrame. And you want to set a new column color to ‘green’ when the second column has ‘Z’. You can do the following:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [210]: df = pd.DataFrame({'col1': list('ABBC'), 'col2': list('ZZXY')})\n\nIn [211]: df['color'] = np.where(df['col2'] == 'Z', 'green', 'red')\n\nIn [212]: df\nOut[212]: \n  col1 col2  color\n0    A    Z  green\n1    B    Z  green\n2    B    X    red\n3    C    Y    red\n</pre></div> </div> <p>If you have multiple conditions, you can use <a class=\"reference external\" href=\"https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select\" title=\"(in NumPy v1.22)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">numpy.select()</span></code></a> to achieve that. Say corresponding to three conditions there are three choice of colors, with a fourth color as a fallback, you can do the following.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [213]: conditions = [\n   .....:     (df['col2'] == 'Z') &amp; (df['col1'] == 'A'),\n   .....:     (df['col2'] == 'Z') &amp; (df['col1'] == 'B'),\n   .....:     (df['col1'] == 'B')\n   .....: ]\n   .....: \n\nIn [214]: choices = ['yellow', 'blue', 'purple']\n\nIn [215]: df['color'] = np.select(conditions, choices, default='black')\n\nIn [216]: df\nOut[216]: \n  col1 col2   color\n0    A    Z  yellow\n1    B    Z    blue\n2    B    X  purple\n3    C    Y   black\n</pre></div> </div> </section> <section id=\"the-query-method\"> <h2>The <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a> Method</h2> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> objects have a <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a> method that allows selection using an expression.</p> <p>You can get the value of the frame where column <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code> has values between the values of columns <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">c</span></code>. For example:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [217]: n = 10\n\nIn [218]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [219]: df\nOut[219]: \n          a         b         c\n0  0.438921  0.118680  0.863670\n1  0.138138  0.577363  0.686602\n2  0.595307  0.564592  0.520630\n3  0.913052  0.926075  0.616184\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n6  0.792342  0.216974  0.564056\n7  0.397890  0.454131  0.915716\n8  0.074315  0.437913  0.019794\n9  0.559209  0.502065  0.026437\n\n# pure python\nIn [220]: df[(df['a'] &lt; df['b']) &amp; (df['b'] &lt; df['c'])]\nOut[220]: \n          a         b         c\n1  0.138138  0.577363  0.686602\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n7  0.397890  0.454131  0.915716\n\n# query\nIn [221]: df.query('(a &lt; b) &amp; (b &lt; c)')\nOut[221]: \n          a         b         c\n1  0.138138  0.577363  0.686602\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n7  0.397890  0.454131  0.915716\n</pre></div> </div> <p>Do the same thing but fall back on a named index if there is no column with the name <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [222]: df = pd.DataFrame(np.random.randint(n / 2, size=(n, 2)), columns=list('bc'))\n\nIn [223]: df.index.name = 'a'\n\nIn [224]: df\nOut[224]: \n   b  c\na      \n0  0  4\n1  0  1\n2  3  4\n3  4  3\n4  1  4\n5  0  3\n6  0  1\n7  3  4\n8  2  3\n9  1  1\n\nIn [225]: df.query('a &lt; b and b &lt; c')\nOut[225]: \n   b  c\na      \n2  3  4\n</pre></div> </div> <p>If instead you don’t want to or cannot name your index, you can use the name <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code> in your query expression:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [226]: df = pd.DataFrame(np.random.randint(n, size=(n, 2)), columns=list('bc'))\n\nIn [227]: df\nOut[227]: \n   b  c\n0  3  1\n1  3  0\n2  5  6\n3  5  2\n4  7  4\n5  0  1\n6  2  5\n7  0  1\n8  6  0\n9  7  9\n\nIn [228]: df.query('index &lt; b &lt; c')\nOut[228]: \n   b  c\n2  5  6\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>If the name of your index overlaps with a column name, the column name is given precedence. For example,</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [229]: df = pd.DataFrame({'a': np.random.randint(5, size=5)})\n\nIn [230]: df.index.name = 'a'\n\nIn [231]: df.query('a &gt; 2')  # uses the column 'a', not the index\nOut[231]: \n   a\na   \n1  3\n3  3\n</pre></div> </div> <p>You can still use the index in a query expression by using the special identifier ‘index’:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [232]: df.query('index &gt; 2')\nOut[232]: \n   a\na   \n3  3\n4  2\n</pre></div> </div> <p>If for some reason you have a column named <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>, then you can refer to the index as <code class=\"docutils literal notranslate\"><span class=\"pre\">ilevel_0</span></code> as well, but at this point you should consider renaming your columns to something less ambiguous.</p> </div> <section id=\"multiindex-query-syntax\"> <h3>\n<a class=\"reference internal\" href=\"../reference/api/pandas.multiindex#pandas.MultiIndex\" title=\"pandas.MultiIndex\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code></a> <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a> Syntax</h3> <p>You can also use the levels of a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> with a <a class=\"reference internal\" href=\"../reference/api/pandas.multiindex#pandas.MultiIndex\" title=\"pandas.MultiIndex\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code></a> as if they were columns in the frame:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [233]: n = 10\n\nIn [234]: colors = np.random.choice(['red', 'green'], size=n)\n\nIn [235]: foods = np.random.choice(['eggs', 'ham'], size=n)\n\nIn [236]: colors\nOut[236]: \narray(['red', 'red', 'red', 'green', 'green', 'green', 'green', 'green',\n       'green', 'green'], dtype='&lt;U5')\n\nIn [237]: foods\nOut[237]: \narray(['ham', 'ham', 'eggs', 'eggs', 'eggs', 'ham', 'ham', 'eggs', 'eggs',\n       'eggs'], dtype='&lt;U4')\n\nIn [238]: index = pd.MultiIndex.from_arrays([colors, foods], names=['color', 'food'])\n\nIn [239]: df = pd.DataFrame(np.random.randn(n, 2), index=index)\n\nIn [240]: df\nOut[240]: \n                   0         1\ncolor food                    \nred   ham   0.194889 -0.381994\n      ham   0.318587  2.089075\n      eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n      eggs -2.029766  0.792652\n      ham   0.461007 -0.542749\n      ham  -0.305384 -0.479195\n      eggs  0.095031 -0.270099\n      eggs -0.707140 -0.773882\n      eggs  0.229453  0.304418\n\nIn [241]: df.query('color == \"red\"')\nOut[241]: \n                   0         1\ncolor food                    \nred   ham   0.194889 -0.381994\n      ham   0.318587  2.089075\n      eggs -0.728293 -0.090255\n</pre></div> </div> <p>If the levels of the <code class=\"docutils literal notranslate\"><span class=\"pre\">MultiIndex</span></code> are unnamed, you can refer to them using special names:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [242]: df.index.names = [None, None]\n\nIn [243]: df\nOut[243]: \n                   0         1\nred   ham   0.194889 -0.381994\n      ham   0.318587  2.089075\n      eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n      eggs -2.029766  0.792652\n      ham   0.461007 -0.542749\n      ham  -0.305384 -0.479195\n      eggs  0.095031 -0.270099\n      eggs -0.707140 -0.773882\n      eggs  0.229453  0.304418\n\nIn [244]: df.query('ilevel_0 == \"red\"')\nOut[244]: \n                 0         1\nred ham   0.194889 -0.381994\n    ham   0.318587  2.089075\n    eggs -0.728293 -0.090255\n</pre></div> </div> <p>The convention is <code class=\"docutils literal notranslate\"><span class=\"pre\">ilevel_0</span></code>, which means “index level 0” for the 0th level of the <code class=\"docutils literal notranslate\"><span class=\"pre\">index</span></code>.</p> </section> <section id=\"query-use-cases\"> <h3>\n<a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a> Use Cases</h3> <p>A use case for <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a> is when you have a collection of <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe#pandas.DataFrame\" title=\"pandas.DataFrame\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code></a> objects that have a subset of column names (or index levels/names) in common. You can pass the same query to both frames <em>without</em> having to specify which frame you’re interested in querying</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [245]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [246]: df\nOut[246]: \n          a         b         c\n0  0.224283  0.736107  0.139168\n1  0.302827  0.657803  0.713897\n2  0.611185  0.136624  0.984960\n3  0.195246  0.123436  0.627712\n4  0.618673  0.371660  0.047902\n5  0.480088  0.062993  0.185760\n6  0.568018  0.483467  0.445289\n7  0.309040  0.274580  0.587101\n8  0.258993  0.477769  0.370255\n9  0.550459  0.840870  0.304611\n\nIn [247]: df2 = pd.DataFrame(np.random.rand(n + 2, 3), columns=df.columns)\n\nIn [248]: df2\nOut[248]: \n           a         b         c\n0   0.357579  0.229800  0.596001\n1   0.309059  0.957923  0.965663\n2   0.123102  0.336914  0.318616\n3   0.526506  0.323321  0.860813\n4   0.518736  0.486514  0.384724\n5   0.190804  0.505723  0.614533\n6   0.891939  0.623977  0.676639\n7   0.480559  0.378528  0.460858\n8   0.420223  0.136404  0.141295\n9   0.732206  0.419540  0.604675\n10  0.604466  0.848974  0.896165\n11  0.589168  0.920046  0.732716\n\nIn [249]: expr = '0.0 &lt;= a &lt;= c &lt;= 0.5'\n\nIn [250]: map(lambda frame: frame.query(expr), [df, df2])\nOut[250]: &lt;map at 0x7fe27a78f280&gt;\n</pre></div> </div> </section> <section id=\"query-python-versus-pandas-syntax-comparison\"> <h3>\n<a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a> Python versus pandas Syntax Comparison</h3> <p>Full numpy-like syntax:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [251]: df = pd.DataFrame(np.random.randint(n, size=(n, 3)), columns=list('abc'))\n\nIn [252]: df\nOut[252]: \n   a  b  c\n0  7  8  9\n1  1  0  7\n2  2  7  2\n3  6  2  2\n4  2  6  3\n5  3  8  2\n6  1  7  2\n7  5  1  5\n8  9  8  0\n9  1  5  0\n\nIn [253]: df.query('(a &lt; b) &amp; (b &lt; c)')\nOut[253]: \n   a  b  c\n0  7  8  9\n\nIn [254]: df[(df['a'] &lt; df['b']) &amp; (df['b'] &lt; df['c'])]\nOut[254]: \n   a  b  c\n0  7  8  9\n</pre></div> </div> <p>Slightly nicer by removing the parentheses (comparison operators bind tighter than <code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">|</span></code>):</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [255]: df.query('a &lt; b &amp; b &lt; c')\nOut[255]: \n   a  b  c\n0  7  8  9\n</pre></div> </div> <p>Use English instead of symbols:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [256]: df.query('a &lt; b and b &lt; c')\nOut[256]: \n   a  b  c\n0  7  8  9\n</pre></div> </div> <p>Pretty close to how you might write it on paper:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [257]: df.query('a &lt; b &lt; c')\nOut[257]: \n   a  b  c\n0  7  8  9\n</pre></div> </div> </section> <section id=\"the-in-and-not-in-operators\"> <h3>The <code class=\"docutils literal notranslate\"><span class=\"pre\">in</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">not</span> <span class=\"pre\">in</span></code> operators</h3> <p><a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a> also supports special use of Python’s <code class=\"docutils literal notranslate\"><span class=\"pre\">in</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">not</span> <span class=\"pre\">in</span></code> comparison operators, providing a succinct syntax for calling the <code class=\"docutils literal notranslate\"><span class=\"pre\">isin</span></code> method of a <code class=\"docutils literal notranslate\"><span class=\"pre\">Series</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># get all rows where columns \"a\" and \"b\" have overlapping values\nIn [258]: df = pd.DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),\n   .....:                    'c': np.random.randint(5, size=12),\n   .....:                    'd': np.random.randint(9, size=12)})\n   .....: \n\nIn [259]: df\nOut[259]: \n    a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [260]: df.query('a in b')\nOut[260]: \n   a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\n# How you'd do it in pure Python\nIn [261]: df[df['a'].isin(df['b'])]\nOut[261]: \n   a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\nIn [262]: df.query('a not in b')\nOut[262]: \n    a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [263]: df[~df['a'].isin(df['b'])]\nOut[263]: \n    a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n</pre></div> </div> <p>You can combine this with other expressions for very succinct queries:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># rows where cols a and b have overlapping values\n# and col c's values are less than col d's\nIn [264]: df.query('a in b and c &lt; d')\nOut[264]: \n   a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n4  c  b  3  6\n5  c  b  0  2\n\n# pure Python\nIn [265]: df[df['b'].isin(df['a']) &amp; (df['c'] &lt; df['d'])]\nOut[265]: \n    a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n4   c  b  3  6\n5   c  b  0  2\n10  f  c  0  6\n11  f  c  1  2\n</pre></div> </div> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>Note that <code class=\"docutils literal notranslate\"><span class=\"pre\">in</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">not</span> <span class=\"pre\">in</span></code> are evaluated in Python, since <code class=\"docutils literal notranslate\"><span class=\"pre\">numexpr</span></code> has no equivalent of this operation. However, <strong>only the</strong> <code class=\"docutils literal notranslate\"><span class=\"pre\">in</span></code>/<code class=\"docutils literal notranslate\"><span class=\"pre\">not</span> <span class=\"pre\">in</span></code> <strong>expression itself</strong> is evaluated in vanilla Python. For example, in the expression</p> <div class=\"highlight-python notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">df.query('a in b + c + d')\n</pre></div> </div> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">(b</span> <span class=\"pre\">+</span> <span class=\"pre\">c</span> <span class=\"pre\">+</span> <span class=\"pre\">d)</span></code> is evaluated by <code class=\"docutils literal notranslate\"><span class=\"pre\">numexpr</span></code> and <em>then</em> the <code class=\"docutils literal notranslate\"><span class=\"pre\">in</span></code> operation is evaluated in plain Python. In general, any operations that can be evaluated using <code class=\"docutils literal notranslate\"><span class=\"pre\">numexpr</span></code> will be.</p> </div> </section> <section id=\"special-use-of-the-operator-with-list-objects\"> <h3>Special use of the <code class=\"docutils literal notranslate\"><span class=\"pre\">==</span></code> operator with <code class=\"docutils literal notranslate\"><span class=\"pre\">list</span></code> objects</h3> <p>Comparing a <code class=\"docutils literal notranslate\"><span class=\"pre\">list</span></code> of values to a column using <code class=\"docutils literal notranslate\"><span class=\"pre\">==</span></code>/<code class=\"docutils literal notranslate\"><span class=\"pre\">!=</span></code> works similarly to <code class=\"docutils literal notranslate\"><span class=\"pre\">in</span></code>/<code class=\"docutils literal notranslate\"><span class=\"pre\">not</span> <span class=\"pre\">in</span></code>.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [266]: df.query('b == [\"a\", \"b\", \"c\"]')\nOut[266]: \n    a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [267]: df[df['b'].isin([\"a\", \"b\", \"c\"])]\nOut[267]: \n    a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [268]: df.query('c == [1, 2]')\nOut[268]: \n    a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [269]: df.query('c != [1, 2]')\nOut[269]: \n    a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# using in/not in\nIn [270]: df.query('[1, 2] in c')\nOut[270]: \n    a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [271]: df.query('[1, 2] not in c')\nOut[271]: \n    a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# pure Python\nIn [272]: df[df['c'].isin([1, 2])]\nOut[272]: \n    a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n</pre></div> </div> </section> <section id=\"boolean-operators\"> <h3>Boolean operators</h3> <p>You can negate boolean expressions with the word <code class=\"docutils literal notranslate\"><span class=\"pre\">not</span></code> or the <code class=\"docutils literal notranslate\"><span class=\"pre\">~</span></code> operator.</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [273]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [274]: df['bools'] = np.random.rand(len(df)) &gt; 0.5\n\nIn [275]: df.query('~bools')\nOut[275]: \n          a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [276]: df.query('not bools')\nOut[276]: \n          a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [277]: df.query('not bools') == df[~df['bools']]\nOut[277]: \n      a     b     c  bools\n2  True  True  True   True\n7  True  True  True   True\n8  True  True  True   True\n</pre></div> </div> <p>Of course, expressions can be arbitrarily complex too:</p> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\"># short query syntax\nIn [278]: shorter = df.query('a &lt; b &lt; c and (not bools) or bools &gt; 2')\n\n# equivalent in pure Python\nIn [279]: longer = df[(df['a'] &lt; df['b'])\n   .....:             &amp; (df['b'] &lt; df['c'])\n   .....:             &amp; (~df['bools'])\n   .....:             | (df['bools'] &gt; 2)]\n   .....: \n\nIn [280]: shorter\nOut[280]: \n          a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [281]: longer\nOut[281]: \n          a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [282]: shorter == longer\nOut[282]: \n      a     b     c  bools\n7  True  True  True   True\n</pre></div> </div> </section> <section id=\"performance-of-query\"> <h3>Performance of <a class=\"reference internal\" href=\"../reference/api/pandas.dataframe.query#pandas.DataFrame.query\" title=\"pandas.DataFrame.query\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">query()</span></code></a>\n</h3> <p><code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.query()</span></code> using <code class=\"docutils literal notranslate\"><span class=\"pre\">numexpr</span></code> is slightly faster than Python for large frames.</p> <img alt=\"../_images/query-perf.png\" src=\"data:image/png;base64,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\"> <div class=\"admonition note\"> <p class=\"admonition-title\">Note</p> <p>You will only see the performance benefits of using the <code class=\"docutils literal notranslate\"><span class=\"pre\">numexpr</span></code> engine with <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame.query()</span></code> if your frame has more than approximately 200,000 rows.</p> <blockquote> <div>\n<img alt=\"../_images/query-perf-small.png\" src=\"data:image/png;base64,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\"> </div>\n</blockquote> </div> <p>This plot was created using a <code class=\"docutils literal notranslate\"><span class=\"pre\">DataFrame</span></code> with 3 columns each containing floating point values generated using <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy.random.randn()</span></code>.</p> </section> </section> <section id=\"duplicate-data\"> <h2>Duplicate data</h2> <p id=\"indexing-duplicate\">If you want to identify and remove duplicate rows in a DataFrame, there are two methods that will help: <code class=\"docutils literal notranslate\"><span class=\"pre\">duplicated</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">drop_duplicates</span></code>. Each takes as an argument the columns to use to identify duplicated rows.</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">duplicated</span></code> returns a boolean vector whose length is the number of rows, and which indicates whether a row is duplicated.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">drop_duplicates</span></code> removes duplicate rows.</p></li> </ul> <p>By default, the first observed row of a duplicate set is considered unique, but each method has a <code class=\"docutils literal notranslate\"><span class=\"pre\">keep</span></code> parameter to specify targets to be kept.</p> <ul class=\"simple\"> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">keep='first'</span></code> (default): mark / drop duplicates except for the first occurrence.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">keep='last'</span></code>: mark / drop duplicates except for the last occurrence.</p></li> <li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">keep=False</span></code>: mark / drop all duplicates.</p></li> </ul> <div class=\"highlight-ipython notranslate\">\n<div class=\"highlight\"><pre data-language=\"python\">In [283]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'two', 'two', 'three', 'four'],\n   .....:                     'b': ['x', 'y', 'x', 'y', 'x', 'x', 'x'],\n   .....:                     'c': np.random.randn(7)})\n   .....: \n\nIn [284]: df2\nOut[284]: \n       a  b         c\n0  